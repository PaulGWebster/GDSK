essage, arg0, arg1, arg2);
                }
            });
        }
        function getDeclarationDiagnosticsWorker(sourceFile, cancellationToken) {
            return getAndCacheDiagnostics(sourceFile, cancellationToken, cachedDeclarationDiagnosticsForFile, getDeclarationDiagnosticsForFileNoCache);
        }
        function getDeclarationDiagnosticsForFileNoCache(sourceFile, cancellationToken) {
            return runWithCancellationToken(function () {
                var resolver = getTypeChecker().getEmitResolver(sourceFile, cancellationToken);
                // Don't actually write any files since we're just getting diagnostics.
                return ts.getDeclarationDiagnostics(getEmitHost(ts.noop), resolver, sourceFile) || ts.emptyArray;
            });
        }
        function getAndCacheDiagnostics(sourceFile, cancellationToken, cache, getDiagnostics) {
            var _a;
            var cachedResult = sourceFile
                ? (_a = cache.perFile) === null || _a === void 0 ? void 0 : _a.get(sourceFile.path)
                : cache.allDiagnostics;
            if (cachedResult) {
                return cachedResult;
            }
            var result = getDiagnostics(sourceFile, cancellationToken);
            if (sourceFile) {
                (cache.perFile || (cache.perFile = new ts.Map())).set(sourceFile.path, result);
            }
            else {
                cache.allDiagnostics = result;
            }
            return result;
        }
        function getDeclarationDiagnosticsForFile(sourceFile, cancellationToken) {
            return sourceFile.isDeclarationFile ? [] : getDeclarationDiagnosticsWorker(sourceFile, cancellationToken);
        }
        function getOptionsDiagnostics() {
            return ts.sortAndDeduplicateDiagnostics(ts.concatenate(programDiagnostics.getGlobalDiagnostics(), getOptionsDiagnosticsOfConfigFile()));
        }
        function getOptionsDiagnosticsOfConfigFile() {
            if (!options.configFile)
                return ts.emptyArray;
            var diagnostics = programDiagnostics.getDiagnostics(options.configFile.fileName);
            forEachResolvedProjectReference(function (resolvedRef) {
                diagnostics = ts.concatenate(diagnostics, programDiagnostics.getDiagnostics(resolvedRef.sourceFile.fileName));
            });
            return diagnostics;
        }
        function getGlobalDiagnostics() {
            return rootNames.length ? ts.sortAndDeduplicateDiagnostics(getTypeChecker().getGlobalDiagnostics().slice()) : ts.emptyArray;
        }
        function getConfigFileParsingDiagnostics() {
            return configFileParsingDiagnostics || ts.emptyArray;
        }
        function processRootFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason) {
            processSourceFile(ts.normalizePath(fileName), isDefaultLib, ignoreNoDefaultLib, /*packageId*/ undefined, reason);
        }
        function fileReferenceIsEqualTo(a, b) {
            return a.fileName === b.fileName;
        }
        function moduleNameIsEqualTo(a, b) {
            return a.kind === 79 /* SyntaxKind.Identifier */
                ? b.kind === 79 /* SyntaxKind.Identifier */ && a.escapedText === b.escapedText
                : b.kind === 10 /* SyntaxKind.StringLiteral */ && a.text === b.text;
        }
        function createSyntheticImport(text, file) {
            var externalHelpersModuleReference = ts.factory.createStringLiteral(text);
            var importDecl = ts.factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*importClause*/ undefined, externalHelpersModuleReference, /*assertClause*/ undefined);
            ts.addEmitFlags(importDecl, 67108864 /* EmitFlags.NeverApplyImportHelper */);
            ts.setParent(externalHelpersModuleReference, importDecl);
            ts.setParent(importDecl, file);
            // explicitly unset the synthesized flag on these declarations so the checker API will answer questions about them
            // (which is required to build the dependency graph for incremental emit)
            externalHelpersModuleReference.flags &= ~8 /* NodeFlags.Synthesized */;
            importDecl.flags &= ~8 /* NodeFlags.Synthesized */;
            return externalHelpersModuleReference;
        }
        function collectExternalModuleReferences(file) {
            if (file.imports) {
                return;
            }
            var isJavaScriptFile = ts.isSourceFileJS(file);
            var isExternalModuleFile = ts.isExternalModule(file);
            // file.imports may not be undefined if there exists dynamic import
            var imports;
            var moduleAugmentations;
            var ambientModules;
            // If we are importing helpers, we need to add a synthetic reference to resolve the
            // helpers library.
            if ((options.isolatedModules || isExternalModuleFile)
                && !file.isDeclarationFile) {
                if (options.importHelpers) {
                    // synthesize 'import "tslib"' declaration
                    imports = [createSyntheticImport(ts.externalHelpersModuleNameText, file)];
                }
                var jsxImport = ts.getJSXRuntimeImport(ts.getJSXImplicitImportBase(options, file), options);
                if (jsxImport) {
                    // synthesize `import "base/jsx-runtime"` declaration
                    (imports || (imports = [])).push(createSyntheticImport(jsxImport, file));
                }
            }
            for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
                var node = _a[_i];
                collectModuleReferences(node, /*inAmbientModule*/ false);
            }
            if ((file.flags & 2097152 /* NodeFlags.PossiblyContainsDynamicImport */) || isJavaScriptFile) {
                collectDynamicImportOrRequireCalls(file);
            }
            file.imports = imports || ts.emptyArray;
            file.moduleAugmentations = moduleAugmentations || ts.emptyArray;
            file.ambientModuleNames = ambientModules || ts.emptyArray;
            return;
            function collectModuleReferences(node, inAmbientModule) {
                if (ts.isAnyImportOrReExport(node)) {
                    var moduleNameExpr = ts.getExternalModuleName(node);
                    // TypeScript 1.0 spec (April 2014): 12.1.6
                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference other external modules
                    // only through top - level external module names. Relative external module names are not permitted.
                    if (moduleNameExpr && ts.isStringLiteral(moduleNameExpr) && moduleNameExpr.text && (!inAmbientModule || !ts.isExternalModuleNameRelative(moduleNameExpr.text))) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, moduleNameExpr);
                        if (!usesUriStyleNodeCoreModules && currentNodeModulesDepth === 0 && !file.isDeclarationFile) {
                            usesUriStyleNodeCoreModules = ts.startsWith(moduleNameExpr.text, "node:");
                        }
                    }
                }
                else if (ts.isModuleDeclaration(node)) {
                    if (ts.isAmbientModule(node) && (inAmbientModule || ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */) || file.isDeclarationFile)) {
                        node.name.parent = node;
                        var nameText = ts.getTextOfIdentifierOrLiteral(node.name);
                        // Ambient module declarations can be interpreted as augmentations for some existing external modules.
                        // This will happen in two cases:
                        // - if current file is external module then module augmentation is a ambient module declaration defined in the top level scope
                        // - if current file is not external module then module augmentation is an ambient module declaration with non-relative module name
                        //   immediately nested in top level ambient module declaration .
                        if (isExternalModuleFile || (inAmbientModule && !ts.isExternalModuleNameRelative(nameText))) {
                            (moduleAugmentations || (moduleAugmentations = [])).push(node.name);
                        }
                        else if (!inAmbientModule) {
                            if (file.isDeclarationFile) {
                                // for global .d.ts files record name of ambient module
                                (ambientModules || (ambientModules = [])).push(nameText);
                            }
                            // An AmbientExternalModuleDeclaration declares an external module.
                            // This type of declaration is permitted only in the global module.
                            // The StringLiteral must specify a top - level external module name.
                            // Relative external module names are not permitted
                            // NOTE: body of ambient module is always a module block, if it exists
                            var body = node.body;
                            if (body) {
                                for (var _i = 0, _a = body.statements; _i < _a.length; _i++) {
                                    var statement = _a[_i];
                                    collectModuleReferences(statement, /*inAmbientModule*/ true);
                                }
                            }
                        }
                    }
                }
            }
            function collectDynamicImportOrRequireCalls(file) {
                var r = /import|require/g;
                while (r.exec(file.text) !== null) { // eslint-disable-line no-null/no-null
                    var node = getNodeAtPosition(file, r.lastIndex);
                    if (isJavaScriptFile && ts.isRequireCall(node, /*checkArgumentIsStringLiteralLike*/ true)) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, node.arguments[0]);
                    }
                    // we have to check the argument list has length of at least 1. We will still have to process these even though we have parsing error.
                    else if (ts.isImportCall(node) && node.arguments.length >= 1 && ts.isStringLiteralLike(node.arguments[0])) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, node.arguments[0]);
                    }
                    else if (ts.isLiteralImportTypeNode(node)) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, node.argument.literal);
                    }
                }
            }
            /** Returns a token if position is in [start-of-leading-trivia, end), includes JSDoc only in JS files */
            function getNodeAtPosition(sourceFile, position) {
                var current = sourceFile;
                var getContainingChild = function (child) {
                    if (child.pos <= position && (position < child.end || (position === child.end && (child.kind === 1 /* SyntaxKind.EndOfFileToken */)))) {
                        return child;
                    }
                };
                while (true) {
                    var child = isJavaScriptFile && ts.hasJSDocNodes(current) && ts.forEach(current.jsDoc, getContainingChild) || ts.forEachChild(current, getContainingChild);
                    if (!child) {
                        return current;
                    }
                    current = child;
                }
            }
        }
        function getLibFileFromReference(ref) {
            var libName = ts.toFileNameLowerCase(ref.fileName);
            var libFileName = ts.libMap.get(libName);
            if (libFileName) {
                return getSourceFile(pathForLibFile(libFileName));
            }
        }
        /** This should have similar behavior to 'processSourceFile' without diagnostics or mutation. */
        function getSourceFileFromReference(referencingFile, ref) {
            return getSourceFileFromReferenceWorker(resolveTripleslashReference(ref.fileName, referencingFile.fileName), getSourceFile);
        }
        function getSourceFileFromReferenceWorker(fileName, getSourceFile, fail, reason) {
            if (ts.hasExtension(fileName)) {
                var canonicalFileName_1 = host.getCanonicalFileName(fileName);
                if (!options.allowNonTsExtensions && !ts.forEach(ts.flatten(supportedExtensionsWithJsonIfResolveJsonModule), function (extension) { return ts.fileExtensionIs(canonicalFileName_1, extension); })) {
                    if (fail) {
                        if (ts.hasJSFileExtension(canonicalFileName_1)) {
                            fail(ts.Diagnostics.File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option, fileName);
                        }
                        else {
                            fail(ts.Diagnostics.File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1, fileName, "'" + ts.flatten(supportedExtensions).join("', '") + "'");
                        }
                    }
                    return undefined;
                }
                var sourceFile = getSourceFile(fileName);
                if (fail) {
                    if (!sourceFile) {
                        var redirect = getProjectReferenceRedirect(fileName);
                        if (redirect) {
                            fail(ts.Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, fileName);
                        }
                        else {
                            fail(ts.Diagnostics.File_0_not_found, fileName);
                        }
                    }
                    else if (isReferencedFile(reason) && canonicalFileName_1 === host.getCanonicalFileName(getSourceFileByPath(reason.file).fileName)) {
                        fail(ts.Diagnostics.A_file_cannot_have_a_reference_to_itself);
                    }
                }
                return sourceFile;
            }
            else {
                var sourceFileNoExtension = options.allowNonTsExtensions && getSourceFile(fileName);
                if (sourceFileNoExtension)
                    return sourceFileNoExtension;
                if (fail && options.allowNonTsExtensions) {
                    fail(ts.Diagnostics.File_0_not_found, fileName);
                    return undefined;
                }
                // Only try adding extensions from the first supported group (which should be .ts/.tsx/.d.ts)
                var sourceFileWithAddedExtension = ts.forEach(supportedExtensions[0], function (extension) { return getSourceFile(fileName + extension); });
                if (fail && !sourceFileWithAddedExtension)
                    fail(ts.Diagnostics.Could_not_resolve_the_path_0_with_the_extensions_Colon_1, fileName, "'" + ts.flatten(supportedExtensions).join("', '") + "'");
                return sourceFileWithAddedExtension;
            }
        }
        /** This has side effects through `findSourceFile`. */
        function processSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, packageId, reason) {
            getSourceFileFromReferenceWorker(fileName, function (fileName) { return findSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId); }, // TODO: GH#18217
            function (diagnostic) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return addFilePreprocessingFileExplainingDiagnostic(/*file*/ undefined, reason, diagnostic, args);
            }, reason);
        }
        function processProjectReferenceFile(fileName, reason) {
            return processSourceFile(fileName, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, /*packageId*/ undefined, reason);
        }
        function reportFileNamesDifferOnlyInCasingError(fileName, existingFile, reason) {
            var hasExistingReasonToReportErrorOn = !isReferencedFile(reason) && ts.some(fileReasons.get(existingFile.path), isReferencedFile);
            if (hasExistingReasonToReportErrorOn) {
                addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, ts.Diagnostics.Already_included_file_name_0_differs_from_file_name_1_only_in_casing, [existingFile.fileName, fileName]);
            }
            else {
                addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, ts.Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, [fileName, existingFile.fileName]);
            }
        }
        function createRedirectSourceFile(redirectTarget, unredirected, fileName, path, resolvedPath, originalFileName) {
            var redirect = Object.create(redirectTarget);
            redirect.fileName = fileName;
            redirect.path = path;
            redirect.resolvedPath = resolvedPath;
            redirect.originalFileName = originalFileName;
            redirect.redirectInfo = { redirectTarget: redirectTarget, unredirected: unredirected };
            sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0);
            Object.defineProperties(redirect, {
                id: {
                    get: function () { return this.redirectInfo.redirectTarget.id; },
                    set: function (value) { this.redirectInfo.redirectTarget.id = value; },
                },
                symbol: {
                    get: function () { return this.redirectInfo.redirectTarget.symbol; },
                    set: function (value) { this.redirectInfo.redirectTarget.symbol = value; },
                },
            });
            return redirect;
        }
        // Get source file from normalized fileName
        function findSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "findSourceFile", {
                fileName: fileName,
                isDefaultLib: isDefaultLib || undefined,
                fileIncludeKind: ts.FileIncludeKind[reason.kind],
            });
            var result = findSourceFileWorker(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            return result;
        }
        function getCreateSourceFileOptions(fileName, moduleResolutionCache, host, options) {
            // It's a _little odd_ that we can't set `impliedNodeFormat` until the program step - but it's the first and only time we have a resolution cache
            // and a freshly made source file node on hand at the same time, and we need both to set the field. Persisting the resolution cache all the way
            // to the check and emit steps would be bad - so we much prefer detecting and storing the format information on the source file node upfront.
            var impliedNodeFormat = getImpliedNodeFormatForFile(toPath(fileName), moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.getPackageJsonInfoCache(), host, options);
            return {
                languageVersion: ts.getEmitScriptTarget(options),
                impliedNodeFormat: impliedNodeFormat,
                setExternalModuleIndicator: ts.getSetExternalModuleIndicator(options)
            };
        }
        function findSourceFileWorker(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId) {
            var path = toPath(fileName);
            if (useSourceOfProjectReferenceRedirect) {
                var source = getSourceOfProjectReferenceRedirect(path);
                // If preserveSymlinks is true, module resolution wont jump the symlink
                // but the resolved real path may be the .d.ts from project reference
                // Note:: Currently we try the real path only if the
                // file is from node_modules to avoid having to run real path on all file paths
                if (!source &&
                    host.realpath &&
                    options.preserveSymlinks &&
                    ts.isDeclarationFileName(fileName) &&
                    ts.stringContains(fileName, ts.nodeModulesPathPart)) {
                    var realPath = toPath(host.realpath(fileName));
                    if (realPath !== path)
                        source = getSourceOfProjectReferenceRedirect(realPath);
                }
                if (source) {
                    var file_1 = ts.isString(source) ?
                        findSourceFile(source, isDefaultLib, ignoreNoDefaultLib, reason, packageId) :
                        undefined;
                    if (file_1)
                        addFileToFilesByName(file_1, path, /*redirectedPath*/ undefined);
                    return file_1;
                }
            }
            var originalFileName = fileName;
            if (filesByName.has(path)) {
                var file_2 = filesByName.get(path);
                addFileIncludeReason(file_2 || undefined, reason);
                // try to check if we've already seen this file but with a different casing in path
                // NOTE: this only makes sense for case-insensitive file systems, and only on files which are not redirected
                if (file_2 && options.forceConsistentCasingInFileNames) {
                    var checkedName = file_2.fileName;
                    var isRedirect = toPath(checkedName) !== toPath(fileName);
                    if (isRedirect) {
                        fileName = getProjectReferenceRedirect(fileName) || fileName;
                    }
                    // Check if it differs only in drive letters its ok to ignore that error:
                    var checkedAbsolutePath = ts.getNormalizedAbsolutePathWithoutRoot(checkedName, currentDirectory);
                    var inputAbsolutePath = ts.getNormalizedAbsolutePathWithoutRoot(fileName, currentDirectory);
                    if (checkedAbsolutePath !== inputAbsolutePath) {
                        reportFileNamesDifferOnlyInCasingError(fileName, file_2, reason);
                    }
                }
                // If the file was previously found via a node_modules search, but is now being processed as a root file,
                // then everything it sucks in may also be marked incorrectly, and needs to be checked again.
                if (file_2 && sourceFilesFoundSearchingNodeModules.get(file_2.path) && currentNodeModulesDepth === 0) {
                    sourceFilesFoundSearchingNodeModules.set(file_2.path, false);
                    if (!options.noResolve) {
                        processReferencedFiles(file_2, isDefaultLib);
                        processTypeReferenceDirectives(file_2);
                    }
                    if (!options.noLib) {
                        processLibReferenceDirectives(file_2);
                    }
                    modulesWithElidedImports.set(file_2.path, false);
                    processImportedModules(file_2);
                }
                // See if we need to reprocess the imports due to prior skipped imports
                else if (file_2 && modulesWithElidedImports.get(file_2.path)) {
                    if (currentNodeModulesDepth < maxNodeModuleJsDepth) {
                        modulesWithElidedImports.set(file_2.path, false);
                        processImportedModules(file_2);
                    }
                }
                return file_2 || undefined;
            }
            var redirectedPath;
            if (isReferencedFile(reason) && !useSourceOfProjectReferenceRedirect) {
                var redirectProject = getProjectReferenceRedirectProject(fileName);
                if (redirectProject) {
                    if (ts.outFile(redirectProject.commandLine.options)) {
                        // Shouldnt create many to 1 mapping file in --out scenario
                        return undefined;
                    }
                    var redirect = getProjectReferenceOutputName(redirectProject, fileName);
                    fileName = redirect;
                    // Once we start redirecting to a file, we can potentially come back to it
                    // via a back-reference from another file in the .d.ts folder. If that happens we'll
                    // end up trying to add it to the program *again* because we were tracking it via its
                    // original (un-redirected) name. So we have to map both the original path and the redirected path
                    // to the source file we're about to find/create
                    redirectedPath = toPath(redirect);
                }
            }
            // We haven't looked for this file, do so now and cache result
            var file = host.getSourceFile(fileName, getCreateSourceFileOptions(fileName, moduleResolutionCache, host, options), function (hostErrorMessage) { return addFilePreprocessingFileExplainingDiagnostic(/*file*/ undefined, reason, ts.Diagnostics.Cannot_read_file_0_Colon_1, [fileName, hostErrorMessage]); }, shouldCreateNewSourceFile);
            if (packageId) {
                var packageIdKey = ts.packageIdToString(packageId);
                var fileFromPackageId = packageIdToSourceFile.get(packageIdKey);
                if (fileFromPackageId) {
                    // Some other SourceFile already exists with this package name and version.
                    // Instead of creating a duplicate, just redirect to the existing one.
                    var dupFile = createRedirectSourceFile(fileFromPackageId, file, fileName, path, toPath(fileName), originalFileName); // TODO: GH#18217
                    redirectTargetsMap.add(fileFromPackageId.path, fileName);
                    addFileToFilesByName(dupFile, path, redirectedPath);
                    addFileIncludeReason(dupFile, reason);
                    sourceFileToPackageName.set(path, ts.packageIdToPackageName(packageId));
                    processingOtherFiles.push(dupFile);
                    return dupFile;
                }
                else if (file) {
                    // This is the first source file to have this packageId.
                    packageIdToSourceFile.set(packageIdKey, file);
                    sourceFileToPackageName.set(path, ts.packageIdToPackageName(packageId));
                }
            }
            addFileToFilesByName(file, path, redirectedPath);
            if (file) {
                sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0);
                file.fileName = fileName; // Ensure that source file has same name as what we were looking for
                file.path = path;
                file.resolvedPath = toPath(fileName);
                file.originalFileName = originalFileName;
                addFileIncludeReason(file, reason);
                if (host.useCaseSensitiveFileNames()) {
                    var pathLowerCase = ts.toFileNameLowerCase(path);
                    // for case-sensitive file systems check if we've already seen some file with similar filename ignoring case
                    var existingFile = filesByNameIgnoreCase.get(pathLowerCase);
                    if (existingFile) {
                        reportFileNamesDifferOnlyInCasingError(fileName, existingFile, reason);
                    }
                    else {
                        filesByNameIgnoreCase.set(pathLowerCase, file);
                    }
                }
                skipDefaultLib = skipDefaultLib || (file.hasNoDefaultLib && !ignoreNoDefaultLib);
                if (!options.noResolve) {
                    processReferencedFiles(file, isDefaultLib);
                    processTypeReferenceDirectives(file);
                }
                if (!options.noLib) {
                    processLibReferenceDirectives(file);
                }
                // always process imported modules to record module name resolutions
                processImportedModules(file);
                if (isDefaultLib) {
                    processingDefaultLibFiles.push(file);
                }
                else {
                    processingOtherFiles.push(file);
                }
            }
            return file;
        }
        function addFileIncludeReason(file, reason) {
            if (file)
                fileReasons.add(file.path, reason);
        }
        function addFileToFilesByName(file, path, redirectedPath) {
            if (redirectedPath) {
                filesByName.set(redirectedPath, file);
                filesByName.set(path, file || false);
            }
            else {
                filesByName.set(path, file);
            }
        }
        function getProjectReferenceRedirect(fileName) {
            var referencedProject = getProjectReferenceRedirectProject(fileName);
            return referencedProject && getProjectReferenceOutputName(referencedProject, fileName);
        }
        function getProjectReferenceRedirectProject(fileName) {
            // Ignore dts or any json files
            if (!resolvedProjectReferences || !resolvedProjectReferences.length || ts.isDeclarationFileName(fileName) || ts.fileExtensionIs(fileName, ".json" /* Extension.Json */)) {
                return undefined;
            }
            // If this file is produced by a referenced project, we need to rewrite it to
            // look in the output folder of the referenced project rather than the input
            return getResolvedProjectReferenceToRedirect(fileName);
        }
        function getProjectReferenceOutputName(referencedProject, fileName) {
            var out = ts.outFile(referencedProject.commandLine.options);
            return out ?
                ts.changeExtension(out, ".d.ts" /* Extension.Dts */) :
                ts.getOutputDeclarationFileName(fileName, referencedProject.commandLine, !host.useCaseSensitiveFileNames());
        }
        /**
         * Get the referenced project if the file is input file from that reference project
         */
        function getResolvedProjectReferenceToRedirect(fileName) {
            if (mapFromFileToProjectReferenceRedirects === undefined) {
                mapFromFileToProjectReferenceRedirects = new ts.Map();
                forEachResolvedProjectReference(function (referencedProject) {
                    // not input file from the referenced project, ignore
                    if (toPath(options.configFilePath) !== referencedProject.sourceFile.path) {
                        referencedProject.commandLine.fileNames.forEach(function (f) {
                            return mapFromFileToProjectReferenceRedirects.set(toPath(f), referencedProject.sourceFile.path);
                        });
                    }
                });
            }
            var referencedProjectPath = mapFromFileToProjectReferenceRedirects.get(toPath(fileName));
            return referencedProjectPath && getResolvedProjectReferenceByPath(referencedProjectPath);
        }
        function forEachResolvedProjectReference(cb) {
            return ts.forEachResolvedProjectReference(resolvedProjectReferences, cb);
        }
        function getSourceOfProjectReferenceRedirect(path) {
            if (!ts.isDeclarationFileName(path))
                return undefined;
            if (mapFromToProjectReferenceRedirectSource === undefined) {
                mapFromToProjectReferenceRedirectSource = new ts.Map();
                forEachResolvedProjectReference(function (resolvedRef) {
                    var out = ts.outFile(resolvedRef.commandLine.options);
                    if (out) {
                        // Dont know which source file it means so return true?
                        var outputDts = ts.changeExtension(out, ".d.ts" /* Extension.Dts */);
                        mapFromToProjectReferenceRedirectSource.set(toPath(outputDts), true);
                    }
                    else {
                        var getCommonSourceDirectory_3 = ts.memoize(function () { return ts.getCommonSourceDirectoryOfConfig(resolvedRef.commandLine, !host.useCaseSensitiveFileNames()); });
                        ts.forEach(resolvedRef.commandLine.fileNames, function (fileName) {
                            if (!ts.isDeclarationFileName(fileName) && !ts.fileExtensionIs(fileName, ".json" /* Extension.Json */)) {
                                var outputDts = ts.getOutputDeclarationFileName(fileName, resolvedRef.commandLine, !host.useCaseSensitiveFileNames(), getCommonSourceDirectory_3);
                                mapFromToProjectReferenceRedirectSource.set(toPath(outputDts), fileName);
                            }
                        });
                    }
                });
            }
            return mapFromToProjectReferenceRedirectSource.get(path);
        }
        function isSourceOfProjectReferenceRedirect(fileName) {
            return useSourceOfProjectReferenceRedirect && !!getResolvedProjectReferenceToRedirect(fileName);
        }
        function getResolvedProjectReferenceByPath(projectReferencePath) {
            if (!projectReferenceRedirects) {
                return undefined;
            }
            return projectReferenceRedirects.get(projectReferencePath) || undefined;
        }
        function processReferencedFiles(file, isDefaultLib) {
            ts.forEach(file.referencedFiles, function (ref, index) {
                processSourceFile(resolveTripleslashReference(ref.fileName, file.fileName), isDefaultLib, 
                /*ignoreNoDefaultLib*/ false, 
                /*packageId*/ undefined, { kind: ts.FileIncludeKind.ReferenceFile, file: file.path, index: index, });
            });
        }
        function processTypeReferenceDirectives(file) {
            var typeDirectives = file.typeReferenceDirectives;
            if (!typeDirectives) {
                return;
            }
            var resolutions = resolveTypeReferenceDirectiveNamesWorker(typeDirectives, file);
            for (var index = 0; index < typeDirectives.length; index++) {
                var ref = file.typeReferenceDirectives[index];
                var resolvedTypeReferenceDirective = resolutions[index];
                // store resolved type directive on the file
                var fileName = ts.toFileNameLowerCase(ref.fileName);
                ts.setResolvedTypeReferenceDirective(file, fileName, resolvedTypeReferenceDirective);
                var mode = ref.resolutionMode || file.impliedNodeFormat;
                if (mode && ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Node16 && ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.NodeNext) {
                    programDiagnostics.add(ts.createDiagnosticForRange(file, ref, ts.Diagnostics.resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext));
                }
                processTypeReferenceDirective(fileName, mode, resolvedTypeReferenceDirective, { kind: ts.FileIncludeKind.TypeReferenceDirective, file: file.path, index: index, });
            }
        }
        function processTypeReferenceDirective(typeReferenceDirective, mode, resolvedTypeReferenceDirective, reason) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "processTypeReferenceDirective", { directive: typeReferenceDirective, hasResolved: !!resolveModuleNamesReusingOldState, refKind: reason.kind, refPath: isReferencedFile(reason) ? reason.file : undefined });
            processTypeReferenceDirectiveWorker(typeReferenceDirective, mode, resolvedTypeReferenceDirective, reason);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        function processTypeReferenceDirectiveWorker(typeReferenceDirective, mode, resolvedTypeReferenceDirective, reason) {
            // If we already found this library as a primary reference - nothing to do
            var previousResolution = resolvedTypeReferenceDirectives.get(typeReferenceDirective, mode);
            if (previousResolution && previousResolution.primary) {
                return;
            }
            var saveResolution = true;
            if (resolvedTypeReferenceDirective) {
                if (resolvedTypeReferenceDirective.isExternalLibraryImport)
                    currentNodeModulesDepth++;
                if (resolvedTypeReferenceDirective.primary) {
                    // resolved from the primary path
                    processSourceFile(resolvedTypeReferenceDirective.resolvedFileName, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, resolvedTypeReferenceDirective.packageId, reason); // TODO: GH#18217
                }
                else {
                    // If we already resolved to this file, it must have been a secondary reference. Check file contents
                    // for sameness and possibly issue an error
                    if (previousResolution) {
                        // Don't bother reading the file again if it's the same file.
                        if (resolvedTypeReferenceDirective.resolvedFileName !== previousResolution.resolvedFileName) {
                            var otherFileText = host.readFile(resolvedTypeReferenceDirective.resolvedFileName);
                            var existingFile = getSourceFile(previousResolution.resolvedFileName);
                            if (otherFileText !== existingFile.text) {
                                addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, ts.Diagnostics.Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict, [typeReferenceDirective, resolvedTypeReferenceDirective.resolvedFileName, previousResolution.resolvedFileName]);
                            }
                        }
                        // don't overwrite previous resolution result
                        saveResolution = false;
                    }
                    else {
                        // First resolution of this library
                        processSourceFile(resolvedTypeReferenceDirective.resolvedFileName, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, resolvedTypeReferenceDirective.packageId, reason);
                    }
                }
                if (resolvedTypeReferenceDirective.isExternalLibraryImport)
                    currentNodeModulesDepth--;
            }
            else {
                addFilePreprocessingFileExplainingDiagnostic(/*file*/ undefined, reason, ts.Diagnostics.Cannot_find_type_definition_file_for_0, [typeReferenceDirective]);
            }
            if (saveResolution) {
                resolvedTypeReferenceDirectives.set(typeReferenceDirective, mode, resolvedTypeReferenceDirective);
            }
        }
        function pathForLibFile(libFileName) {
            // Support resolving to lib.dom.d.ts -> @typescript/lib-dom, and
            //                      lib.dom.iterable.d.ts -> @typescript/lib-dom/iterable
            //                      lib.es2015.symbol.wellknown.d.ts -> @typescript/lib-es2015/symbol-wellknown
            var components = libFileName.split(".");
            var path = components[1];
            var i = 2;
            while (components[i] && components[i] !== "d") {
                path += (i === 2 ? "/" : "-") + components[i];
                i++;
            }
            var resolveFrom = ts.combinePaths(currentDirectory, "__lib_node_modules_lookup_".concat(libFileName, "__.ts"));
            var localOverrideModuleResult = ts.resolveModuleName("@typescript/lib-" + path, resolveFrom, { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, moduleResolutionCache);
            if (localOverrideModuleResult === null || localOverrideModuleResult === void 0 ? void 0 : localOverrideModuleResult.resolvedModule) {
                return localOverrideModuleResult.resolvedModule.resolvedFileName;
            }
            return ts.combinePaths(defaultLibraryPath, libFileName);
        }
        function processLibReferenceDirectives(file) {
            ts.forEach(file.libReferenceDirectives, function (libReference, index) {
                var libName = ts.toFileNameLowerCase(libReference.fileName);
                var libFileName = ts.libMap.get(libName);
                if (libFileName) {
                    // we ignore any 'no-default-lib' reference set on this file.
                    processRootFile(pathForLibFile(libFileName), /*isDefaultLib*/ true, /*ignoreNoDefaultLib*/ true, { kind: ts.FileIncludeKind.LibReferenceDirective, file: file.path, index: index, });
                }
                else {
                    var unqualifiedLibName = ts.removeSuffix(ts.removePrefix(libName, "lib."), ".d.ts");
                    var suggestion = ts.getSpellingSuggestion(unqualifiedLibName, ts.libs, ts.identity);
                    var diagnostic = suggestion ? ts.Diagnostics.Cannot_find_lib_definition_for_0_Did_you_mean_1 : ts.Diagnostics.Cannot_find_lib_definition_for_0;
                    (fileProcessingDiagnostics || (fileProcessingDiagnostics = [])).push({
                        kind: 0 /* FilePreprocessingDiagnosticsKind.FilePreprocessingReferencedDiagnostic */,
                        reason: { kind: ts.FileIncludeKind.LibReferenceDirective, file: file.path, index: index, },
                        diagnostic: diagnostic,
                        args: [libName, suggestion]
                    });
                }
            });
        }
        function getCanonicalFileName(fileName) {
            return host.getCanonicalFileName(fileName);
        }
        function processImportedModules(file) {
            var _a;
            collectExternalModuleReferences(file);
            if (file.imports.length || file.moduleAugmentations.length) {
                // Because global augmentation doesn't have string literal name, we can check for global augmentation as such.
                var moduleNames = getModuleNames(file);
                var resolutions = resolveModuleNamesReusingOldState(moduleNames, file);
                ts.Debug.assert(resolutions.length === moduleNames.length);
                var optionsForFile = (useSourceOfProjectReferenceRedirect ? (_a = getRedirectReferenceForResolution(file)) === null || _a === void 0 ? void 0 : _a.commandLine.options : undefined) || options;
                for (var index = 0; index < moduleNames.length; index++) {
                    var resolution = resolutions[index];
                    ts.setResolvedModule(file, moduleNames[index], resolution, getModeForResolutionAtIndex(file, index));
                    if (!resolution) {
                        continue;
                    }
                    var isFromNodeModulesSearch = resolution.isExternalLibraryImport;
                    var isJsFile = !ts.resolutionExtensionIsTSOrJson(resolution.extension);
                    var isJsFileFromNodeModules = isFromNodeModulesSearch && isJsFile;
                    var resolvedFileName = resolution.resolvedFileName;
                    if (isFromNodeModulesSearch) {
                        currentNodeModulesDepth++;
                    }
                    // add file to program only if:
                    // - resolution was successful
                    // - noResolve is falsy
                    // - module name comes from the list of imports
                    // - it's not a top level JavaScript module that exceeded the search max
                    var elideImport = isJsFileFromNodeModules && currentNodeModulesDepth > maxNodeModuleJsDepth;
                    // Don't add the file if it has a bad extension (e.g. 'tsx' if we don't have '--allowJs')
                    // This may still end up being an untyped module -- the file won't be included but imports will be allowed.
                    var shouldAddFile = resolvedFileName
                        && !getResolutionDiagnostic(optionsForFile, resolution)
                        && !optionsForFile.noResolve
                        && index < file.imports.length
                        && !elideImport
                        && !(isJsFile && !ts.getAllowJSCompilerOption(optionsForFile))
                        && (ts.isInJSFile(file.imports[index]) || !(file.imports[index].flags & 8388608 /* NodeFlags.JSDoc */));
                    if (elideImport) {
                        modulesWithElidedImports.set(file.path, true);
                    }
                    else if (shouldAddFile) {
                        findSourceFile(resolvedFileName, 
                        /*isDefaultLib*/ false, 
                        /*ignoreNoDefaultLib*/ false, { kind: ts.FileIncludeKind.Import, file: file.path, index: index, }, resolution.packageId);
                    }
                    if (isFromNodeModulesSearch) {
                        currentNodeModulesDepth--;
                    }
                }
            }
            else {
                // no imports - drop cached module resolutions
                file.resolvedModules = undefined;
            }
        }
        function checkSourceFilesBelongToPath(sourceFiles, rootDirectory) {
            var allFilesBelongToPath = true;
            var absoluteRootDirectoryPath = host.getCanonicalFileName(ts.getNormalizedAbsolutePath(rootDirectory, currentDirectory));
            for (var _i = 0, sourceFiles_2 = sourceFiles; _i < sourceFiles_2.length; _i++) {
                var sourceFile = sourceFiles_2[_i];
                if (!sourceFile.isDeclarationFile) {
                    var absoluteSourceFilePath = host.getCanonicalFileName(ts.getNormalizedAbsolutePath(sourceFile.fileName, currentDirectory));
                    if (absoluteSourceFilePath.indexOf(absoluteRootDirectoryPath) !== 0) {
                        addProgramDiagnosticExplainingFile(sourceFile, ts.Diagnostics.File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files, [sourceFile.fileName, rootDirectory]);
                        allFilesBelongToPath = false;
                    }
                }
            }
            return allFilesBelongToPath;
        }
        function parseProjectReferenceConfigFile(ref) {
            if (!projectReferenceRedirects) {
                projectReferenceRedirects = new ts.Map();
            }
            // The actual filename (i.e. add "/tsconfig.json" if necessary)
            var refPath = resolveProjectReferencePath(ref);
            var sourceFilePath = toPath(refPath);
            var fromCache = projectReferenceRedirects.get(sourceFilePath);
            if (fromCache !== undefined) {
                return fromCache || undefined;
            }
            var commandLine;
            var sourceFile;
            if (host.getParsedCommandLine) {
                commandLine = host.getParsedCommandLine(refPath);
                if (!commandLine) {
                    addFileToFilesByName(/*sourceFile*/ undefined, sourceFilePath, /*redirectedPath*/ undefined);
                    projectReferenceRedirects.set(sourceFilePath, false);
                    return undefined;
                }
                sourceFile = ts.Debug.checkDefined(commandLine.options.configFile);
                ts.Debug.assert(!sourceFile.path || sourceFile.path === sourceFilePath);
                addFileToFilesByName(sourceFile, sourceFilePath, /*redirectedPath*/ undefined);
            }
            else {
                // An absolute path pointing to the containing directory of the config file
                var basePath = ts.getNormalizedAbsolutePath(ts.getDirectoryPath(refPath), host.getCurrentDirectory());
                sourceFile = host.getSourceFile(refPath, 100 /* ScriptTarget.JSON */);
                addFileToFilesByName(sourceFile, sourceFilePath, /*redirectedPath*/ undefined);
                if (sourceFile === undefined) {
                    projectReferenceRedirects.set(sourceFilePath, false);
                    return undefined;
                }
                commandLine = ts.parseJsonSourceFileConfigFileContent(sourceFile, configParsingHost, basePath, /*existingOptions*/ undefined, refPath);
            }
            sourceFile.fileName = refPath;
            sourceFile.path = sourceFilePath;
            sourceFile.resolvedPath = sourceFilePath;
            sourceFile.originalFileName = refPath;
            var resolvedRef = { commandLine: commandLine, sourceFile: sourceFile };
            projectReferenceRedirects.set(sourceFilePath, resolvedRef);
            if (commandLine.projectReferences) {
                resolvedRef.references = commandLine.projectReferences.map(parseProjectReferenceConfigFile);
            }
            return resolvedRef;
        }
        function verifyCompilerOptions() {
            if (options.strictPropertyInitialization && !ts.getStrictOptionValue(options, "strictNullChecks")) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "strictPropertyInitialization", "strictNullChecks");
            }
            if (options.exactOptionalPropertyTypes && !ts.getStrictOptionValue(options, "strictNullChecks")) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "exactOptionalPropertyTypes", "strictNullChecks");
            }
            if (options.isolatedModules) {
                if (options.out) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "out", "isolatedModules");
                }
                if (options.outFile) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "outFile", "isolatedModules");
                }
            }
            if (options.inlineSourceMap) {
                if (options.sourceMap) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "sourceMap", "inlineSourceMap");
                }
                if (options.mapRoot) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "mapRoot", "inlineSourceMap");
                }
            }
            if (options.composite) {
                if (options.declaration === false) {
                    createDiagnosticForOptionName(ts.Diagnostics.Composite_projects_may_not_disable_declaration_emit, "declaration");
                }
                if (options.incremental === false) {
                    createDiagnosticForOptionName(ts.Diagnostics.Composite_projects_may_not_disable_incremental_compilation, "declaration");
                }
            }
            var outputFile = ts.outFile(options);
            if (options.tsBuildInfoFile) {
                if (!ts.isIncrementalCompilation(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "tsBuildInfoFile", "incremental", "composite");
                }
            }
            else if (options.incremental && !outputFile && !options.configFilePath) {
                programDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified));
            }
            verifyProjectReferences();
            // List of collected files is complete; validate exhautiveness if this is a project with a file list
            if (options.composite) {
                var rootPaths = new ts.Set(rootNames.map(toPath));
                for (var _i = 0, files_4 = files; _i < files_4.length; _i++) {
                    var file = files_4[_i];
                    // Ignore file that is not emitted
                    if (ts.sourceFileMayBeEmitted(file, program) && !rootPaths.has(file.path)) {
                        addProgramDiagnosticExplainingFile(file, ts.Diagnostics.File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern, [file.fileName, options.configFilePath || ""]);
                    }
                }
            }
            if (options.paths) {
                for (var key in options.paths) {
                    if (!ts.hasProperty(options.paths, key)) {
                        continue;
                    }
                    if (!ts.hasZeroOrOneAsteriskCharacter(key)) {
                        createDiagnosticForOptionPaths(/*onKey*/ true, key, ts.Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, key);
                    }
                    if (ts.isArray(options.paths[key])) {
                        var len = options.paths[key].length;
                        if (len === 0) {
                            createDiagnosticForOptionPaths(/*onKey*/ false, key, ts.Diagnostics.Substitutions_for_pattern_0_shouldn_t_be_an_empty_array, key);
                        }
                        for (var i = 0; i < len; i++) {
                            var subst = options.paths[key][i];
                            var typeOfSubst = typeof subst;
                            if (typeOfSubst === "string") {
                                if (!ts.hasZeroOrOneAsteriskCharacter(subst)) {
                                    createDiagnosticForOptionPathKeyValue(key, i, ts.Diagnostics.Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character, subst, key);
                                }
                                if (!options.baseUrl && !ts.pathIsRelative(subst) && !ts.pathIsAbsolute(subst)) {
                                    createDiagnosticForOptionPathKeyValue(key, i, ts.Diagnostics.Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash);
                                }
                            }
                            else {
                                createDiagnosticForOptionPathKeyValue(key, i, ts.Diagnostics.Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2, subst, key, typeOfSubst);
                            }
                        }
                    }
                    else {
                        createDiagnosticForOptionPaths(/*onKey*/ false, key, ts.Diagnostics.Substitutions_for_pattern_0_should_be_an_array, key);
                    }
                }
            }
            if (!options.sourceMap && !options.inlineSourceMap) {
                if (options.inlineSources) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided, "inlineSources");
                }
                if (options.sourceRoot) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided, "sourceRoot");
                }
            }
            if (options.out && options.outFile) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "out", "outFile");
            }
            if (options.mapRoot && !(options.sourceMap || options.declarationMap)) {
                // Error to specify --mapRoot without --sourcemap
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "mapRoot", "sourceMap", "declarationMap");
            }
            if (options.declarationDir) {
                if (!ts.getEmitDeclarations(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "declarationDir", "declaration", "composite");
                }
                if (outputFile) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "declarationDir", options.out ? "out" : "outFile");
                }
            }
            if (options.declarationMap && !ts.getEmitDeclarations(options)) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "declarationMap", "declaration", "composite");
            }
            if (options.lib && options.noLib) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "lib", "noLib");
            }
            if (options.noImplicitUseStrict && ts.getStrictOptionValue(options, "alwaysStrict")) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "noImplicitUseStrict", "alwaysStrict");
            }
            var languageVersion = ts.getEmitScriptTarget(options);
            var firstNonAmbientExternalModuleSourceFile = ts.find(files, function (f) { return ts.isExternalModule(f) && !f.isDeclarationFile; });
            if (options.isolatedModules) {
                if (options.module === ts.ModuleKind.None && languageVersion < 2 /* ScriptTarget.ES2015 */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher, "isolatedModules", "target");
                }
                if (options.preserveConstEnums === false) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled, "preserveConstEnums", "isolatedModules");
                }
                var firstNonExternalModuleSourceFile = ts.find(files, function (f) { return !ts.isExternalModule(f) && !ts.isSourceFileJS(f) && !f.isDeclarationFile && f.scriptKind !== 6 /* ScriptKind.JSON */; });
                if (firstNonExternalModuleSourceFile) {
                    var span = ts.getErrorSpanForNode(firstNonExternalModuleSourceFile, firstNonExternalModuleSourceFile);
                    programDiagnostics.add(ts.createFileDiagnostic(firstNonExternalModuleSourceFile, span.start, span.length, ts.Diagnostics._0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_import_export_or_an_empty_export_statement_to_make_it_a_module, ts.getBaseFileName(firstNonExternalModuleSourceFile.fileName)));
                }
            }
            else if (firstNonAmbientExternalModuleSourceFile && languageVersion < 2 /* ScriptTarget.ES2015 */ && options.module === ts.ModuleKind.None) {
                // We cannot use createDiagnosticFromNode because nodes do not have parents yet
                var span = ts.getErrorSpanForNode(firstNonAmbientExternalModuleSourceFile, typeof firstNonAmbientExternalModuleSourceFile.externalModuleIndicator === "boolean" ? firstNonAmbientExternalModuleSourceFile : firstNonAmbientExternalModuleSourceFile.externalModuleIndicator);
                programDiagnostics.add(ts.createFileDiagnostic(firstNonAmbientExternalModuleSourceFile, span.start, span.length, ts.Diagnostics.Cannot_use_imports_exports_or_module_augmentations_when_module_is_none));
            }
            // Cannot specify module gen that isn't amd or system with --out
            if (outputFile && !options.emitDeclarationOnly) {
                if (options.module && !(options.module === ts.ModuleKind.AMD || options.module === ts.ModuleKind.System)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Only_amd_and_system_modules_are_supported_alongside_0, options.out ? "out" : "outFile", "module");
                }
                else if (options.module === undefined && firstNonAmbientExternalModuleSourceFile) {
                    var span = ts.getErrorSpanForNode(firstNonAmbientExternalModuleSourceFile, typeof firstNonAmbientExternalModuleSourceFile.externalModuleIndicator === "boolean" ? firstNonAmbientExternalModuleSourceFile : firstNonAmbientExternalModuleSourceFile.externalModuleIndicator);
                    programDiagnostics.add(ts.createFileDiagnostic(firstNonAmbientExternalModuleSourceFile, span.start, span.length, ts.Diagnostics.Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system, options.out ? "out" : "outFile"));
                }
            }
            if (options.resolveJsonModule) {
                if (ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.NodeJs &&
                    ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Node16 &&
                    ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.NodeNext) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy, "resolveJsonModule");
                }
                // Any emit other than common js, amd, es2015 or esnext is error
                else if (!ts.hasJsonModuleEmitEnabled(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext, "resolveJsonModule", "module");
                }
            }
            // there has to be common source directory if user specified --outdir || --rootDir || --sourceRoot
            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted
            if (options.outDir || // there is --outDir specified
                options.rootDir || // there is --rootDir specified
                options.sourceRoot || // there is --sourceRoot specified
                options.mapRoot) { // there is --mapRoot specified
                // Precalculate and cache the common source directory
                var dir = getCommonSourceDirectory();
                // If we failed to find a good common directory, but outDir is specified and at least one of our files is on a windows drive/URL/other resource, add a failure
                if (options.outDir && dir === "" && files.some(function (file) { return ts.getRootLength(file.fileName) > 1; })) {
                    createDiagnosticForOptionName(ts.Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files, "outDir");
                }
            }
            if (options.useDefineForClassFields && languageVersion === 0 /* ScriptTarget.ES3 */) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_target_is_ES3, "useDefineForClassFields");
            }
            if (options.checkJs && !ts.getAllowJSCompilerOption(options)) {
                programDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "checkJs", "allowJs"));
            }
            if (options.emitDeclarationOnly) {
                if (!ts.getEmitDeclarations(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "emitDeclarationOnly", "declaration", "composite");
                }
                if (options.noEmit) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "emitDeclarationOnly", "noEmit");
                }
            }
            if (options.emitDecoratorMetadata &&
                !options.experimentalDecorators) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "emitDecoratorMetadata", "experimentalDecorators");
            }
            if (options.jsxFactory) {
                if (options.reactNamespace) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "reactNamespace", "jsxFactory");
                }
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxFactory", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
                if (!ts.parseIsolatedEntityName(options.jsxFactory, languageVersion)) {
                    createOptionValueDiagnostic("jsxFactory", ts.Diagnostics.Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name, options.jsxFactory);
                }
            }
            else if (options.reactNamespace && !ts.isIdentifierText(options.reactNamespace, languageVersion)) {
                createOptionValueDiagnostic("reactNamespace", ts.Diagnostics.Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier, options.reactNamespace);
            }
            if (options.jsxFragmentFactory) {
                if (!options.jsxFactory) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "jsxFragmentFactory", "jsxFactory");
                }
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxFragmentFactory", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
                if (!ts.parseIsolatedEntityName(options.jsxFragmentFactory, languageVersion)) {
                    createOptionValueDiagnostic("jsxFragmentFactory", ts.Diagnostics.Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name, options.jsxFragmentFactory);
                }
            }
            if (options.reactNamespace) {
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "reactNamespace", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
            }
            if (options.jsxImportSource) {
                if (options.jsx === 2 /* JsxEmit.React */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxImportSource", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
            }
            if (options.preserveValueImports && ts.getEmitModuleKind(options) < ts.ModuleKind.ES2015) {
                createOptionValueDiagnostic("importsNotUsedAsValues", ts.Diagnostics.Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later);
            }
            // If the emit is enabled make sure that every output file is unique and not overwriting any of the input files
            if (!options.noEmit && !options.suppressOutputPathCheck) {
                var emitHost = getEmitHost();
                var emitFilesSeen_1 = new ts.Set();
                ts.forEachEmittedFile(emitHost, function (emitFileNames) {
                    if (!options.emitDeclarationOnly) {
                        verifyEmitFilePath(emitFileNames.jsFilePath, emitFilesSeen_1);
                    }
                    verifyEmitFilePath(emitFileNames.declarationFilePath, emitFilesSeen_1);
                });
            }
            // Verify that all the emit files are unique and don't overwrite input files
            function verifyEmitFilePath(emitFileName, emitFilesSeen) {
                if (emitFileName) {
                    var emitFilePath = toPath(emitFileName);
                    // Report error if the output overwrites input file
                    if (filesByName.has(emitFilePath)) {
                        var chain = void 0;
                        if (!options.configFilePath) {
                            // The program is from either an inferred project or an external project
                            chain = ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig);
                        }
                        chain = ts.chainDiagnosticMessages(chain, ts.Diagnostics.Cannot_write_file_0_because_it_would_overwrite_input_file, emitFileName);
                        blockEmittingOfFile(emitFileName, ts.createCompilerDiagnosticFromMessageChain(chain));
                    }
                    var emitFileKey = !host.useCaseSensitiveFileNames() ? ts.toFileNameLowerCase(emitFilePath) : emitFilePath;
                    // Report error if multiple files write into same file
                    if (emitFilesSeen.has(emitFileKey)) {
                        // Already seen the same emit file - report error
                        blockEmittingOfFile(emitFileName, ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files, emitFileName));
                    }
                    else {
                        emitFilesSeen.add(emitFileKey);
                    }
                }
            }
        }
        function createDiagnosticExplainingFile(file, fileProcessingReason, diagnostic, args) {
            var _a;
            var fileIncludeReasons;
            var relatedInfo;
            var locationReason = isReferencedFile(fileProcessingReason) ? fileProcessingReason : undefined;
            if (file)
                (_a = fileReasons.get(file.path)) === null || _a === void 0 ? void 0 : _a.forEach(processReason);
            if (fileProcessingReason)
                processReason(fileProcessingReason);
            // If we have location and there is only one reason file is in which is the location, dont add details for file include
            if (locationReason && (fileIncludeReasons === null || fileIncludeReasons === void 0 ? void 0 : fileIncludeReasons.length) === 1)
                fileIncludeReasons = undefined;
            var location = locationReason && getReferencedFileLocation(getSourceFileByPath, locationReason);
            var fileIncludeReasonDetails = fileIncludeReasons && ts.chainDiagnosticMessages(fileIncludeReasons, ts.Diagnostics.The_file_is_in_the_program_because_Colon);
            var redirectInfo = file && ts.explainIfFileIsRedirect(file);
            var chain = ts.chainDiagnosticMessages.apply(void 0, __spreadArray([redirectInfo ? fileIncludeReasonDetails ? __spreadArray([fileIncludeReasonDetails], redirectInfo, true) : redirectInfo : fileIncludeReasonDetails, diagnostic], args || ts.emptyArray, false));
            return location && isReferenceFileLocation(location) ?
                ts.createFileDiagnosticFromMessageChain(location.file, location.pos, location.end - location.pos, chain, relatedInfo) :
                ts.createCompilerDiagnosticFromMessageChain(chain, relatedInfo);
            function processReason(reason) {
                (fileIncludeReasons || (fileIncludeReasons = [])).push(ts.fileIncludeReasonToDiagnostics(program, reason));
                if (!locationReason && isReferencedFile(reason)) {
                    // Report error at first reference file or file currently in processing and dont report in related information
                    locationReason = reason;
                }
                else if (locationReason !== reason) {
                    relatedInfo = ts.append(relatedInfo, fileIncludeReasonToRelatedInformation(reason));
                }
                // Remove fileProcessingReason if its already included in fileReasons of the program
                if (reason === fileProcessingReason)
                    fileProcessingReason = undefined;
            }
        }
        function addFilePreprocessingFileExplainingDiagnostic(file, fileProcessingReason, diagnostic, args) {
            (fileProcessingDiagnostics || (fileProcessingDiagnostics = [])).push({
                kind: 1 /* FilePreprocessingDiagnosticsKind.FilePreprocessingFileExplainingDiagnostic */,
                file: file && file.path,
                fileProcessingReason: fileProcessingReason,
                diagnostic: diagnostic,
                args: args
            });
        }
        function addProgramDiagnosticExplainingFile(file, diagnostic, args) {
            programDiagnostics.add(createDiagnosticExplainingFile(file, /*fileProcessingReason*/ undefined, diagnostic, args));
        }
        function fileIncludeReasonToRelatedInformation(reason) {
            if (isReferencedFile(reason)) {
                var referenceLocation = getReferencedFileLocation(getSourceFileByPath, reason);
                var message_2;
                switch (reason.kind) {
                    case ts.FileIncludeKind.Import:
                        message_2 = ts.Diagnostics.File_is_included_via_import_here;
                        break;
                    case ts.FileIncludeKind.ReferenceFile:
                        message_2 = ts.Diagnostics.File_is_included_via_reference_here;
                        break;
                    case ts.FileIncludeKind.TypeReferenceDirective:
                        message_2 = ts.Diagnostics.File_is_included_via_type_library_reference_here;
                        break;
                    case ts.FileIncludeKind.LibReferenceDirective:
                        message_2 = ts.Diagnostics.File_is_included_via_library_reference_here;
                        break;
                    default:
                        ts.Debug.assertNever(reason);
                }
                return isReferenceFileLocation(referenceLocation) ? ts.createFileDiagnostic(referenceLocation.file, referenceLocation.pos, referenceLocation.end - referenceLocation.pos, message_2) : undefined;
            }
            if (!options.configFile)
                return undefined;
            var configFileNode;
            var message;
            switch (reason.kind) {
                case ts.FileIncludeKind.RootFile:
                    if (!options.configFile.configFileSpecs)
                        return undefined;
                    var fileName = ts.getNormalizedAbsolutePath(rootNames[reason.index], currentDirectory);
                    var matchedByFiles = ts.getMatchedFileSpec(program, fileName);
                    if (matchedByFiles) {
                        configFileNode = ts.getTsConfigPropArrayElementValue(options.configFile, "files", matchedByFiles);
                        message = ts.Diagnostics.File_is_matched_by_files_list_specified_here;
                        break;
                    }
                    var matchedByInclude = ts.getMatchedIncludeSpec(program, fileName);
                    // Could be additional files specified as roots
                    if (!matchedByInclude)
                        return undefined;
                    configFileNode = ts.getTsConfigPropArrayElementValue(options.configFile, "include", matchedByInclude);
                    message = ts.Diagnostics.File_is_matched_by_include_pattern_specified_here;
                    break;
                case ts.FileIncludeKind.SourceFromProjectReference:
                case ts.FileIncludeKind.OutputFromProjectReference:
                    var referencedResolvedRef_1 = ts.Debug.checkDefined(resolvedProjectReferences === null || resolvedProjectReferences === void 0 ? void 0 : resolvedProjectReferences[reason.index]);
                    var referenceInfo = forEachProjectReference(projectReferences, resolvedProjectReferences, function (resolvedRef, parent, index) {
                        return resolvedRef === referencedResolvedRef_1 ? { sourceFile: (parent === null || parent === void 0 ? void 0 : parent.sourceFile) || options.configFile, index: index } : undefined;
                    });
                    if (!referenceInfo)
                        return undefined;
                    var sourceFile = referenceInfo.sourceFile, index = referenceInfo.index;
                    var referencesSyntax = ts.firstDefined(ts.getTsConfigPropArray(sourceFile, "references"), function (property) { return ts.isArrayLiteralExpression(property.initializer) ? property.initializer : undefined; });
                    return referencesSyntax && referencesSyntax.elements.length > index ?
                        ts.createDiagnosticForNodeInSourceFile(sourceFile, referencesSyntax.elements[index], reason.kind === ts.FileIncludeKind.OutputFromProjectReference ?
                            ts.Diagnostics.File_is_output_from_referenced_project_specified_here :
                            ts.Diagnostics.File_is_source_from_referenced_project_specified_here) :
                        undefined;
                case ts.FileIncludeKind.AutomaticTypeDirectiveFile:
                    if (!options.types)
                        return undefined;
                    configFileNode = getOptionsSyntaxByArrayElementValue("types", reason.typeReference);
                    message = ts.Diagnostics.File_is_entry_point_of_type_library_specified_here;
                    break;
                case ts.FileIncludeKind.LibFile:
                    if (reason.index !== undefined) {
                        configFileNode = getOptionsSyntaxByArrayElementValue("lib", options.lib[reason.index]);
                        message = ts.Diagnostics.File_is_library_specified_here;
                        break;
                    }
                    var target = ts.forEachEntry(ts.targetOptionDeclaration.type, function (value, key) { return value === ts.getEmitScriptTarget(options) ? key : undefined; });
                    configFileNode = target ? getOptionsSyntaxByValue("target", target) : undefined;
                    message = ts.Diagnostics.File_is_default_library_for_target_specified_here;
                    break;
                default:
                    ts.Debug.assertNever(reason);
            }
            return configFileNode && ts.createDiagnosticForNodeInSourceFile(options.configFile, configFileNode, message);
        }
        function verifyProjectReferences() {
            var buildInfoPath = !options.suppressOutputPathCheck ? ts.getTsBuildInfoEmitOutputFilePath(options) : undefined;
            forEachProjectReference(projectReferences, resolvedProjectReferences, function (resolvedRef, parent, index) {
                var ref = (parent ? parent.commandLine.projectReferences : projectReferences)[index];
                var parentFile = parent && parent.sourceFile;
                if (!resolvedRef) {
                    createDiagnosticForReference(parentFile, index, ts.Diagnostics.File_0_not_found, ref.path);
                    return;
                }
                var options = resolvedRef.commandLine.options;
                if (!options.composite || options.noEmit) {
                    // ok to not have composite if the current program is container only
                    var inputs = parent ? parent.commandLine.fileNames : rootNames;
                    if (inputs.length) {
                        if (!options.composite)
                            createDiagnosticForReference(parentFile, index, ts.Diagnostics.Referenced_project_0_must_have_setting_composite_Colon_true, ref.path);
                        if (options.noEmit)
                            createDiagnosticForReference(parentFile, index, ts.Diagnostics.Referenced_project_0_may_not_disable_emit, ref.path);
                    }
                }
                if (ref.prepend) {
                    var out = ts.outFile(options);
                    if (out) {
                        if (!host.fileExists(out)) {
                            createDiagnosticForReference(parentFile, index, ts.Diagnostics.Output_file_0_from_project_1_does_not_exist, out, ref.path);
                        }
                    }
                    else {
                        createDiagnosticForReference(parentFile, index, ts.Diagnostics.Cannot_prepend_project_0_because_it_does_not_have_outFile_set, ref.path);
                    }
                }
                if (!parent && buildInfoPath && buildInfoPath === ts.getTsBuildInfoEmitOutputFilePath(options)) {
                    createDiagnosticForReference(parentFile, index, ts.Diagnostics.Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1, buildInfoPath, ref.path);
                    hasEmitBlockingDiagnostics.set(toPath(buildInfoPath), true);
                }
            });
        }
        function createDiagnosticForOptionPathKeyValue(key, valueIndex, message, arg0, arg1, arg2) {
            var needCompilerDiagnostic = true;
            var pathsSyntax = getOptionPathsSyntax();
            for (var _i = 0, pathsSyntax_1 = pathsSyntax; _i < pathsSyntax_1.length; _i++) {
                var pathProp = pathsSyntax_1[_i];
                if (ts.isObjectLiteralExpression(pathProp.initializer)) {
                    for (var _a = 0, _b = ts.getPropertyAssignment(pathProp.initializer, key); _a < _b.length; _a++) {
                        var keyProps = _b[_a];
                        var initializer = keyProps.initializer;
                        if (ts.isArrayLiteralExpression(initializer) && initializer.elements.length > valueIndex) {
                            programDiagnostics.add(ts.createDiagnosticForNodeInSourceFile(options.configFile, initializer.elements[valueIndex], message, arg0, arg1, arg2));
                            needCompilerDiagnostic = false;
                        }
                    }
                }
            }
            if (needCompilerDiagnostic) {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0, arg1, arg2));
            }
        }
        function createDiagnosticForOptionPaths(onKey, key, message, arg0) {
            var needCompilerDiagnostic = true;
            var pathsSyntax = getOptionPathsSyntax();
            for (var _i = 0, pathsSyntax_2 = pathsSyntax; _i < pathsSyntax_2.length; _i++) {
                var pathProp = pathsSyntax_2[_i];
                if (ts.isObjectLiteralExpression(pathProp.initializer) &&
                    createOptionDiagnosticInObjectLiteralSyntax(pathProp.initializer, onKey, key, /*key2*/ undefined, message, arg0)) {
                    needCompilerDiagnostic = false;
                }
            }
            if (needCompilerDiagnostic) {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0));
            }
        }
        function getOptionsSyntaxByName(name) {
            var compilerOptionsObjectLiteralSyntax = getCompilerOptionsObjectLiteralSyntax();
            return compilerOptionsObjectLiteralSyntax && ts.getPropertyAssignment(compilerOptionsObjectLiteralSyntax, name);
        }
        function getOptionPathsSyntax() {
            return getOptionsSyntaxByName("paths") || ts.emptyArray;
        }
        function getOptionsSyntaxByValue(name, value) {
            var syntaxByName = getOptionsSyntaxByName(name);
            return syntaxByName && ts.firstDefined(syntaxByName, function (property) { return ts.isStringLiteral(property.initializer) && property.initializer.text === value ? property.initializer : undefined; });
        }
        function getOptionsSyntaxByArrayElementValue(name, value) {
            var compilerOptionsObjectLiteralSyntax = getCompilerOptionsObjectLiteralSyntax();
            return compilerOptionsObjectLiteralSyntax && ts.getPropertyArrayElementValue(compilerOptionsObjectLiteralSyntax, name, value);
        }
        function createDiagnosticForOptionName(message, option1, option2, option3) {
            createDiagnosticForOption(/*onKey*/ true, option1, option2, message, option1, option2, option3);
        }
        function createOptionValueDiagnostic(option1, message, arg0, arg1) {
            createDiagnosticForOption(/*onKey*/ false, option1, /*option2*/ undefined, message, arg0, arg1);
        }
        function createDiagnosticForReference(sourceFile, index, message, arg0, arg1) {
            var referencesSyntax = ts.firstDefined(ts.getTsConfigPropArray(sourceFile || options.configFile, "references"), function (property) { return ts.isArrayLiteralExpression(property.initializer) ? property.initializer : undefined; });
            if (referencesSyntax && referencesSyntax.elements.length > index) {
                programDiagnostics.add(ts.createDiagnosticForNodeInSourceFile(sourceFile || options.configFile, referencesSyntax.elements[index], message, arg0, arg1));
            }
            else {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0, arg1));
            }
        }
        function createDiagnosticForOption(onKey, option1, option2, message, arg0, arg1, arg2) {
            var compilerOptionsObjectLiteralSyntax = getCompilerOptionsObjectLiteralSyntax();
            var needCompilerDiagnostic = !compilerOptionsObjectLiteralSyntax ||
                !createOptionDiagnosticInObjectLiteralSyntax(compilerOptionsObjectLiteralSyntax, onKey, option1, option2, message, arg0, arg1, arg2);
            if (needCompilerDiagnostic) {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0, arg1, arg2));
            }
        }
        function getCompilerOptionsObjectLiteralSyntax() {
            if (_compilerOptionsObjectLiteralSyntax === undefined) {
                _compilerOptionsObjectLiteralSyntax = false;
                var jsonObjectLiteral = ts.getTsConfigObjectLiteralExpression(options.configFile);
                if (jsonObjectLiteral) {
                    for (var _i = 0, _a = ts.getPropertyAssignment(jsonObjectLiteral, "compilerOptions"); _i < _a.length; _i++) {
                        var prop = _a[_i];
                        if (ts.isObjectLiteralExpression(prop.initializer)) {
                            _compilerOptionsObjectLiteralSyntax = prop.initializer;
                            break;
                        }
                    }
                }
            }
            return _compilerOptionsObjectLiteralSyntax || undefined;
        }
        function createOptionDiagnosticInObjectLiteralSyntax(objectLiteral, onKey, key1, key2, message, arg0, arg1, arg2) {
            var props = ts.getPropertyAssignment(objectLiteral, key1, key2);
            for (var _i = 0, props_3 = props; _i < props_3.length; _i++) {
                var prop = props_3[_i];
                programDiagnostics.add(ts.createDiagnosticForNodeInSourceFile(options.configFile, onKey ? prop.name : prop.initializer, message, arg0, arg1, arg2));
            }
            return !!props.length;
        }
        function blockEmittingOfFile(emitFileName, diag) {
            hasEmitBlockingDiagnostics.set(toPath(emitFileName), true);
            programDiagnostics.add(diag);
        }
        function isEmittedFile(file) {
            if (options.noEmit) {
                return false;
            }
            // If this is source file, its not emitted file
            var filePath = toPath(file);
            if (getSourceFileByPath(filePath)) {
                return false;
            }
            // If options have --outFile or --out just check that
            var out = ts.outFile(options);
            if (out) {
                return isSameFile(filePath, out) || isSameFile(filePath, ts.removeFileExtension(out) + ".d.ts" /* Extension.Dts */);
            }
            // If declarationDir is specified, return if its a file in that directory
            if (options.declarationDir && ts.containsPath(options.declarationDir, filePath, currentDirectory, !host.useCaseSensitiveFileNames())) {
                return true;
            }
            // If --outDir, check if file is in that directory
            if (options.outDir) {
                return ts.containsPath(options.outDir, filePath, currentDirectory, !host.useCaseSensitiveFileNames());
            }
            if (ts.fileExtensionIsOneOf(filePath, ts.supportedJSExtensionsFlat) || ts.isDeclarationFileName(filePath)) {
                // Otherwise just check if sourceFile with the name exists
                var filePathWithoutExtension = ts.removeFileExtension(filePath);
                return !!getSourceFileByPath((filePathWithoutExtension + ".ts" /* Extension.Ts */)) ||
                    !!getSourceFileByPath((filePathWithoutExtension + ".tsx" /* Extension.Tsx */));
            }
            return false;
        }
        function isSameFile(file1, file2) {
            return ts.comparePaths(file1, file2, currentDirectory, !host.useCaseSensitiveFileNames()) === 0 /* Comparison.EqualTo */;
        }
        function getSymlinkCache() {
            if (host.getSymlinkCache) {
                return host.getSymlinkCache();
            }
            if (!symlinks) {
                symlinks = ts.createSymlinkCache(currentDirectory, getCanonicalFileName);
            }
            if (files && resolvedTypeReferenceDirectives && !symlinks.hasProcessedResolutions()) {
                symlinks.setSymlinksFromResolutions(files, resolvedTypeReferenceDirectives);
            }
            return symlinks;
        }
    }
    ts.createProgram = createProgram;
    function updateHostForUseSourceOfProjectReferenceRedirect(host) {
        var setOfDeclarationDirectories;
        var originalFileExists = host.compilerHost.fileExists;
        var originalDirectoryExists = host.compilerHost.directoryExists;
        var originalGetDirectories = host.compilerHost.getDirectories;
        var originalRealpath = host.compilerHost.realpath;
        if (!host.useSourceOfProjectReferenceRedirect)
            return { onProgramCreateComplete: ts.noop, fileExists: fileExists };
        host.compilerHost.fileExists = fileExists;
        var directoryExists;
        if (originalDirectoryExists) {
            // This implementation of directoryExists checks if the directory being requested is
            // directory of .d.ts file for the referenced Project.
            // If it is it returns true irrespective of whether that directory exists on host
            directoryExists = host.compilerHost.directoryExists = function (path) {
                if (originalDirectoryExists.call(host.compilerHost, path)) {
                    handleDirectoryCouldBeSymlink(path);
                    return true;
                }
                if (!host.getResolvedProjectReferences())
                    return false;
                if (!setOfDeclarationDirectories) {
                    setOfDeclarationDirectories = new ts.Set();
                    host.forEachResolvedProjectReference(function (ref) {
                        var out = ts.outFile(ref.commandLine.options);
                        if (out) {
                            setOfDeclarationDirectories.add(ts.getDirectoryPath(host.toPath(out)));
                        }
                        else {
                            // Set declaration's in different locations only, if they are next to source the directory present doesnt change
                            var declarationDir = ref.commandLine.options.declarationDir || ref.commandLine.options.outDir;
                            if (declarationDir) {
                                setOfDeclarationDirectories.add(host.toPath(declarationDir));
                            }
                        }
                    });
                }
                return fileOrDirectoryExistsUsingSource(path, /*isFile*/ false);
            };
        }
        if (originalGetDirectories) {
            // Call getDirectories only if directory actually present on the host
            // This is needed to ensure that we arent getting directories that we fake about presence for
            host.compilerHost.getDirectories = function (path) {
                return !host.getResolvedProjectReferences() || (originalDirectoryExists && originalDirectoryExists.call(host.compilerHost, path)) ?
                    originalGetDirectories.call(host.compilerHost, path) :
                    [];
            };
        }
        // This is something we keep for life time of the host
        if (originalRealpath) {
            host.compilerHost.realpath = function (s) {
                var _a;
                return ((_a = host.getSymlinkCache().getSymlinkedFiles()) === null || _a === void 0 ? void 0 : _a.get(host.toPath(s))) ||
                    originalRealpath.call(host.compilerHost, s);
            };
        }
        return { onProgramCreateComplete: onProgramCreateComplete, fileExists: fileExists, directoryExists: directoryExists };
        function onProgramCreateComplete() {
            host.compilerHost.fileExists = originalFileExists;
            host.compilerHost.directoryExists = originalDirectoryExists;
            host.compilerHost.getDirectories = originalGetDirectories;
            // DO not revert realpath as it could be used later
        }
        // This implementation of fileExists checks if the file being requested is
        // .d.ts file for the referenced Project.
        // If it is it returns true irrespective of whether that file exists on host
        function fileExists(file) {
            if (originalFileExists.call(host.compilerHost, file))
                return true;
            if (!host.getResolvedProjectReferences())
                return false;
            if (!ts.isDeclarationFileName(file))
                return false;
            // Project references go to source file instead of .d.ts file
            return fileOrDirectoryExistsUsingSource(file, /*isFile*/ true);
        }
        function fileExistsIfProjectReferenceDts(file) {
            var source = host.getSourceOfProjectReferenceRedirect(host.toPath(file));
            return source !== undefined ?
                ts.isString(source) ? originalFileExists.call(host.compilerHost, source) : true :
                undefined;
        }
        function directoryExistsIfProjectReferenceDeclDir(dir) {
            var dirPath = host.toPath(dir);
            var dirPathWithTrailingDirectorySeparator = "".concat(dirPath).concat(ts.directorySeparator);
            return ts.forEachKey(setOfDeclarationDirectories, function (declDirPath) { return dirPath === declDirPath ||
                // Any parent directory of declaration dir
                ts.startsWith(declDirPath, dirPathWithTrailingDirectorySeparator) ||
                // Any directory inside declaration dir
                ts.startsWith(dirPath, "".concat(declDirPath, "/")); });
        }
        function handleDirectoryCouldBeSymlink(directory) {
            var _a;
            if (!host.getResolvedProjectReferences() || ts.containsIgnoredPath(directory))
                return;
            // Because we already watch node_modules, handle symlinks in there
            if (!originalRealpath || !ts.stringContains(directory, ts.nodeModulesPathPart))
                return;
            var symlinkCache = host.getSymlinkCache();
            var directoryPath = ts.ensureTrailingDirectorySeparator(host.toPath(directory));
            if ((_a = symlinkCache.getSymlinkedDirectories()) === null || _a === void 0 ? void 0 : _a.has(directoryPath))
                return;
            var real = ts.normalizePath(originalRealpath.call(host.compilerHost, directory));
            var realPath;
            if (real === directory ||
                (realPath = ts.ensureTrailingDirectorySeparator(host.toPath(real))) === directoryPath) {
                // not symlinked
                symlinkCache.setSymlinkedDirectory(directoryPath, false);
                return;
            }
            symlinkCache.setSymlinkedDirectory(directory, {
                real: ts.ensureTrailingDirectorySeparator(real),
                realPath: realPath
            });
        }
        function fileOrDirectoryExistsUsingSource(fileOrDirectory, isFile) {
            var _a;
            var fileOrDirectoryExistsUsingSource = isFile ?
                function (file) { return fileExistsIfProjectReferenceDts(file); } :
                function (dir) { return directoryExistsIfProjectReferenceDeclDir(dir); };
            // Check current directory or file
            var result = fileOrDirectoryExistsUsingSource(fileOrDirectory);
            if (result !== undefined)
                return result;
            var symlinkCache = host.getSymlinkCache();
            var symlinkedDirectories = symlinkCache.getSymlinkedDirectories();
            if (!symlinkedDirectories)
                return false;
            var fileOrDirectoryPath = host.toPath(fileOrDirectory);
            if (!ts.stringContains(fileOrDirectoryPath, ts.nodeModulesPathPart))
                return false;
            if (isFile && ((_a = symlinkCache.getSymlinkedFiles()) === null || _a === void 0 ? void 0 : _a.has(fileOrDirectoryPath)))
                return true;
            // If it contains node_modules check if its one of the symlinked path we know of
            return ts.firstDefinedIterator(symlinkedDirectories.entries(), function (_a) {
                var directoryPath = _a[0], symlinkedDirectory = _a[1];
                if (!symlinkedDirectory || !ts.startsWith(fileOrDirectoryPath, directoryPath))
                    return undefined;
                var result = fileOrDirectoryExistsUsingSource(fileOrDirectoryPath.replace(directoryPath, symlinkedDirectory.realPath));
                if (isFile && result) {
                    // Store the real path for the file'
                    var absolutePath = ts.getNormalizedAbsolutePath(fileOrDirectory, host.compilerHost.getCurrentDirectory());
                    symlinkCache.setSymlinkedFile(fileOrDirectoryPath, "".concat(symlinkedDirectory.real).concat(absolutePath.replace(new RegExp(directoryPath, "i"), "")));
                }
                return result;
            }) || false;
        }
    }
    /*@internal*/
    ts.emitSkippedWithNoDiagnostics = { diagnostics: ts.emptyArray, sourceMaps: undefined, emittedFiles: undefined, emitSkipped: true };
    /*@internal*/
    function handleNoEmitOptions(program, sourceFile, writeFile, cancellationToken) {
        var options = program.getCompilerOptions();
        if (options.noEmit) {
            // Cache the semantic diagnostics
            program.getSemanticDiagnostics(sourceFile, cancellationToken);
            return sourceFile || ts.outFile(options) ?
                ts.emitSkippedWithNoDiagnostics :
                program.emitBuildInfo(writeFile, cancellationToken);
        }
        // If the noEmitOnError flag is set, then check if we have any errors so far.  If so,
        // immediately bail out.  Note that we pass 'undefined' for 'sourceFile' so that we
        // get any preEmit diagnostics, not just the ones
        if (!options.noEmitOnError)
            return undefined;
        var diagnostics = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], program.getOptionsDiagnostics(cancellationToken), true), program.getSyntacticDiagnostics(sourceFile, cancellationToken), true), program.getGlobalDiagnostics(cancellationToken), true), program.getSemanticDiagnostics(sourceFile, cancellationToken), true);
        if (diagnostics.length === 0 && ts.getEmitDeclarations(program.getCompilerOptions())) {
            diagnostics = program.getDeclarationDiagnostics(/*sourceFile*/ undefined, cancellationToken);
        }
        if (!diagnostics.length)
            return undefined;
        var emittedFiles;
        if (!sourceFile && !ts.outFile(options)) {
            var emitResult = program.emitBuildInfo(writeFile, cancellationToken);
            if (emitResult.diagnostics)
                diagnostics = __spreadArray(__spreadArray([], diagnostics, true), emitResult.diagnostics, true);
            emittedFiles = emitResult.emittedFiles;
        }
        return { diagnostics: diagnostics, sourceMaps: undefined, emittedFiles: emittedFiles, emitSkipped: true };
    }
    ts.handleNoEmitOptions = handleNoEmitOptions;
    /*@internal*/
    function filterSemanticDiagnostics(diagnostic, option) {
        return ts.filter(diagnostic, function (d) { return !d.skippedOn || !option[d.skippedOn]; });
    }
    ts.filterSemanticDiagnostics = filterSemanticDiagnostics;
    /* @internal */
    function parseConfigHostFromCompilerHostLike(host, directoryStructureHost) {
        if (directoryStructureHost === void 0) { directoryStructureHost = host; }
        return {
            fileExists: function (f) { return directoryStructureHost.fileExists(f); },
            readDirectory: function (root, extensions, excludes, includes, depth) {
                ts.Debug.assertIsDefined(directoryStructureHost.readDirectory, "'CompilerHost.readDirectory' must be implemented to correctly process 'projectReferences'");
                return directoryStructureHost.readDirectory(root, extensions, excludes, includes, depth);
            },
            readFile: function (f) { return directoryStructureHost.readFile(f); },
            useCaseSensitiveFileNames: host.useCaseSensitiveFileNames(),
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            onUnRecoverableConfigFileDiagnostic: host.onUnRecoverableConfigFileDiagnostic || ts.returnUndefined,
            trace: host.trace ? function (s) { return host.trace(s); } : undefined
        };
    }
    ts.parseConfigHostFromCompilerHostLike = parseConfigHostFromCompilerHostLike;
    /* @internal */
    function createPrependNodes(projectReferences, getCommandLine, readFile) {
        if (!projectReferences)
            return ts.emptyArray;
        var nodes;
        for (var i = 0; i < projectReferences.length; i++) {
            var ref = projectReferences[i];
            var resolvedRefOpts = getCommandLine(ref, i);
            if (ref.prepend && resolvedRefOpts && resolvedRefOpts.options) {
                var out = ts.outFile(resolvedRefOpts.options);
                // Upstream project didn't have outFile set -- skip (error will have been issued earlier)
                if (!out)
                    continue;
                var _a = ts.getOutputPathsForBundle(resolvedRefOpts.options, /*forceDtsPaths*/ true), jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath, buildInfoPath = _a.buildInfoPath;
                var node = ts.createInputFiles(readFile, jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath);
                (nodes || (nodes = [])).push(node);
            }
        }
        return nodes || ts.emptyArray;
    }
    ts.createPrependNodes = createPrependNodes;
    function resolveProjectReferencePath(hostOrRef, ref) {
        var passedInRef = ref ? ref : hostOrRef;
        return ts.resolveConfigFileProjectName(passedInRef.path);
    }
    ts.resolveProjectReferencePath = resolveProjectReferencePath;
    /* @internal */
    /**
     * Returns a DiagnosticMessage if we won't include a resolved module due to its extension.
     * The DiagnosticMessage's parameters are the imported module name, and the filename it resolved to.
     * This returns a diagnostic even if the module will be an untyped module.
     */
    function getResolutionDiagnostic(options, _a) {
        var extension = _a.extension;
        switch (extension) {
            case ".ts" /* Extension.Ts */:
            case ".d.ts" /* Extension.Dts */:
                // These are always allowed.
                return undefined;
            case ".tsx" /* Extension.Tsx */:
                return needJsx();
            case ".jsx" /* Extension.Jsx */:
                return needJsx() || needAllowJs();
            case ".js" /* Extension.Js */:
                return needAllowJs();
            case ".json" /* Extension.Json */:
                return needResolveJsonModule();
        }
        function needJsx() {
            return options.jsx ? undefined : ts.Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set;
        }
        function needAllowJs() {
            return ts.getAllowJSCompilerOption(options) || !ts.getStrictOptionValue(options, "noImplicitAny") ? undefined : ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type;
        }
        function needResolveJsonModule() {
            return options.resolveJsonModule ? undefined : ts.Diagnostics.Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used;
        }
    }
    ts.getResolutionDiagnostic = getResolutionDiagnostic;
    function getModuleNames(_a) {
        var imports = _a.imports, moduleAugmentations = _a.moduleAugmentations;
        var res = imports.map(function (i) { return i.text; });
        for (var _i = 0, moduleAugmentations_1 = moduleAugmentations; _i < moduleAugmentations_1.length; _i++) {
            var aug = moduleAugmentations_1[_i];
            if (aug.kind === 10 /* SyntaxKind.StringLiteral */) {
                res.push(aug.text);
            }
            // Do nothing if it's an Identifier; we don't need to do module resolution for `declare global`.
        }
        return res;
    }
    /* @internal */
    function getModuleNameStringLiteralAt(_a, index) {
        var imports = _a.imports, moduleAugmentations = _a.moduleAugmentations;
        if (index < imports.length)
            return imports[index];
        var augIndex = imports.length;
        for (var _i = 0, moduleAugmentations_2 = moduleAugmentations; _i < moduleAugmentations_2.length; _i++) {
            var aug = moduleAugmentations_2[_i];
            if (aug.kind === 10 /* SyntaxKind.StringLiteral */) {
                if (index === augIndex)
                    return aug;
                augIndex++;
            }
            // Do nothing if it's an Identifier; we don't need to do module resolution for `declare global`.
        }
        ts.Debug.fail("should never ask for module name at index higher than possible module name");
    }
    ts.getModuleNameStringLiteralAt = getModuleNameStringLiteralAt;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function getFileEmitOutput(program, sourceFile, emitOnlyDtsFiles, cancellationToken, customTransformers, forceDtsEmit) {
        var outputFiles = [];
        var _a = program.emit(sourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers, forceDtsEmit), emitSkipped = _a.emitSkipped, diagnostics = _a.diagnostics, exportedModulesFromDeclarationEmit = _a.exportedModulesFromDeclarationEmit;
        return { outputFiles: outputFiles, emitSkipped: emitSkipped, diagnostics: diagnostics, exportedModulesFromDeclarationEmit: exportedModulesFromDeclarationEmit };
        function writeFile(fileName, text, writeByteOrderMark) {
            outputFiles.push({ name: fileName, writeByteOrderMark: writeByteOrderMark, text: text });
        }
    }
    ts.getFileEmitOutput = getFileEmitOutput;
    var BuilderState;
    (function (BuilderState) {
        function createManyToManyPathMap() {
            function create(forward, reverse, deleted) {
                var map = {
                    clone: function () { return create(new ts.Map(forward), new ts.Map(reverse), deleted && new ts.Set(deleted)); },
                    forEach: function (fn) { return forward.forEach(fn); },
                    getKeys: function (v) { return reverse.get(v); },
                    getValues: function (k) { return forward.get(k); },
                    hasKey: function (k) { return forward.has(k); },
                    keys: function () { return forward.keys(); },
                    deletedKeys: function () { return deleted; },
                    deleteKey: function (k) {
                        (deleted || (deleted = new ts.Set())).add(k);
                        var set = forward.get(k);
                        if (!set) {
                            return false;
                        }
                        set.forEach(function (v) { return deleteFromMultimap(reverse, v, k); });
                        forward.delete(k);
                        return true;
                    },
                    set: function (k, vSet) {
                        deleted === null || deleted === void 0 ? void 0 : deleted.delete(k);
                        var existingVSet = forward.get(k);
                        forward.set(k, vSet);
                        existingVSet === null || existingVSet === void 0 ? void 0 : existingVSet.forEach(function (v) {
                            if (!vSet.has(v)) {
                                deleteFromMultimap(reverse, v, k);
                            }
                        });
                        vSet.forEach(function (v) {
                            if (!(existingVSet === null || existingVSet === void 0 ? void 0 : existingVSet.has(v))) {
                                addToMultimap(reverse, v, k);
                            }
                        });
                        return map;
                    },
                    clear: function () {
                        forward.clear();
                        reverse.clear();
                        deleted === null || deleted === void 0 ? void 0 : deleted.clear();
                    }
                };
                return map;
            }
            return create(new ts.Map(), new ts.Map(), /*deleted*/ undefined);
        }
        BuilderState.createManyToManyPathMap = createManyToManyPathMap;
        function addToMultimap(map, k, v) {
            var set = map.get(k);
            if (!set) {
                set = new ts.Set();
                map.set(k, set);
            }
            set.add(v);
        }
        function deleteFromMultimap(map, k, v) {
            var set = map.get(k);
            if (set === null || set === void 0 ? void 0 : set.delete(v)) {
                if (!set.size) {
                    map.delete(k);
                }
                return true;
            }
            return false;
        }
        function getReferencedFilesFromImportedModuleSymbol(symbol) {
            return ts.mapDefined(symbol.declarations, function (declaration) { var _a; return (_a = ts.getSourceFileOfNode(declaration)) === null || _a === void 0 ? void 0 : _a.resolvedPath; });
        }
        /**
         * Get the module source file and all augmenting files from the import name node from file
         */
        function getReferencedFilesFromImportLiteral(checker, importName) {
            var symbol = checker.getSymbolAtLocation(importName);
            return symbol && getReferencedFilesFromImportedModuleSymbol(symbol);
        }
        /**
         * Gets the path to reference file from file name, it could be resolvedPath if present otherwise path
         */
        function getReferencedFileFromFileName(program, fileName, sourceFileDirectory, getCanonicalFileName) {
            return ts.toPath(program.getProjectReferenceRedirect(fileName) || fileName, sourceFileDirectory, getCanonicalFileName);
        }
        /**
         * Gets the referenced files for a file from the program with values for the keys as referenced file's path to be true
         */
        function getReferencedFiles(program, sourceFile, getCanonicalFileName) {
            var referencedFiles;
            // We need to use a set here since the code can contain the same import twice,
            // but that will only be one dependency.
            // To avoid invernal conversion, the key of the referencedFiles map must be of type Path
            if (sourceFile.imports && sourceFile.imports.length > 0) {
                var checker = program.getTypeChecker();
                for (var _i = 0, _a = sourceFile.imports; _i < _a.length; _i++) {
                    var importName = _a[_i];
                    var declarationSourceFilePaths = getReferencedFilesFromImportLiteral(checker, importName);
                    declarationSourceFilePaths === null || declarationSourceFilePaths === void 0 ? void 0 : declarationSourceFilePaths.forEach(addReferencedFile);
                }
            }
            var sourceFileDirectory = ts.getDirectoryPath(sourceFile.resolvedPath);
            // Handle triple slash references
            if (sourceFile.referencedFiles && sourceFile.referencedFiles.length > 0) {
                for (var _b = 0, _c = sourceFile.referencedFiles; _b < _c.length; _b++) {
                    var referencedFile = _c[_b];
                    var referencedPath = getReferencedFileFromFileName(program, referencedFile.fileName, sourceFileDirectory, getCanonicalFileName);
                    addReferencedFile(referencedPath);
                }
            }
            // Handle type reference directives
            if (sourceFile.resolvedTypeReferenceDirectiveNames) {
                sourceFile.resolvedTypeReferenceDirectiveNames.forEach(function (resolvedTypeReferenceDirective) {
                    if (!resolvedTypeReferenceDirective) {
                        return;
                    }
                    var fileName = resolvedTypeReferenceDirective.resolvedFileName; // TODO: GH#18217
                    var typeFilePath = getReferencedFileFromFileName(program, fileName, sourceFileDirectory, getCanonicalFileName);
                    addReferencedFile(typeFilePath);
                });
            }
            // Add module augmentation as references
            if (sourceFile.moduleAugmentations.length) {
                var checker = program.getTypeChecker();
                for (var _d = 0, _e = sourceFile.moduleAugmentations; _d < _e.length; _d++) {
                    var moduleName = _e[_d];
                    if (!ts.isStringLiteral(moduleName))
                        continue;
                    var symbol = checker.getSymbolAtLocation(moduleName);
                    if (!symbol)
                        continue;
                    // Add any file other than our own as reference
                    addReferenceFromAmbientModule(symbol);
                }
            }
            // From ambient modules
            for (var _f = 0, _g = program.getTypeChecker().getAmbientModules(); _f < _g.length; _f++) {
                var ambientModule = _g[_f];
                if (ambientModule.declarations && ambientModule.declarations.length > 1) {
                    addReferenceFromAmbientModule(ambientModule);
                }
            }
            return referencedFiles;
            function addReferenceFromAmbientModule(symbol) {
                if (!symbol.declarations) {
                    return;
                }
                // Add any file other than our own as reference
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    var declarationSourceFile = ts.getSourceFileOfNode(declaration);
                    if (declarationSourceFile &&
                        declarationSourceFile !== sourceFile) {
                        addReferencedFile(declarationSourceFile.resolvedPath);
                    }
                }
            }
            function addReferencedFile(referencedPath) {
                (referencedFiles || (referencedFiles = new ts.Set())).add(referencedPath);
            }
        }
        /**
         * Returns true if oldState is reusable, that is the emitKind = module/non module has not changed
         */
        function canReuseOldState(newReferencedMap, oldState) {
            return oldState && !oldState.referencedMap === !newReferencedMap;
        }
        BuilderState.canReuseOldState = canReuseOldState;
        /**
         * Creates the state of file references and signature for the new program from oldState if it is safe
         */
        function create(newProgram, getCanonicalFileName, oldState, disableUseFileVersionAsSignature) {
            var fileInfos = new ts.Map();
            var referencedMap = newProgram.getCompilerOptions().module !== ts.ModuleKind.None ? createManyToManyPathMap() : undefined;
            var exportedModulesMap = referencedMap ? createManyToManyPathMap() : undefined;
            var hasCalledUpdateShapeSignature = new ts.Set();
            var useOldState = canReuseOldState(referencedMap, oldState);
            // Ensure source files have parent pointers set
            newProgram.getTypeChecker();
            // Create the reference map, and set the file infos
            for (var _i = 0, _a = newProgram.getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile = _a[_i];
                var version_2 = ts.Debug.checkDefined(sourceFile.version, "Program intended to be used with Builder should have source files with versions set");
                var oldInfo = useOldState ? oldState.fileInfos.get(sourceFile.resolvedPath) : undefined;
                if (referencedMap) {
                    var newReferences = getReferencedFiles(newProgram, sourceFile, getCanonicalFileName);
                    if (newReferences) {
                        referencedMap.set(sourceFile.resolvedPath, newReferences);
                    }
                    // Copy old visible to outside files map
                    if (useOldState) {
                        var exportedModules = oldState.exportedModulesMap.getValues(sourceFile.resolvedPath);
                        if (exportedModules) {
                            exportedModulesMap.set(sourceFile.resolvedPath, exportedModules);
                        }
                    }
                }
                fileInfos.set(sourceFile.resolvedPath, { version: version_2, signature: oldInfo && oldInfo.signature, affectsGlobalScope: isFileAffectingGlobalScope(sourceFile) || undefined, impliedFormat: sourceFile.impliedNodeFormat });
            }
            return {
                fileInfos: fileInfos,
                referencedMap: referencedMap,
                exportedModulesMap: exportedModulesMap,
                hasCalledUpdateShapeSignature: hasCalledUpdateShapeSignature,
                useFileVersionAsSignature: !disableUseFileVersionAsSignature && !useOldState
            };
        }
        BuilderState.create = create;
        /**
         * Releases needed properties
         */
        function releaseCache(state) {
            state.allFilesExcludingDefaultLibraryFile = undefined;
            state.allFileNames = undefined;
        }
        BuilderState.releaseCache = releaseCache;
        /**
         * Creates a clone of the state
         */
        function clone(state) {
            var _a, _b;
            // Dont need to backup allFiles info since its cache anyway
            return {
                fileInfos: new ts.Map(state.fileInfos),
                referencedMap: (_a = state.referencedMap) === null || _a === void 0 ? void 0 : _a.clone(),
                exportedModulesMap: (_b = state.exportedModulesMap) === null || _b === void 0 ? void 0 : _b.clone(),
                hasCalledUpdateShapeSignature: new ts.Set(state.hasCalledUpdateShapeSignature),
                useFileVersionAsSignature: state.useFileVersionAsSignature,
            };
        }
        BuilderState.clone = clone;
        /**
         * Gets the files affected by the path from the program
         */
        function getFilesAffectedBy(state, programOfThisState, path, cancellationToken, computeHash, cacheToUpdateSignature, exportedModulesMapCache) {
            // Since the operation could be cancelled, the signatures are always stored in the cache
            // They will be committed once it is safe to use them
            // eg when calling this api from tsserver, if there is no cancellation of the operation
            // In the other cases the affected files signatures are committed only after the iteration through the result is complete
            var signatureCache = cacheToUpdateSignature || new ts.Map();
            var sourceFile = programOfThisState.getSourceFileByPath(path);
            if (!sourceFile) {
                return ts.emptyArray;
            }
            if (!updateShapeSignature(state, programOfThisState, sourceFile, signatureCache, cancellationToken, computeHash, exportedModulesMapCache)) {
                return [sourceFile];
            }
            var result = (state.referencedMap ? getFilesAffectedByUpdatedShapeWhenModuleEmit : getFilesAffectedByUpdatedShapeWhenNonModuleEmit)(state, programOfThisState, sourceFile, signatureCache, cancellationToken, computeHash, exportedModulesMapCache);
            if (!cacheToUpdateSignature) {
                // Commit all the signatures in the signature cache
                updateSignaturesFromCache(state, signatureCache);
            }
            return result;
        }
        BuilderState.getFilesAffectedBy = getFilesAffectedBy;
        /**
         * Updates the signatures from the cache into state's fileinfo signatures
         * This should be called whenever it is safe to commit the state of the builder
         */
        function updateSignaturesFromCache(state, signatureCache) {
            signatureCache.forEach(function (signature, path) { return updateSignatureOfFile(state, signature, path); });
        }
        BuilderState.updateSignaturesFromCache = updateSignaturesFromCache;
        function updateSignatureOfFile(state, signature, path) {
            state.fileInfos.get(path).signature = signature;
            state.hasCalledUpdateShapeSignature.add(path);
        }
        BuilderState.updateSignatureOfFile = updateSignatureOfFile;
        /**
         * Returns if the shape of the signature has changed since last emit
         */
        function updateShapeSignature(state, programOfThisState, sourceFile, cacheToUpdateSignature, cancellationToken, computeHash, exportedModulesMapCache, useFileVersionAsSignature) {
            if (useFileVersionAsSignature === void 0) { useFileVersionAsSignature = state.useFileVersionAsSignature; }
            ts.Debug.assert(!!sourceFile);
            ts.Debug.assert(!exportedModulesMapCache || !!state.exportedModulesMap, "Compute visible to outside map only if visibleToOutsideReferencedMap present in the state");
            // If we have cached the result for this file, that means hence forth we should assume file shape is uptodate
            if (state.hasCalledUpdateShapeSignature.has(sourceFile.resolvedPath) || cacheToUpdateSignature.has(sourceFile.resolvedPath)) {
                return false;
            }
            var info = state.fileInfos.get(sourceFile.resolvedPath);
            if (!info)
                return ts.Debug.fail();
            var prevSignature = info.signature;
            var latestSignature;
            if (!sourceFile.isDeclarationFile && !useFileVersionAsSignature) {
                var emitOutput_1 = getFileEmitOutput(programOfThisState, sourceFile, 
                /*emitOnlyDtsFiles*/ true, cancellationToken, 
                /*customTransformers*/ undefined, 
                /*forceDtsEmit*/ true);
                var firstDts_1 = ts.firstOrUndefined(emitOutput_1.outputFiles);
                if (firstDts_1) {
                    ts.Debug.assert(ts.isDeclarationFileName(firstDts_1.name), "File extension for signature expected to be dts", function () { return "Found: ".concat(ts.getAnyExtensionFromPath(firstDts_1.name), " for ").concat(firstDts_1.name, ":: All output files: ").concat(JSON.stringify(emitOutput_1.outputFiles.map(function (f) { return f.name; }))); });
                    latestSignature = (computeHash || ts.generateDjb2Hash)(firstDts_1.text);
                    if (exportedModulesMapCache && latestSignature !== prevSignature) {
                        updateExportedModules(sourceFile, emitOutput_1.exportedModulesFromDeclarationEmit, exportedModulesMapCache);
                    }
                }
            }
            // Default is to use file version as signature
            if (latestSignature === undefined) {
                latestSignature = sourceFile.version;
                if (exportedModulesMapCache && latestSignature !== prevSignature) {
                    // All the references in this file are exported
                    var references = state.referencedMap ? state.referencedMap.getValues(sourceFile.resolvedPath) : undefined;
                    if (references) {
                        exportedModulesMapCache.set(sourceFile.resolvedPath, references);
                    }
                    else {
                        exportedModulesMapCache.deleteKey(sourceFile.resolvedPath);
                    }
                }
            }
            cacheToUpdateSignature.set(sourceFile.resolvedPath, latestSignature);
            return latestSignature !== prevSignature;
        }
        BuilderState.updateShapeSignature = updateShapeSignature;
        /**
         * Coverts the declaration emit result into exported modules map
         */
        function updateExportedModules(sourceFile, exportedModulesFromDeclarationEmit, exportedModulesMapCache) {
            if (!exportedModulesFromDeclarationEmit) {
                exportedModulesMapCache.deleteKey(sourceFile.resolvedPath);
                return;
            }
            var exportedModules;
            exportedModulesFromDeclarationEmit.forEach(function (symbol) { return addExportedModule(getReferencedFilesFromImportedModuleSymbol(symbol)); });
            if (exportedModules) {
                exportedModulesMapCache.set(sourceFile.resolvedPath, exportedModules);
            }
            else {
                exportedModulesMapCache.deleteKey(sourceFile.resolvedPath);
            }
            function addExportedModule(exportedModulePaths) {
                if (exportedModulePaths === null || exportedModulePaths === void 0 ? void 0 : exportedModulePaths.length) {
                    if (!exportedModules) {
                        exportedModules = new ts.Set();
                    }
                    exportedModulePaths.forEach(function (path) { return exportedModules.add(path); });
                }
            }
        }
        BuilderState.updateExportedModules = updateExportedModules;
        /**
         * Updates the exported modules from cache into state's exported modules map
         * This should be called whenever it is safe to commit the state of the builder
         */
        function updateExportedFilesMapFromCache(state, exportedModulesMapCache) {
            var _a;
            if (exportedModulesMapCache) {
                ts.Debug.assert(!!state.exportedModulesMap);
                (_a = exportedModulesMapCache.deletedKeys()) === null || _a === void 0 ? void 0 : _a.forEach(function (path) { return state.exportedModulesMap.deleteKey(path); });
                exportedModulesMapCache.forEach(function (exportedModules, path) { return state.exportedModulesMap.set(path, exportedModules); });
            }
        }
        BuilderState.updateExportedFilesMapFromCache = updateExportedFilesMapFromCache;
        /**
         * Get all the dependencies of the sourceFile
         */
        function getAllDependencies(state, programOfThisState, sourceFile) {
            var compilerOptions = programOfThisState.getCompilerOptions();
            // With --out or --outFile all outputs go into single file, all files depend on each other
            if (ts.outFile(compilerOptions)) {
                return getAllFileNames(state, programOfThisState);
            }
            // If this is non module emit, or its a global file, it depends on all the source files
            if (!state.referencedMap || isFileAffectingGlobalScope(sourceFile)) {
                return getAllFileNames(state, programOfThisState);
            }
            // Get the references, traversing deep from the referenceMap
            var seenMap = new ts.Set();
            var queue = [sourceFile.resolvedPath];
            while (queue.length) {
                var path = queue.pop();
                if (!seenMap.has(path)) {
                    seenMap.add(path);
                    var references = state.referencedMap.getValues(path);
                    if (references) {
                        var iterator = references.keys();
                        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
                            queue.push(iterResult.value);
                        }
                    }
                }
            }
            return ts.arrayFrom(ts.mapDefinedIterator(seenMap.keys(), function (path) { var _a, _b; return (_b = (_a = programOfThisState.getSourceFileByPath(path)) === null || _a === void 0 ? void 0 : _a.fileName) !== null && _b !== void 0 ? _b : path; }));
        }
        BuilderState.getAllDependencies = getAllDependencies;
        /**
         * Gets the names of all files from the program
         */
        function getAllFileNames(state, programOfThisState) {
            if (!state.allFileNames) {
                var sourceFiles = programOfThisState.getSourceFiles();
                state.allFileNames = sourceFiles === ts.emptyArray ? ts.emptyArray : sourceFiles.map(function (file) { return file.fileName; });
            }
            return state.allFileNames;
        }
        /**
         * Gets the files referenced by the the file path
         */
        function getReferencedByPaths(state, referencedFilePath) {
            var keys = state.referencedMap.getKeys(referencedFilePath);
            return keys ? ts.arrayFrom(keys.keys()) : [];
        }
        BuilderState.getReferencedByPaths = getReferencedByPaths;
        /**
         * For script files that contains only ambient external modules, although they are not actually external module files,
         * they can only be consumed via importing elements from them. Regular script files cannot consume them. Therefore,
         * there are no point to rebuild all script files if these special files have changed. However, if any statement
         * in the file is not ambient external module, we treat it as a regular script file.
         */
        function containsOnlyAmbientModules(sourceFile) {
            for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
                var statement = _a[_i];
                if (!ts.isModuleWithStringLiteralName(statement)) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Return true if file contains anything that augments to global scope we need to build them as if
         * they are global files as well as module
         */
        function containsGlobalScopeAugmentation(sourceFile) {
            return ts.some(sourceFile.moduleAugmentations, function (augmentation) { return ts.isGlobalScopeAugmentation(augmentation.parent); });
        }
        /**
         * Return true if the file will invalidate all files because it affectes global scope
         */
        function isFileAffectingGlobalScope(sourceFile) {
            return containsGlobalScopeAugmentation(sourceFile) ||
                !ts.isExternalOrCommonJsModule(sourceFile) && !ts.isJsonSourceFile(sourceFile) && !containsOnlyAmbientModules(sourceFile);
        }
        /**
         * Gets all files of the program excluding the default library file
         */
        function getAllFilesExcludingDefaultLibraryFile(state, programOfThisState, firstSourceFile) {
            // Use cached result
            if (state.allFilesExcludingDefaultLibraryFile) {
                return state.allFilesExcludingDefaultLibraryFile;
            }
            var result;
            if (firstSourceFile)
                addSourceFile(firstSourceFile);
            for (var _i = 0, _a = programOfThisState.getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile = _a[_i];
                if (sourceFile !== firstSourceFile) {
                    addSourceFile(sourceFile);
                }
            }
            state.allFilesExcludingDefaultLibraryFile = result || ts.emptyArray;
            return state.allFilesExcludingDefaultLibraryFile;
            function addSourceFile(sourceFile) {
                if (!programOfThisState.isSourceFileDefaultLibrary(sourceFile)) {
                    (result || (result = [])).push(sourceFile);
                }
            }
        }
        BuilderState.getAllFilesExcludingDefaultLibraryFile = getAllFilesExcludingDefaultLibraryFile;
        /**
         * When program emits non modular code, gets the files affected by the sourceFile whose shape has changed
         */
        function getFilesAffectedByUpdatedShapeWhenNonModuleEmit(state, programOfThisState, sourceFileWithUpdatedShape) {
            var compilerOptions = programOfThisState.getCompilerOptions();
            // If `--out` or `--outFile` is specified, any new emit will result in re-emitting the entire project,
            // so returning the file itself is good enough.
            if (compilerOptions && ts.outFile(compilerOptions)) {
                return [sourceFileWithUpdatedShape];
            }
            return getAllFilesExcludingDefaultLibraryFile(state, programOfThisState, sourceFileWithUpdatedShape);
        }
        /**
         * When program emits modular code, gets the files affected by the sourceFile whose shape has changed
         */
        function getFilesAffectedByUpdatedShapeWhenModuleEmit(state, programOfThisState, sourceFileWithUpdatedShape, cacheToUpdateSignature, cancellationToken, computeHash, exportedModulesMapCache) {
            if (isFileAffectingGlobalScope(sourceFileWithUpdatedShape)) {
                return getAllFilesExcludingDefaultLibraryFile(state, programOfThisState, sourceFileWithUpdatedShape);
            }
            var compilerOptions = programOfThisState.getCompilerOptions();
            if (compilerOptions && (compilerOptions.isolatedModules || ts.outFile(compilerOptions))) {
                return [sourceFileWithUpdatedShape];
            }
            // Now we need to if each file in the referencedBy list has a shape change as well.
            // Because if so, its own referencedBy files need to be saved as well to make the
            // emitting result consistent with files on disk.
            var seenFileNamesMap = new ts.Map();
            // Start with the paths this file was referenced by
            seenFileNamesMap.set(sourceFileWithUpdatedShape.resolvedPath, sourceFileWithUpdatedShape);
            var queue = getReferencedByPaths(state, sourceFileWithUpdatedShape.resolvedPath);
            while (queue.length > 0) {
                var currentPath = queue.pop();
                if (!seenFileNamesMap.has(currentPath)) {
                    var currentSourceFile = programOfThisState.getSourceFileByPath(currentPath);
                    seenFileNamesMap.set(currentPath, currentSourceFile);
                    if (currentSourceFile && updateShapeSignature(state, programOfThisState, currentSourceFile, cacheToUpdateSignature, cancellationToken, computeHash, exportedModulesMapCache)) {
                        queue.push.apply(queue, getReferencedByPaths(state, currentSourceFile.resolvedPath));
                    }
                }
            }
            // Return array of values that needs emit
            return ts.arrayFrom(ts.mapDefinedIterator(seenFileNamesMap.values(), function (value) { return value; }));
        }
    })(BuilderState = ts.BuilderState || (ts.BuilderState = {}));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var BuilderFileEmit;
    (function (BuilderFileEmit) {
        BuilderFileEmit[BuilderFileEmit["DtsOnly"] = 0] = "DtsOnly";
        BuilderFileEmit[BuilderFileEmit["Full"] = 1] = "Full";
    })(BuilderFileEmit = ts.BuilderFileEmit || (ts.BuilderFileEmit = {}));
    function hasSameKeys(map1, map2) {
        // Has same size and every key is present in both maps
        return map1 === map2 || map1 !== undefined && map2 !== undefined && map1.size === map2.size && !ts.forEachKey(map1, function (key) { return !map2.has(key); });
    }
    /**
     * Create the state so that we can iterate on changedFiles/affected files
     */
    function createBuilderProgramState(newProgram, getCanonicalFileName, oldState, disableUseFileVersionAsSignature) {
        var state = ts.BuilderState.create(newProgram, getCanonicalFileName, oldState, disableUseFileVersionAsSignature);
        state.program = newProgram;
        var compilerOptions = newProgram.getCompilerOptions();
        state.compilerOptions = compilerOptions;
        // With --out or --outFile, any change affects all semantic diagnostics so no need to cache them
        if (!ts.outFile(compilerOptions)) {
            state.semanticDiagnosticsPerFile = new ts.Map();
        }
        state.changedFilesSet = new ts.Set();
        var useOldState = ts.BuilderState.canReuseOldState(state.referencedMap, oldState);
        var oldCompilerOptions = useOldState ? oldState.compilerOptions : undefined;
        var canCopySemanticDiagnostics = useOldState && oldState.semanticDiagnosticsPerFile && !!state.semanticDiagnosticsPerFile &&
            !ts.compilerOptionsAffectSemanticDiagnostics(compilerOptions, oldCompilerOptions);
        if (useOldState) {
            // Verify the sanity of old state
            if (!oldState.currentChangedFilePath) {
                var affectedSignatures = oldState.currentAffectedFilesSignatures;
                ts.Debug.assert(!oldState.affectedFiles && (!affectedSignatures || !affectedSignatures.size), "Cannot reuse if only few affected files of currentChangedFile were iterated");
            }
            var changedFilesSet = oldState.changedFilesSet;
            if (canCopySemanticDiagnostics) {
                ts.Debug.assert(!changedFilesSet || !ts.forEachKey(changedFilesSet, function (path) { return oldState.semanticDiagnosticsPerFile.has(path); }), "Semantic diagnostics shouldnt be available for changed files");
            }
            // Copy old state's changed files set
            changedFilesSet === null || changedFilesSet === void 0 ? void 0 : changedFilesSet.forEach(function (value) { return state.changedFilesSet.add(value); });
            if (!ts.outFile(compilerOptions) && oldState.affectedFilesPendingEmit) {
                state.affectedFilesPendingEmit = oldState.affectedFilesPendingEmit.slice();
                state.affectedFilesPendingEmitKind = oldState.affectedFilesPendingEmitKind && new ts.Map(oldState.affectedFilesPendingEmitKind);
                state.affectedFilesPendingEmitIndex = oldState.affectedFilesPendingEmitIndex;
                state.seenAffectedFiles = new ts.Set();
            }
        }
        // Update changed files and copy semantic diagnostics if we can
        var referencedMap = state.referencedMap;
        var oldReferencedMap = useOldState ? oldState.referencedMap : undefined;
        var copyDeclarationFileDiagnostics = canCopySemanticDiagnostics && !compilerOptions.skipLibCheck === !oldCompilerOptions.skipLibCheck;
        var copyLibFileDiagnostics = copyDeclarationFileDiagnostics && !compilerOptions.skipDefaultLibCheck === !oldCompilerOptions.skipDefaultLibCheck;
        state.fileInfos.forEach(function (info, sourceFilePath) {
            var oldInfo;
            var newReferences;
            // if not using old state, every file is changed
            if (!useOldState ||
                // File wasn't present in old state
                !(oldInfo = oldState.fileInfos.get(sourceFilePath)) ||
                // versions dont match
                oldInfo.version !== info.version ||
                // Referenced files changed
                !hasSameKeys(newReferences = referencedMap && referencedMap.getValues(sourceFilePath), oldReferencedMap && oldReferencedMap.getValues(sourceFilePath)) ||
                // Referenced file was deleted in the new program
                newReferences && ts.forEachKey(newReferences, function (path) { return !state.fileInfos.has(path) && oldState.fileInfos.has(path); })) {
                // Register file as changed file and do not copy semantic diagnostics, since all changed files need to be re-evaluated
                state.changedFilesSet.add(sourceFilePath);
            }
            else if (canCopySemanticDiagnostics) {
                var sourceFile = newProgram.getSourceFileByPath(sourceFilePath);
                if (sourceFile.isDeclarationFile && !copyDeclarationFileDiagnostics)
                    return;
                if (sourceFile.hasNoDefaultLib && !copyLibFileDiagnostics)
                    return;
                // Unchanged file copy diagnostics
                var diagnostics = oldState.semanticDiagnosticsPerFile.get(sourceFilePath);
                if (diagnostics) {
                    state.semanticDiagnosticsPerFile.set(sourceFilePath, oldState.hasReusableDiagnostic ? convertToDiagnostics(diagnostics, newProgram, getCanonicalFileName) : diagnostics);
                    if (!state.semanticDiagnosticsFromOldState) {
                        state.semanticDiagnosticsFromOldState = new ts.Set();
                    }
                    state.semanticDiagnosticsFromOldState.add(sourceFilePath);
                }
            }
        });
        // If the global file is removed, add all files as changed
        if (useOldState && ts.forEachEntry(oldState.fileInfos, function (info, sourceFilePath) { return info.affectsGlobalScope && !state.fileInfos.has(sourceFilePath); })) {
            ts.BuilderState.getAllFilesExcludingDefaultLibraryFile(state, newProgram, /*firstSourceFile*/ undefined)
                .forEach(function (file) { return state.changedFilesSet.add(file.resolvedPath); });
        }
        else if (oldCompilerOptions && !ts.outFile(compilerOptions) && ts.compilerOptionsAffectEmit(compilerOptions, oldCompilerOptions)) {
            // Add all files to affectedFilesPendingEmit since emit changed
            newProgram.getSourceFiles().forEach(function (f) { return addToAffectedFilesPendingEmit(state, f.resolvedPath, 1 /* BuilderFileEmit.Full */); });
            ts.Debug.assert(!state.seenAffectedFiles || !state.seenAffectedFiles.size);
            state.seenAffectedFiles = state.seenAffectedFiles || new ts.Set();
        }
        if (useOldState) {
            // Any time the interpretation of a source file changes, mark it as changed
            ts.forEachEntry(oldState.fileInfos, function (info, sourceFilePath) {
                if (state.fileInfos.has(sourceFilePath) && state.fileInfos.get(sourceFilePath).impliedFormat !== info.impliedFormat) {
                    state.changedFilesSet.add(sourceFilePath);
                }
            });
        }
        state.buildInfoEmitPending = !!state.changedFilesSet.size;
        return state;
    }
    function convertToDiagnostics(diagnostics, newProgram, getCanonicalFileName) {
        if (!diagnostics.length)
            return ts.emptyArray;
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(ts.getTsBuildInfoEmitOutputFilePath(newProgram.getCompilerOptions()), newProgram.getCurrentDirectory()));
        return diagnostics.map(function (diagnostic) {
            var result = convertToDiagnosticRelatedInformation(diagnostic, newProgram, toPath);
            result.reportsUnnecessary = diagnostic.reportsUnnecessary;
            result.reportsDeprecated = diagnostic.reportDeprecated;
            result.source = diagnostic.source;
            result.skippedOn = diagnostic.skippedOn;
            var relatedInformation = diagnostic.relatedInformation;
            result.relatedInformation = relatedInformation ?
                relatedInformation.length ?
                    relatedInformation.map(function (r) { return convertToDiagnosticRelatedInformation(r, newProgram, toPath); }) :
                    [] :
                undefined;
            return result;
        });
        function toPath(path) {
            return ts.toPath(path, buildInfoDirectory, getCanonicalFileName);
        }
    }
    function convertToDiagnosticRelatedInformation(diagnostic, newProgram, toPath) {
        var file = diagnostic.file;
        return __assign(__assign({}, diagnostic), { file: file ? newProgram.getSourceFileByPath(toPath(file)) : undefined });
    }
    /**
     * Releases program and other related not needed properties
     */
    function releaseCache(state) {
        ts.BuilderState.releaseCache(state);
        state.program = undefined;
    }
    /**
     * Creates a clone of the state
     */
    function cloneBuilderProgramState(state) {
        var _a;
        var newState = ts.BuilderState.clone(state);
        newState.semanticDiagnosticsPerFile = state.semanticDiagnosticsPerFile && new ts.Map(state.semanticDiagnosticsPerFile);
        newState.changedFilesSet = new ts.Set(state.changedFilesSet);
        newState.affectedFiles = state.affectedFiles;
        newState.affectedFilesIndex = state.affectedFilesIndex;
        newState.currentChangedFilePath = state.currentChangedFilePath;
        newState.currentAffectedFilesSignatures = state.currentAffectedFilesSignatures && new ts.Map(state.currentAffectedFilesSignatures);
        newState.currentAffectedFilesExportedModulesMap = (_a = state.currentAffectedFilesExportedModulesMap) === null || _a === void 0 ? void 0 : _a.clone();
        newState.seenAffectedFiles = state.seenAffectedFiles && new ts.Set(state.seenAffectedFiles);
        newState.cleanedDiagnosticsOfLibFiles = state.cleanedDiagnosticsOfLibFiles;
        newState.semanticDiagnosticsFromOldState = state.semanticDiagnosticsFromOldState && new ts.Set(state.semanticDiagnosticsFromOldState);
        newState.program = state.program;
        newState.compilerOptions = state.compilerOptions;
        newState.affectedFilesPendingEmit = state.affectedFilesPendingEmit && state.affectedFilesPendingEmit.slice();
        newState.affectedFilesPendingEmitKind = state.affectedFilesPendingEmitKind && new ts.Map(state.affectedFilesPendingEmitKind);
        newState.affectedFilesPendingEmitIndex = state.affectedFilesPendingEmitIndex;
        newState.seenEmittedFiles = state.seenEmittedFiles && new ts.Map(state.seenEmittedFiles);
        newState.programEmitComplete = state.programEmitComplete;
        return newState;
    }
    /**
     * Verifies that source file is ok to be used in calls that arent handled by next
     */
    function assertSourceFileOkWithoutNextAffectedCall(state, sourceFile) {
        ts.Debug.assert(!sourceFile || !state.affectedFiles || state.affectedFiles[state.affectedFilesIndex - 1] !== sourceFile || !state.semanticDiagnosticsPerFile.has(sourceFile.resolvedPath));
    }
    /**
     * This function returns the next affected file to be processed.
     * Note that until doneAffected is called it would keep reporting same result
     * This is to allow the callers to be able to actually remove affected file only when the operation is complete
     * eg. if during diagnostics check cancellation token ends up cancelling the request, the affected file should be retained
     */
    function getNextAffectedFile(state, cancellationToken, computeHash, host) {
        var _a;
        while (true) {
            var affectedFiles = state.affectedFiles;
            if (affectedFiles) {
                var seenAffectedFiles = state.seenAffectedFiles;
                var affectedFilesIndex = state.affectedFilesIndex; // TODO: GH#18217
                while (affectedFilesIndex < affectedFiles.length) {
                    var affectedFile = affectedFiles[affectedFilesIndex];
                    if (!seenAffectedFiles.has(affectedFile.resolvedPath)) {
                        // Set the next affected file as seen and remove the cached semantic diagnostics
                        state.affectedFilesIndex = affectedFilesIndex;
                        handleDtsMayChangeOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host);
                        return affectedFile;
                    }
                    affectedFilesIndex++;
                }
                // Remove the changed file from the change set
                state.changedFilesSet.delete(state.currentChangedFilePath);
                state.currentChangedFilePath = undefined;
                // Commit the changes in file signature
                ts.BuilderState.updateSignaturesFromCache(state, state.currentAffectedFilesSignatures);
                state.currentAffectedFilesSignatures.clear();
                ts.BuilderState.updateExportedFilesMapFromCache(state, state.currentAffectedFilesExportedModulesMap);
                (_a = state.currentAffectedFilesExportedModulesMap) === null || _a === void 0 ? void 0 : _a.clear();
                state.affectedFiles = undefined;
            }
            // Get next changed file
            var nextKey = state.changedFilesSet.keys().next();
            if (nextKey.done) {
                // Done
                return undefined;
            }
            // With --out or --outFile all outputs go into single file
            // so operations are performed directly on program, return program
            var program = ts.Debug.checkDefined(state.program);
            var compilerOptions = program.getCompilerOptions();
            if (ts.outFile(compilerOptions)) {
                ts.Debug.assert(!state.semanticDiagnosticsPerFile);
                return program;
            }
            // Get next batch of affected files
            if (!state.currentAffectedFilesSignatures)
                state.currentAffectedFilesSignatures = new ts.Map();
            if (state.exportedModulesMap) {
                state.currentAffectedFilesExportedModulesMap || (state.currentAffectedFilesExportedModulesMap = ts.BuilderState.createManyToManyPathMap());
            }
            state.affectedFiles = ts.BuilderState.getFilesAffectedBy(state, program, nextKey.value, cancellationToken, computeHash, state.currentAffectedFilesSignatures, state.currentAffectedFilesExportedModulesMap);
            state.currentChangedFilePath = nextKey.value;
            state.affectedFilesIndex = 0;
            if (!state.seenAffectedFiles)
                state.seenAffectedFiles = new ts.Set();
        }
    }
    function clearAffectedFilesPendingEmit(state) {
        state.affectedFilesPendingEmit = undefined;
        state.affectedFilesPendingEmitKind = undefined;
        state.affectedFilesPendingEmitIndex = undefined;
    }
    /**
     * Returns next file to be emitted from files that retrieved semantic diagnostics but did not emit yet
     */
    function getNextAffectedFilePendingEmit(state) {
        var affectedFilesPendingEmit = state.affectedFilesPendingEmit;
        if (affectedFilesPendingEmit) {
            var seenEmittedFiles = (state.seenEmittedFiles || (state.seenEmittedFiles = new ts.Map()));
            for (var i = state.affectedFilesPendingEmitIndex; i < affectedFilesPendingEmit.length; i++) {
                var affectedFile = ts.Debug.checkDefined(state.program).getSourceFileByPath(affectedFilesPendingEmit[i]);
                if (affectedFile) {
                    var seenKind = seenEmittedFiles.get(affectedFile.resolvedPath);
                    var emitKind = ts.Debug.checkDefined(ts.Debug.checkDefined(state.affectedFilesPendingEmitKind).get(affectedFile.resolvedPath));
                    if (seenKind === undefined || seenKind < emitKind) {
                        // emit this file
                        state.affectedFilesPendingEmitIndex = i;
                        return { affectedFile: affectedFile, emitKind: emitKind };
                    }
                }
            }
            clearAffectedFilesPendingEmit(state);
        }
        return undefined;
    }
    function removeDiagnosticsOfLibraryFiles(state) {
        if (!state.cleanedDiagnosticsOfLibFiles) {
            state.cleanedDiagnosticsOfLibFiles = true;
            var program_1 = ts.Debug.checkDefined(state.program);
            var options_2 = program_1.getCompilerOptions();
            ts.forEach(program_1.getSourceFiles(), function (f) {
                return program_1.isSourceFileDefaultLibrary(f) &&
                    !ts.skipTypeChecking(f, options_2, program_1) &&
                    removeSemanticDiagnosticsOf(state, f.resolvedPath);
            });
        }
    }
    /**
     *  Handles semantic diagnostics and dts emit for affectedFile and files, that are referencing modules that export entities from affected file
     *  This is because even though js emit doesnt change, dts emit / type used can change resulting in need for dts emit and js change
     */
    function handleDtsMayChangeOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host) {
        var _a;
        removeSemanticDiagnosticsOf(state, affectedFile.resolvedPath);
        // If affected files is everything except default library, then nothing more to do
        if (state.allFilesExcludingDefaultLibraryFile === state.affectedFiles) {
            removeDiagnosticsOfLibraryFiles(state);
            // When a change affects the global scope, all files are considered to be affected without updating their signature
            // That means when affected file is handled, its signature can be out of date
            // To avoid this, ensure that we update the signature for any affected file in this scenario.
            ts.BuilderState.updateShapeSignature(state, ts.Debug.checkDefined(state.program), affectedFile, ts.Debug.checkDefined(state.currentAffectedFilesSignatures), cancellationToken, computeHash, state.currentAffectedFilesExportedModulesMap);
            return;
        }
        ts.Debug.assert(state.hasCalledUpdateShapeSignature.has(affectedFile.resolvedPath) || ((_a = state.currentAffectedFilesSignatures) === null || _a === void 0 ? void 0 : _a.has(affectedFile.resolvedPath)), "Signature not updated for affected file: ".concat(affectedFile.fileName));
        if (state.compilerOptions.assumeChangesOnlyAffectDirectDependencies)
            return;
        handleDtsMayChangeOfReferencingExportOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host);
    }
    /**
     * Handle the dts may change, so they need to be added to pending emit if dts emit is enabled,
     * Also we need to make sure signature is updated for these files
     */
    function handleDtsMayChangeOf(state, path, cancellationToken, computeHash, host) {
        removeSemanticDiagnosticsOf(state, path);
        if (!state.changedFilesSet.has(path)) {
            var program = ts.Debug.checkDefined(state.program);
            var sourceFile = program.getSourceFileByPath(path);
            if (sourceFile) {
                // Even though the js emit doesnt change and we are already handling dts emit and semantic diagnostics
                // we need to update the signature to reflect correctness of the signature(which is output d.ts emit) of this file
                // This ensures that we dont later during incremental builds considering wrong signature.
                // Eg where this also is needed to ensure that .tsbuildinfo generated by incremental build should be same as if it was first fresh build
                // But we avoid expensive full shape computation, as using file version as shape is enough for correctness.
                ts.BuilderState.updateShapeSignature(state, program, sourceFile, ts.Debug.checkDefined(state.currentAffectedFilesSignatures), cancellationToken, computeHash, state.currentAffectedFilesExportedModulesMap, !host.disableUseFileVersionAsSignature);
                // If not dts emit, nothing more to do
                if (ts.getEmitDeclarations(state.compilerOptions)) {
                    addToAffectedFilesPendingEmit(state, path, 0 /* BuilderFileEmit.DtsOnly */);
                }
            }
        }
    }
    /**
     * Removes semantic diagnostics for path and
     * returns true if there are no more semantic diagnostics from the old state
     */
    function removeSemanticDiagnosticsOf(state, path) {
        if (!state.semanticDiagnosticsFromOldState) {
            return true;
        }
        state.semanticDiagnosticsFromOldState.delete(path);
        state.semanticDiagnosticsPerFile.delete(path);
        return !state.semanticDiagnosticsFromOldState.size;
    }
    function isChangedSignature(state, path) {
        var newSignature = ts.Debug.checkDefined(state.currentAffectedFilesSignatures).get(path);
        var oldSignature = ts.Debug.checkDefined(state.fileInfos.get(path)).signature;
        return newSignature !== oldSignature;
    }
    function forEachKeyOfExportedModulesMap(state, filePath, fn) {
        // Go through exported modules from cache first
        var keys = state.currentAffectedFilesExportedModulesMap.getKeys(filePath);
        var result = keys && ts.forEachKey(keys, fn);
        if (result)
            return result;
        // If exported from path is not from cache and exported modules has path, all files referencing file exported from are affected
        keys = state.exportedModulesMap.getKeys(filePath);
        return keys && ts.forEachKey(keys, function (exportedFromPath) {
            var _a;
            // If the cache had an updated value, skip
            return !state.currentAffectedFilesExportedModulesMap.hasKey(exportedFromPath) &&
                !((_a = state.currentAffectedFilesExportedModulesMap.deletedKeys()) === null || _a === void 0 ? void 0 : _a.has(exportedFromPath)) ?
                fn(exportedFromPath) :
                undefined;
        });
    }
    function handleDtsMayChangeOfGlobalScope(state, filePath, cancellationToken, computeHash, host) {
        var _a;
        if (!((_a = state.fileInfos.get(filePath)) === null || _a === void 0 ? void 0 : _a.affectsGlobalScope))
            return false;
        // Every file needs to be handled
        ts.BuilderState.getAllFilesExcludingDefaultLibraryFile(state, state.program, /*firstSourceFile*/ undefined)
            .forEach(function (file) { return handleDtsMayChangeOf(state, file.resolvedPath, cancellationToken, computeHash, host); });
        removeDiagnosticsOfLibraryFiles(state);
        return true;
    }
    /**
     * Iterate on referencing modules that export entities from affected file and delete diagnostics and add pending emit
     */
    function handleDtsMayChangeOfReferencingExportOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host) {
        // If there was change in signature (dts output) for the changed file,
        // then only we need to handle pending file emit
        if (!state.exportedModulesMap || !state.changedFilesSet.has(affectedFile.resolvedPath))
            return;
        if (!isChangedSignature(state, affectedFile.resolvedPath))
            return;
        // Since isolated modules dont change js files, files affected by change in signature is itself
        // But we need to cleanup semantic diagnostics and queue dts emit for affected files
        if (state.compilerOptions.isolatedModules) {
            var seenFileNamesMap = new ts.Map();
            seenFileNamesMap.set(affectedFile.resolvedPath, true);
            var queue = ts.BuilderState.getReferencedByPaths(state, affectedFile.resolvedPath);
            while (queue.length > 0) {
                var currentPath = queue.pop();
                if (!seenFileNamesMap.has(currentPath)) {
                    seenFileNamesMap.set(currentPath, true);
                    if (handleDtsMayChangeOfGlobalScope(state, currentPath, cancellationToken, computeHash, host))
                        return;
                    handleDtsMayChangeOf(state, currentPath, cancellationToken, computeHash, host);
                    if (isChangedSignature(state, currentPath)) {
                        var currentSourceFile = ts.Debug.checkDefined(state.program).getSourceFileByPath(currentPath);
                        queue.push.apply(queue, ts.BuilderState.getReferencedByPaths(state, currentSourceFile.resolvedPath));
                    }
                }
            }
        }
        ts.Debug.assert(!!state.currentAffectedFilesExportedModulesMap);
        var seenFileAndExportsOfFile = new ts.Set();
        // Go through exported modules from cache first
        // If exported modules has path, all files referencing file exported from are affected
        forEachKeyOfExportedModulesMap(state, affectedFile.resolvedPath, function (exportedFromPath) {
            if (handleDtsMayChangeOfGlobalScope(state, exportedFromPath, cancellationToken, computeHash, host))
                return true;
            var references = state.referencedMap.getKeys(exportedFromPath);
            return references && ts.forEachKey(references, function (filePath) {
                return handleDtsMayChangeOfFileAndExportsOfFile(state, filePath, seenFileAndExportsOfFile, cancellationToken, computeHash, host);
            });
        });
    }
    /**
     * handle dts and semantic diagnostics on file and iterate on anything that exports this file
     * return true when all work is done and we can exit handling dts emit and semantic diagnostics
     */
    function handleDtsMayChangeOfFileAndExportsOfFile(state, filePath, seenFileAndExportsOfFile, cancellationToken, computeHash, host) {
        var _a;
        if (!ts.tryAddToSet(seenFileAndExportsOfFile, filePath))
            return undefined;
        if (handleDtsMayChangeOfGlobalScope(state, filePath, cancellationToken, computeHash, host))
            return true;
        handleDtsMayChangeOf(state, filePath, cancellationToken, computeHash, host);
        ts.Debug.assert(!!state.currentAffectedFilesExportedModulesMap);
        // If exported modules has path, all files referencing file exported from are affected
        forEachKeyOfExportedModulesMap(state, filePath, function (exportedFromPath) {
            return handleDtsMayChangeOfFileAndExportsOfFile(state, exportedFromPath, seenFileAndExportsOfFile, cancellationToken, computeHash, host);
        });
        // Remove diagnostics of files that import this file (without going to exports of referencing files)
        (_a = state.referencedMap.getKeys(filePath)) === null || _a === void 0 ? void 0 : _a.forEach(function (referencingFilePath) {
            return !seenFileAndExportsOfFile.has(referencingFilePath) && // Not already removed diagnostic file
                handleDtsMayChangeOf(// Dont add to seen since this is not yet done with the export removal
                state, referencingFilePath, cancellationToken, computeHash, host);
        });
        return undefined;
    }
    /**
     * This is called after completing operation on the next affected file.
     * The operations here are postponed to ensure that cancellation during the iteration is handled correctly
     */
    function doneWithAffectedFile(state, affected, emitKind, isPendingEmit, isBuildInfoEmit) {
        if (isBuildInfoEmit) {
            state.buildInfoEmitPending = false;
        }
        else if (affected === state.program) {
            state.changedFilesSet.clear();
            state.programEmitComplete = true;
        }
        else {
            state.seenAffectedFiles.add(affected.resolvedPath);
            if (emitKind !== undefined) {
                (state.seenEmittedFiles || (state.seenEmittedFiles = new ts.Map())).set(affected.resolvedPath, emitKind);
            }
            if (isPendingEmit) {
                state.affectedFilesPendingEmitIndex++;
                state.buildInfoEmitPending = true;
            }
            else {
                state.affectedFilesIndex++;
            }
        }
    }
    /**
     * Returns the result with affected file
     */
    function toAffectedFileResult(state, result, affected) {
        doneWithAffectedFile(state, affected);
        return { result: result, affected: affected };
    }
    /**
     * Returns the result with affected file
     */
    function toAffectedFileEmitResult(state, result, affected, emitKind, isPendingEmit, isBuildInfoEmit) {
        doneWithAffectedFile(state, affected, emitKind, isPendingEmit, isBuildInfoEmit);
        return { result: result, affected: affected };
    }
    /**
     * Gets semantic diagnostics for the file which are
     * bindAndCheckDiagnostics (from cache) and program diagnostics
     */
    function getSemanticDiagnosticsOfFile(state, sourceFile, cancellationToken) {
        return ts.concatenate(getBinderAndCheckerDiagnosticsOfFile(state, sourceFile, cancellationToken), ts.Debug.checkDefined(state.program).getProgramDiagnostics(sourceFile));
    }
    /**
     * Gets the binder and checker diagnostics either from cache if present, or otherwise from program and caches it
     * Note that it is assumed that when asked about binder and checker diagnostics, the file has been taken out of affected files/changed file set
     */
    function getBinderAndCheckerDiagnosticsOfFile(state, sourceFile, cancellationToken) {
        var path = sourceFile.resolvedPath;
        if (state.semanticDiagnosticsPerFile) {
            var cachedDiagnostics = state.semanticDiagnosticsPerFile.get(path);
            // Report the bind and check diagnostics from the cache if we already have those diagnostics present
            if (cachedDiagnostics) {
                return ts.filterSemanticDiagnostics(cachedDiagnostics, state.compilerOptions);
            }
        }
        // Diagnostics werent cached, get them from program, and cache the result
        var diagnostics = ts.Debug.checkDefined(state.program).getBindAndCheckDiagnostics(sourceFile, cancellationToken);
        if (state.semanticDiagnosticsPerFile) {
            state.semanticDiagnosticsPerFile.set(path, diagnostics);
        }
        return ts.filterSemanticDiagnostics(diagnostics, state.compilerOptions);
    }
    /**
     * Gets the program information to be emitted in buildInfo so that we can use it to create new program
     */
    function getProgramBuildInfo(state, getCanonicalFileName) {
        if (ts.outFile(state.compilerOptions))
            return undefined;
        var currentDirectory = ts.Debug.checkDefined(state.program).getCurrentDirectory();
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(ts.getTsBuildInfoEmitOutputFilePath(state.compilerOptions), currentDirectory));
        var fileNames = [];
        var fileNameToFileId = new ts.Map();
        var fileIdsList;
        var fileNamesToFileIdListId;
        var fileInfos = ts.arrayFrom(state.fileInfos.entries(), function (_a) {
            var key = _a[0], value = _a[1];
            // Ensure fileId
            var fileId = toFileId(key);
            ts.Debug.assert(fileNames[fileId - 1] === relativeToBuildInfo(key));
            var signature = state.currentAffectedFilesSignatures && state.currentAffectedFilesSignatures.get(key);
            var actualSignature = signature !== null && signature !== void 0 ? signature : value.signature;
            return value.version === actualSignature ?
                value.affectsGlobalScope || value.impliedFormat ?
                    // If file version is same as signature, dont serialize signature
                    { version: value.version, signature: undefined, affectsGlobalScope: value.affectsGlobalScope, impliedFormat: value.impliedFormat } :
                    // If file info only contains version and signature and both are same we can just write string
                    value.version :
                actualSignature !== undefined ? // If signature is not same as version, encode signature in the fileInfo
                    signature === undefined ?
                        // If we havent computed signature, use fileInfo as is
                        value :
                        // Serialize fileInfo with new updated signature
                        { version: value.version, signature: signature, affectsGlobalScope: value.affectsGlobalScope, impliedFormat: value.impliedFormat } :
                    // Signature of the FileInfo is undefined, serialize it as false
                    { version: value.version, signature: false, affectsGlobalScope: value.affectsGlobalScope, impliedFormat: value.impliedFormat };
        });
        var referencedMap;
        if (state.referencedMap) {
            referencedMap = ts.arrayFrom(state.referencedMap.keys()).sort(ts.compareStringsCaseSensitive).map(function (key) { return [
                toFileId(key),
                toFileIdListId(state.referencedMap.getValues(key))
            ]; });
        }
        var exportedModulesMap;
        if (state.exportedModulesMap) {
            exportedModulesMap = ts.mapDefined(ts.arrayFrom(state.exportedModulesMap.keys()).sort(ts.compareStringsCaseSensitive), function (key) {
                var _a;
                if (state.currentAffectedFilesExportedModulesMap) {
                    if ((_a = state.currentAffectedFilesExportedModulesMap.deletedKeys()) === null || _a === void 0 ? void 0 : _a.has(key)) {
                        return undefined;
                    }
                    var newValue = state.currentAffectedFilesExportedModulesMap.getValues(key);
                    if (newValue) {
                        return [toFileId(key), toFileIdListId(newValue)];
                    }
                }
                // Not in temporary cache, use existing value
                return [toFileId(key), toFileIdListId(state.exportedModulesMap.getValues(key))];
            });
        }
        var semanticDiagnosticsPerFile;
        if (state.semanticDiagnosticsPerFile) {
            for (var _i = 0, _a = ts.arrayFrom(state.semanticDiagnosticsPerFile.keys()).sort(ts.compareStringsCaseSensitive); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = state.semanticDiagnosticsPerFile.get(key);
                (semanticDiagnosticsPerFile || (semanticDiagnosticsPerFile = [])).push(value.length ?
                    [
                        toFileId(key),
                        state.hasReusableDiagnostic ?
                            value :
                            convertToReusableDiagnostics(value, relativeToBuildInfo)
                    ] :
                    toFileId(key));
            }
        }
        var affectedFilesPendingEmit;
        if (state.affectedFilesPendingEmit) {
            var seenFiles = new ts.Set();
            for (var _b = 0, _c = state.affectedFilesPendingEmit.slice(state.affectedFilesPendingEmitIndex).sort(ts.compareStringsCaseSensitive); _b < _c.length; _b++) {
                var path = _c[_b];
                if (ts.tryAddToSet(seenFiles, path)) {
                    (affectedFilesPendingEmit || (affectedFilesPendingEmit = [])).push([toFileId(path), state.affectedFilesPendingEmitKind.get(path)]);
                }
            }
        }
        return {
            fileNames: fileNames,
            fileInfos: fileInfos,
            options: convertToProgramBuildInfoCompilerOptions(state.compilerOptions, relativeToBuildInfoEnsuringAbsolutePath),
            fileIdsList: fileIdsList,
            referencedMap: referencedMap,
            exportedModulesMap: exportedModulesMap,
            semanticDiagnosticsPerFile: semanticDiagnosticsPerFile,
            affectedFilesPendingEmit: affectedFilesPendingEmit,
        };
        function relativeToBuildInfoEnsuringAbsolutePath(path) {
            return relativeToBuildInfo(ts.getNormalizedAbsolutePath(path, currentDirectory));
        }
        function relativeToBuildInfo(path) {
            return ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(buildInfoDirectory, path, getCanonicalFileName));
        }
        function toFileId(path) {
            var fileId = fileNameToFileId.get(path);
            if (fileId === undefined) {
                fileNames.push(relativeToBuildInfo(path));
                fileNameToFileId.set(path, fileId = fileNames.length);
            }
            return fileId;
        }
        function toFileIdListId(set) {
            var fileIds = ts.arrayFrom(set.keys(), toFileId).sort(ts.compareValues);
            var key = fileIds.join();
            var fileIdListId = fileNamesToFileIdListId === null || fileNamesToFileIdListId === void 0 ? void 0 : fileNamesToFileIdListId.get(key);
            if (fileIdListId === undefined) {
                (fileIdsList || (fileIdsList = [])).push(fileIds);
                (fileNamesToFileIdListId || (fileNamesToFileIdListId = new ts.Map())).set(key, fileIdListId = fileIdsList.length);
            }
            return fileIdListId;
        }
    }
    function convertToProgramBuildInfoCompilerOptions(options, relativeToBuildInfo) {
        var result;
        var optionsNameMap = ts.getOptionsNameMap().optionsNameMap;
        for (var _i = 0, _a = ts.getOwnKeys(options).sort(ts.compareStringsCaseSensitive); _i < _a.length; _i++) {
            var name = _a[_i];
            var optionKey = name.toLowerCase();
            var optionInfo = optionsNameMap.get(optionKey);
            if ((optionInfo === null || optionInfo === void 0 ? void 0 : optionInfo.affectsEmit) || (optionInfo === null || optionInfo === void 0 ? void 0 : optionInfo.affectsSemanticDiagnostics) ||
                // We need to store `strict`, even though it won't be examined directly, so that the
                // flags it controls (e.g. `strictNullChecks`) will be retrieved correctly from the buildinfo
                optionKey === "strict" ||
                // We need to store these to determine whether `lib` files need to be rechecked.
                optionKey === "skiplibcheck" || optionKey === "skipdefaultlibcheck") {
                (result || (result = {}))[name] = convertToReusableCompilerOptionValue(optionInfo, options[name], relativeToBuildInfo);
            }
        }
        return result;
    }
    function convertToReusableCompilerOptionValue(option, value, relativeToBuildInfo) {
        if (option) {
            if (option.type === "list") {
                var values = value;
                if (option.element.isFilePath && values.length) {
                    return values.map(relativeToBuildInfo);
                }
            }
            else if (option.isFilePath) {
                return relativeToBuildInfo(value);
            }
        }
        return value;
    }
    function convertToReusableDiagnostics(diagnostics, relativeToBuildInfo) {
        ts.Debug.assert(!!diagnostics.length);
        return diagnostics.map(function (diagnostic) {
            var result = convertToReusableDiagnosticRelatedInformation(diagnostic, relativeToBuildInfo);
            result.reportsUnnecessary = diagnostic.reportsUnnecessary;
            result.reportDeprecated = diagnostic.reportsDeprecated;
            result.source = diagnostic.source;
            result.skippedOn = diagnostic.skippedOn;
            var relatedInformation = diagnostic.relatedInformation;
            result.relatedInformation = relatedInformation ?
                relatedInformation.length ?
                    relatedInformation.map(function (r) { return convertToReusableDiagnosticRelatedInformation(r, relativeToBuildInfo); }) :
                    [] :
                undefined;
            return result;
        });
    }
    function convertToReusableDiagnosticRelatedInformation(diagnostic, relativeToBuildInfo) {
        var file = diagnostic.file;
        return __assign(__assign({}, diagnostic), { file: file ? relativeToBuildInfo(file.resolvedPath) : undefined });
    }
    var BuilderProgramKind;
    (function (BuilderProgramKind) {
        BuilderProgramKind[BuilderProgramKind["SemanticDiagnosticsBuilderProgram"] = 0] = "SemanticDiagnosticsBuilderProgram";
        BuilderProgramKind[BuilderProgramKind["EmitAndSemanticDiagnosticsBuilderProgram"] = 1] = "EmitAndSemanticDiagnosticsBuilderProgram";
    })(BuilderProgramKind = ts.BuilderProgramKind || (ts.BuilderProgramKind = {}));
    function getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        var host;
        var newProgram;
        var oldProgram;
        if (newProgramOrRootNames === undefined) {
            ts.Debug.assert(hostOrOptions === undefined);
            host = oldProgramOrHost;
            oldProgram = configFileParsingDiagnosticsOrOldProgram;
            ts.Debug.assert(!!oldProgram);
            newProgram = oldProgram.getProgram();
        }
        else if (ts.isArray(newProgramOrRootNames)) {
            oldProgram = configFileParsingDiagnosticsOrOldProgram;
            newProgram = ts.createProgram({
                rootNames: newProgramOrRootNames,
                options: hostOrOptions,
                host: oldProgramOrHost,
                oldProgram: oldProgram && oldProgram.getProgramOrUndefined(),
                configFileParsingDiagnostics: configFileParsingDiagnostics,
                projectReferences: projectReferences
            });
            host = oldProgramOrHost;
        }
        else {
            newProgram = newProgramOrRootNames;
            host = hostOrOptions;
            oldProgram = oldProgramOrHost;
            configFileParsingDiagnostics = configFileParsingDiagnosticsOrOldProgram;
        }
        return { host: host, newProgram: newProgram, oldProgram: oldProgram, configFileParsingDiagnostics: configFileParsingDiagnostics || ts.emptyArray };
    }
    ts.getBuilderCreationParameters = getBuilderCreationParameters;
    function createBuilderProgram(kind, _a) {
        var newProgram = _a.newProgram, host = _a.host, oldProgram = _a.oldProgram, configFileParsingDiagnostics = _a.configFileParsingDiagnostics;
        // Return same program if underlying program doesnt change
        var oldState = oldProgram && oldProgram.getState();
        if (oldState && newProgram === oldState.program && configFileParsingDiagnostics === newProgram.getConfigFileParsingDiagnostics()) {
            newProgram = undefined; // TODO: GH#18217
            oldState = undefined;
            return oldProgram;
        }
        /**
         * Create the canonical file name for identity
         */
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        /**
         * Computing hash to for signature verification
         */
        var computeHash = ts.maybeBind(host, host.createHash);
        var state = createBuilderProgramState(newProgram, getCanonicalFileName, oldState, host.disableUseFileVersionAsSignature);
        var backupState;
        newProgram.getProgramBuildInfo = function () { return getProgramBuildInfo(state, getCanonicalFileName); };
        // To ensure that we arent storing any references to old program or new program without state
        newProgram = undefined; // TODO: GH#18217
        oldProgram = undefined;
        oldState = undefined;
        var getState = function () { return state; };
        var builderProgram = createRedirectedBuilderProgram(getState, configFileParsingDiagnostics);
        builderProgram.getState = getState;
        builderProgram.backupState = function () {
            ts.Debug.assert(backupState === undefined);
            backupState = cloneBuilderProgramState(state);
        };
        builderProgram.restoreState = function () {
            state = ts.Debug.checkDefined(backupState);
            backupState = undefined;
        };
        builderProgram.getAllDependencies = function (sourceFile) { return ts.BuilderState.getAllDependencies(state, ts.Debug.checkDefined(state.program), sourceFile); };
        builderProgram.getSemanticDiagnostics = getSemanticDiagnostics;
        builderProgram.emit = emit;
        builderProgram.releaseProgram = function () {
            releaseCache(state);
            backupState = undefined;
        };
        if (kind === BuilderProgramKind.SemanticDiagnosticsBuilderProgram) {
            builderProgram.getSemanticDiagnosticsOfNextAffectedFile = getSemanticDiagnosticsOfNextAffectedFile;
        }
        else if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram) {
            builderProgram.getSemanticDiagnosticsOfNextAffectedFile = getSemanticDiagnosticsOfNextAffectedFile;
            builderProgram.emitNextAffectedFile = emitNextAffectedFile;
            builderProgram.emitBuildInfo = emitBuildInfo;
        }
        else {
            ts.notImplemented();
        }
        return builderProgram;
        function emitBuildInfo(writeFile, cancellationToken) {
            if (state.buildInfoEmitPending) {
                var result = ts.Debug.checkDefined(state.program).emitBuildInfo(writeFile || ts.maybeBind(host, host.writeFile), cancellationToken);
                state.buildInfoEmitPending = false;
                return result;
            }
            return ts.emitSkippedWithNoDiagnostics;
        }
        /**
         * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        function emitNextAffectedFile(writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
            var affected = getNextAffectedFile(state, cancellationToken, computeHash, host);
            var emitKind = 1 /* BuilderFileEmit.Full */;
            var isPendingEmitFile = false;
            if (!affected) {
                if (!ts.outFile(state.compilerOptions)) {
                    var pendingAffectedFile = getNextAffectedFilePendingEmit(state);
                    if (!pendingAffectedFile) {
                        if (!state.buildInfoEmitPending) {
                            return undefined;
                        }
                        var affected_1 = ts.Debug.checkDefined(state.program);
                        return toAffectedFileEmitResult(state, 
                        // When whole program is affected, do emit only once (eg when --out or --outFile is specified)
                        // Otherwise just affected file
                        affected_1.emitBuildInfo(writeFile || ts.maybeBind(host, host.writeFile), cancellationToken), affected_1, 1 /* BuilderFileEmit.Full */, 
                        /*isPendingEmitFile*/ false, 
                        /*isBuildInfoEmit*/ true);
                    }
                    (affected = pendingAffectedFile.affectedFile, emitKind = pendingAffectedFile.emitKind);
                    isPendingEmitFile = true;
                }
                else {
                    var program = ts.Debug.checkDefined(state.program);
                    if (state.programEmitComplete)
                        return undefined;
                    affected = program;
                }
            }
            return toAffectedFileEmitResult(state, 
            // When whole program is affected, do emit only once (eg when --out or --outFile is specified)
            // Otherwise just affected file
            ts.Debug.checkDefined(state.program).emit(affected === state.program ? undefined : affected, affected !== state.program && ts.getEmitDeclarations(state.compilerOptions) && !customTransformers ?
                getWriteFileUpdatingSignatureCallback(writeFile) :
                writeFile || ts.maybeBind(host, host.writeFile), cancellationToken, emitOnlyDtsFiles || emitKind === 0 /* BuilderFileEmit.DtsOnly */, customTransformers), affected, emitKind, isPendingEmitFile);
        }
        function getWriteFileUpdatingSignatureCallback(writeFile) {
            return function (fileName, text, writeByteOrderMark, onError, sourceFiles, data) {
                var _a;
                if (ts.isDeclarationFileName(fileName)) {
                    ts.Debug.assert((sourceFiles === null || sourceFiles === void 0 ? void 0 : sourceFiles.length) === 1);
                    var file = sourceFiles[0];
                    var info = state.fileInfos.get(file.resolvedPath);
                    var signature = ((_a = state.currentAffectedFilesSignatures) === null || _a === void 0 ? void 0 : _a.get(file.resolvedPath)) || info.signature;
                    if (signature === file.version) {
                        var newSignature = (computeHash || ts.generateDjb2Hash)((data === null || data === void 0 ? void 0 : data.sourceMapUrlPos) !== undefined ? text.substring(0, data.sourceMapUrlPos) : text);
                        if (newSignature !== file.version) { // Update it
                            if (host.storeFilesChangingSignatureDuringEmit)
                                (state.filesChangingSignature || (state.filesChangingSignature = new ts.Set())).add(file.resolvedPath);
                            if (state.exportedModulesMap)
                                ts.BuilderState.updateExportedModules(file, file.exportedModulesFromDeclarationEmit, state.currentAffectedFilesExportedModulesMap || (state.currentAffectedFilesExportedModulesMap = ts.BuilderState.createManyToManyPathMap()));
                            if (state.affectedFiles && state.affectedFilesIndex < state.affectedFiles.length) {
                                state.currentAffectedFilesSignatures.set(file.resolvedPath, newSignature);
                            }
                            else {
                                info.signature = newSignature;
                                if (state.exportedModulesMap)
                                    ts.BuilderState.updateExportedFilesMapFromCache(state, state.currentAffectedFilesExportedModulesMap);
                            }
                        }
                    }
                }
                if (writeFile)
                    writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
                else if (host.writeFile)
                    host.writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
                else
                    state.program.writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
            };
        }
        /**
         * Emits the JavaScript and declaration files.
         * When targetSource file is specified, emits the files corresponding to that source file,
         * otherwise for the whole program.
         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,
         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,
         * it will only emit all the affected files instead of whole program
         *
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        function emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
            var _a;
            if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram) {
                assertSourceFileOkWithoutNextAffectedCall(state, targetSourceFile);
            }
            var result = ts.handleNoEmitOptions(builderProgram, targetSourceFile, writeFile, cancellationToken);
            if (result)
                return result;
            // Emit only affected files if using builder for emit
            if (!targetSourceFile) {
                if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram) {
                    // Emit and report any errors we ran into.
                    var sourceMaps = [];
                    var emitSkipped = false;
                    var diagnostics = void 0;
                    var emittedFiles = [];
                    var affectedEmitResult = void 0;
                    while (affectedEmitResult = emitNextAffectedFile(writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers)) {
                        emitSkipped = emitSkipped || affectedEmitResult.result.emitSkipped;
                        diagnostics = ts.addRange(diagnostics, affectedEmitResult.result.diagnostics);
                        emittedFiles = ts.addRange(emittedFiles, affectedEmitResult.result.emittedFiles);
                        sourceMaps = ts.addRange(sourceMaps, affectedEmitResult.result.sourceMaps);
                    }
                    return {
                        emitSkipped: emitSkipped,
                        diagnostics: diagnostics || ts.emptyArray,
                        emittedFiles: emittedFiles,
                        sourceMaps: sourceMaps
                    };
                }
                // In non Emit builder, clear affected files pending emit
                else if ((_a = state.affectedFilesPendingEmitKind) === null || _a === void 0 ? void 0 : _a.size) {
                    ts.Debug.assert(kind === BuilderProgramKind.SemanticDiagnosticsBuilderProgram);
                    // State can clear affected files pending emit if
                    if (!emitOnlyDtsFiles // If we are doing complete emit, affected files pending emit can be cleared
                        // If every file pending emit is pending on only dts emit
                        || ts.every(state.affectedFilesPendingEmit, function (path, index) {
                            return index < state.affectedFilesPendingEmitIndex ||
                                state.affectedFilesPendingEmitKind.get(path) === 0 /* BuilderFileEmit.DtsOnly */;
                        })) {
                        clearAffectedFilesPendingEmit(state);
                    }
                }
            }
            return ts.Debug.checkDefined(state.program).emit(targetSourceFile, !ts.outFile(state.compilerOptions) && ts.getEmitDeclarations(state.compilerOptions) && !customTransformers ?
                getWriteFileUpdatingSignatureCallback(writeFile) :
                writeFile || ts.maybeBind(host, host.writeFile), cancellationToken, emitOnlyDtsFiles, customTransformers);
        }
        /**
         * Return the semantic diagnostics for the next affected file or undefined if iteration is complete
         * If provided ignoreSourceFile would be called before getting the diagnostics and would ignore the sourceFile if the returned value was true
         */
        function getSemanticDiagnosticsOfNextAffectedFile(cancellationToken, ignoreSourceFile) {
            while (true) {
                var affected = getNextAffectedFile(state, cancellationToken, computeHash, host);
                if (!affected) {
                    // Done
                    return undefined;
                }
                else if (affected === state.program) {
                    // When whole program is affected, get all semantic diagnostics (eg when --out or --outFile is specified)
                    return toAffectedFileResult(state, state.program.getSemanticDiagnostics(/*targetSourceFile*/ undefined, cancellationToken), affected);
                }
                // Add file to affected file pending emit to handle for later emit time
                // Apart for emit builder do this for tsbuildinfo, do this for non emit builder when noEmit is set as tsbuildinfo is written and reused between emitters
                if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram || state.compilerOptions.noEmit || state.compilerOptions.noEmitOnError) {
                    addToAffectedFilesPendingEmit(state, affected.resolvedPath, 1 /* BuilderFileEmit.Full */);
                }
                // Get diagnostics for the affected file if its not ignored
                if (ignoreSourceFile && ignoreSourceFile(affected)) {
                    // Get next affected file
                    doneWithAffectedFile(state, affected);
                    continue;
                }
                return toAffectedFileResult(state, getSemanticDiagnosticsOfFile(state, affected, cancellationToken), affected);
            }
        }
        /**
         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program
         * The semantic diagnostics are cached and managed here
         * Note that it is assumed that when asked about semantic diagnostics through this API,
         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics
         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,
         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics
         */
        function getSemanticDiagnostics(sourceFile, cancellationToken) {
            assertSourceFileOkWithoutNextAffectedCall(state, sourceFile);
            var compilerOptions = ts.Debug.checkDefined(state.program).getCompilerOptions();
            if (ts.outFile(compilerOptions)) {
                ts.Debug.assert(!state.semanticDiagnosticsPerFile);
                // We dont need to cache the diagnostics just return them from program
                return ts.Debug.checkDefined(state.program).getSemanticDiagnostics(sourceFile, cancellationToken);
            }
            if (sourceFile) {
                return getSemanticDiagnosticsOfFile(state, sourceFile, cancellationToken);
            }
            // When semantic builder asks for diagnostics of the whole program,
            // ensure that all the affected files are handled
            // eslint-disable-next-line no-empty
            while (getSemanticDiagnosticsOfNextAffectedFile(cancellationToken)) {
            }
            var diagnostics;
            for (var _i = 0, _a = ts.Debug.checkDefined(state.program).getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile_1 = _a[_i];
                diagnostics = ts.addRange(diagnostics, getSemanticDiagnosticsOfFile(state, sourceFile_1, cancellationToken));
            }
            return diagnostics || ts.emptyArray;
        }
    }
    ts.createBuilderProgram = createBuilderProgram;
    function addToAffectedFilesPendingEmit(state, affectedFilePendingEmit, kind) {
        if (!state.affectedFilesPendingEmit)
            state.affectedFilesPendingEmit = [];
        if (!state.affectedFilesPendingEmitKind)
            state.affectedFilesPendingEmitKind = new ts.Map();
        var existingKind = state.affectedFilesPendingEmitKind.get(affectedFilePendingEmit);
        state.affectedFilesPendingEmit.push(affectedFilePendingEmit);
        state.affectedFilesPendingEmitKind.set(affectedFilePendingEmit, existingKind || kind);
        // affectedFilesPendingEmitIndex === undefined
        // - means the emit state.affectedFilesPendingEmit was undefined before adding current affected files
        //   so start from 0 as array would be affectedFilesPendingEmit
        // else, continue to iterate from existing index, the current set is appended to existing files
        if (state.affectedFilesPendingEmitIndex === undefined) {
            state.affectedFilesPendingEmitIndex = 0;
        }
    }
    function toBuilderStateFileInfo(fileInfo) {
        return ts.isString(fileInfo) ?
            { version: fileInfo, signature: fileInfo, affectsGlobalScope: undefined, impliedFormat: undefined } :
            ts.isString(fileInfo.signature) ?
                fileInfo :
                { version: fileInfo.version, signature: fileInfo.signature === false ? undefined : fileInfo.version, affectsGlobalScope: fileInfo.affectsGlobalScope, impliedFormat: fileInfo.impliedFormat };
    }
    ts.toBuilderStateFileInfo = toBuilderStateFileInfo;
    function createBuildProgramUsingProgramBuildInfo(program, buildInfoPath, host) {
        var _a;
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        var filePaths = program.fileNames.map(toPath);
        var filePathsSetList = (_a = program.fileIdsList) === null || _a === void 0 ? void 0 : _a.map(function (fileIds) { return new ts.Set(fileIds.map(toFilePath)); });
        var fileInfos = new ts.Map();
        program.fileInfos.forEach(function (fileInfo, index) { return fileInfos.set(toFilePath(index + 1), toBuilderStateFileInfo(fileInfo)); });
        var state = {
            fileInfos: fileInfos,
            compilerOptions: program.options ? ts.convertToOptionsWithAbsolutePaths(program.options, toAbsolutePath) : {},
            referencedMap: toManyToManyPathMap(program.referencedMap),
            exportedModulesMap: toManyToManyPathMap(program.exportedModulesMap),
            semanticDiagnosticsPerFile: program.semanticDiagnosticsPerFile && ts.arrayToMap(program.semanticDiagnosticsPerFile, function (value) { return toFilePath(ts.isNumber(value) ? value : value[0]); }, function (value) { return ts.isNumber(value) ? ts.emptyArray : value[1]; }),
            hasReusableDiagnostic: true,
            affectedFilesPendingEmit: ts.map(program.affectedFilesPendingEmit, function (value) { return toFilePath(value[0]); }),
            affectedFilesPendingEmitKind: program.affectedFilesPendingEmit && ts.arrayToMap(program.affectedFilesPendingEmit, function (value) { return toFilePath(value[0]); }, function (value) { return value[1]; }),
            affectedFilesPendingEmitIndex: program.affectedFilesPendingEmit && 0,
        };
        return {
            getState: function () { return state; },
            backupState: ts.noop,
            restoreState: ts.noop,
            getProgram: ts.notImplemented,
            getProgramOrUndefined: ts.returnUndefined,
            releaseProgram: ts.noop,
            getCompilerOptions: function () { return state.compilerOptions; },
            getSourceFile: ts.notImplemented,
            getSourceFiles: ts.notImplemented,
            getOptionsDiagnostics: ts.notImplemented,
            getGlobalDiagnostics: ts.notImplemented,
            getConfigFileParsingDiagnostics: ts.notImplemented,
            getSyntacticDiagnostics: ts.notImplemented,
            getDeclarationDiagnostics: ts.notImplemented,
            getSemanticDiagnostics: ts.notImplemented,
            emit: ts.notImplemented,
            getAllDependencies: ts.notImplemented,
            getCurrentDirectory: ts.notImplemented,
            emitNextAffectedFile: ts.notImplemented,
            getSemanticDiagnosticsOfNextAffectedFile: ts.notImplemented,
            emitBuildInfo: ts.notImplemented,
            close: ts.noop,
        };
        function toPath(path) {
            return ts.toPath(path, buildInfoDirectory, getCanonicalFileName);
        }
        function toAbsolutePath(path) {
            return ts.getNormalizedAbsolutePath(path, buildInfoDirectory);
        }
        function toFilePath(fileId) {
            return filePaths[fileId - 1];
        }
        function toFilePathsSet(fileIdsListId) {
            return filePathsSetList[fileIdsListId - 1];
        }
        function toManyToManyPathMap(referenceMap) {
            if (!referenceMap) {
                return undefined;
            }
            var map = ts.BuilderState.createManyToManyPathMap();
            referenceMap.forEach(function (_a) {
                var fileId = _a[0], fileIdListId = _a[1];
                return map.set(toFilePath(fileId), toFilePathsSet(fileIdListId));
            });
            return map;
        }
    }
    ts.createBuildProgramUsingProgramBuildInfo = createBuildProgramUsingProgramBuildInfo;
    function createRedirectedBuilderProgram(getState, configFileParsingDiagnostics) {
        return {
            getState: ts.notImplemented,
            backupState: ts.noop,
            restoreState: ts.noop,
            getProgram: getProgram,
            getProgramOrUndefined: function () { return getState().program; },
            releaseProgram: function () { return getState().program = undefined; },
            getCompilerOptions: function () { return getState().compilerOptions; },
            getSourceFile: function (fileName) { return getProgram().getSourceFile(fileName); },
            getSourceFiles: function () { return getProgram().getSourceFiles(); },
            getOptionsDiagnostics: function (cancellationToken) { return getProgram().getOptionsDiagnostics(cancellationToken); },
            getGlobalDiagnostics: function (cancellationToken) { return getProgram().getGlobalDiagnostics(cancellationToken); },
            getConfigFileParsingDiagnostics: function () { return configFileParsingDiagnostics; },
            getSyntacticDiagnostics: function (sourceFile, cancellationToken) { return getProgram().getSyntacticDiagnostics(sourceFile, cancellationToken); },
            getDeclarationDiagnostics: function (sourceFile, cancellationToken) { return getProgram().getDeclarationDiagnostics(sourceFile, cancellationToken); },
            getSemanticDiagnostics: function (sourceFile, cancellationToken) { return getProgram().getSemanticDiagnostics(sourceFile, cancellationToken); },
            emit: function (sourceFile, writeFile, cancellationToken, emitOnlyDts, customTransformers) { return getProgram().emit(sourceFile, writeFile, cancellationToken, emitOnlyDts, customTransformers); },
            emitBuildInfo: function (writeFile, cancellationToken) { return getProgram().emitBuildInfo(writeFile, cancellationToken); },
            getAllDependencies: ts.notImplemented,
            getCurrentDirectory: function () { return getProgram().getCurrentDirectory(); },
            close: ts.noop,
        };
        function getProgram() {
            return ts.Debug.checkDefined(getState().program);
        }
    }
    ts.createRedirectedBuilderProgram = createRedirectedBuilderProgram;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createSemanticDiagnosticsBuilderProgram(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        return ts.createBuilderProgram(ts.BuilderProgramKind.SemanticDiagnosticsBuilderProgram, ts.getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences));
    }
    ts.createSemanticDiagnosticsBuilderProgram = createSemanticDiagnosticsBuilderProgram;
    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        return ts.createBuilderProgram(ts.BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram, ts.getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences));
    }
    ts.createEmitAndSemanticDiagnosticsBuilderProgram = createEmitAndSemanticDiagnosticsBuilderProgram;
    function createAbstractBuilder(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        var _a = ts.getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences), newProgram = _a.newProgram, newConfigFileParsingDiagnostics = _a.configFileParsingDiagnostics;
        return ts.createRedirectedBuilderProgram(function () { return ({ program: newProgram, compilerOptions: newProgram.getCompilerOptions() }); }, newConfigFileParsingDiagnostics);
    }
    ts.createAbstractBuilder = createAbstractBuilder;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function removeIgnoredPath(path) {
        // Consider whole staging folder as if node_modules changed.
        if (ts.endsWith(path, "/node_modules/.staging")) {
            return ts.removeSuffix(path, "/.staging");
        }
        return ts.some(ts.ignoredPaths, function (searchPath) { return ts.stringContains(path, searchPath); }) ?
            undefined :
            path;
    }
    ts.removeIgnoredPath = removeIgnoredPath;
    /**
     * Filter out paths like
     * "/", "/user", "/user/username", "/user/username/folderAtRoot",
     * "c:/", "c:/users", "c:/users/username", "c:/users/username/folderAtRoot", "c:/folderAtRoot"
     * @param dirPath
     */
    function canWatchDirectory(dirPath) {
        var rootLength = ts.getRootLength(dirPath);
        if (dirPath.length === rootLength) {
            // Ignore "/", "c:/"
            return false;
        }
        var nextDirectorySeparator = dirPath.indexOf(ts.directorySeparator, rootLength);
        if (nextDirectorySeparator === -1) {
            // ignore "/user", "c:/users" or "c:/folderAtRoot"
            return false;
        }
        var pathPartForUserCheck = dirPath.substring(rootLength, nextDirectorySeparator + 1);
        var isNonDirectorySeparatorRoot = rootLength > 1 || dirPath.charCodeAt(0) !== 47 /* CharacterCodes.slash */;
        if (isNonDirectorySeparatorRoot &&
            dirPath.search(/[a-zA-Z]:/) !== 0 && // Non dos style paths
            pathPartForUserCheck.search(/[a-zA-z]\$\//) === 0) { // Dos style nextPart
            nextDirectorySeparator = dirPath.indexOf(ts.directorySeparator, nextDirectorySeparator + 1);
            if (nextDirectorySeparator === -1) {
                // ignore "//vda1cs4850/c$/folderAtRoot"
                return false;
            }
            pathPartForUserCheck = dirPath.substring(rootLength + pathPartForUserCheck.length, nextDirectorySeparator + 1);
        }
        if (isNonDirectorySeparatorRoot &&
            pathPartForUserCheck.search(/users\//i) !== 0) {
            // Paths like c:/folderAtRoot/subFolder are allowed
            return true;
        }
        for (var searchIndex = nextDirectorySeparator + 1, searchLevels = 2; searchLevels > 0; searchLevels--) {
            searchIndex = dirPath.indexOf(ts.directorySeparator, searchIndex) + 1;
            if (searchIndex === 0) {
                // Folder isnt at expected minimum levels
                return false;
            }
        }
        return true;
    }
    ts.canWatchDirectory = canWatchDirectory;
    function createResolutionCache(resolutionHost, rootDirForResolution, logChangesWhenResolvingModule) {
        var filesWithChangedSetOfUnresolvedImports;
        var filesWithInvalidatedResolutions;
        var filesWithInvalidatedNonRelativeUnresolvedImports;
        var nonRelativeExternalModuleResolutions = ts.createMultiMap();
        var resolutionsWithFailedLookups = [];
        var resolvedFileToResolution = ts.createMultiMap();
        var hasChangedAutomaticTypeDirectiveNames = false;
        var failedLookupChecks;
        var startsWithPathChecks;
        var isInDirectoryChecks;
        var getCurrentDirectory = ts.memoize(function () { return resolutionHost.getCurrentDirectory(); }); // TODO: GH#18217
        var cachedDirectoryStructureHost = resolutionHost.getCachedDirectoryStructureHost();
        // The resolvedModuleNames and resolvedTypeReferenceDirectives are the cache of resolutions per file.
        // The key in the map is source file's path.
        // The values are Map of resolutions with key being name lookedup.
        var resolvedModuleNames = new ts.Map();
        var perDirectoryResolvedModuleNames = ts.createCacheWithRedirects();
        var nonRelativeModuleNameCache = ts.createCacheWithRedirects();
        var moduleResolutionCache = ts.createModuleResolutionCache(getCurrentDirectory(), resolutionHost.getCanonicalFileName, 
        /*options*/ undefined, perDirectoryResolvedModuleNames, nonRelativeModuleNameCache);
        var resolvedTypeReferenceDirectives = new ts.Map();
        var perDirectoryResolvedTypeReferenceDirectives = ts.createCacheWithRedirects();
        var typeReferenceDirectiveResolutionCache = ts.createTypeReferenceDirectiveResolutionCache(getCurrentDirectory(), resolutionHost.getCanonicalFileName, 
        /*options*/ undefined, moduleResolutionCache.getPackageJsonInfoCache(), perDirectoryResolvedTypeReferenceDirectives);
        /**
         * These are the extensions that failed lookup files will have by default,
         * any other extension of failed lookup will be store that path in custom failed lookup path
         * This helps in not having to comb through all resolutions when files are added/removed
         * Note that .d.ts file also has .d.ts extension hence will be part of default extensions
         */
        var failedLookupDefaultExtensions = [".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */, ".json" /* Extension.Json */];
        var customFailedLookupPaths = new ts.Map();
        var directoryWatchesOfFailedLookups = new ts.Map();
        var rootDir = rootDirForResolution && ts.removeTrailingDirectorySeparator(ts.getNormalizedAbsolutePath(rootDirForResolution, getCurrentDirectory()));
        var rootPath = (rootDir && resolutionHost.toPath(rootDir)); // TODO: GH#18217
        var rootSplitLength = rootPath !== undefined ? rootPath.split(ts.directorySeparator).length : 0;
        // TypeRoot watches for the types that get added as part of getAutomaticTypeDirectiveNames
        var typeRootsWatches = new ts.Map();
        return {
            getModuleResolutionCache: function () { return moduleResolutionCache; },
            startRecordingFilesWithChangedResolutions: startRecordingFilesWithChangedResolutions,
            finishRecordingFilesWithChangedResolutions: finishRecordingFilesWithChangedResolutions,
            // perDirectoryResolvedModuleNames and perDirectoryResolvedTypeReferenceDirectives could be non empty if there was exception during program update
            // (between startCachingPerDirectoryResolution and finishCachingPerDirectoryResolution)
            startCachingPerDirectoryResolution: clearPerDirectoryResolutions,
            finishCachingPerDirectoryResolution: finishCachingPerDirectoryResolution,
            resolveModuleNames: resolveModuleNames,
            getResolvedModuleWithFailedLookupLocationsFromCache: getResolvedModuleWithFailedLookupLocationsFromCache,
            resolveTypeReferenceDirectives: resolveTypeReferenceDirectives,
            removeResolutionsFromProjectReferenceRedirects: removeResolutionsFromProjectReferenceRedirects,
            removeResolutionsOfFile: removeResolutionsOfFile,
            hasChangedAutomaticTypeDirectiveNames: function () { return hasChangedAutomaticTypeDirectiveNames; },
            invalidateResolutionOfFile: invalidateResolutionOfFile,
            invalidateResolutionsOfFailedLookupLocations: invalidateResolutionsOfFailedLookupLocations,
            setFilesWithInvalidatedNonRelativeUnresolvedImports: setFilesWithInvalidatedNonRelativeUnresolvedImports,
            createHasInvalidatedResolution: createHasInvalidatedResolution,
            isFileWithInvalidatedNonRelativeUnresolvedImports: isFileWithInvalidatedNonRelativeUnresolvedImports,
            updateTypeRootsWatch: updateTypeRootsWatch,
            closeTypeRootsWatch: closeTypeRootsWatch,
            clear: clear
        };
        function getResolvedModule(resolution) {
            return resolution.resolvedModule;
        }
        function getResolvedTypeReferenceDirective(resolution) {
            return resolution.resolvedTypeReferenceDirective;
        }
        function isInDirectoryPath(dir, file) {
            if (dir === undefined || file.length <= dir.length) {
                return false;
            }
            return ts.startsWith(file, dir) && file[dir.length] === ts.directorySeparator;
        }
        function clear() {
            ts.clearMap(directoryWatchesOfFailedLookups, ts.closeFileWatcherOf);
            customFailedLookupPaths.clear();
            nonRelativeExternalModuleResolutions.clear();
            closeTypeRootsWatch();
            resolvedModuleNames.clear();
            resolvedTypeReferenceDirectives.clear();
            resolvedFileToResolution.clear();
            resolutionsWithFailedLookups.length = 0;
            failedLookupChecks = undefined;
            startsWithPathChecks = undefined;
            isInDirectoryChecks = undefined;
            // perDirectoryResolvedModuleNames and perDirectoryResolvedTypeReferenceDirectives could be non empty if there was exception during program update
            // (between startCachingPerDirectoryResolution and finishCachingPerDirectoryResolution)
            clearPerDirectoryResolutions();
            hasChangedAutomaticTypeDirectiveNames = false;
        }
        function startRecordingFilesWithChangedResolutions() {
            filesWithChangedSetOfUnresolvedImports = [];
        }
        function finishRecordingFilesWithChangedResolutions() {
            var collected = filesWithChangedSetOfUnresolvedImports;
            filesWithChangedSetOfUnresolvedImports = undefined;
            return collected;
        }
        function isFileWithInvalidatedNonRelativeUnresolvedImports(path) {
            if (!filesWithInvalidatedNonRelativeUnresolvedImports) {
                return false;
            }
            // Invalidated if file has unresolved imports
            var value = filesWithInvalidatedNonRelativeUnresolvedImports.get(path);
            return !!value && !!value.length;
        }
        function createHasInvalidatedResolution(forceAllFilesAsInvalidated) {
            // Ensure pending resolutions are applied
            invalidateResolutionsOfFailedLookupLocations();
            if (forceAllFilesAsInvalidated) {
                // Any file asked would have invalidated resolution
                filesWithInvalidatedResolutions = undefined;
                return ts.returnTrue;
            }
            var collected = filesWithInvalidatedResolutions;
            filesWithInvalidatedResolutions = undefined;
            return function (path) { return (!!collected && collected.has(path)) ||
                isFileWithInvalidatedNonRelativeUnresolvedImports(path); };
        }
        function clearPerDirectoryResolutions() {
            moduleResolutionCache.clear();
            typeReferenceDirectiveResolutionCache.clear();
            nonRelativeExternalModuleResolutions.forEach(watchFailedLookupLocationOfNonRelativeModuleResolutions);
            nonRelativeExternalModuleResolutions.clear();
        }
        function finishCachingPerDirectoryResolution() {
            filesWithInvalidatedNonRelativeUnresolvedImports = undefined;
            clearPerDirectoryResolutions();
            directoryWatchesOfFailedLookups.forEach(function (watcher, path) {
                if (watcher.refCount === 0) {
                    directoryWatchesOfFailedLookups.delete(path);
                    watcher.watcher.close();
                }
            });
            hasChangedAutomaticTypeDirectiveNames = false;
        }
        function resolveModuleName(moduleName, containingFile, compilerOptions, host, redirectedReference, _containingSourceFile, mode) {
            var _a;
            var primaryResult = ts.resolveModuleName(moduleName, containingFile, compilerOptions, host, moduleResolutionCache, redirectedReference, mode);
            // return result immediately only if global cache support is not enabled or if it is .ts, .tsx or .d.ts
            if (!resolutionHost.getGlobalCache) {
                return primaryResult;
            }
            // otherwise try to load typings from @types
            var globalCache = resolutionHost.getGlobalCache();
            if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                // create different collection of failed lookup locations for second pass
                // if it will fail and we've already found something during the first pass - we don't want to pollute its results
                var _b = ts.loadModuleFromGlobalCache(ts.Debug.checkDefined(resolutionHost.globalCacheResolutionModuleName)(moduleName), resolutionHost.projectName, compilerOptions, host, globalCache, moduleResolutionCache), resolvedModule = _b.resolvedModule, failedLookupLocations = _b.failedLookupLocations;
                if (resolvedModule) {
                    // Modify existing resolution so its saved in the directory cache as well
                    primaryResult.resolvedModule = resolvedModule;
                    (_a = primaryResult.failedLookupLocations).push.apply(_a, failedLookupLocations);
                    return primaryResult;
                }
            }
            // Default return the result from the first pass
            return primaryResult;
        }
        function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, _containingSourceFile, resolutionMode) {
            return ts.resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, typeReferenceDirectiveResolutionCache, resolutionMode);
        }
        function resolveNamesWithLocalCache(_a) {
            var _b, _c, _d;
            var names = _a.names, containingFile = _a.containingFile, redirectedReference = _a.redirectedReference, cache = _a.cache, perDirectoryCacheWithRedirects = _a.perDirectoryCacheWithRedirects, loader = _a.loader, getResolutionWithResolvedFileName = _a.getResolutionWithResolvedFileName, shouldRetryResolution = _a.shouldRetryResolution, reusedNames = _a.reusedNames, logChanges = _a.logChanges, containingSourceFile = _a.containingSourceFile, containingSourceFileMode = _a.containingSourceFileMode;
            var path = resolutionHost.toPath(containingFile);
            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createModeAwareCache()).get(path);
            var dirPath = ts.getDirectoryPath(path);
            var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
            var perDirectoryResolution = perDirectoryCache.get(dirPath);
            if (!perDirectoryResolution) {
                perDirectoryResolution = ts.createModeAwareCache();
                perDirectoryCache.set(dirPath, perDirectoryResolution);
            }
            var resolvedModules = [];
            var compilerOptions = resolutionHost.getCompilationSettings();
            var hasInvalidatedNonRelativeUnresolvedImport = logChanges && isFileWithInvalidatedNonRelativeUnresolvedImports(path);
            // All the resolutions in this file are invalidated if this file wasn't resolved using same redirect
            var program = resolutionHost.getCurrentProgram();
            var oldRedirect = program && program.getResolvedProjectReferenceToRedirect(containingFile);
            var unmatchedRedirects = oldRedirect ?
                !redirectedReference || redirectedReference.sourceFile.path !== oldRedirect.sourceFile.path :
                !!redirectedReference;
            var seenNamesInFile = ts.createModeAwareCache();
            var i = 0;
            for (var _i = 0, names_5 = names; _i < names_5.length; _i++) {
                var entry = names_5[_i];
                var name = ts.isString(entry) ? entry : entry.fileName.toLowerCase();
                // Imports supply a `containingSourceFile` but no `containingSourceFileMode` - it would be redundant
                // they require calculating the mode for a given import from it's position in the resolution table, since a given
                // import's syntax may override the file's default mode.
                // Type references instead supply a `containingSourceFileMode` and a non-string entry which contains
                // a default file mode override if applicable.
                var mode = !ts.isString(entry) ? ts.getModeForFileReference(entry, containingSourceFileMode) :
                    containingSourceFile ? ts.getModeForResolutionAtIndex(containingSourceFile, i) : undefined;
                i++;
                var resolution = resolutionsInFile.get(name, mode);
                // Resolution is valid if it is present and not invalidated
                if (!seenNamesInFile.has(name, mode) &&
                    unmatchedRedirects || !resolution || resolution.isInvalidated ||
                    // If the name is unresolved import that was invalidated, recalculate
                    (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                    var existingResolution = resolution;
                    var resolutionInDirectory = perDirectoryResolution.get(name, mode);
                    if (resolutionInDirectory) {
                        resolution = resolutionInDirectory;
                        var host = ((_b = resolutionHost.getCompilerHost) === null || _b === void 0 ? void 0 : _b.call(resolutionHost)) || resolutionHost;
                        if (ts.isTraceEnabled(compilerOptions, host)) {
                            var resolved = getResolutionWithResolvedFileName(resolution);
                            ts.trace(host, loader === resolveModuleName ?
                                (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                    resolved.packagetId ?
                                        ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 :
                                        ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 :
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved :
                                (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                    resolved.packagetId ?
                                        ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 :
                                        ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 :
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved, name, containingFile, ts.getDirectoryPath(containingFile), resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName, (resolved === null || resolved === void 0 ? void 0 : resolved.packagetId) && ts.packageIdToString(resolved.packagetId));
                        }
                    }
                    else {
                        resolution = loader(name, containingFile, compilerOptions, ((_c = resolutionHost.getCompilerHost) === null || _c === void 0 ? void 0 : _c.call(resolutionHost)) || resolutionHost, redirectedReference, containingSourceFile, mode);
                        perDirectoryResolution.set(name, mode, resolution);
                        if (resolutionHost.onDiscoveredSymlink && resolutionIsSymlink(resolution)) {
                            resolutionHost.onDiscoveredSymlink();
                        }
                    }
                    resolutionsInFile.set(name, mode, resolution);
                    watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution, path, getResolutionWithResolvedFileName);
                    if (existingResolution) {
                        stopWatchFailedLookupLocationOfResolution(existingResolution, path, getResolutionWithResolvedFileName);
                    }
                    if (logChanges && filesWithChangedSetOfUnresolvedImports && !resolutionIsEqualTo(existingResolution, resolution)) {
                        filesWithChangedSetOfUnresolvedImports.push(path);
                        // reset log changes to avoid recording the same file multiple times
                        logChanges = false;
                    }
                }
                else {
                    var host = ((_d = resolutionHost.getCompilerHost) === null || _d === void 0 ? void 0 : _d.call(resolutionHost)) || resolutionHost;
                    if (ts.isTraceEnabled(compilerOptions, host) && !seenNamesInFile.has(name, mode)) {
                        var resolved = getResolutionWithResolvedFileName(resolution);
                        ts.trace(host, loader === resolveModuleName ?
                            (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                resolved.packagetId ?
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2 :
                                ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved :
                            (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                resolved.packagetId ?
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2 :
                                ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved, name, containingFile, resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName, (resolved === null || resolved === void 0 ? void 0 : resolved.packagetId) && ts.packageIdToString(resolved.packagetId));
                    }
                }
                ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
                seenNamesInFile.set(name, mode, true);
                resolvedModules.push(getResolutionWithResolvedFileName(resolution));
            }
            // Stop watching and remove the unused name
            resolutionsInFile.forEach(function (resolution, name, mode) {
                if (!seenNamesInFile.has(name, mode) && !ts.contains(reusedNames, name)) {
                    stopWatchFailedLookupLocationOfResolution(resolution, path, getResolutionWithResolvedFileName);
                    resolutionsInFile.delete(name, mode);
                }
            });
            return resolvedModules;
            function resolutionIsEqualTo(oldResolution, newResolution) {
                if (oldResolution === newResolution) {
                    return true;
                }
                if (!oldResolution || !newResolution) {
                    return false;
                }
                var oldResult = getResolutionWithResolvedFileName(oldResolution);
                var newResult = getResolutionWithResolvedFileName(newResolution);
                if (oldResult === newResult) {
                    return true;
                }
                if (!oldResult || !newResult) {
                    return false;
                }
                return oldResult.resolvedFileName === newResult.resolvedFileName;
            }
        }
        function resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, containingFileMode) {
            return resolveNamesWithLocalCache({
                names: typeDirectiveNames,
                containingFile: containingFile,
                redirectedReference: redirectedReference,
                cache: resolvedTypeReferenceDirectives,
                perDirectoryCacheWithRedirects: perDirectoryResolvedTypeReferenceDirectives,
                loader: resolveTypeReferenceDirective,
                getResolutionWithResolvedFileName: getResolvedTypeReferenceDirective,
                shouldRetryResolution: function (resolution) { return resolution.resolvedTypeReferenceDirective === undefined; },
                containingSourceFileMode: containingFileMode
            });
        }
        function resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, containingSourceFile) {
            return resolveNamesWithLocalCache({
                names: moduleNames,
                containingFile: containingFile,
                redirectedReference: redirectedReference,
                cache: resolvedModuleNames,
                perDirectoryCacheWithRedirects: perDirectoryResolvedModuleNames,
                loader: resolveModuleName,
                getResolutionWithResolvedFileName: getResolvedModule,
                shouldRetryResolution: function (resolution) { return !resolution.resolvedModule || !ts.resolutionExtensionIsTSOrJson(resolution.resolvedModule.extension); },
                reusedNames: reusedNames,
                logChanges: logChangesWhenResolvingModule,
                containingSourceFile: containingSourceFile,
            });
        }
        function getResolvedModuleWithFailedLookupLocationsFromCache(moduleName, containingFile, resolutionMode) {
            var cache = resolvedModuleNames.get(resolutionHost.toPath(containingFile));
            if (!cache)
                return undefined;
            return cache.get(moduleName, resolutionMode);
        }
        function isNodeModulesAtTypesDirectory(dirPath) {
            return ts.endsWith(dirPath, "/node_modules/@types");
        }
        function getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath) {
            if (isInDirectoryPath(rootPath, failedLookupLocationPath)) {
                // Ensure failed look up is normalized path
                failedLookupLocation = ts.isRootedDiskPath(failedLookupLocation) ? ts.normalizePath(failedLookupLocation) : ts.getNormalizedAbsolutePath(failedLookupLocation, getCurrentDirectory());
                var failedLookupPathSplit = failedLookupLocationPath.split(ts.directorySeparator);
                var failedLookupSplit = failedLookupLocation.split(ts.directorySeparator);
                ts.Debug.assert(failedLookupSplit.length === failedLookupPathSplit.length, "FailedLookup: ".concat(failedLookupLocation, " failedLookupLocationPath: ").concat(failedLookupLocationPath));
                if (failedLookupPathSplit.length > rootSplitLength + 1) {
                    // Instead of watching root, watch directory in root to avoid watching excluded directories not needed for module resolution
                    return {
                        dir: failedLookupSplit.slice(0, rootSplitLength + 1).join(ts.directorySeparator),
                        dirPath: failedLookupPathSplit.slice(0, rootSplitLength + 1).join(ts.directorySeparator)
                    };
                }
                else {
                    // Always watch root directory non recursively
                    return {
                        dir: rootDir,
                        dirPath: rootPath,
                        nonRecursive: false
                    };
                }
            }
            return getDirectoryToWatchFromFailedLookupLocationDirectory(ts.getDirectoryPath(ts.getNormalizedAbsolutePath(failedLookupLocation, getCurrentDirectory())), ts.getDirectoryPath(failedLookupLocationPath));
        }
        function getDirectoryToWatchFromFailedLookupLocationDirectory(dir, dirPath) {
            // If directory path contains node module, get the most parent node_modules directory for watching
            while (ts.pathContainsNodeModules(dirPath)) {
                dir = ts.getDirectoryPath(dir);
                dirPath = ts.getDirectoryPath(dirPath);
            }
            // If the directory is node_modules use it to watch, always watch it recursively
            if (ts.isNodeModulesDirectory(dirPath)) {
                return canWatchDirectory(ts.getDirectoryPath(dirPath)) ? { dir: dir, dirPath: dirPath } : undefined;
            }
            var nonRecursive = true;
            // Use some ancestor of the root directory
            var subDirectoryPath, subDirectory;
            if (rootPath !== undefined) {
                while (!isInDirectoryPath(dirPath, rootPath)) {
                    var parentPath = ts.getDirectoryPath(dirPath);
                    if (parentPath === dirPath) {
                        break;
                    }
                    nonRecursive = false;
                    subDirectoryPath = dirPath;
                    subDirectory = dir;
                    dirPath = parentPath;
                    dir = ts.getDirectoryPath(dir);
                }
            }
            return canWatchDirectory(dirPath) ? { dir: subDirectory || dir, dirPath: subDirectoryPath || dirPath, nonRecursive: nonRecursive } : undefined;
        }
        function isPathWithDefaultFailedLookupExtension(path) {
            return ts.fileExtensionIsOneOf(path, failedLookupDefaultExtensions);
        }
        function watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution, filePath, getResolutionWithResolvedFileName) {
            if (resolution.refCount) {
                resolution.refCount++;
                ts.Debug.assertIsDefined(resolution.files);
            }
            else {
                resolution.refCount = 1;
                ts.Debug.assert(ts.length(resolution.files) === 0); // This resolution shouldnt be referenced by any file yet
                if (ts.isExternalModuleNameRelative(name)) {
                    watchFailedLookupLocationOfResolution(resolution);
                }
                else {
                    nonRelativeExternalModuleResolutions.add(name, resolution);
                }
                var resolved = getResolutionWithResolvedFileName(resolution);
                if (resolved && resolved.resolvedFileName) {
                    resolvedFileToResolution.add(resolutionHost.toPath(resolved.resolvedFileName), resolution);
                }
            }
            (resolution.files || (resolution.files = [])).push(filePath);
        }
        function watchFailedLookupLocationOfResolution(resolution) {
            ts.Debug.assert(!!resolution.refCount);
            var failedLookupLocations = resolution.failedLookupLocations;
            if (!failedLookupLocations.length)
                return;
            resolutionsWithFailedLookups.push(resolution);
            var setAtRoot = false;
            for (var _i = 0, failedLookupLocations_1 = failedLookupLocations; _i < failedLookupLocations_1.length; _i++) {
                var failedLookupLocation = failedLookupLocations_1[_i];
                var failedLookupLocationPath = resolutionHost.toPath(failedLookupLocation);
                var toWatch = getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath);
                if (toWatch) {
                    var dir = toWatch.dir, dirPath = toWatch.dirPath, nonRecursive = toWatch.nonRecursive;
                    // If the failed lookup location path is not one of the supported extensions,
                    // store it in the custom path
                    if (!isPathWithDefaultFailedLookupExtension(failedLookupLocationPath)) {
                        var refCount = customFailedLookupPaths.get(failedLookupLocationPath) || 0;
                        customFailedLookupPaths.set(failedLookupLocationPath, refCount + 1);
                    }
                    if (dirPath === rootPath) {
                        ts.Debug.assert(!nonRecursive);
                        setAtRoot = true;
                    }
                    else {
                        setDirectoryWatcher(dir, dirPath, nonRecursive);
                    }
                }
            }
            if (setAtRoot) {
                // This is always non recursive
                setDirectoryWatcher(rootDir, rootPath, /*nonRecursive*/ true); // TODO: GH#18217
            }
        }
        function watchFailedLookupLocationOfNonRelativeModuleResolutions(resolutions, name) {
            var program = resolutionHost.getCurrentProgram();
            if (!program || !program.getTypeChecker().tryFindAmbientModuleWithoutAugmentations(name)) {
                resolutions.forEach(watchFailedLookupLocationOfResolution);
            }
        }
        function setDirectoryWatcher(dir, dirPath, nonRecursive) {
            var dirWatcher = directoryWatchesOfFailedLookups.get(dirPath);
            if (dirWatcher) {
                ts.Debug.assert(!!nonRecursive === !!dirWatcher.nonRecursive);
                dirWatcher.refCount++;
            }
            else {
                directoryWatchesOfFailedLookups.set(dirPath, { watcher: createDirectoryWatcher(dir, dirPath, nonRecursive), refCount: 1, nonRecursive: nonRecursive });
            }
        }
        function stopWatchFailedLookupLocationOfResolution(resolution, filePath, getResolutionWithResolvedFileName) {
            ts.unorderedRemoveItem(ts.Debug.checkDefined(resolution.files), filePath);
            resolution.refCount--;
            if (resolution.refCount) {
                return;
            }
            var resolved = getResolutionWithResolvedFileName(resolution);
            if (resolved && resolved.resolvedFileName) {
                resolvedFileToResolution.remove(resolutionHost.toPath(resolved.resolvedFileName), resolution);
            }
            if (!ts.unorderedRemoveItem(resolutionsWithFailedLookups, resolution)) {
                // If not watching failed lookups, it wont be there in resolutionsWithFailedLookups
                return;
            }
            var failedLookupLocations = resolution.failedLookupLocations;
            var removeAtRoot = false;
            for (var _i = 0, failedLookupLocations_2 = failedLookupLocations; _i < failedLookupLocations_2.length; _i++) {
                var failedLookupLocation = failedLookupLocations_2[_i];
                var failedLookupLocationPath = resolutionHost.toPath(failedLookupLocation);
                var toWatch = getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath);
                if (toWatch) {
                    var dirPath = toWatch.dirPath;
                    var refCount = customFailedLookupPaths.get(failedLookupLocationPath);
                    if (refCount) {
                        if (refCount === 1) {
                            customFailedLookupPaths.delete(failedLookupLocationPath);
                        }
                        else {
                            ts.Debug.assert(refCount > 1);
                            customFailedLookupPaths.set(failedLookupLocationPath, refCount - 1);
                        }
                    }
                    if (dirPath === rootPath) {
                        removeAtRoot = true;
                    }
                    else {
                        removeDirectoryWatcher(dirPath);
                    }
                }
            }
            if (removeAtRoot) {
                removeDirectoryWatcher(rootPath);
            }
        }
        function removeDirectoryWatcher(dirPath) {
            var dirWatcher = directoryWatchesOfFailedLookups.get(dirPath);
            // Do not close the watcher yet since it might be needed by other failed lookup locations.
            dirWatcher.refCount--;
        }
        function createDirectoryWatcher(directory, dirPath, nonRecursive) {
            return resolutionHost.watchDirectoryOfFailedLookupLocation(directory, function (fileOrDirectory) {
                var fileOrDirectoryPath = resolutionHost.toPath(fileOrDirectory);
                if (cachedDirectoryStructureHost) {
                    // Since the file existence changed, update the sourceFiles cache
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, dirPath === fileOrDirectoryPath);
            }, nonRecursive ? 0 /* WatchDirectoryFlags.None */ : 1 /* WatchDirectoryFlags.Recursive */);
        }
        function removeResolutionsOfFileFromCache(cache, filePath, getResolutionWithResolvedFileName) {
            // Deleted file, stop watching failed lookups for all the resolutions in the file
            var resolutions = cache.get(filePath);
            if (resolutions) {
                resolutions.forEach(function (resolution) { return stopWatchFailedLookupLocationOfResolution(resolution, filePath, getResolutionWithResolvedFileName); });
                cache.delete(filePath);
            }
        }
        function removeResolutionsFromProjectReferenceRedirects(filePath) {
            if (!ts.fileExtensionIs(filePath, ".json" /* Extension.Json */))
                return;
            var program = resolutionHost.getCurrentProgram();
            if (!program)
                return;
            // If this file is input file for the referenced project, get it
            var resolvedProjectReference = program.getResolvedProjectReferenceByPath(filePath);
            if (!resolvedProjectReference)
                return;
            // filePath is for the projectReference and the containing file is from this project reference, invalidate the resolution
            resolvedProjectReference.commandLine.fileNames.forEach(function (f) { return removeResolutionsOfFile(resolutionHost.toPath(f)); });
        }
        function removeResolutionsOfFile(filePath) {
            removeResolutionsOfFileFromCache(resolvedModuleNames, filePath, getResolvedModule);
            removeResolutionsOfFileFromCache(resolvedTypeReferenceDirectives, filePath, getResolvedTypeReferenceDirective);
        }
        function invalidateResolutions(resolutions, canInvalidate) {
            if (!resolutions)
                return false;
            var invalidated = false;
            for (var _i = 0, resolutions_1 = resolutions; _i < resolutions_1.length; _i++) {
                var resolution = resolutions_1[_i];
                if (resolution.isInvalidated || !canInvalidate(resolution))
                    continue;
                resolution.isInvalidated = invalidated = true;
                for (var _a = 0, _b = ts.Debug.checkDefined(resolution.files); _a < _b.length; _a++) {
                    var containingFilePath = _b[_a];
                    (filesWithInvalidatedResolutions || (filesWithInvalidatedResolutions = new ts.Set())).add(containingFilePath);
                    // When its a file with inferred types resolution, invalidate type reference directive resolution
                    hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames || ts.endsWith(containingFilePath, ts.inferredTypesContainingFile);
                }
            }
            return invalidated;
        }
        function invalidateResolutionOfFile(filePath) {
            removeResolutionsOfFile(filePath);
            // Resolution is invalidated if the resulting file name is same as the deleted file path
            var prevHasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            if (invalidateResolutions(resolvedFileToResolution.get(filePath), ts.returnTrue) &&
                hasChangedAutomaticTypeDirectiveNames &&
                !prevHasChangedAutomaticTypeDirectiveNames) {
                resolutionHost.onChangedAutomaticTypeDirectiveNames();
            }
        }
        function setFilesWithInvalidatedNonRelativeUnresolvedImports(filesMap) {
            ts.Debug.assert(filesWithInvalidatedNonRelativeUnresolvedImports === filesMap || filesWithInvalidatedNonRelativeUnresolvedImports === undefined);
            filesWithInvalidatedNonRelativeUnresolvedImports = filesMap;
        }
        function scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, isCreatingWatchedDirectory) {
            if (isCreatingWatchedDirectory) {
                // Watching directory is created
                // Invalidate any resolution has failed lookup in this directory
                (isInDirectoryChecks || (isInDirectoryChecks = [])).push(fileOrDirectoryPath);
            }
            else {
                // If something to do with folder/file starting with "." in node_modules folder, skip it
                var updatedPath = removeIgnoredPath(fileOrDirectoryPath);
                if (!updatedPath)
                    return false;
                fileOrDirectoryPath = updatedPath;
                // prevent saving an open file from over-eagerly triggering invalidation
                if (resolutionHost.fileIsOpen(fileOrDirectoryPath)) {
                    return false;
                }
                // Some file or directory in the watching directory is created
                // Return early if it does not have any of the watching extension or not the custom failed lookup path
                var dirOfFileOrDirectory = ts.getDirectoryPath(fileOrDirectoryPath);
                if (isNodeModulesAtTypesDirectory(fileOrDirectoryPath) || ts.isNodeModulesDirectory(fileOrDirectoryPath) ||
                    isNodeModulesAtTypesDirectory(dirOfFileOrDirectory) || ts.isNodeModulesDirectory(dirOfFileOrDirectory)) {
                    // Invalidate any resolution from this directory
                    (failedLookupChecks || (failedLookupChecks = [])).push(fileOrDirectoryPath);
                    (startsWithPathChecks || (startsWithPathChecks = new ts.Set())).add(fileOrDirectoryPath);
                }
                else {
                    if (!isPathWithDefaultFailedLookupExtension(fileOrDirectoryPath) && !customFailedLookupPaths.has(fileOrDirectoryPath)) {
                        return false;
                    }
                    // Ignore emits from the program
                    if (ts.isEmittedFileOfProgram(resolutionHost.getCurrentProgram(), fileOrDirectoryPath)) {
                        return false;
                    }
                    // Resolution need to be invalidated if failed lookup location is same as the file or directory getting created
                    (failedLookupChecks || (failedLookupChecks = [])).push(fileOrDirectoryPath);
                    // If the invalidated file is from a node_modules package, invalidate everything else
                    // in the package since we might not get notifications for other files in the package.
                    // This hardens our logic against unreliable file watchers.
                    var packagePath = ts.parseNodeModuleFromPath(fileOrDirectoryPath);
                    if (packagePath)
                        (startsWithPathChecks || (startsWithPathChecks = new ts.Set())).add(packagePath);
                }
            }
            resolutionHost.scheduleInvalidateResolutionsOfFailedLookupLocations();
        }
        function invalidateResolutionsOfFailedLookupLocations() {
            if (!failedLookupChecks && !startsWithPathChecks && !isInDirectoryChecks) {
                return false;
            }
            var invalidated = invalidateResolutions(resolutionsWithFailedLookups, canInvalidateFailedLookupResolution);
            failedLookupChecks = undefined;
            startsWithPathChecks = undefined;
            isInDirectoryChecks = undefined;
            return invalidated;
        }
        function canInvalidateFailedLookupResolution(resolution) {
            return resolution.failedLookupLocations.some(function (location) {
                var locationPath = resolutionHost.toPath(location);
                return ts.contains(failedLookupChecks, locationPath) ||
                    ts.firstDefinedIterator((startsWithPathChecks === null || startsWithPathChecks === void 0 ? void 0 : startsWithPathChecks.keys()) || ts.emptyIterator, function (fileOrDirectoryPath) { return ts.startsWith(locationPath, fileOrDirectoryPath) ? true : undefined; }) ||
                    (isInDirectoryChecks === null || isInDirectoryChecks === void 0 ? void 0 : isInDirectoryChecks.some(function (fileOrDirectoryPath) { return isInDirectoryPath(fileOrDirectoryPath, locationPath); }));
            });
        }
        function closeTypeRootsWatch() {
            ts.clearMap(typeRootsWatches, ts.closeFileWatcher);
        }
        function getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot, typeRootPath) {
            if (isInDirectoryPath(rootPath, typeRootPath)) {
                return rootPath;
            }
            var toWatch = getDirectoryToWatchFromFailedLookupLocationDirectory(typeRoot, typeRootPath);
            return toWatch && directoryWatchesOfFailedLookups.has(toWatch.dirPath) ? toWatch.dirPath : undefined;
        }
        function createTypeRootsWatch(typeRootPath, typeRoot) {
            // Create new watch and recursive info
            return resolutionHost.watchTypeRootsDirectory(typeRoot, function (fileOrDirectory) {
                var fileOrDirectoryPath = resolutionHost.toPath(fileOrDirectory);
                if (cachedDirectoryStructureHost) {
                    // Since the file existence changed, update the sourceFiles cache
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                // For now just recompile
                // We could potentially store more data here about whether it was/would be really be used or not
                // and with that determine to trigger compilation but for now this is enough
                hasChangedAutomaticTypeDirectiveNames = true;
                resolutionHost.onChangedAutomaticTypeDirectiveNames();
                // Since directory watchers invoked are flaky, the failed lookup location events might not be triggered
                // So handle to failed lookup locations here as well to ensure we are invalidating resolutions
                var dirPath = getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot, typeRootPath);
                if (dirPath) {
                    scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, dirPath === fileOrDirectoryPath);
                }
            }, 1 /* WatchDirectoryFlags.Recursive */);
        }
        /**
         * Watches the types that would get added as part of getAutomaticTypeDirectiveNames
         * To be called when compiler options change
         */
        function updateTypeRootsWatch() {
            var options = resolutionHost.getCompilationSettings();
            if (options.types) {
                // No need to do any watch since resolution cache is going to handle the failed lookups
                // for the types added by this
                closeTypeRootsWatch();
                return;
            }
            // we need to assume the directories exist to ensure that we can get all the type root directories that get included
            // But filter directories that are at root level to say directory doesnt exist, so that we arent watching them
            var typeRoots = ts.getEffectiveTypeRoots(options, { directoryExists: directoryExistsForTypeRootWatch, getCurrentDirectory: getCurrentDirectory });
            if (typeRoots) {
                ts.mutateMap(typeRootsWatches, ts.arrayToMap(typeRoots, function (tr) { return resolutionHost.toPath(tr); }), {
                    createNewValue: createTypeRootsWatch,
                    onDeleteValue: ts.closeFileWatcher
                });
            }
            else {
                closeTypeRootsWatch();
            }
        }
        /**
         * Use this function to return if directory exists to get type roots to watch
         * If we return directory exists then only the paths will be added to type roots
         * Hence return true for all directories except root directories which are filtered from watching
         */
        function directoryExistsForTypeRootWatch(nodeTypesDirectory) {
            var dir = ts.getDirectoryPath(ts.getDirectoryPath(nodeTypesDirectory));
            var dirPath = resolutionHost.toPath(dir);
            return dirPath === rootPath || canWatchDirectory(dirPath);
        }
    }
    ts.createResolutionCache = createResolutionCache;
    function resolutionIsSymlink(resolution) {
        var _a, _b;
        return !!(((_a = resolution.resolvedModule) === null || _a === void 0 ? void 0 : _a.originalPath) ||
            ((_b = resolution.resolvedTypeReferenceDirective) === null || _b === void 0 ? void 0 : _b.originalPath));
    }
})(ts || (ts = {}));
// Used by importFixes, getEditsForFileRename, and declaration emit to synthesize import module specifiers.
/* @internal */
var ts;
(function (ts) {
    var moduleSpecifiers;
    (function (moduleSpecifiers_1) {
        var RelativePreference;
        (function (RelativePreference) {
            RelativePreference[RelativePreference["Relative"] = 0] = "Relative";
            RelativePreference[RelativePreference["NonRelative"] = 1] = "NonRelative";
            RelativePreference[RelativePreference["Shortest"] = 2] = "Shortest";
            RelativePreference[RelativePreference["ExternalNonRelative"] = 3] = "ExternalNonRelative";
        })(RelativePreference || (RelativePreference = {}));
        // See UserPreferences#importPathEnding
        var Ending;
        (function (Ending) {
            Ending[Ending["Minimal"] = 0] = "Minimal";
            Ending[Ending["Index"] = 1] = "Index";
            Ending[Ending["JsExtension"] = 2] = "JsExtension";
        })(Ending || (Ending = {}));
        function getPreferences(host, _a, compilerOptions, importingSourceFile) {
            var importModuleSpecifierPreference = _a.importModuleSpecifierPreference, importModuleSpecifierEnding = _a.importModuleSpecifierEnding;
            return {
                relativePreference: importModuleSpecifierPreference === "relative" ? 0 /* RelativePreference.Relative */ :
                    importModuleSpecifierPreference === "non-relative" ? 1 /* RelativePreference.NonRelative */ :
                        importModuleSpecifierPreference === "project-relative" ? 3 /* RelativePreference.ExternalNonRelative */ :
                            2 /* RelativePreference.Shortest */,
                ending: getEnding(),
            };
            function getEnding() {
                switch (importModuleSpecifierEnding) {
                    case "minimal": return 0 /* Ending.Minimal */;
                    case "index": return 1 /* Ending.Index */;
                    case "js": return 2 /* Ending.JsExtension */;
                    default: return usesJsExtensionOnImports(importingSourceFile) || isFormatRequiringExtensions(compilerOptions, importingSourceFile.path, host) ? 2 /* Ending.JsExtension */
                        : ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeJs ? 1 /* Ending.Index */ : 0 /* Ending.Minimal */;
                }
            }
        }
        function getPreferencesForUpdate(compilerOptions, oldImportSpecifier, importingSourceFileName, host) {
            return {
                relativePreference: ts.isExternalModuleNameRelative(oldImportSpecifier) ? 0 /* RelativePreference.Relative */ : 1 /* RelativePreference.NonRelative */,
                ending: ts.hasJSFileExtension(oldImportSpecifier) || isFormatRequiringExtensions(compilerOptions, importingSourceFileName, host) ?
                    2 /* Ending.JsExtension */ :
                    ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeJs || ts.endsWith(oldImportSpecifier, "index") ? 1 /* Ending.Index */ : 0 /* Ending.Minimal */,
            };
        }
        function isFormatRequiringExtensions(compilerOptions, importingSourceFileName, host) {
            var _a;
            if (ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.Node16
                && ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeNext) {
                return false;
            }
            return ts.getImpliedNodeFormatForFile(importingSourceFileName, (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host), getModuleResolutionHost(host), compilerOptions) !== ts.ModuleKind.CommonJS;
        }
        function getModuleResolutionHost(host) {
            var _a;
            return {
                fileExists: host.fileExists,
                readFile: ts.Debug.checkDefined(host.readFile),
                directoryExists: host.directoryExists,
                getCurrentDirectory: host.getCurrentDirectory,
                realpath: host.realpath,
                useCaseSensitiveFileNames: (_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host),
            };
        }
        // `importingSourceFile` and `importingSourceFileName`? Why not just use `importingSourceFile.path`?
        // Because when this is called by the file renamer, `importingSourceFile` is the file being renamed,
        // while `importingSourceFileName` its *new* name. We need a source file just to get its
        // `impliedNodeFormat` and to detect certain preferences from existing import module specifiers.
        function updateModuleSpecifier(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, oldImportSpecifier, options) {
            if (options === void 0) { options = {}; }
            var res = getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, getPreferencesForUpdate(compilerOptions, oldImportSpecifier, importingSourceFileName, host), {}, options);
            if (res === oldImportSpecifier)
                return undefined;
            return res;
        }
        moduleSpecifiers_1.updateModuleSpecifier = updateModuleSpecifier;
        // `importingSourceFile` and `importingSourceFileName`? Why not just use `importingSourceFile.path`?
        // Because when this is called by the declaration emitter, `importingSourceFile` is the implementation
        // file, but `importingSourceFileName` and `toFileName` refer to declaration files (the former to the
        // one currently being produced; the latter to the one being imported). We need an implementation file
        // just to get its `impliedNodeFormat` and to detect certain preferences from existing import module
        // specifiers.
        function getModuleSpecifier(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) {
            if (options === void 0) { options = {}; }
            return getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, getPreferences(host, {}, compilerOptions, importingSourceFile), {}, options);
        }
        moduleSpecifiers_1.getModuleSpecifier = getModuleSpecifier;
        function getNodeModulesPackageName(compilerOptions, importingSourceFile, nodeModulesFileName, host, preferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFile.path, host);
            var modulePaths = getAllModulePaths(importingSourceFile.path, nodeModulesFileName, host, preferences, options);
            return ts.firstDefined(modulePaths, function (modulePath) { return tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, preferences, /*packageNameOnly*/ true, options.overrideImportMode); });
        }
        moduleSpecifiers_1.getNodeModulesPackageName = getNodeModulesPackageName;
        function getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, preferences, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFileName, host);
            var modulePaths = getAllModulePaths(importingSourceFileName, toFileName, host, userPreferences, options);
            return ts.firstDefined(modulePaths, function (modulePath) { return tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, userPreferences, /*packageNameOnly*/ undefined, options.overrideImportMode); }) ||
                getLocalModuleSpecifier(toFileName, info, compilerOptions, host, preferences);
        }
        function tryGetModuleSpecifiersFromCache(moduleSymbol, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            return tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options)[0];
        }
        moduleSpecifiers_1.tryGetModuleSpecifiersFromCache = tryGetModuleSpecifiersFromCache;
        function tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options) {
            var _a;
            if (options === void 0) { options = {}; }
            var moduleSourceFile = ts.getSourceFileOfModule(moduleSymbol);
            if (!moduleSourceFile) {
                return ts.emptyArray;
            }
            var cache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            var cached = cache === null || cache === void 0 ? void 0 : cache.get(importingSourceFile.path, moduleSourceFile.path, userPreferences, options);
            return [cached === null || cached === void 0 ? void 0 : cached.moduleSpecifiers, moduleSourceFile, cached === null || cached === void 0 ? void 0 : cached.modulePaths, cache];
        }
        /** Returns an import for each symlink and for the realpath. */
        function getModuleSpecifiers(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            return getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options).moduleSpecifiers;
        }
        moduleSpecifiers_1.getModuleSpecifiers = getModuleSpecifiers;
        function getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var computedWithoutCache = false;
            var ambient = tryGetModuleNameFromAmbientModule(moduleSymbol, checker);
            if (ambient)
                return { moduleSpecifiers: [ambient], computedWithoutCache: computedWithoutCache };
            // eslint-disable-next-line prefer-const
            var _a = tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options), specifiers = _a[0], moduleSourceFile = _a[1], modulePaths = _a[2], cache = _a[3];
            if (specifiers)
                return { moduleSpecifiers: specifiers, computedWithoutCache: computedWithoutCache };
            if (!moduleSourceFile)
                return { moduleSpecifiers: ts.emptyArray, computedWithoutCache: computedWithoutCache };
            computedWithoutCache = true;
            modulePaths || (modulePaths = getAllModulePathsWorker(importingSourceFile.path, moduleSourceFile.originalFileName, host));
            var result = computeModuleSpecifiers(modulePaths, compilerOptions, importingSourceFile, host, userPreferences, options);
            cache === null || cache === void 0 ? void 0 : cache.set(importingSourceFile.path, moduleSourceFile.path, userPreferences, options, modulePaths, result);
            return { moduleSpecifiers: result, computedWithoutCache: computedWithoutCache };
        }
        moduleSpecifiers_1.getModuleSpecifiersWithCacheInfo = getModuleSpecifiersWithCacheInfo;
        function computeModuleSpecifiers(modulePaths, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFile.path, host);
            var preferences = getPreferences(host, userPreferences, compilerOptions, importingSourceFile);
            var existingSpecifier = ts.forEach(modulePaths, function (modulePath) { return ts.forEach(host.getFileIncludeReasons().get(ts.toPath(modulePath.path, host.getCurrentDirectory(), info.getCanonicalFileName)), function (reason) {
                if (reason.kind !== ts.FileIncludeKind.Import || reason.file !== importingSourceFile.path)
                    return undefined;
                // If the candidate import mode doesn't match the mode we're generating for, don't consider it
                // TODO: maybe useful to keep around as an alternative option for certain contexts where the mode is overridable
                if (importingSourceFile.impliedNodeFormat && importingSourceFile.impliedNodeFormat !== ts.getModeForResolutionAtIndex(importingSourceFile, reason.index))
                    return undefined;
                var specifier = ts.getModuleNameStringLiteralAt(importingSourceFile, reason.index).text;
                // If the preference is for non relative and the module specifier is relative, ignore it
                return preferences.relativePreference !== 1 /* RelativePreference.NonRelative */ || !ts.pathIsRelative(specifier) ?
                    specifier :
                    undefined;
            }); });
            if (existingSpecifier) {
                var moduleSpecifiers_2 = [existingSpecifier];
                return moduleSpecifiers_2;
            }
            var importedFileIsInNodeModules = ts.some(modulePaths, function (p) { return p.isInNodeModules; });
            // Module specifier priority:
            //   1. "Bare package specifiers" (e.g. "@foo/bar") resulting from a path through node_modules to a package.json's "types" entry
            //   2. Specifiers generated using "paths" from tsconfig
            //   3. Non-relative specfiers resulting from a path through node_modules (e.g. "@foo/bar/path/to/file")
            //   4. Relative paths
            var nodeModulesSpecifiers;
            var pathsSpecifiers;
            var relativeSpecifiers;
            for (var _i = 0, modulePaths_1 = modulePaths; _i < modulePaths_1.length; _i++) {
                var modulePath = modulePaths_1[_i];
                var specifier = tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, userPreferences, /*packageNameOnly*/ undefined, options.overrideImportMode);
                nodeModulesSpecifiers = ts.append(nodeModulesSpecifiers, specifier);
                if (specifier && modulePath.isRedirect) {
                    // If we got a specifier for a redirect, it was a bare package specifier (e.g. "@foo/bar",
                    // not "@foo/bar/path/to/file"). No other specifier will be this good, so stop looking.
                    return nodeModulesSpecifiers;
                }
                if (!specifier && !modulePath.isRedirect) {
                    var local = getLocalModuleSpecifier(modulePath.path, info, compilerOptions, host, preferences);
                    if (ts.pathIsBareSpecifier(local)) {
                        pathsSpecifiers = ts.append(pathsSpecifiers, local);
                    }
                    else if (!importedFileIsInNodeModules || modulePath.isInNodeModules) {
                        // Why this extra conditional, not just an `else`? If some path to the file contained
                        // 'node_modules', but we can't create a non-relative specifier (e.g. "@foo/bar/path/to/file"),
                        // that means we had to go through a *sibling's* node_modules, not one we can access directly.
                        // If some path to the file was in node_modules but another was not, this likely indicates that
                        // we have a monorepo structure with symlinks. In this case, the non-node_modules path is
                        // probably the realpath, e.g. "../bar/path/to/file", but a relative path to another package
                        // in a monorepo is probably not portable. So, the module specifier we actually go with will be
                        // the relative path through node_modules, so that the declaration emitter can produce a
                        // portability error. (See declarationEmitReexportedSymlinkReference3)
                        relativeSpecifiers = ts.append(relativeSpecifiers, local);
                    }
                }
            }
            return (pathsSpecifiers === null || pathsSpecifiers === void 0 ? void 0 : pathsSpecifiers.length) ? pathsSpecifiers :
                (nodeModulesSpecifiers === null || nodeModulesSpecifiers === void 0 ? void 0 : nodeModulesSpecifiers.length) ? nodeModulesSpecifiers :
                    ts.Debug.checkDefined(relativeSpecifiers);
        }
        // importingSourceFileName is separate because getEditsForFileRename may need to specify an updated path
        function getInfo(importingSourceFileName, host) {
            var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames ? host.useCaseSensitiveFileNames() : true);
            var sourceDirectory = ts.getDirectoryPath(importingSourceFileName);
            return { getCanonicalFileName: getCanonicalFileName, importingSourceFileName: importingSourceFileName, sourceDirectory: sourceDirectory };
        }
        function getLocalModuleSpecifier(moduleFileName, info, compilerOptions, host, _a) {
            var ending = _a.ending, relativePreference = _a.relativePreference;
            var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths, rootDirs = compilerOptions.rootDirs;
            var sourceDirectory = info.sourceDirectory, getCanonicalFileName = info.getCanonicalFileName;
            var relativePath = rootDirs && tryGetModuleNameFromRootDirs(rootDirs, moduleFileName, sourceDirectory, getCanonicalFileName, ending, compilerOptions) ||
                removeExtensionAndIndexPostFix(ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(sourceDirectory, moduleFileName, getCanonicalFileName)), ending, compilerOptions);
            if (!baseUrl && !paths || relativePreference === 0 /* RelativePreference.Relative */) {
                return relativePath;
            }
            var baseDirectory = ts.getNormalizedAbsolutePath(ts.getPathsBasePath(compilerOptions, host) || baseUrl, host.getCurrentDirectory());
            var relativeToBaseUrl = getRelativePathIfInDirectory(moduleFileName, baseDirectory, getCanonicalFileName);
            if (!relativeToBaseUrl) {
                return relativePath;
            }
            var importRelativeToBaseUrl = removeExtensionAndIndexPostFix(relativeToBaseUrl, ending, compilerOptions);
            var fromPaths = paths && tryGetModuleNameFromPaths(ts.removeFileExtension(relativeToBaseUrl), importRelativeToBaseUrl, paths);
            var nonRelative = fromPaths === undefined && baseUrl !== undefined ? importRelativeToBaseUrl : fromPaths;
            if (!nonRelative) {
                return relativePath;
            }
            if (relativePreference === 1 /* RelativePreference.NonRelative */) {
                return nonRelative;
            }
            if (relativePreference === 3 /* RelativePreference.ExternalNonRelative */) {
                var projectDirectory = compilerOptions.configFilePath ?
                    ts.toPath(ts.getDirectoryPath(compilerOptions.configFilePath), host.getCurrentDirectory(), info.getCanonicalFileName) :
                    info.getCanonicalFileName(host.getCurrentDirectory());
                var modulePath = ts.toPath(moduleFileName, projectDirectory, getCanonicalFileName);
                var sourceIsInternal = ts.startsWith(sourceDirectory, projectDirectory);
                var targetIsInternal = ts.startsWith(modulePath, projectDirectory);
                if (sourceIsInternal && !targetIsInternal || !sourceIsInternal && targetIsInternal) {
                    // 1. The import path crosses the boundary of the tsconfig.json-containing directory.
                    //
                    //      src/
                    //        tsconfig.json
                    //        index.ts -------
                    //      lib/              | (path crosses tsconfig.json)
                    //        imported.ts <---
                    //
                    return nonRelative;
                }
                var nearestTargetPackageJson = getNearestAncestorDirectoryWithPackageJson(host, ts.getDirectoryPath(modulePath));
                var nearestSourcePackageJson = getNearestAncestorDirectoryWithPackageJson(host, sourceDirectory);
                if (nearestSourcePackageJson !== nearestTargetPackageJson) {
                    // 2. The importing and imported files are part of different packages.
                    //
                    //      packages/a/
                    //        package.json
                    //        index.ts --------
                    //      packages/b/        | (path crosses package.json)
                    //        package.json     |
                    //        component.ts <---
                    //
                    return nonRelative;
                }
                return relativePath;
            }
            if (relativePreference !== 2 /* RelativePreference.Shortest */)
                ts.Debug.assertNever(relativePreference);
            // Prefer a relative import over a baseUrl import if it has fewer components.
            return isPathRelativeToParent(nonRelative) || countPathComponents(relativePath) < countPathComponents(nonRelative) ? relativePath : nonRelative;
        }
        function countPathComponents(path) {
            var count = 0;
            for (var i = ts.startsWith(path, "./") ? 2 : 0; i < path.length; i++) {
                if (path.charCodeAt(i) === 47 /* CharacterCodes.slash */)
                    count++;
            }
            return count;
        }
        moduleSpecifiers_1.countPathComponents = countPathComponents;
        function usesJsExtensionOnImports(_a) {
            var imports = _a.imports;
            return ts.firstDefined(imports, function (_a) {
                var text = _a.text;
                return ts.pathIsRelative(text) ? ts.hasJSFileExtension(text) : undefined;
            }) || false;
        }
        function comparePathsByRedirectAndNumberOfDirectorySeparators(a, b) {
            return ts.compareBooleans(b.isRedirect, a.isRedirect) || ts.compareNumberOfDirectorySeparators(a.path, b.path);
        }
        function getNearestAncestorDirectoryWithPackageJson(host, fileName) {
            if (host.getNearestAncestorDirectoryWithPackageJson) {
                return host.getNearestAncestorDirectoryWithPackageJson(fileName);
            }
            return !!ts.forEachAncestorDirectory(fileName, function (directory) {
                return host.fileExists(ts.combinePaths(directory, "package.json")) ? true : undefined;
            });
        }
        function forEachFileNameOfModule(importingFileName, importedFileName, host, preferSymlinks, cb) {
            var _a;
            var getCanonicalFileName = ts.hostGetCanonicalFileName(host);
            var cwd = host.getCurrentDirectory();
            var referenceRedirect = host.isSourceOfProjectReferenceRedirect(importedFileName) ? host.getProjectReferenceRedirect(importedFileName) : undefined;
            var importedPath = ts.toPath(importedFileName, cwd, getCanonicalFileName);
            var redirects = host.redirectTargetsMap.get(importedPath) || ts.emptyArray;
            var importedFileNames = __spreadArray(__spreadArray(__spreadArray([], (referenceRedirect ? [referenceRedirect] : ts.emptyArray), true), [importedFileName], false), redirects, true);
            var targets = importedFileNames.map(function (f) { return ts.getNormalizedAbsolutePath(f, cwd); });
            var shouldFilterIgnoredPaths = !ts.every(targets, ts.containsIgnoredPath);
            if (!preferSymlinks) {
                // Symlinks inside ignored paths are already filtered out of the symlink cache,
                // so we only need to remove them from the realpath filenames.
                var result_15 = ts.forEach(targets, function (p) { return !(shouldFilterIgnoredPaths && ts.containsIgnoredPath(p)) && cb(p, referenceRedirect === p); });
                if (result_15)
                    return result_15;
            }
            var symlinkedDirectories = (_a = host.getSymlinkCache) === null || _a === void 0 ? void 0 : _a.call(host).getSymlinkedDirectoriesByRealpath();
            var fullImportedFileName = ts.getNormalizedAbsolutePath(importedFileName, cwd);
            var result = symlinkedDirectories && ts.forEachAncestorDirectory(ts.getDirectoryPath(fullImportedFileName), function (realPathDirectory) {
                var symlinkDirectories = symlinkedDirectories.get(ts.ensureTrailingDirectorySeparator(ts.toPath(realPathDirectory, cwd, getCanonicalFileName)));
                if (!symlinkDirectories)
                    return undefined; // Continue to ancestor directory
                // Don't want to a package to globally import from itself (importNameCodeFix_symlink_own_package.ts)
                if (ts.startsWithDirectory(importingFileName, realPathDirectory, getCanonicalFileName)) {
                    return false; // Stop search, each ancestor directory will also hit this condition
                }
                return ts.forEach(targets, function (target) {
                    if (!ts.startsWithDirectory(target, realPathDirectory, getCanonicalFileName)) {
                        return;
                    }
                    var relative = ts.getRelativePathFromDirectory(realPathDirectory, target, getCanonicalFileName);
                    for (var _i = 0, symlinkDirectories_1 = symlinkDirectories; _i < symlinkDirectories_1.length; _i++) {
                        var symlinkDirectory = symlinkDirectories_1[_i];
                        var option = ts.resolvePath(symlinkDirectory, relative);
                        var result_16 = cb(option, target === referenceRedirect);
                        shouldFilterIgnoredPaths = true; // We found a non-ignored path in symlinks, so we can reject ignored-path realpaths
                        if (result_16)
                            return result_16;
                    }
                });
            });
            return result || (preferSymlinks
                ? ts.forEach(targets, function (p) { return shouldFilterIgnoredPaths && ts.containsIgnoredPath(p) ? undefined : cb(p, p === referenceRedirect); })
                : undefined);
        }
        moduleSpecifiers_1.forEachFileNameOfModule = forEachFileNameOfModule;
        /**
         * Looks for existing imports that use symlinks to this module.
         * Symlinks will be returned first so they are preferred over the real path.
         */
        function getAllModulePaths(importingFilePath, importedFileName, host, preferences, options) {
            var _a;
            if (options === void 0) { options = {}; }
            var importedFilePath = ts.toPath(importedFileName, host.getCurrentDirectory(), ts.hostGetCanonicalFileName(host));
            var cache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            if (cache) {
                var cached = cache.get(importingFilePath, importedFilePath, preferences, options);
                if (cached === null || cached === void 0 ? void 0 : cached.modulePaths)
                    return cached.modulePaths;
            }
            var modulePaths = getAllModulePathsWorker(importingFilePath, importedFileName, host);
            if (cache) {
                cache.setModulePaths(importingFilePath, importedFilePath, preferences, options, modulePaths);
            }
            return modulePaths;
        }
        function getAllModulePathsWorker(importingFileName, importedFileName, host) {
            var getCanonicalFileName = ts.hostGetCanonicalFileName(host);
            var allFileNames = new ts.Map();
            var importedFileFromNodeModules = false;
            forEachFileNameOfModule(importingFileName, importedFileName, host, 
            /*preferSymlinks*/ true, function (path, isRedirect) {
                var isInNodeModules = ts.pathContainsNodeModules(path);
                allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect: isRedirect, isInNodeModules: isInNodeModules });
                importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
                // don't return value, so we collect everything
            });
            // Sort by paths closest to importing file Name directory
            var sortedPaths = [];
            var _loop_32 = function (directory) {
                var directoryStart = ts.ensureTrailingDirectorySeparator(directory);
                var pathsInDirectory;
                allFileNames.forEach(function (_a, fileName) {
                    var path = _a.path, isRedirect = _a.isRedirect, isInNodeModules = _a.isInNodeModules;
                    if (ts.startsWith(path, directoryStart)) {
                        (pathsInDirectory || (pathsInDirectory = [])).push({ path: fileName, isRedirect: isRedirect, isInNodeModules: isInNodeModules });
                        allFileNames.delete(fileName);
                    }
                });
                if (pathsInDirectory) {
                    if (pathsInDirectory.length > 1) {
                        pathsInDirectory.sort(comparePathsByRedirectAndNumberOfDirectorySeparators);
                    }
                    sortedPaths.push.apply(sortedPaths, pathsInDirectory);
                }
                var newDirectory = ts.getDirectoryPath(directory);
                if (newDirectory === directory)
                    return out_directory_1 = directory, "break";
                directory = newDirectory;
                out_directory_1 = directory;
            };
            var out_directory_1;
            for (var directory = ts.getDirectoryPath(importingFileName); allFileNames.size !== 0;) {
                var state_10 = _loop_32(directory);
                directory = out_directory_1;
                if (state_10 === "break")
                    break;
            }
            if (allFileNames.size) {
                var remainingPaths = ts.arrayFrom(allFileNames.values());
                if (remainingPaths.length > 1)
                    remainingPaths.sort(comparePathsByRedirectAndNumberOfDirectorySeparators);
                sortedPaths.push.apply(sortedPaths, remainingPaths);
            }
            return sortedPaths;
        }
        function tryGetModuleNameFromAmbientModule(moduleSymbol, checker) {
            var _a;
            var decl = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return ts.isNonGlobalAmbientModule(d) && (!ts.isExternalModuleAugmentation(d) || !ts.isExternalModuleNameRelative(ts.getTextOfIdentifierOrLiteral(d.name))); });
            if (decl) {
                return decl.name.text;
            }
            // the module could be a namespace, which is export through "export=" from an ambient module.
            /**
             * declare module "m" {
             *     namespace ns {
             *         class c {}
             *     }
             *     export = ns;
             * }
             */
            // `import {c} from "m";` is valid, in which case, `moduleSymbol` is "ns", but the module name should be "m"
            var ambientModuleDeclareCandidates = ts.mapDefined(moduleSymbol.declarations, function (d) {
                var _a, _b, _c, _d;
                if (!ts.isModuleDeclaration(d))
                    return;
                var topNamespace = getTopNamespace(d);
                if (!(((_a = topNamespace === null || topNamespace === void 0 ? void 0 : topNamespace.parent) === null || _a === void 0 ? void 0 : _a.parent)
                    && ts.isModuleBlock(topNamespace.parent) && ts.isAmbientModule(topNamespace.parent.parent) && ts.isSourceFile(topNamespace.parent.parent.parent)))
                    return;
                var exportAssignment = (_d = (_c = (_b = topNamespace.parent.parent.symbol.exports) === null || _b === void 0 ? void 0 : _b.get("export=")) === null || _c === void 0 ? void 0 : _c.valueDeclaration) === null || _d === void 0 ? void 0 : _d.expression;
                if (!exportAssignment)
                    return;
                var exportSymbol = checker.getSymbolAtLocation(exportAssignment);
                if (!exportSymbol)
                    return;
                var originalExportSymbol = (exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.flags) & 2097152 /* SymbolFlags.Alias */ ? checker.getAliasedSymbol(exportSymbol) : exportSymbol;
                if (originalExportSymbol === d.symbol)
                    return topNamespace.parent.parent;
                function getTopNamespace(namespaceDeclaration) {
                    while (namespaceDeclaration.flags & 4 /* NodeFlags.NestedNamespace */) {
                        namespaceDeclaration = namespaceDeclaration.parent;
                    }
                    return namespaceDeclaration;
                }
            });
            var ambientModuleDeclare = ambientModuleDeclareCandidates[0];
            if (ambientModuleDeclare) {
                return ambientModuleDeclare.name.text;
            }
        }
        function tryGetModuleNameFromPaths(relativeToBaseUrlWithIndex, relativeToBaseUrl, paths) {
            for (var key in paths) {
                for (var _i = 0, _a = paths[key]; _i < _a.length; _i++) {
                    var patternText_1 = _a[_i];
                    var pattern = ts.removeFileExtension(ts.normalizePath(patternText_1));
                    var indexOfStar = pattern.indexOf("*");
                    if (indexOfStar !== -1) {
                        var prefix = pattern.substr(0, indexOfStar);
                        var suffix = pattern.substr(indexOfStar + 1);
                        if (relativeToBaseUrl.length >= prefix.length + suffix.length &&
                            ts.startsWith(relativeToBaseUrl, prefix) &&
                            ts.endsWith(relativeToBaseUrl, suffix) ||
                            !suffix && relativeToBaseUrl === ts.removeTrailingDirectorySeparator(prefix)) {
                            var matchedStar = relativeToBaseUrl.substr(prefix.length, relativeToBaseUrl.length - suffix.length - prefix.length);
                            return key.replace("*", matchedStar);
                        }
                    }
                    else if (pattern === relativeToBaseUrl || pattern === relativeToBaseUrlWithIndex) {
                        return key;
                    }
                }
            }
        }
        var MatchingMode;
        (function (MatchingMode) {
            MatchingMode[MatchingMode["Exact"] = 0] = "Exact";
            MatchingMode[MatchingMode["Directory"] = 1] = "Directory";
            MatchingMode[MatchingMode["Pattern"] = 2] = "Pattern";
        })(MatchingMode || (MatchingMode = {}));
        function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, exports, conditions, mode) {
            if (mode === void 0) { mode = 0 /* MatchingMode.Exact */; }
            if (typeof exports === "string") {
                var pathOrPattern = ts.getNormalizedAbsolutePath(ts.combinePaths(packageDirectory, exports), /*currentDirectory*/ undefined);
                var extensionSwappedTarget = ts.hasTSFileExtension(targetFilePath) ? ts.removeFileExtension(targetFilePath) + tryGetJSExtensionForFile(targetFilePath, options) : undefined;
                switch (mode) {
                    case 0 /* MatchingMode.Exact */:
                        if (ts.comparePaths(targetFilePath, pathOrPattern) === 0 /* Comparison.EqualTo */ || (extensionSwappedTarget && ts.comparePaths(extensionSwappedTarget, pathOrPattern) === 0 /* Comparison.EqualTo */)) {
                            return { moduleFileToTry: packageName };
                        }
                        break;
                    case 1 /* MatchingMode.Directory */:
                        if (ts.containsPath(pathOrPattern, targetFilePath)) {
                            var fragment = ts.getRelativePathFromDirectory(pathOrPattern, targetFilePath, /*ignoreCase*/ false);
                            return { moduleFileToTry: ts.getNormalizedAbsolutePath(ts.combinePaths(ts.combinePaths(packageName, exports), fragment), /*currentDirectory*/ undefined) };
                        }
                        break;
                    case 2 /* MatchingMode.Pattern */:
                        var starPos = pathOrPattern.indexOf("*");
                        var leadingSlice = pathOrPattern.slice(0, starPos);
                        var trailingSlice = pathOrPattern.slice(starPos + 1);
                        if (ts.startsWith(targetFilePath, leadingSlice) && ts.endsWith(targetFilePath, trailingSlice)) {
                            var starReplacement = targetFilePath.slice(leadingSlice.length, targetFilePath.length - trailingSlice.length);
                            return { moduleFileToTry: packageName.replace("*", starReplacement) };
                        }
                        if (extensionSwappedTarget && ts.startsWith(extensionSwappedTarget, leadingSlice) && ts.endsWith(extensionSwappedTarget, trailingSlice)) {
                            var starReplacement = extensionSwappedTarget.slice(leadingSlice.length, extensionSwappedTarget.length - trailingSlice.length);
                            return { moduleFileToTry: packageName.replace("*", starReplacement) };
                        }
                        break;
                }
            }
            else if (Array.isArray(exports)) {
                return ts.forEach(exports, function (e) { return tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, e, conditions); });
            }
            else if (typeof exports === "object" && exports !== null) { // eslint-disable-line no-null/no-null
                if (ts.allKeysStartWithDot(exports)) {
                    // sub-mappings
                    // 3 cases:
                    // * directory mappings (legacyish, key ends with / (technically allows index/extension resolution under cjs mode))
                    // * pattern mappings (contains a *)
                    // * exact mappings (no *, does not end with /)
                    return ts.forEach(ts.getOwnKeys(exports), function (k) {
                        var subPackageName = ts.getNormalizedAbsolutePath(ts.combinePaths(packageName, k), /*currentDirectory*/ undefined);
                        var mode = ts.endsWith(k, "/") ? 1 /* MatchingMode.Directory */
                            : ts.stringContains(k, "*") ? 2 /* MatchingMode.Pattern */
                                : 0 /* MatchingMode.Exact */;
                        return tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, subPackageName, exports[k], conditions, mode);
                    });
                }
                else {
                    // conditional mapping
                    for (var _i = 0, _a = ts.getOwnKeys(exports); _i < _a.length; _i++) {
                        var key = _a[_i];
                        if (key === "default" || conditions.indexOf(key) >= 0 || ts.isApplicableVersionedTypesKey(conditions, key)) {
                            var subTarget = exports[key];
                            var result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
            }
            return undefined;
        }
        function tryGetModuleNameFromRootDirs(rootDirs, moduleFileName, sourceDirectory, getCanonicalFileName, ending, compilerOptions) {
            var normalizedTargetPath = getPathRelativeToRootDirs(moduleFileName, rootDirs, getCanonicalFileName);
            if (normalizedTargetPath === undefined) {
                return undefined;
            }
            var normalizedSourcePath = getPathRelativeToRootDirs(sourceDirectory, rootDirs, getCanonicalFileName);
            var relativePath = normalizedSourcePath !== undefined ? ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(normalizedSourcePath, normalizedTargetPath, getCanonicalFileName)) : normalizedTargetPath;
            return ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs
                ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)
                : ts.removeFileExtension(relativePath);
        }
        function tryGetModuleNameAsNodeModule(_a, _b, importingSourceFile, host, options, userPreferences, packageNameOnly, overrideMode) {
            var path = _a.path, isRedirect = _a.isRedirect;
            var getCanonicalFileName = _b.getCanonicalFileName, sourceDirectory = _b.sourceDirectory;
            if (!host.fileExists || !host.readFile) {
                return undefined;
            }
            var parts = ts.getNodeModulePathParts(path);
            if (!parts) {
                return undefined;
            }
            // Simplify the full file path to something that can be resolved by Node.
            var moduleSpecifier = path;
            var isPackageRootPath = false;
            if (!packageNameOnly) {
                var preferences = getPreferences(host, userPreferences, options, importingSourceFile);
                var packageRootIndex = parts.packageRootIndex;
                var moduleFileName = void 0;
                while (true) {
                    // If the module could be imported by a directory name, use that directory's name
                    var _c = tryDirectoryWithPackageJson(packageRootIndex), moduleFileToTry = _c.moduleFileToTry, packageRootPath = _c.packageRootPath, blockedByExports = _c.blockedByExports, verbatimFromExports = _c.verbatimFromExports;
                    if (ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Classic) {
                        if (blockedByExports) {
                            return undefined; // File is under this package.json, but is not publicly exported - there's no way to name it via `node_modules` resolution
                        }
                        if (verbatimFromExports) {
                            return moduleFileToTry;
                        }
                    }
                    if (packageRootPath) {
                        moduleSpecifier = packageRootPath;
                        isPackageRootPath = true;
                        break;
                    }
                    if (!moduleFileName)
                        moduleFileName = moduleFileToTry;
                    // try with next level of directory
                    packageRootIndex = path.indexOf(ts.directorySeparator, packageRootIndex + 1);
                    if (packageRootIndex === -1) {
                        moduleSpecifier = removeExtensionAndIndexPostFix(moduleFileName, preferences.ending, options, host);
                        break;
                    }
                }
            }
            if (isRedirect && !isPackageRootPath) {
                return undefined;
            }
            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
            // Get a path that's relative to node_modules or the importing file's path
            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
                return undefined;
            }
            // If the module was found in @types, get the actual Node package name
            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
            // For classic resolution, only allow importing from node_modules/@types, not other node_modules
            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
            function tryDirectoryWithPackageJson(packageRootIndex) {
                var _a, _b;
                var packageRootPath = path.substring(0, packageRootIndex);
                var packageJsonPath = ts.combinePaths(packageRootPath, "package.json");
                var moduleFileToTry = path;
                var cachedPackageJson = (_b = (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host)) === null || _b === void 0 ? void 0 : _b.getPackageJsonInfo(packageJsonPath);
                if (typeof cachedPackageJson === "object" || cachedPackageJson === undefined && host.fileExists(packageJsonPath)) {
                    var packageJsonContent = (cachedPackageJson === null || cachedPackageJson === void 0 ? void 0 : cachedPackageJson.packageJsonContent) || JSON.parse(host.readFile(packageJsonPath));
                    if (ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.NodeNext) {
                        // `conditions` *could* be made to go against `importingSourceFile.impliedNodeFormat` if something wanted to generate
                        // an ImportEqualsDeclaration in an ESM-implied file or an ImportCall in a CJS-implied file. But since this function is
                        // usually called to conjure an import out of thin air, we don't have an existing usage to call `getModeForUsageAtIndex`
                        // with, so for now we just stick with the mode of the file.
                        var conditions = ["node", overrideMode || importingSourceFile.impliedNodeFormat === ts.ModuleKind.ESNext ? "import" : "require", "types"];
                        var fromExports = packageJsonContent.exports && typeof packageJsonContent.name === "string"
                            ? tryGetModuleNameFromExports(options, path, packageRootPath, ts.getPackageNameFromTypesPackageName(packageJsonContent.name), packageJsonContent.exports, conditions)
                            : undefined;
                        if (fromExports) {
                            var withJsExtension = !ts.hasTSFileExtension(fromExports.moduleFileToTry)
                                ? fromExports
                                : { moduleFileToTry: ts.removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
                            return __assign(__assign({}, withJsExtension), { verbatimFromExports: true });
                        }
                        if (packageJsonContent.exports) {
                            return { moduleFileToTry: path, blockedByExports: true };
                        }
                    }
                    var versionPaths = packageJsonContent.typesVersions
                        ? ts.getPackageJsonTypesVersionsPaths(packageJsonContent.typesVersions)
                        : undefined;
                    if (versionPaths) {
                        var subModuleName = path.slice(packageRootPath.length + 1);
                        var fromPaths = tryGetModuleNameFromPaths(ts.removeFileExtension(subModuleName), removeExtensionAndIndexPostFix(subModuleName, 0 /* Ending.Minimal */, options), versionPaths.paths);
                        if (fromPaths !== undefined) {
                            moduleFileToTry = ts.combinePaths(packageRootPath, fromPaths);
                        }
                    }
                    // If the file is the main module, it can be imported by the package name
                    var mainFileRelative = packageJsonContent.typings || packageJsonContent.types || packageJsonContent.main || "index.js";
                    if (ts.isString(mainFileRelative)) {
                        var mainExportFile = ts.toPath(mainFileRelative, packageRootPath, getCanonicalFileName);
                        if (ts.removeFileExtension(mainExportFile) === ts.removeFileExtension(getCanonicalFileName(moduleFileToTry))) {
                            return { packageRootPath: packageRootPath, moduleFileToTry: moduleFileToTry };
                        }
                    }
                }
                else {
                    // No package.json exists; an index.js will still resolve as the package name
                    var fileName = getCanonicalFileName(moduleFileToTry.substring(parts.packageRootIndex + 1));
                    if (fileName === "index.d.ts" || fileName === "index.js" || fileName === "index.ts" || fileName === "index.tsx") {
                        return { moduleFileToTry: moduleFileToTry, packageRootPath: packageRootPath };
                    }
                }
                return { moduleFileToTry: moduleFileToTry };
            }
        }
        function tryGetAnyFileFromPath(host, path) {
            if (!host.fileExists)
                return;
            // We check all js, `node` and `json` extensions in addition to TS, since node module resolution would also choose those over the directory
            var extensions = ts.flatten(ts.getSupportedExtensions({ allowJs: true }, [{ extension: "node", isMixedContent: false }, { extension: "json", isMixedContent: false, scriptKind: 6 /* ScriptKind.JSON */ }]));
            for (var _i = 0, extensions_3 = extensions; _i < extensions_3.length; _i++) {
                var e = extensions_3[_i];
                var fullPath = path + e;
                if (host.fileExists(fullPath)) {
                    return fullPath;
                }
            }
        }
        function getPathRelativeToRootDirs(path, rootDirs, getCanonicalFileName) {
            return ts.firstDefined(rootDirs, function (rootDir) {
                var relativePath = getRelativePathIfInDirectory(path, rootDir, getCanonicalFileName);
                return relativePath !== undefined && isPathRelativeToParent(relativePath) ? undefined : relativePath;
            });
        }
        function removeExtensionAndIndexPostFix(fileName, ending, options, host) {
            if (ts.fileExtensionIsOneOf(fileName, [".json" /* Extension.Json */, ".mjs" /* Extension.Mjs */, ".cjs" /* Extension.Cjs */]))
                return fileName;
            var noExtension = ts.removeFileExtension(fileName);
            if (fileName === noExtension)
                return fileName;
            if (ts.fileExtensionIsOneOf(fileName, [".d.mts" /* Extension.Dmts */, ".mts" /* Extension.Mts */, ".d.cts" /* Extension.Dcts */, ".cts" /* Extension.Cts */]))
                return noExtension + getJSExtensionForFile(fileName, options);
            switch (ending) {
                case 0 /* Ending.Minimal */:
                    var withoutIndex = ts.removeSuffix(noExtension, "/index");
                    if (host && withoutIndex !== noExtension && tryGetAnyFileFromPath(host, withoutIndex)) {
                        // Can't remove index if there's a file by the same name as the directory.
                        // Probably more callers should pass `host` so we can determine this?
                        return noExtension;
                    }
                    return withoutIndex;
                case 1 /* Ending.Index */:
                    return noExtension;
                case 2 /* Ending.JsExtension */:
                    return noExtension + getJSExtensionForFile(fileName, options);
                default:
                    return ts.Debug.assertNever(ending);
            }
        }
        function getJSExtensionForFile(fileName, options) {
            var _a;
            return (_a = tryGetJSExtensionForFile(fileName, options)) !== null && _a !== void 0 ? _a : ts.Debug.fail("Extension ".concat(ts.extensionFromPath(fileName), " is unsupported:: FileName:: ").concat(fileName));
        }
        function tryGetJSExtensionForFile(fileName, options) {
            var ext = ts.tryGetExtensionFromPath(fileName);
            switch (ext) {
                case ".ts" /* Extension.Ts */:
                case ".d.ts" /* Extension.Dts */:
                    return ".js" /* Extension.Js */;
                case ".tsx" /* Extension.Tsx */:
                    return options.jsx === 1 /* JsxEmit.Preserve */ ? ".jsx" /* Extension.Jsx */ : ".js" /* Extension.Js */;
                case ".js" /* Extension.Js */:
                case ".jsx" /* Extension.Jsx */:
                case ".json" /* Extension.Json */:
                    return ext;
                case ".d.mts" /* Extension.Dmts */:
                case ".mts" /* Extension.Mts */:
                case ".mjs" /* Extension.Mjs */:
                    return ".mjs" /* Extension.Mjs */;
                case ".d.cts" /* Extension.Dcts */:
                case ".cts" /* Extension.Cts */:
                case ".cjs" /* Extension.Cjs */:
                    return ".cjs" /* Extension.Cjs */;
                default:
                    return undefined;
            }
        }
        moduleSpecifiers_1.tryGetJSExtensionForFile = tryGetJSExtensionForFile;
        function getRelativePathIfInDirectory(path, directoryPath, getCanonicalFileName) {
            var relativePath = ts.getRelativePathToDirectoryOrUrl(directoryPath, path, directoryPath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);
            return ts.isRootedDiskPath(relativePath) ? undefined : relativePath;
        }
        function isPathRelativeToParent(path) {
            return ts.startsWith(path, "..");
        }
    })(moduleSpecifiers = ts.moduleSpecifiers || (ts.moduleSpecifiers = {}));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var sysFormatDiagnosticsHost = ts.sys ? {
        getCurrentDirectory: function () { return ts.sys.getCurrentDirectory(); },
        getNewLine: function () { return ts.sys.newLine; },
        getCanonicalFileName: ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)
    } : undefined;
    /**
     * Create a function that reports error by writing to the system and handles the formatting of the diagnostic
     */
    function createDiagnosticReporter(system, pretty) {
        var host = system === ts.sys && sysFormatDiagnosticsHost ? sysFormatDiagnosticsHost : {
            getCurrentDirectory: function () { return system.getCurrentDirectory(); },
            getNewLine: function () { return system.newLine; },
            getCanonicalFileName: ts.createGetCanonicalFileName(system.useCaseSensitiveFileNames),
        };
        if (!pretty) {
            return function (diagnostic) { return system.write(ts.formatDiagnostic(diagnostic, host)); };
        }
        var diagnostics = new Array(1);
        return function (diagnostic) {
            diagnostics[0] = diagnostic;
            system.write(ts.formatDiagnosticsWithColorAndContext(diagnostics, host) + host.getNewLine());
            diagnostics[0] = undefined; // TODO: GH#18217
        };
    }
    ts.createDiagnosticReporter = createDiagnosticReporter;
    /**
     * @returns Whether the screen was cleared.
     */
    function clearScreenIfNotWatchingForFileChanges(system, diagnostic, options) {
        if (system.clearScreen &&
            !options.preserveWatchOutput &&
            !options.extendedDiagnostics &&
            !options.diagnostics &&
            ts.contains(ts.screenStartingMessageCodes, diagnostic.code)) {
            system.clearScreen();
            return true;
        }
        return false;
    }
    ts.screenStartingMessageCodes = [
        ts.Diagnostics.Starting_compilation_in_watch_mode.code,
        ts.Diagnostics.File_change_detected_Starting_incremental_compilation.code,
    ];
    function getPlainDiagnosticFollowingNewLines(diagnostic, newLine) {
        return ts.contains(ts.screenStartingMessageCodes, diagnostic.code)
            ? newLine + newLine
            : newLine;
    }
    /**
     * Get locale specific time based on whether we are in test mode
     */
    function getLocaleTimeString(system) {
        return !system.now ?
            new Date().toLocaleTimeString() :
            system.now().toLocaleTimeString("en-US", { timeZone: "UTC" });
    }
    ts.getLocaleTimeString = getLocaleTimeString;
    /**
     * Create a function that reports watch status by writing to the system and handles the formatting of the diagnostic
     */
    function createWatchStatusReporter(system, pretty) {
        return pretty ?
            function (diagnostic, newLine, options) {
                clearScreenIfNotWatchingForFileChanges(system, diagnostic, options);
                var output = "[".concat(ts.formatColorAndReset(getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey), "] ");
                output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(newLine + newLine);
                system.write(output);
            } :
            function (diagnostic, newLine, options) {
                var output = "";
                if (!clearScreenIfNotWatchingForFileChanges(system, diagnostic, options)) {
                    output += newLine;
                }
                output += "".concat(getLocaleTimeString(system), " - ");
                output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(getPlainDiagnosticFollowingNewLines(diagnostic, newLine));
                system.write(output);
            };
    }
    ts.createWatchStatusReporter = createWatchStatusReporter;
    /** Parses config file using System interface */
    function parseConfigFileWithSystem(configFileName, optionsToExtend, extendedConfigCache, watchOptionsToExtend, system, reportDiagnostic) {
        var host = system;
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic); };
        var result = ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache, watchOptionsToExtend);
        host.onUnRecoverableConfigFileDiagnostic = undefined; // TODO: GH#18217
        return result;
    }
    ts.parseConfigFileWithSystem = parseConfigFileWithSystem;
    function getErrorCountForSummary(diagnostics) {
        return ts.countWhere(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; });
    }
    ts.getErrorCountForSummary = getErrorCountForSummary;
    function getFilesInErrorForSummary(diagnostics) {
        var filesInError = ts.filter(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; })
            .map(function (errorDiagnostic) {
            if (errorDiagnostic.file === undefined)
                return;
            return "".concat(errorDiagnostic.file.fileName);
        });
        return filesInError.map(function (fileName) {
            var diagnosticForFileName = ts.find(diagnostics, function (diagnostic) {
                return diagnostic.file !== undefined && diagnostic.file.fileName === fileName;
            });
            if (diagnosticForFileName !== undefined) {
                var line = ts.getLineAndCharacterOfPosition(diagnosticForFileName.file, diagnosticForFileName.start).line;
                return {
                    fileName: fileName,
                    line: line + 1,
                };
            }
        });
    }
    ts.getFilesInErrorForSummary = getFilesInErrorForSummary;
    function getWatchErrorSummaryDiagnosticMessage(errorCount) {
        return errorCount === 1 ?
            ts.Diagnostics.Found_1_error_Watching_for_file_changes :
            ts.Diagnostics.Found_0_errors_Watching_for_file_changes;
    }
    ts.getWatchErrorSummaryDiagnosticMessage = getWatchErrorSummaryDiagnosticMessage;
    function prettyPathForFileError(error, cwd) {
        var line = ts.formatColorAndReset(":" + error.line, ts.ForegroundColorEscapeSequences.Grey);
        if (ts.pathIsAbsolute(error.fileName) && ts.pathIsAbsolute(cwd)) {
            return ts.getRelativePathFromDirectory(cwd, error.fileName, /* ignoreCase */ false) + line;
        }
        return error.fileName + line;
    }
    function getErrorSummaryText(errorCount, filesInError, newLine, host) {
        if (errorCount === 0)
            return "";
        var nonNilFiles = filesInError.filter(function (fileInError) { return fileInError !== undefined; });
        var distinctFileNamesWithLines = nonNilFiles.map(function (fileInError) { return "".concat(fileInError.fileName, ":").concat(fileInError.line); })
            .filter(function (value, index, self) { return self.indexOf(value) === index; });
        var firstFileReference = nonNilFiles[0] && prettyPathForFileError(nonNilFiles[0], host.getCurrentDirectory());
        var d = errorCount === 1 ?
            ts.createCompilerDiagnostic(filesInError[0] !== undefined ?
                ts.Diagnostics.Found_1_error_in_1 :
                ts.Diagnostics.Found_1_error, errorCount, firstFileReference) :
            ts.createCompilerDiagnostic(distinctFileNamesWithLines.length === 0 ?
                ts.Diagnostics.Found_0_errors :
                distinctFileNamesWithLines.length === 1 ?
                    ts.Diagnostics.Found_0_errors_in_the_same_file_starting_at_Colon_1 :
                    ts.Diagnostics.Found_0_errors_in_1_files, errorCount, distinctFileNamesWithLines.length === 1 ? firstFileReference : distinctFileNamesWithLines.length);
        var suffix = distinctFileNamesWithLines.length > 1 ? createTabularErrorsDisplay(nonNilFiles, host) : "";
        return "".concat(newLine).concat(ts.flattenDiagnosticMessageText(d.messageText, newLine)).concat(newLine).concat(newLine).concat(suffix);
    }
    ts.getErrorSummaryText = getErrorSummaryText;
    function createTabularErrorsDisplay(filesInError, host) {
        var distinctFiles = filesInError.filter(function (value, index, self) { return index === self.findIndex(function (file) { return (file === null || file === void 0 ? void 0 : file.fileName) === (value === null || value === void 0 ? void 0 : value.fileName); }); });
        if (distinctFiles.length === 0)
            return "";
        var numberLength = function (num) { return Math.log(num) * Math.LOG10E + 1; };
        var fileToErrorCount = distinctFiles.map(function (file) { return [file, ts.countWhere(filesInError, function (fileInError) { return fileInError.fileName === file.fileName; })]; });
        var maxErrors = fileToErrorCount.reduce(function (acc, value) { return Math.max(acc, value[1] || 0); }, 0);
        var headerRow = ts.Diagnostics.Errors_Files.message;
        var leftColumnHeadingLength = headerRow.split(" ")[0].length;
        var leftPaddingGoal = Math.max(leftColumnHeadingLength, numberLength(maxErrors));
        var headerPadding = Math.max(numberLength(maxErrors) - leftColumnHeadingLength, 0);
        var tabularData = "";
        tabularData += " ".repeat(headerPadding) + headerRow + "\n";
        fileToErrorCount.forEach(function (row) {
            var file = row[0], errorCount = row[1];
            var errorCountDigitsLength = Math.log(errorCount) * Math.LOG10E + 1 | 0;
            var leftPadding = errorCountDigitsLength < leftPaddingGoal ?
                " ".repeat(leftPaddingGoal - errorCountDigitsLength)
                : "";
            var fileRef = prettyPathForFileError(file, host.getCurrentDirectory());
            tabularData += "".concat(leftPadding).concat(errorCount, "  ").concat(fileRef, "\n");
        });
        return tabularData;
    }
    function isBuilderProgram(program) {
        return !!program.getState;
    }
    ts.isBuilderProgram = isBuilderProgram;
    function listFiles(program, write) {
        var options = program.getCompilerOptions();
        if (options.explainFiles) {
            explainFiles(isBuilderProgram(program) ? program.getProgram() : program, write);
        }
        else if (options.listFiles || options.listFilesOnly) {
            ts.forEach(program.getSourceFiles(), function (file) {
                write(file.fileName);
            });
        }
    }
    ts.listFiles = listFiles;
    function explainFiles(program, write) {
        var _a, _b;
        var reasons = program.getFileIncludeReasons();
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var relativeFileName = function (fileName) { return ts.convertToRelativePath(fileName, program.getCurrentDirectory(), getCanonicalFileName); };
        for (var _i = 0, _c = program.getSourceFiles(); _i < _c.length; _i++) {
            var file = _c[_i];
            write("".concat(toFileName(file, relativeFileName)));
            (_a = reasons.get(file.path)) === null || _a === void 0 ? void 0 : _a.forEach(function (reason) { return write("  ".concat(fileIncludeReasonToDiagnostics(program, reason, relativeFileName).messageText)); });
            (_b = explainIfFileIsRedirect(file, relativeFileName)) === null || _b === void 0 ? void 0 : _b.forEach(function (d) { return write("  ".concat(d.messageText)); });
        }
    }
    ts.explainFiles = explainFiles;
    function explainIfFileIsRedirect(file, fileNameConvertor) {
        var result;
        if (file.path !== file.resolvedPath) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_is_output_of_project_reference_source_0, toFileName(file.originalFileName, fileNameConvertor)));
        }
        if (file.redirectInfo) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_redirects_to_file_0, toFileName(file.redirectInfo.redirectTarget, fileNameConvertor)));
        }
        return result;
    }
    ts.explainIfFileIsRedirect = explainIfFileIsRedirect;
    function getMatchedFileSpec(program, fileName) {
        var _a;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedFilesSpec))
            return undefined;
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var filePath = getCanonicalFileName(fileName);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        return ts.find(configFile.configFileSpecs.validatedFilesSpec, function (fileSpec) { return getCanonicalFileName(ts.getNormalizedAbsolutePath(fileSpec, basePath)) === filePath; });
    }
    ts.getMatchedFileSpec = getMatchedFileSpec;
    function getMatchedIncludeSpec(program, fileName) {
        var _a, _b;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedIncludeSpecs))
            return undefined;
        var isJsonFile = ts.fileExtensionIs(fileName, ".json" /* Extension.Json */);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        var useCaseSensitiveFileNames = program.useCaseSensitiveFileNames();
        return ts.find((_b = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _b === void 0 ? void 0 : _b.validatedIncludeSpecs, function (includeSpec) {
            if (isJsonFile && !ts.endsWith(includeSpec, ".json" /* Extension.Json */))
                return false;
            var pattern = ts.getPatternFromSpec(includeSpec, basePath, "files");
            return !!pattern && ts.getRegexFromPattern("(".concat(pattern, ")$"), useCaseSensitiveFileNames).test(fileName);
        });
    }
    ts.getMatchedIncludeSpec = getMatchedIncludeSpec;
    function fileIncludeReasonToDiagnostics(program, reason, fileNameConvertor) {
        var _a, _b;
        var options = program.getCompilerOptions();
        if (ts.isReferencedFile(reason)) {
            var referenceLocation = ts.getReferencedFileLocation(function (path) { return program.getSourceFileByPath(path); }, reason);
            var referenceText = ts.isReferenceFileLocation(referenceLocation) ? referenceLocation.file.text.substring(referenceLocation.pos, referenceLocation.end) : "\"".concat(referenceLocation.text, "\"");
            var message = void 0;
            ts.Debug.assert(ts.isReferenceFileLocation(referenceLocation) || reason.kind === ts.FileIncludeKind.Import, "Only synthetic references are imports");
            switch (reason.kind) {
                case ts.FileIncludeKind.Import:
                    if (ts.isReferenceFileLocation(referenceLocation)) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2 :
                            ts.Diagnostics.Imported_via_0_from_file_1;
                    }
                    else if (referenceLocation.text === ts.externalHelpersModuleNameText) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions;
                    }
                    else {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions;
                    }
                    break;
                case ts.FileIncludeKind.ReferenceFile:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.TypeReferenceDirective:
                    message = referenceLocation.packageId ?
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1_with_packageId_2 :
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.LibReferenceDirective:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Library_referenced_via_0_from_file_1;
                    break;
                default:
                    ts.Debug.assertNever(reason);
            }
            return ts.chainDiagnosticMessages(
            /*details*/ undefined, message, referenceText, toFileName(referenceLocation.file, fileNameConvertor), referenceLocation.packageId && ts.packageIdToString(referenceLocation.packageId));
        }
        switch (reason.kind) {
            case ts.FileIncludeKind.RootFile:
                if (!((_a = options.configFile) === null || _a === void 0 ? void 0 : _a.configFileSpecs))
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
                var fileName = ts.getNormalizedAbsolutePath(program.getRootFileNames()[reason.index], program.getCurrentDirectory());
                var matchedByFiles = getMatchedFileSpec(program, fileName);
                if (matchedByFiles)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Part_of_files_list_in_tsconfig_json);
                var matchedByInclude = getMatchedIncludeSpec(program, fileName);
                return matchedByInclude ?
                    ts.chainDiagnosticMessages(
                    /*details*/ undefined, ts.Diagnostics.Matched_by_include_pattern_0_in_1, matchedByInclude, toFileName(options.configFile, fileNameConvertor)) :
                    // Could be additional files specified as roots
                    ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
            case ts.FileIncludeKind.SourceFromProjectReference:
            case ts.FileIncludeKind.OutputFromProjectReference:
                var isOutput = reason.kind === ts.FileIncludeKind.OutputFromProjectReference;
                var referencedResolvedRef = ts.Debug.checkDefined((_b = program.getResolvedProjectReferences()) === null || _b === void 0 ? void 0 : _b[reason.index]);
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, ts.outFile(options) ?
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_1_specified :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_1_specified :
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_module_is_specified_as_none :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_module_is_specified_as_none, toFileName(referencedResolvedRef.sourceFile.fileName, fileNameConvertor), options.outFile ? "--outFile" : "--out");
            case ts.FileIncludeKind.AutomaticTypeDirectiveFile:
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, options.types ?
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1 :
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions :
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0_with_packageId_1 :
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0, reason.typeReference, reason.packageId && ts.packageIdToString(reason.packageId));
            case ts.FileIncludeKind.LibFile:
                if (reason.index !== undefined)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Library_0_specified_in_compilerOptions, options.lib[reason.index]);
                var target = ts.forEachEntry(ts.targetOptionDeclaration.type, function (value, key) { return value === ts.getEmitScriptTarget(options) ? key : undefined; });
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, target ?
                    ts.Diagnostics.Default_library_for_target_0 :
                    ts.Diagnostics.Default_library, target);
            default:
                ts.Debug.assertNever(reason);
        }
    }
    ts.fileIncludeReasonToDiagnostics = fileIncludeReasonToDiagnostics;
    function toFileName(file, fileNameConvertor) {
        var fileName = ts.isString(file) ? file : file.fileName;
        return fileNameConvertor ? fileNameConvertor(fileName) : fileName;
    }
    /**
     * Helper that emit files, report diagnostics and lists emitted and/or source files depending on compiler options
     */
    function emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var isListFilesOnly = !!program.getCompilerOptions().listFilesOnly;
        // First get and report any syntactic errors.
        var allDiagnostics = program.getConfigFileParsingDiagnostics().slice();
        var configFileParsingDiagnosticsLength = allDiagnostics.length;
        ts.addRange(allDiagnostics, program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
        // If we didn't have any syntactic errors, then also try getting the global and
        // semantic errors.
        if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
            ts.addRange(allDiagnostics, program.getOptionsDiagnostics(cancellationToken));
            if (!isListFilesOnly) {
                ts.addRange(allDiagnostics, program.getGlobalDiagnostics(cancellationToken));
                if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
                    ts.addRange(allDiagnostics, program.getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
                }
            }
        }
        // Emit and report any errors we ran into.
        var emitResult = isListFilesOnly
            ? { emitSkipped: true, diagnostics: ts.emptyArray }
            : program.emit(/*targetSourceFile*/ undefined, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
        var emittedFiles = emitResult.emittedFiles, emitDiagnostics = emitResult.diagnostics;
        ts.addRange(allDiagnostics, emitDiagnostics);
        var diagnostics = ts.sortAndDeduplicateDiagnostics(allDiagnostics);
        diagnostics.forEach(reportDiagnostic);
        if (write) {
            var currentDir_1 = program.getCurrentDirectory();
            ts.forEach(emittedFiles, function (file) {
                var filepath = ts.getNormalizedAbsolutePath(file, currentDir_1);
                write("TSFILE: ".concat(filepath));
            });
            listFiles(program, write);
        }
        if (reportSummary) {
            reportSummary(getErrorCountForSummary(diagnostics), getFilesInErrorForSummary(diagnostics));
        }
        return {
            emitResult: emitResult,
            diagnostics: diagnostics,
        };
    }
    ts.emitFilesAndReportErrors = emitFilesAndReportErrors;
    function emitFilesAndReportErrorsAndGetExitStatus(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var _a = emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers), emitResult = _a.emitResult, diagnostics = _a.diagnostics;
        if (emitResult.emitSkipped && diagnostics.length > 0) {
            // If the emitter didn't emit anything, then pass that value along.
            return ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
        }
        else if (diagnostics.length > 0) {
            // The emitter emitted something, inform the caller if that happened in the presence
            // of diagnostics or not.
            return ts.ExitStatus.DiagnosticsPresent_OutputsGenerated;
        }
        return ts.ExitStatus.Success;
    }
    ts.emitFilesAndReportErrorsAndGetExitStatus = emitFilesAndReportErrorsAndGetExitStatus;
    ts.noopFileWatcher = { close: ts.noop };
    ts.returnNoopFileWatcher = function () { return ts.noopFileWatcher; };
    function createWatchHost(system, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var onWatchStatusChange = reportWatchStatus || createWatchStatusReporter(system);
        return {
            onWatchStatusChange: onWatchStatusChange,
            watchFile: ts.maybeBind(system, system.watchFile) || ts.returnNoopFileWatcher,
            watchDirectory: ts.maybeBind(system, system.watchDirectory) || ts.returnNoopFileWatcher,
            setTimeout: ts.maybeBind(system, system.setTimeout) || ts.noop,
            clearTimeout: ts.maybeBind(system, system.clearTimeout) || ts.noop
        };
    }
    ts.createWatchHost = createWatchHost;
    ts.WatchType = {
        ConfigFile: "Config file",
        ExtendedConfigFile: "Extended config file",
        SourceFile: "Source file",
        MissingFile: "Missing file",
        WildcardDirectory: "Wild card directory",
        FailedLookupLocations: "Failed Lookup Locations",
        TypeRoots: "Type roots",
        ConfigFileOfReferencedProject: "Config file of referened project",
        ExtendedConfigOfReferencedProject: "Extended config file of referenced project",
        WildcardDirectoryOfReferencedProject: "Wild card directory of referenced project",
        PackageJson: "package.json file",
    };
    function createWatchFactory(host, options) {
        var watchLogLevel = host.trace ? options.extendedDiagnostics ? ts.WatchLogLevel.Verbose : options.diagnostics ? ts.WatchLogLevel.TriggerOnly : ts.WatchLogLevel.None : ts.WatchLogLevel.None;
        var writeLog = watchLogLevel !== ts.WatchLogLevel.None ? (function (s) { return host.trace(s); }) : ts.noop;
        var result = ts.getWatchFactory(host, watchLogLevel, writeLog);
        result.writeLog = writeLog;
        return result;
    }
    ts.createWatchFactory = createWatchFactory;
    function createCompilerHostFromProgramHost(host, getCompilerOptions, directoryStructureHost) {
        if (directoryStructureHost === void 0) { directoryStructureHost = host; }
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var hostGetNewLine = ts.memoize(function () { return host.getNewLine(); });
        return {
            getSourceFile: function (fileName, languageVersionOrOptions, onError) {
                var text;
                try {
                    ts.performance.mark("beforeIORead");
                    text = host.readFile(fileName, getCompilerOptions().charset);
                    ts.performance.mark("afterIORead");
                    ts.performance.measure("I/O Read", "beforeIORead", "afterIORead");
                }
                catch (e) {
                    if (onError) {
                        onError(e.message);
                    }
                    text = "";
                }
                return text !== undefined ? ts.createSourceFile(fileName, text, languageVersionOrOptions) : undefined;
            },
            getDefaultLibLocation: ts.maybeBind(host, host.getDefaultLibLocation),
            getDefaultLibFileName: function (options) { return host.getDefaultLibFileName(options); },
            writeFile: writeFile,
            getCurrentDirectory: ts.memoize(function () { return host.getCurrentDirectory(); }),
            useCaseSensitiveFileNames: function () { return useCaseSensitiveFileNames; },
            getCanonicalFileName: ts.createGetCanonicalFileName(useCaseSensitiveFileNames),
            getNewLine: function () { return ts.getNewLineCharacter(getCompilerOptions(), hostGetNewLine); },
            fileExists: function (f) { return host.fileExists(f); },
            readFile: function (f) { return host.readFile(f); },
            trace: ts.maybeBind(host, host.trace),
            directoryExists: ts.maybeBind(directoryStructureHost, directoryStructureHost.directoryExists),
            getDirectories: ts.maybeBind(directoryStructureHost, directoryStructureHost.getDirectories),
            realpath: ts.maybeBind(host, host.realpath),
            getEnvironmentVariable: ts.maybeBind(host, host.getEnvironmentVariable) || (function () { return ""; }),
            createHash: ts.maybeBind(host, host.createHash),
            readDirectory: ts.maybeBind(host, host.readDirectory),
            disableUseFileVersionAsSignature: host.disableUseFileVersionAsSignature,
            storeFilesChangingSignatureDuringEmit: host.storeFilesChangingSignatureDuringEmit,
        };
        function writeFile(fileName, text, writeByteOrderMark, onError) {
            try {
                ts.performance.mark("beforeIOWrite");
                // NOTE: If patchWriteFileEnsuringDirectory has been called,
                // the host.writeFile will do its own directory creation and
                // the ensureDirectoriesExist call will always be redundant.
                ts.writeFileEnsuringDirectories(fileName, text, writeByteOrderMark, function (path, data, writeByteOrderMark) { return host.writeFile(path, data, writeByteOrderMark); }, function (path) { return host.createDirectory(path); }, function (path) { return host.directoryExists(path); });
                ts.performance.mark("afterIOWrite");
                ts.performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite");
            }
            catch (e) {
                if (onError) {
                    onError(e.message);
                }
            }
        }
    }
    ts.createCompilerHostFromProgramHost = createCompilerHostFromProgramHost;
    function setGetSourceFileAsHashVersioned(compilerHost, host) {
        var originalGetSourceFile = compilerHost.getSourceFile;
        var computeHash = ts.maybeBind(host, host.createHash) || ts.generateDjb2Hash;
        compilerHost.getSourceFile = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var result = originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
            if (result) {
                result.version = computeHash(result.text);
            }
            return result;
        };
    }
    ts.setGetSourceFileAsHashVersioned = setGetSourceFileAsHashVersioned;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createProgramHost(system, createProgram) {
        var getDefaultLibLocation = ts.memoize(function () { return ts.getDirectoryPath(ts.normalizePath(system.getExecutingFilePath())); });
        return {
            useCaseSensitiveFileNames: function () { return system.useCaseSensitiveFileNames; },
            getNewLine: function () { return system.newLine; },
            getCurrentDirectory: ts.memoize(function () { return system.getCurrentDirectory(); }),
            getDefaultLibLocation: getDefaultLibLocation,
            getDefaultLibFileName: function (options) { return ts.combinePaths(getDefaultLibLocation(), ts.getDefaultLibFileName(options)); },
            fileExists: function (path) { return system.fileExists(path); },
            readFile: function (path, encoding) { return system.readFile(path, encoding); },
            directoryExists: function (path) { return system.directoryExists(path); },
            getDirectories: function (path) { return system.getDirectories(path); },
            readDirectory: function (path, extensions, exclude, include, depth) { return system.readDirectory(path, extensions, exclude, include, depth); },
            realpath: ts.maybeBind(system, system.realpath),
            getEnvironmentVariable: ts.maybeBind(system, system.getEnvironmentVariable),
            trace: function (s) { return system.write(s + system.newLine); },
            createDirectory: function (path) { return system.createDirectory(path); },
            writeFile: function (path, data, writeByteOrderMark) { return system.writeFile(path, data, writeByteOrderMark); },
            createHash: ts.maybeBind(system, system.createHash),
            createProgram: createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram,
            disableUseFileVersionAsSignature: system.disableUseFileVersionAsSignature,
            storeFilesChangingSignatureDuringEmit: system.storeFilesChangingSignatureDuringEmit,
        };
    }
    ts.createProgramHost = createProgramHost;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createWatchCompilerHost(system, createProgram, reportDiagnostic, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var write = function (s) { return system.write(s + system.newLine); };
        var result = createProgramHost(system, createProgram);
        ts.copyProperties(result, createWatchHost(system, reportWatchStatus));
        result.afterProgramCreate = function (builderProgram) {
            var compilerOptions = builderProgram.getCompilerOptions();
            var newLine = ts.getNewLineCharacter(compilerOptions, function () { return system.newLine; });
            emitFilesAndReportErrors(builderProgram, reportDiagnostic, write, function (errorCount) { return result.onWatchStatusChange(ts.createCompilerDiagnostic(getWatchErrorSummaryDiagnosticMessage(errorCount), errorCount), newLine, compilerOptions, errorCount); });
        };
        return result;
    }
    /**
     * Report error and exit
     */
    function reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic) {
        reportDiagnostic(diagnostic);
        system.exit(ts.ExitStatus.DiagnosticsPresent_OutputsSkipped);
    }
    /**
     * Creates the watch compiler host from system for config file in watch mode
     */
    function createWatchCompilerHostOfConfigFile(_a) {
        var configFileName = _a.configFileName, optionsToExtend = _a.optionsToExtend, watchOptionsToExtend = _a.watchOptionsToExtend, extraFileExtensions = _a.extraFileExtensions, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var diagnosticReporter = reportDiagnostic || createDiagnosticReporter(system);
        var host = createWatchCompilerHost(system, createProgram, diagnosticReporter, reportWatchStatus);
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, diagnosticReporter, diagnostic); };
        host.configFileName = configFileName;
        host.optionsToExtend = optionsToExtend;
        host.watchOptionsToExtend = watchOptionsToExtend;
        host.extraFileExtensions = extraFileExtensions;
        return host;
    }
    ts.createWatchCompilerHostOfConfigFile = createWatchCompilerHostOfConfigFile;
    /**
     * Creates the watch compiler host from system for compiling root files and options in watch mode
     */
    function createWatchCompilerHostOfFilesAndCompilerOptions(_a) {
        var rootFiles = _a.rootFiles, options = _a.options, watchOptions = _a.watchOptions, projectReferences = _a.projectReferences, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var host = createWatchCompilerHost(system, createProgram, reportDiagnostic || createDiagnosticReporter(system), reportWatchStatus);
        host.rootFiles = rootFiles;
        host.options = options;
        host.watchOptions = watchOptions;
        host.projectReferences = projectReferences;
        return host;
    }
    ts.createWatchCompilerHostOfFilesAndCompilerOptions = createWatchCompilerHostOfFilesAndCompilerOptions;
    function performIncrementalCompilation(input) {
        var system = input.system || ts.sys;
        var host = input.host || (input.host = ts.createIncrementalCompilerHost(input.options, system));
        var builderProgram = ts.createIncrementalProgram(input);
        var exitStatus = emitFilesAndReportErrorsAndGetExitStatus(builderProgram, input.reportDiagnostic || createDiagnosticReporter(system), function (s) { return host.trace && host.trace(s); }, input.reportErrorSummary || input.options.pretty ? function (errorCount, filesInError) { return system.write(getErrorSummaryText(errorCount, filesInError, system.newLine, host)); } : undefined);
        if (input.afterProgramEmitAndDiagnostics)
            input.afterProgramEmitAndDiagnostics(builderProgram);
        return exitStatus;
    }
    ts.performIncrementalCompilation = performIncrementalCompilation;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function readBuilderProgram(compilerOptions, host) {
        if (ts.outFile(compilerOptions))
            return undefined;
        var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(compilerOptions);
        if (!buildInfoPath)
            return undefined;
        var content = host.readFile(buildInfoPath);
        if (!content)
            return undefined;
        var buildInfo = ts.getBuildInfo(content);
        if (buildInfo.version !== ts.version)
            return undefined;
        if (!buildInfo.program)
            return undefined;
        return ts.createBuildProgramUsingProgramBuildInfo(buildInfo.program, buildInfoPath, host);
    }
    ts.readBuilderProgram = readBuilderProgram;
    function createIncrementalCompilerHost(options, system) {
        if (system === void 0) { system = ts.sys; }
        var host = ts.createCompilerHostWorker(options, /*setParentNodes*/ undefined, system);
        host.createHash = ts.maybeBind(system, system.createHash);
        host.disableUseFileVersionAsSignature = system.disableUseFileVersionAsSignature;
        host.storeFilesChangingSignatureDuringEmit = system.storeFilesChangingSignatureDuringEmit;
        ts.setGetSourceFileAsHashVersioned(host, system);
        ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return ts.toPath(fileName, host.getCurrentDirectory(), host.getCanonicalFileName); });
        return host;
    }
    ts.createIncrementalCompilerHost = createIncrementalCompilerHost;
    function createIncrementalProgram(_a) {
        var rootNames = _a.rootNames, options = _a.options, configFileParsingDiagnostics = _a.configFileParsingDiagnostics, projectReferences = _a.projectReferences, host = _a.host, createProgram = _a.createProgram;
        host = host || createIncrementalCompilerHost(options);
        createProgram = createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram;
        var oldProgram = readBuilderProgram(options, host);
        return createProgram(rootNames, options, host, oldProgram, configFileParsingDiagnostics, projectReferences);
    }
    ts.createIncrementalProgram = createIncrementalProgram;
    function createWatchCompilerHost(rootFilesOrConfigFileName, options, system, createProgram, reportDiagnostic, reportWatchStatus, projectReferencesOrWatchOptionsToExtend, watchOptionsOrExtraFileExtensions) {
        if (ts.isArray(rootFilesOrConfigFileName)) {
            return ts.createWatchCompilerHostOfFilesAndCompilerOptions({
                rootFiles: rootFilesOrConfigFileName,
                options: options,
                watchOptions: watchOptionsOrExtraFileExtensions,
                projectReferences: projectReferencesOrWatchOptionsToExtend,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
        else {
            return ts.createWatchCompilerHostOfConfigFile({
                configFileName: rootFilesOrConfigFileName,
                optionsToExtend: options,
                watchOptionsToExtend: projectReferencesOrWatchOptionsToExtend,
                extraFileExtensions: watchOptionsOrExtraFileExtensions,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
    }
    ts.createWatchCompilerHost = createWatchCompilerHost;
    function createWatchProgram(host) {
        var builderProgram;
        var reloadLevel; // level to indicate if the program needs to be reloaded from config file/just filenames etc
        var missingFilesMap; // Map of file watchers for the missing files
        var packageJsonMap; // map of watchers for package json files used in module resolution
        var watchedWildcardDirectories; // map of watchers for the wild card directories in the config file
        var timerToUpdateProgram; // timer callback to recompile the program
        var timerToInvalidateFailedLookupResolutions; // timer callback to invalidate resolutions for changes in failed lookup locations
        var parsedConfigs; // Parsed commandline and watching cached for referenced projects
        var sharedExtendedConfigFileWatchers; // Map of file watchers for extended files, shared between different referenced projects
        var extendedConfigCache = host.extendedConfigCache; // Cache for extended config evaluation
        var changesAffectResolution = false; // Flag for indicating non-config changes affect module resolution
        var reportFileChangeDetectedOnCreateProgram = false; // True if synchronizeProgram should report "File change detected..." when a new program is created
        var sourceFilesCache = new ts.Map(); // Cache that stores the source file and version info
        var missingFilePathsRequestedForRelease; // These paths are held temporarily so that we can remove the entry from source file cache if the file is not tracked by missing files
        var hasChangedCompilerOptions = false; // True if the compiler options have changed between compilations
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var currentDirectory = host.getCurrentDirectory();
        var configFileName = host.configFileName, _a = host.optionsToExtend, optionsToExtendForConfigFile = _a === void 0 ? {} : _a, watchOptionsToExtend = host.watchOptionsToExtend, extraFileExtensions = host.extraFileExtensions, createProgram = host.createProgram;
        var rootFileNames = host.rootFiles, compilerOptions = host.options, watchOptions = host.watchOptions, projectReferences = host.projectReferences;
        var wildcardDirectories;
        var configFileParsingDiagnostics;
        var canConfigFileJsonReportNoInputFiles = false;
        var hasChangedConfigFileParsingErrors = false;
        var cachedDirectoryStructureHost = configFileName === undefined ? undefined : ts.createCachedDirectoryStructureHost(host, currentDirectory, useCaseSensitiveFileNames);
        var directoryStructureHost = cachedDirectoryStructureHost || host;
        var parseConfigFileHost = ts.parseConfigHostFromCompilerHostLike(host, directoryStructureHost);
        // From tsc we want to get already parsed result and hence check for rootFileNames
        var newLine = updateNewLine();
        if (configFileName && host.configFileParsingResult) {
            setConfigFileParsingResult(host.configFileParsingResult);
            newLine = updateNewLine();
        }
        reportWatchDiagnostic(ts.Diagnostics.Starting_compilation_in_watch_mode);
        if (configFileName && !host.configFileParsingResult) {
            newLine = ts.getNewLineCharacter(optionsToExtendForConfigFile, function () { return host.getNewLine(); });
            ts.Debug.assert(!rootFileNames);
            parseConfigFile();
            newLine = updateNewLine();
        }
        var _b = ts.createWatchFactory(host, compilerOptions), watchFile = _b.watchFile, watchDirectory = _b.watchDirectory, writeLog = _b.writeLog;
        var getCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        writeLog("Current directory: ".concat(currentDirectory, " CaseSensitiveFileNames: ").concat(useCaseSensitiveFileNames));
        var configFileWatcher;
        if (configFileName) {
            configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
        }
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        // Members for CompilerHost
        var getNewSourceFile = compilerHost.getSourceFile;
        compilerHost.getSourceFile = function (fileName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return getVersionedSourceFileByPath.apply(void 0, __spreadArray([fileName, toPath(fileName)], args, false));
        };
        compilerHost.getSourceFileByPath = getVersionedSourceFileByPath;
        compilerHost.getNewLine = function () { return newLine; };
        compilerHost.fileExists = fileExists;
        compilerHost.onReleaseOldSourceFile = onReleaseOldSourceFile;
        compilerHost.onReleaseParsedCommandLine = onReleaseParsedCommandLine;
        // Members for ResolutionCacheHost
        compilerHost.toPath = toPath;
        compilerHost.getCompilationSettings = function () { return compilerOptions; };
        compilerHost.useSourceOfProjectReferenceRedirect = ts.maybeBind(host, host.useSourceOfProjectReferenceRedirect);
        compilerHost.watchDirectoryOfFailedLookupLocation = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.FailedLookupLocations); };
        compilerHost.watchTypeRootsDirectory = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.TypeRoots); };
        compilerHost.getCachedDirectoryStructureHost = function () { return cachedDirectoryStructureHost; };
        compilerHost.scheduleInvalidateResolutionsOfFailedLookupLocations = scheduleInvalidateResolutionsOfFailedLookupLocations;
        compilerHost.onInvalidatedResolution = scheduleProgramUpdate;
        compilerHost.onChangedAutomaticTypeDirectiveNames = scheduleProgramUpdate;
        compilerHost.fileIsOpen = ts.returnFalse;
        compilerHost.getCurrentProgram = getCurrentProgram;
        compilerHost.writeLog = writeLog;
        compilerHost.getParsedCommandLine = getParsedCommandLine;
        // Cache for the module resolution
        var resolutionCache = ts.createResolutionCache(compilerHost, configFileName ?
            ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFileName, currentDirectory)) :
            currentDirectory, 
        /*logChangesWhenResolvingModule*/ false);
        // Resolve module using host module resolution strategy if provided otherwise use resolution cache to resolve module names
        compilerHost.resolveModuleNames = host.resolveModuleNames ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveModuleNames.apply(host, args);
            }) :
            (function (moduleNames, containingFile, reusedNames, redirectedReference, _options, sourceFile) { return resolutionCache.resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, sourceFile); });
        compilerHost.resolveTypeReferenceDirectives = host.resolveTypeReferenceDirectives ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveTypeReferenceDirectives.apply(host, args);
            }) :
            (function (typeDirectiveNames, containingFile, redirectedReference, _options, containingFileMode) { return resolutionCache.resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, containingFileMode); });
        var userProvidedResolution = !!host.resolveModuleNames || !!host.resolveTypeReferenceDirectives;
        builderProgram = readBuilderProgram(compilerOptions, compilerHost);
        synchronizeProgram();
        // Update the wild card directory watch
        watchConfigFileWildCardDirectories();
        // Update extended config file watch
        if (configFileName)
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        return configFileName ?
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, close: close } :
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, updateRootFileNames: updateRootFileNames, close: close };
        function close() {
            clearInvalidateResolutionsOfFailedLookupLocations();
            resolutionCache.clear();
            ts.clearMap(sourceFilesCache, function (value) {
                if (value && value.fileWatcher) {
                    value.fileWatcher.close();
                    value.fileWatcher = undefined;
                }
            });
            if (configFileWatcher) {
                configFileWatcher.close();
                configFileWatcher = undefined;
            }
            extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
            extendedConfigCache = undefined;
            if (sharedExtendedConfigFileWatchers) {
                ts.clearMap(sharedExtendedConfigFileWatchers, ts.closeFileWatcherOf);
                sharedExtendedConfigFileWatchers = undefined;
            }
            if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
                watchedWildcardDirectories = undefined;
            }
            if (missingFilesMap) {
                ts.clearMap(missingFilesMap, ts.closeFileWatcher);
                missingFilesMap = undefined;
            }
            if (parsedConfigs) {
                ts.clearMap(parsedConfigs, function (config) {
                    var _a;
                    (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
                    config.watcher = undefined;
                    if (config.watchedDirectories)
                        ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
                    config.watchedDirectories = undefined;
                });
                parsedConfigs = undefined;
            }
            if (packageJsonMap) {
                ts.clearMap(packageJsonMap, ts.closeFileWatcher);
                packageJsonMap = undefined;
            }
        }
        function getCurrentBuilderProgram() {
            return builderProgram;
        }
        function getCurrentProgram() {
            return builderProgram && builderProgram.getProgramOrUndefined();
        }
        function synchronizeProgram() {
            writeLog("Synchronizing program");
            clearInvalidateResolutionsOfFailedLookupLocations();
            var program = getCurrentBuilderProgram();
            if (hasChangedCompilerOptions) {
                newLine = updateNewLine();
                if (program && (changesAffectResolution || ts.changesAffectModuleResolution(program.getCompilerOptions(), compilerOptions))) {
                    resolutionCache.clear();
                }
            }
            // All resolutions are invalid if user provided resolutions
            var hasInvalidatedResolution = resolutionCache.createHasInvalidatedResolution(userProvidedResolution || changesAffectResolution);
            if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, fileExists, hasInvalidatedResolution, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                if (hasChangedConfigFileParsingErrors) {
                    if (reportFileChangeDetectedOnCreateProgram) {
                        reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
                    }
                    builderProgram = createProgram(/*rootNames*/ undefined, /*options*/ undefined, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
                    hasChangedConfigFileParsingErrors = false;
                }
            }
            else {
                if (reportFileChangeDetectedOnCreateProgram) {
                    reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
                }
                createNewProgram(hasInvalidatedResolution);
            }
            changesAffectResolution = false; // reset for next sync
            reportFileChangeDetectedOnCreateProgram = false;
            if (host.afterProgramCreate && program !== builderProgram) {
                host.afterProgramCreate(builderProgram);
            }
            return builderProgram;
        }
        function createNewProgram(hasInvalidatedResolution) {
            // Compile the program
            writeLog("CreatingProgramWith::");
            writeLog("  roots: ".concat(JSON.stringify(rootFileNames)));
            writeLog("  options: ".concat(JSON.stringify(compilerOptions)));
            if (projectReferences)
                writeLog("  projectReferences: ".concat(JSON.stringify(projectReferences)));
            var needsUpdateInTypeRootWatch = hasChangedCompilerOptions || !getCurrentProgram();
            hasChangedCompilerOptions = false;
            hasChangedConfigFileParsingErrors = false;
            resolutionCache.startCachingPerDirectoryResolution();
            compilerHost.hasInvalidatedResolution = hasInvalidatedResolution;
            compilerHost.hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            builderProgram = createProgram(rootFileNames, compilerOptions, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
            // map package json cache entries to their realpaths so we don't try to watch across symlinks
            var packageCacheEntries = ts.map(resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache().entries(), function (_a) {
                var path = _a[0], data = _a[1];
                return [compilerHost.realpath ? toPath(compilerHost.realpath(path)) : path, data];
            });
            resolutionCache.finishCachingPerDirectoryResolution();
            // Update watches
            ts.updateMissingFilePathsWatch(builderProgram.getProgram(), missingFilesMap || (missingFilesMap = new ts.Map()), watchMissingFilePath);
            ts.updatePackageJsonWatch(packageCacheEntries, packageJsonMap || (packageJsonMap = new ts.Map()), watchPackageJsonLookupPath);
            if (needsUpdateInTypeRootWatch) {
                resolutionCache.updateTypeRootsWatch();
            }
            if (missingFilePathsRequestedForRelease) {
                // These are the paths that program creater told us as not in use any more but were missing on the disk.
                // We didnt remove the entry for them from sourceFiles cache so that we dont have to do File IO,
                // if there is already watcher for it (for missing files)
                // At this point our watches were updated, hence now we know that these paths are not tracked and need to be removed
                // so that at later time we have correct result of their presence
                for (var _i = 0, missingFilePathsRequestedForRelease_1 = missingFilePathsRequestedForRelease; _i < missingFilePathsRequestedForRelease_1.length; _i++) {
                    var missingFilePath = missingFilePathsRequestedForRelease_1[_i];
                    if (!missingFilesMap.has(missingFilePath)) {
                        sourceFilesCache.delete(missingFilePath);
                    }
                }
                missingFilePathsRequestedForRelease = undefined;
            }
        }
        function updateRootFileNames(files) {
            ts.Debug.assert(!configFileName, "Cannot update root file names with config file watch mode");
            rootFileNames = files;
            scheduleProgramUpdate();
        }
        function updateNewLine() {
            return ts.getNewLineCharacter(compilerOptions || optionsToExtendForConfigFile, function () { return host.getNewLine(); });
        }
        function toPath(fileName) {
            return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        }
        function isFileMissingOnHost(hostSourceFile) {
            return typeof hostSourceFile === "boolean";
        }
        function isFilePresenceUnknownOnHost(hostSourceFile) {
            return typeof hostSourceFile.version === "boolean";
        }
        function fileExists(fileName) {
            var path = toPath(fileName);
            // If file is missing on host from cache, we can definitely say file doesnt exist
            // otherwise we need to ensure from the disk
            if (isFileMissingOnHost(sourceFilesCache.get(path))) {
                return false;
            }
            return directoryStructureHost.fileExists(fileName);
        }
        function getVersionedSourceFileByPath(fileName, path, languageVersionOrOptions, onError, shouldCreateNewSourceFile) {
            var hostSourceFile = sourceFilesCache.get(path);
            // No source file on the host
            if (isFileMissingOnHost(hostSourceFile)) {
                return undefined;
            }
            // Create new source file if requested or the versions dont match
            if (hostSourceFile === undefined || shouldCreateNewSourceFile || isFilePresenceUnknownOnHost(hostSourceFile)) {
                var sourceFile = getNewSourceFile(fileName, languageVersionOrOptions, onError);
                if (hostSourceFile) {
                    if (sourceFile) {
                        // Set the source file and create file watcher now that file was present on the disk
                        hostSourceFile.sourceFile = sourceFile;
                        hostSourceFile.version = sourceFile.version;
                        if (!hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        }
                    }
                    else {
                        // There is no source file on host any more, close the watch, missing file paths will track it
                        if (hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher.close();
                        }
                        sourceFilesCache.set(path, false);
                    }
                }
                else {
                    if (sourceFile) {
                        var fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        sourceFilesCache.set(path, { sourceFile: sourceFile, version: sourceFile.version, fileWatcher: fileWatcher });
                    }
                    else {
                        sourceFilesCache.set(path, false);
                    }
                }
                if (sourceFile) {
                    sourceFile.impliedNodeFormat = ts.getImpliedNodeFormatForFile(path, resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache(), compilerHost, compilerHost.getCompilationSettings());
                }
                return sourceFile;
            }
            return hostSourceFile.sourceFile;
        }
        function nextSourceFileVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            if (hostSourceFile !== undefined) {
                if (isFileMissingOnHost(hostSourceFile)) {
                    // The next version, lets set it as presence unknown file
                    sourceFilesCache.set(path, { version: false });
                }
                else {
                    hostSourceFile.version = false;
                }
            }
        }
        function getSourceVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            return !hostSourceFile || !hostSourceFile.version ? undefined : hostSourceFile.version;
        }
        function onReleaseOldSourceFile(oldSourceFile, _oldOptions, hasSourceFileByPath) {
            var hostSourceFileInfo = sourceFilesCache.get(oldSourceFile.resolvedPath);
            // If this is the source file thats in the cache and new program doesnt need it,
            // remove the cached entry.
            // Note we arent deleting entry if file became missing in new program or
            // there was version update and new source file was created.
            if (hostSourceFileInfo !== undefined) {
                // record the missing file paths so they can be removed later if watchers arent tracking them
                if (isFileMissingOnHost(hostSourceFileInfo)) {
                    (missingFilePathsRequestedForRelease || (missingFilePathsRequestedForRelease = [])).push(oldSourceFile.path);
                }
                else if (hostSourceFileInfo.sourceFile === oldSourceFile) {
                    if (hostSourceFileInfo.fileWatcher) {
                        hostSourceFileInfo.fileWatcher.close();
                    }
                    sourceFilesCache.delete(oldSourceFile.resolvedPath);
                    if (!hasSourceFileByPath) {
                        resolutionCache.removeResolutionsOfFile(oldSourceFile.path);
                    }
                }
            }
        }
        function reportWatchDiagnostic(message) {
            if (host.onWatchStatusChange) {
                host.onWatchStatusChange(ts.createCompilerDiagnostic(message), newLine, compilerOptions || optionsToExtendForConfigFile);
            }
        }
        function hasChangedAutomaticTypeDirectiveNames() {
            return resolutionCache.hasChangedAutomaticTypeDirectiveNames();
        }
        function clearInvalidateResolutionsOfFailedLookupLocations() {
            if (!timerToInvalidateFailedLookupResolutions)
                return false;
            host.clearTimeout(timerToInvalidateFailedLookupResolutions);
            timerToInvalidateFailedLookupResolutions = undefined;
            return true;
        }
        function scheduleInvalidateResolutionsOfFailedLookupLocations() {
            if (!host.setTimeout || !host.clearTimeout) {
                return resolutionCache.invalidateResolutionsOfFailedLookupLocations();
            }
            var pending = clearInvalidateResolutionsOfFailedLookupLocations();
            writeLog("Scheduling invalidateFailedLookup".concat(pending ? ", Cancelled earlier one" : ""));
            timerToInvalidateFailedLookupResolutions = host.setTimeout(invalidateResolutionsOfFailedLookup, 250);
        }
        function invalidateResolutionsOfFailedLookup() {
            timerToInvalidateFailedLookupResolutions = undefined;
            if (resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
                scheduleProgramUpdate();
            }
        }
        // Upon detecting a file change, wait for 250ms and then perform a recompilation. This gives batch
        // operations (such as saving all modified files in an editor) a chance to complete before we kick
        // off a new compilation.
        function scheduleProgramUpdate() {
            if (!host.setTimeout || !host.clearTimeout) {
                return;
            }
            if (timerToUpdateProgram) {
                host.clearTimeout(timerToUpdateProgram);
            }
            writeLog("Scheduling update");
            timerToUpdateProgram = host.setTimeout(updateProgramWithWatchStatus, 250);
        }
        function scheduleProgramReload() {
            ts.Debug.assert(!!configFileName);
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            scheduleProgramUpdate();
        }
        function updateProgramWithWatchStatus() {
            timerToUpdateProgram = undefined;
            reportFileChangeDetectedOnCreateProgram = true;
            updateProgram();
        }
        function updateProgram() {
            switch (reloadLevel) {
                case ts.ConfigFileProgramReloadLevel.Partial:
                    ts.perfLogger.logStartUpdateProgram("PartialConfigReload");
                    reloadFileNamesFromConfigFile();
                    break;
                case ts.ConfigFileProgramReloadLevel.Full:
                    ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                    reloadConfigFile();
                    break;
                default:
                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                    synchronizeProgram();
                    break;
            }
            ts.perfLogger.logStopUpdateProgram("Done");
            return getCurrentBuilderProgram();
        }
        function reloadFileNamesFromConfigFile() {
            writeLog("Reloading new file names and options");
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            rootFileNames = ts.getFileNamesFromConfigSpecs(compilerOptions.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost, extraFileExtensions);
            if (ts.updateErrorForNoInputFiles(rootFileNames, ts.getNormalizedAbsolutePath(configFileName, currentDirectory), compilerOptions.configFile.configFileSpecs, configFileParsingDiagnostics, canConfigFileJsonReportNoInputFiles)) {
                hasChangedConfigFileParsingErrors = true;
            }
            // Update the program
            synchronizeProgram();
        }
        function reloadConfigFile() {
            writeLog("Reloading config file: ".concat(configFileName));
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.clearCache();
            }
            parseConfigFile();
            hasChangedCompilerOptions = true;
            synchronizeProgram();
            // Update the wild card directory watch
            watchConfigFileWildCardDirectories();
            // Update extended config file watch
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        }
        function parseConfigFile() {
            setConfigFileParsingResult(ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtendForConfigFile, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend, extraFileExtensions)); // TODO: GH#18217
        }
        function setConfigFileParsingResult(configFileParseResult) {
            rootFileNames = configFileParseResult.fileNames;
            compilerOptions = configFileParseResult.options;
            watchOptions = configFileParseResult.watchOptions;
            projectReferences = configFileParseResult.projectReferences;
            wildcardDirectories = configFileParseResult.wildcardDirectories;
            configFileParsingDiagnostics = ts.getConfigFileParsingDiagnostics(configFileParseResult).slice();
            canConfigFileJsonReportNoInputFiles = ts.canJsonReportNoInputFiles(configFileParseResult.raw);
            hasChangedConfigFileParsingErrors = true;
        }
        function getParsedCommandLine(configFileName) {
            var configPath = toPath(configFileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
            if (config) {
                if (!config.reloadLevel)
                    return config.parsedCommandLine;
                // With host implementing getParsedCommandLine we cant just update file names
                if (config.parsedCommandLine && config.reloadLevel === ts.ConfigFileProgramReloadLevel.Partial && !host.getParsedCommandLine) {
                    writeLog("Reloading new file names and options");
                    var fileNames = ts.getFileNamesFromConfigSpecs(config.parsedCommandLine.options.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost);
                    config.parsedCommandLine = __assign(__assign({}, config.parsedCommandLine), { fileNames: fileNames });
                    config.reloadLevel = undefined;
                    return config.parsedCommandLine;
                }
            }
            writeLog("Loading config file: ".concat(configFileName));
            var parsedCommandLine = host.getParsedCommandLine ?
                host.getParsedCommandLine(configFileName) :
                getParsedCommandLineFromConfigFileHost(configFileName);
            if (config) {
                config.parsedCommandLine = parsedCommandLine;
                config.reloadLevel = undefined;
            }
            else {
                (parsedConfigs || (parsedConfigs = new ts.Map())).set(configPath, config = { parsedCommandLine: parsedCommandLine });
            }
            watchReferencedProject(configFileName, configPath, config);
            return parsedCommandLine;
        }
        function getParsedCommandLineFromConfigFileHost(configFileName) {
            // Ignore the file absent errors
            var onUnRecoverableConfigFileDiagnostic = parseConfigFileHost.onUnRecoverableConfigFileDiagnostic;
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
            var parsedCommandLine = ts.getParsedCommandLineOfConfigFile(configFileName, 
            /*optionsToExtend*/ undefined, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend);
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = onUnRecoverableConfigFileDiagnostic;
            return parsedCommandLine;
        }
        function onReleaseParsedCommandLine(fileName) {
            var _a;
            var path = toPath(fileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(path);
            if (!config)
                return;
            parsedConfigs.delete(path);
            if (config.watchedDirectories)
                ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
            (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
            ts.clearSharedExtendedConfigFileWatcher(path, sharedExtendedConfigFileWatchers);
        }
        function watchFilePath(path, file, callback, pollingInterval, options, watchType) {
            return watchFile(file, function (fileName, eventKind) { return callback(fileName, eventKind, path); }, pollingInterval, options, watchType);
        }
        function onSourceFileChange(fileName, eventKind, path) {
            updateCachedSystemWithFile(fileName, path, eventKind);
            // Update the source file cache
            if (eventKind === ts.FileWatcherEventKind.Deleted && sourceFilesCache.has(path)) {
                resolutionCache.invalidateResolutionOfFile(path);
            }
            nextSourceFileVersion(path);
            // Update the program
            scheduleProgramUpdate();
        }
        function updateCachedSystemWithFile(fileName, path, eventKind) {
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.addOrDeleteFile(fileName, path, eventKind);
            }
        }
        function watchMissingFilePath(missingFilePath) {
            // If watching missing referenced config file, we are already watching it so no need for separate watcher
            return (parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.has(missingFilePath)) ?
                ts.noopFileWatcher :
                watchFilePath(missingFilePath, missingFilePath, onMissingFileChange, ts.PollingInterval.Medium, watchOptions, ts.WatchType.MissingFile);
        }
        function watchPackageJsonLookupPath(packageJsonPath) {
            // If the package.json is pulled into the compilation itself (eg, via json imports), don't add a second watcher here
            return sourceFilesCache.has(packageJsonPath) ?
                ts.noopFileWatcher :
                watchFilePath(packageJsonPath, packageJsonPath, onPackageJsonChange, ts.PollingInterval.High, watchOptions, ts.WatchType.PackageJson);
        }
        function onPackageJsonChange(fileName, eventKind, path) {
            updateCachedSystemWithFile(fileName, path, eventKind);
            // package.json changes invalidate module resolution and can change the set of loaded files
            // so if we witness a change to one, we have to do a full reload
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            changesAffectResolution = true;
            // Update the program
            scheduleProgramUpdate();
        }
        function onMissingFileChange(fileName, eventKind, missingFilePath) {
            updateCachedSystemWithFile(fileName, missingFilePath, eventKind);
            if (eventKind === ts.FileWatcherEventKind.Created && missingFilesMap.has(missingFilePath)) {
                missingFilesMap.get(missingFilePath).close();
                missingFilesMap.delete(missingFilePath);
                // Delete the entry in the source files cache so that new source file is created
                nextSourceFileVersion(missingFilePath);
                // When a missing file is created, we should update the graph.
                scheduleProgramUpdate();
            }
        }
        function watchConfigFileWildCardDirectories() {
            if (wildcardDirectories) {
                ts.updateWatchingWildcardDirectories(watchedWildcardDirectories || (watchedWildcardDirectories = new ts.Map()), new ts.Map(ts.getEntries(wildcardDirectories)), watchWildcardDirectory);
            }
            else if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
            }
        }
        function watchWildcardDirectory(directory, flags) {
            return watchDirectory(directory, function (fileOrDirectory) {
                ts.Debug.assert(!!configFileName);
                var fileOrDirectoryPath = toPath(fileOrDirectory);
                // Since the file existence changed, update the sourceFiles cache
                if (cachedDirectoryStructureHost) {
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                nextSourceFileVersion(fileOrDirectoryPath);
                if (ts.isIgnoredFileFromWildCardWatching({
                    watchedDirPath: toPath(directory),
                    fileOrDirectory: fileOrDirectory,
                    fileOrDirectoryPath: fileOrDirectoryPath,
                    configFileName: configFileName,
                    extraFileExtensions: extraFileExtensions,
                    options: compilerOptions,
                    program: getCurrentBuilderProgram() || rootFileNames,
                    currentDirectory: currentDirectory,
                    useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                    writeLog: writeLog,
                    toPath: toPath,
                }))
                    return;
                // Reload is pending, do the reload
                if (reloadLevel !== ts.ConfigFileProgramReloadLevel.Full) {
                    reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                    // Schedule Update the program
                    scheduleProgramUpdate();
                }
            }, flags, watchOptions, ts.WatchType.WildcardDirectory);
        }
        function updateExtendedConfigFilesWatches(forProjectPath, options, watchOptions, watchType) {
            ts.updateSharedExtendedConfigFileWatcher(forProjectPath, options, sharedExtendedConfigFileWatchers || (sharedExtendedConfigFileWatchers = new ts.Map()), function (extendedConfigFileName, extendedConfigFilePath) { return watchFile(extendedConfigFileName, function (_fileName, eventKind) {
                var _a;
                updateCachedSystemWithFile(extendedConfigFileName, extendedConfigFilePath, eventKind);
                // Update extended config cache
                if (extendedConfigCache)
                    ts.cleanExtendedConfigCache(extendedConfigCache, extendedConfigFilePath, toPath);
                // Update projects
                var projects = (_a = sharedExtendedConfigFileWatchers.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects;
                // If there are no referenced projects this extended config file watcher depend on ignore
                if (!(projects === null || projects === void 0 ? void 0 : projects.size))
                    return;
                projects.forEach(function (projectPath) {
                    if (toPath(configFileName) === projectPath) {
                        // If this is the config file of the project, reload completely
                        reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                    }
                    else {
                        // Reload config for the referenced projects and remove the resolutions from referenced projects since the config file changed
                        var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(projectPath);
                        if (config)
                            config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                        resolutionCache.removeResolutionsFromProjectReferenceRedirects(projectPath);
                    }
                    scheduleProgramUpdate();
                });
            }, ts.PollingInterval.High, watchOptions, watchType); }, toPath);
        }
        function watchReferencedProject(configFileName, configPath, commandLine) {
            var _a, _b, _c, _d, _e;
            // Watch file
            commandLine.watcher || (commandLine.watcher = watchFile(configFileName, function (_fileName, eventKind) {
                updateCachedSystemWithFile(configFileName, configPath, eventKind);
                var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
                if (config)
                    config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                resolutionCache.removeResolutionsFromProjectReferenceRedirects(configPath);
                scheduleProgramUpdate();
            }, ts.PollingInterval.High, ((_a = commandLine.parsedCommandLine) === null || _a === void 0 ? void 0 : _a.watchOptions) || watchOptions, ts.WatchType.ConfigFileOfReferencedProject));
            // Watch Wild card
            if ((_b = commandLine.parsedCommandLine) === null || _b === void 0 ? void 0 : _b.wildcardDirectories) {
                ts.updateWatchingWildcardDirectories(commandLine.watchedDirectories || (commandLine.watchedDirectories = new ts.Map()), new ts.Map(ts.getEntries((_c = commandLine.parsedCommandLine) === null || _c === void 0 ? void 0 : _c.wildcardDirectories)), function (directory, flags) {
                    var _a;
                    return watchDirectory(directory, function (fileOrDirectory) {
                        var fileOrDirectoryPath = toPath(fileOrDirectory);
                        // Since the file existence changed, update the sourceFiles cache
                        if (cachedDirectoryStructureHost) {
                            cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                        }
                        nextSourceFileVersion(fileOrDirectoryPath);
                        var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
                        if (!(config === null || config === void 0 ? void 0 : config.parsedCommandLine))
                            return;
                        if (ts.isIgnoredFileFromWildCardWatching({
                            watchedDirPath: toPath(directory),
                            fileOrDirectory: fileOrDirectory,
                            fileOrDirectoryPath: fileOrDirectoryPath,
                            configFileName: configFileName,
                            options: config.parsedCommandLine.options,
                            program: config.parsedCommandLine.fileNames,
                            currentDirectory: currentDirectory,
                            useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                            writeLog: writeLog,
                            toPath: toPath,
                        }))
                            return;
                        // Reload is pending, do the reload
                        if (config.reloadLevel !== ts.ConfigFileProgramReloadLevel.Full) {
                            config.reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                            // Schedule Update the program
                            scheduleProgramUpdate();
                        }
                    }, flags, ((_a = commandLine.parsedCommandLine) === null || _a === void 0 ? void 0 : _a.watchOptions) || watchOptions, ts.WatchType.WildcardDirectoryOfReferencedProject);
                });
            }
            else if (commandLine.watchedDirectories) {
                ts.clearMap(commandLine.watchedDirectories, ts.closeFileWatcherOf);
                commandLine.watchedDirectories = undefined;
            }
            // Watch extended config files
            updateExtendedConfigFilesWatches(configPath, (_d = commandLine.parsedCommandLine) === null || _d === void 0 ? void 0 : _d.options, ((_e = commandLine.parsedCommandLine) === null || _e === void 0 ? void 0 : _e.watchOptions) || watchOptions, ts.WatchType.ExtendedConfigOfReferencedProject);
        }
    }
    ts.createWatchProgram = createWatchProgram;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var UpToDateStatusType;
    (function (UpToDateStatusType) {
        UpToDateStatusType[UpToDateStatusType["Unbuildable"] = 0] = "Unbuildable";
        UpToDateStatusType[UpToDateStatusType["UpToDate"] = 1] = "UpToDate";
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just touch timestamps), as if we had actually built this project.
         */
        UpToDateStatusType[UpToDateStatusType["UpToDateWithUpstreamTypes"] = 2] = "UpToDateWithUpstreamTypes";
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just manipulate outputs), as if we had actually built this project.
         */
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithPrepend"] = 3] = "OutOfDateWithPrepend";
        UpToDateStatusType[UpToDateStatusType["OutputMissing"] = 4] = "OutputMissing";
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithSelf"] = 5] = "OutOfDateWithSelf";
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithUpstream"] = 6] = "OutOfDateWithUpstream";
        UpToDateStatusType[UpToDateStatusType["UpstreamOutOfDate"] = 7] = "UpstreamOutOfDate";
        UpToDateStatusType[UpToDateStatusType["UpstreamBlocked"] = 8] = "UpstreamBlocked";
        UpToDateStatusType[UpToDateStatusType["ComputingUpstream"] = 9] = "ComputingUpstream";
        UpToDateStatusType[UpToDateStatusType["TsVersionOutputOfDate"] = 10] = "TsVersionOutputOfDate";
        /**
         * Projects with no outputs (i.e. "solution" files)
         */
        UpToDateStatusType[UpToDateStatusType["ContainerOnly"] = 11] = "ContainerOnly";
    })(UpToDateStatusType = ts.UpToDateStatusType || (ts.UpToDateStatusType = {}));
    function resolveConfigFileProjectName(project) {
        if (ts.fileExtensionIs(project, ".json" /* Extension.Json */)) {
            return project;
        }
        return ts.combinePaths(project, "tsconfig.json");
    }
    ts.resolveConfigFileProjectName = resolveConfigFileProjectName;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var minimumDate = new Date(-8640000000000000);
    var maximumDate = new Date(8640000000000000);
    var BuildResultFlags;
    (function (BuildResultFlags) {
        BuildResultFlags[BuildResultFlags["None"] = 0] = "None";
        /**
         * No errors of any kind occurred during build
         */
        BuildResultFlags[BuildResultFlags["Success"] = 1] = "Success";
        /**
         * None of the .d.ts files emitted by this build were
         * different from the existing files on disk
         */
        BuildResultFlags[BuildResultFlags["DeclarationOutputUnchanged"] = 2] = "DeclarationOutputUnchanged";
        BuildResultFlags[BuildResultFlags["ConfigFileErrors"] = 4] = "ConfigFileErrors";
        BuildResultFlags[BuildResultFlags["SyntaxErrors"] = 8] = "SyntaxErrors";
        BuildResultFlags[BuildResultFlags["TypeErrors"] = 16] = "TypeErrors";
        BuildResultFlags[BuildResultFlags["DeclarationEmitErrors"] = 32] = "DeclarationEmitErrors";
        BuildResultFlags[BuildResultFlags["EmitErrors"] = 64] = "EmitErrors";
        BuildResultFlags[BuildResultFlags["AnyErrors"] = 124] = "AnyErrors";
    })(BuildResultFlags || (BuildResultFlags = {}));
    function getOrCreateValueFromConfigFileMap(configFileMap, resolved, createT) {
        var existingValue = configFileMap.get(resolved);
        var newValue;
        if (!existingValue) {
            newValue = createT();
            configFileMap.set(resolved, newValue);
        }
        return existingValue || newValue;
    }
    function getOrCreateValueMapFromConfigFileMap(configFileMap, resolved) {
        return getOrCreateValueFromConfigFileMap(configFileMap, resolved, function () { return new ts.Map(); });
    }
    function newer(date1, date2) {
        return date2 > date1 ? date2 : date1;
    }
    /*@internal*/
    function isCircularBuildOrder(buildOrder) {
        return !!buildOrder && !!buildOrder.buildOrder;
    }
    ts.isCircularBuildOrder = isCircularBuildOrder;
    /*@internal*/
    function getBuildOrderFromAnyBuildOrder(anyBuildOrder) {
        return isCircularBuildOrder(anyBuildOrder) ? anyBuildOrder.buildOrder : anyBuildOrder;
    }
    ts.getBuildOrderFromAnyBuildOrder = getBuildOrderFromAnyBuildOrder;
    /**
     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
     */
    function createBuilderStatusReporter(system, pretty) {
        return function (diagnostic) {
            var output = pretty ? "[".concat(ts.formatColorAndReset(ts.getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey), "] ") : "".concat(ts.getLocaleTimeString(system), " - ");
            output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(system.newLine + system.newLine);
            system.write(output);
        };
    }
    ts.createBuilderStatusReporter = createBuilderStatusReporter;
    function createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) {
        var host = ts.createProgramHost(system, createProgram);
        host.getModifiedTime = system.getModifiedTime ? function (path) { return system.getModifiedTime(path); } : ts.returnUndefined;
        host.setModifiedTime = system.setModifiedTime ? function (path, date) { return system.setModifiedTime(path, date); } : ts.noop;
        host.deleteFile = system.deleteFile ? function (path) { return system.deleteFile(path); } : ts.noop;
        host.reportDiagnostic = reportDiagnostic || ts.createDiagnosticReporter(system);
        host.reportSolutionBuilderStatus = reportSolutionBuilderStatus || createBuilderStatusReporter(system);
        host.now = ts.maybeBind(system, system.now); // For testing
        return host;
    }
    function createSolutionBuilderHost(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus, reportErrorSummary) {
        if (system === void 0) { system = ts.sys; }
        var host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus);
        host.reportErrorSummary = reportErrorSummary;
        return host;
    }
    ts.createSolutionBuilderHost = createSolutionBuilderHost;
    function createSolutionBuilderWithWatchHost(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus);
        var watchHost = ts.createWatchHost(system, reportWatchStatus);
        ts.copyProperties(host, watchHost);
        return host;
    }
    ts.createSolutionBuilderWithWatchHost = createSolutionBuilderWithWatchHost;
    function getCompilerOptionsOfBuildOptions(buildOptions) {
        var result = {};
        ts.commonOptionsWithBuild.forEach(function (option) {
            if (ts.hasProperty(buildOptions, option.name))
                result[option.name] = buildOptions[option.name];
        });
        return result;
    }
    function createSolutionBuilder(host, rootNames, defaultOptions) {
        return createSolutionBuilderWorker(/*watch*/ false, host, rootNames, defaultOptions);
    }
    ts.createSolutionBuilder = createSolutionBuilder;
    function createSolutionBuilderWithWatch(host, rootNames, defaultOptions, baseWatchOptions) {
        return createSolutionBuilderWorker(/*watch*/ true, host, rootNames, defaultOptions, baseWatchOptions);
    }
    ts.createSolutionBuilderWithWatch = createSolutionBuilderWithWatch;
    function createSolutionBuilderState(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions) {
        var host = hostOrHostWithWatch;
        var hostWithWatch = hostOrHostWithWatch;
        var currentDirectory = host.getCurrentDirectory();
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        // State of the solution
        var baseCompilerOptions = getCompilerOptionsOfBuildOptions(options);
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return state.projectCompilerOptions; });
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        compilerHost.getParsedCommandLine = function (fileName) { return parseConfigFile(state, fileName, toResolvedConfigFilePath(state, fileName)); };
        compilerHost.resolveModuleNames = ts.maybeBind(host, host.resolveModuleNames);
        compilerHost.resolveTypeReferenceDirectives = ts.maybeBind(host, host.resolveTypeReferenceDirectives);
        var moduleResolutionCache = !compilerHost.resolveModuleNames ? ts.createModuleResolutionCache(currentDirectory, getCanonicalFileName) : undefined;
        var typeReferenceDirectiveResolutionCache = !compilerHost.resolveTypeReferenceDirectives ? ts.createTypeReferenceDirectiveResolutionCache(currentDirectory, getCanonicalFileName, /*options*/ undefined, moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.getPackageJsonInfoCache()) : undefined;
        if (!compilerHost.resolveModuleNames) {
            var loader_3 = function (moduleName, resolverMode, containingFile, redirectedReference) { return ts.resolveModuleName(moduleName, containingFile, state.projectCompilerOptions, compilerHost, moduleResolutionCache, redirectedReference, resolverMode).resolvedModule; };
            compilerHost.resolveModuleNames = function (moduleNames, containingFile, _reusedNames, redirectedReference, _options, containingSourceFile) {
                return ts.loadWithModeAwareCache(ts.Debug.checkEachDefined(moduleNames), ts.Debug.checkDefined(containingSourceFile), containingFile, redirectedReference, loader_3);
            };
            compilerHost.getModuleResolutionCache = function () { return moduleResolutionCache; };
        }
        if (!compilerHost.resolveTypeReferenceDirectives) {
            var loader_4 = function (moduleName, containingFile, redirectedReference, containingFileMode) { return ts.resolveTypeReferenceDirective(moduleName, containingFile, state.projectCompilerOptions, compilerHost, redirectedReference, state.typeReferenceDirectiveResolutionCache, containingFileMode).resolvedTypeReferenceDirective; };
            compilerHost.resolveTypeReferenceDirectives = function (typeReferenceDirectiveNames, containingFile, redirectedReference, _options, containingFileMode) {
                return ts.loadWithTypeDirectiveCache(ts.Debug.checkEachDefined(typeReferenceDirectiveNames), containingFile, redirectedReference, containingFileMode, loader_4);
            };
        }
        var _a = ts.createWatchFactory(hostWithWatch, options), watchFile = _a.watchFile, watchDirectory = _a.watchDirectory, writeLog = _a.writeLog;
        var state = {
            host: host,
            hostWithWatch: hostWithWatch,
            currentDirectory: currentDirectory,
            getCanonicalFileName: getCanonicalFileName,
            parseConfigFileHost: ts.parseConfigHostFromCompilerHostLike(host),
            write: ts.maybeBind(host, host.trace),
            // State of solution
            options: options,
            baseCompilerOptions: baseCompilerOptions,
            rootNames: rootNames,
            baseWatchOptions: baseWatchOptions,
            resolvedConfigFilePaths: new ts.Map(),
            configFileCache: new ts.Map(),
            projectStatus: new ts.Map(),
            buildInfoChecked: new ts.Map(),
            extendedConfigCache: new ts.Map(),
            builderPrograms: new ts.Map(),
            diagnostics: new ts.Map(),
            projectPendingBuild: new ts.Map(),
            projectErrorsReported: new ts.Map(),
            compilerHost: compilerHost,
            moduleResolutionCache: moduleResolutionCache,
            typeReferenceDirectiveResolutionCache: typeReferenceDirectiveResolutionCache,
            // Mutable state
            buildOrder: undefined,
            readFileWithCache: function (f) { return host.readFile(f); },
            projectCompilerOptions: baseCompilerOptions,
            cache: undefined,
            allProjectBuildPending: true,
            needsSummary: true,
            watchAllProjectsPending: watch,
            currentInvalidatedProject: undefined,
            // Watch state
            watch: watch,
            allWatchedWildcardDirectories: new ts.Map(),
            allWatchedInputFiles: new ts.Map(),
            allWatchedConfigFiles: new ts.Map(),
            allWatchedExtendedConfigFiles: new ts.Map(),
            allWatchedPackageJsonFiles: new ts.Map(),
            lastCachedPackageJsonLookups: new ts.Map(),
            timerToBuildInvalidatedProject: undefined,
            reportFileChangeDetected: false,
            watchFile: watchFile,
            watchDirectory: watchDirectory,
            writeLog: writeLog,
        };
        return state;
    }
    function toPath(state, fileName) {
        return ts.toPath(fileName, state.currentDirectory, state.getCanonicalFileName);
    }
    function toResolvedConfigFilePath(state, fileName) {
        var resolvedConfigFilePaths = state.resolvedConfigFilePaths;
        var path = resolvedConfigFilePaths.get(fileName);
        if (path !== undefined)
            return path;
        var resolvedPath = toPath(state, fileName);
        resolvedConfigFilePaths.set(fileName, resolvedPath);
        return resolvedPath;
    }
    function isParsedCommandLine(entry) {
        return !!entry.options;
    }
    function getCachedParsedConfigFile(state, configFilePath) {
        var value = state.configFileCache.get(configFilePath);
        return value && isParsedCommandLine(value) ? value : undefined;
    }
    function parseConfigFile(state, configFileName, configFilePath) {
        var configFileCache = state.configFileCache;
        var value = configFileCache.get(configFilePath);
        if (value) {
            return isParsedCommandLine(value) ? value : undefined;
        }
        var diagnostic;
        var parseConfigFileHost = state.parseConfigFileHost, baseCompilerOptions = state.baseCompilerOptions, baseWatchOptions = state.baseWatchOptions, extendedConfigCache = state.extendedConfigCache, host = state.host;
        var parsed;
        if (host.getParsedCommandLine) {
            parsed = host.getParsedCommandLine(configFileName);
            if (!parsed)
                diagnostic = ts.createCompilerDiagnostic(ts.Diagnostics.File_0_not_found, configFileName);
        }
        else {
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = function (d) { return diagnostic = d; };
            parsed = ts.getParsedCommandLineOfConfigFile(configFileName, baseCompilerOptions, parseConfigFileHost, extendedConfigCache, baseWatchOptions);
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
        }
        configFileCache.set(configFilePath, parsed || diagnostic);
        return parsed;
    }
    function resolveProjectName(state, name) {
        return ts.resolveConfigFileProjectName(ts.resolvePath(state.currentDirectory, name));
    }
    function createBuildOrder(state, roots) {
        var temporaryMarks = new ts.Map();
        var permanentMarks = new ts.Map();
        var circularityReportStack = [];
        var buildOrder;
        var circularDiagnostics;
        for (var _i = 0, roots_1 = roots; _i < roots_1.length; _i++) {
            var root = roots_1[_i];
            visit(root);
        }
        return circularDiagnostics ?
            { buildOrder: buildOrder || ts.emptyArray, circularDiagnostics: circularDiagnostics } :
            buildOrder || ts.emptyArray;
        function visit(configFileName, inCircularContext) {
            var projPath = toResolvedConfigFilePath(state, configFileName);
            // Already visited
            if (permanentMarks.has(projPath))
                return;
            // Circular
            if (temporaryMarks.has(projPath)) {
                if (!inCircularContext) {
                    (circularDiagnostics || (circularDiagnostics = [])).push(ts.createCompilerDiagnostic(ts.Diagnostics.Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0, circularityReportStack.join("\r\n")));
                }
                return;
            }
            temporaryMarks.set(projPath, true);
            circularityReportStack.push(configFileName);
            var parsed = parseConfigFile(state, configFileName, projPath);
            if (parsed && parsed.projectReferences) {
                for (var _i = 0, _a = parsed.projectReferences; _i < _a.length; _i++) {
                    var ref = _a[_i];
                    var resolvedRefPath = resolveProjectName(state, ref.path);
                    visit(resolvedRefPath, inCircularContext || ref.circular);
                }
            }
            circularityReportStack.pop();
            permanentMarks.set(projPath, true);
            (buildOrder || (buildOrder = [])).push(configFileName);
        }
    }
    function getBuildOrder(state) {
        return state.buildOrder || createStateBuildOrder(state);
    }
    function createStateBuildOrder(state) {
        var buildOrder = createBuildOrder(state, state.rootNames.map(function (f) { return resolveProjectName(state, f); }));
        // Clear all to ResolvedConfigFilePaths cache to start fresh
        state.resolvedConfigFilePaths.clear();
        // TODO(rbuckton): Should be a `Set`, but that requires changing the code below that uses `mutateMapSkippingNewValues`
        var currentProjects = new ts.Map(getBuildOrderFromAnyBuildOrder(buildOrder).map(function (resolved) { return [toResolvedConfigFilePath(state, resolved), true]; }));
        var noopOnDelete = { onDeleteValue: ts.noop };
        // Config file cache
        ts.mutateMapSkippingNewValues(state.configFileCache, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectStatus, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.buildInfoChecked, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.builderPrograms, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.diagnostics, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectPendingBuild, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectErrorsReported, currentProjects, noopOnDelete);
        // Remove watches for the program no longer in the solution
        if (state.watch) {
            ts.mutateMapSkippingNewValues(state.allWatchedConfigFiles, currentProjects, { onDeleteValue: ts.closeFileWatcher });
            state.allWatchedExtendedConfigFiles.forEach(function (watcher) {
                watcher.projects.forEach(function (project) {
                    if (!currentProjects.has(project)) {
                        watcher.projects.delete(project);
                    }
                });
                watcher.close();
            });
            ts.mutateMapSkippingNewValues(state.allWatchedWildcardDirectories, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcherOf); } });
            ts.mutateMapSkippingNewValues(state.allWatchedInputFiles, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcher); } });
            ts.mutateMapSkippingNewValues(state.allWatchedPackageJsonFiles, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcher); } });
        }
        return state.buildOrder = buildOrder;
    }
    function getBuildOrderFor(state, project, onlyReferences) {
        var resolvedProject = project && resolveProjectName(state, project);
        var buildOrderFromState = getBuildOrder(state);
        if (isCircularBuildOrder(buildOrderFromState))
            return buildOrderFromState;
        if (resolvedProject) {
            var projectPath_1 = toResolvedConfigFilePath(state, resolvedProject);
            var projectIndex = ts.findIndex(buildOrderFromState, function (configFileName) { return toResolvedConfigFilePath(state, configFileName) === projectPath_1; });
            if (projectIndex === -1)
                return undefined;
        }
        var buildOrder = resolvedProject ? createBuildOrder(state, [resolvedProject]) : buildOrderFromState;
        ts.Debug.assert(!isCircularBuildOrder(buildOrder));
        ts.Debug.assert(!onlyReferences || resolvedProject !== undefined);
        ts.Debug.assert(!onlyReferences || buildOrder[buildOrder.length - 1] === resolvedProject);
        return onlyReferences ? buildOrder.slice(0, buildOrder.length - 1) : buildOrder;
    }
    function enableCache(state) {
        if (state.cache) {
            disableCache(state);
        }
        var compilerHost = state.compilerHost, host = state.host;
        var originalReadFileWithCache = state.readFileWithCache;
        var originalGetSourceFile = compilerHost.getSourceFile;
        var _a = ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return toPath(state, fileName); }, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
        }), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile, getSourceFileWithCache = _a.getSourceFileWithCache, readFileWithCache = _a.readFileWithCache;
        state.readFileWithCache = readFileWithCache;
        compilerHost.getSourceFile = getSourceFileWithCache;
        state.cache = {
            originalReadFile: originalReadFile,
            originalFileExists: originalFileExists,
            originalDirectoryExists: originalDirectoryExists,
            originalCreateDirectory: originalCreateDirectory,
            originalWriteFile: originalWriteFile,
            originalReadFileWithCache: originalReadFileWithCache,
            originalGetSourceFile: originalGetSourceFile,
        };
    }
    function disableCache(state) {
        if (!state.cache)
            return;
        var cache = state.cache, host = state.host, compilerHost = state.compilerHost, extendedConfigCache = state.extendedConfigCache, moduleResolutionCache = state.moduleResolutionCache, typeReferenceDirectiveResolutionCache = state.typeReferenceDirectiveResolutionCache;
        host.readFile = cache.originalReadFile;
        host.fileExists = cache.originalFileExists;
        host.directoryExists = cache.originalDirectoryExists;
        host.createDirectory = cache.originalCreateDirectory;
        host.writeFile = cache.originalWriteFile;
        compilerHost.getSourceFile = cache.originalGetSourceFile;
        state.readFileWithCache = cache.originalReadFileWithCache;
        extendedConfigCache.clear();
        moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.clear();
        typeReferenceDirectiveResolutionCache === null || typeReferenceDirectiveResolutionCache === void 0 ? void 0 : typeReferenceDirectiveResolutionCache.clear();
        state.cache = undefined;
    }
    function clearProjectStatus(state, resolved) {
        state.projectStatus.delete(resolved);
        state.diagnostics.delete(resolved);
    }
    function addProjToQueue(_a, proj, reloadLevel) {
        var projectPendingBuild = _a.projectPendingBuild;
        var value = projectPendingBuild.get(proj);
        if (value === undefined) {
            projectPendingBuild.set(proj, reloadLevel);
        }
        else if (value < reloadLevel) {
            projectPendingBuild.set(proj, reloadLevel);
        }
    }
    function setupInitialBuild(state, cancellationToken) {
        // Set initial build if not already built
        if (!state.allProjectBuildPending)
            return;
        state.allProjectBuildPending = false;
        if (state.options.watch)
            reportWatchStatus(state, ts.Diagnostics.Starting_compilation_in_watch_mode);
        enableCache(state);
        var buildOrder = getBuildOrderFromAnyBuildOrder(getBuildOrder(state));
        buildOrder.forEach(function (configFileName) {
            return state.projectPendingBuild.set(toResolvedConfigFilePath(state, configFileName), ts.ConfigFileProgramReloadLevel.None);
        });
        if (cancellationToken) {
            cancellationToken.throwIfCancellationRequested();
        }
    }
    var InvalidatedProjectKind;
    (function (InvalidatedProjectKind) {
        InvalidatedProjectKind[InvalidatedProjectKind["Build"] = 0] = "Build";
        InvalidatedProjectKind[InvalidatedProjectKind["UpdateBundle"] = 1] = "UpdateBundle";
        InvalidatedProjectKind[InvalidatedProjectKind["UpdateOutputFileStamps"] = 2] = "UpdateOutputFileStamps";
    })(InvalidatedProjectKind = ts.InvalidatedProjectKind || (ts.InvalidatedProjectKind = {}));
    function doneInvalidatedProject(state, projectPath) {
        state.projectPendingBuild.delete(projectPath);
        state.currentInvalidatedProject = undefined;
        return state.diagnostics.has(projectPath) ?
            ts.ExitStatus.DiagnosticsPresent_OutputsSkipped :
            ts.ExitStatus.Success;
    }
    function createUpdateOutputFileStampsProject(state, project, projectPath, config, buildOrder) {
        var updateOutputFileStampsPending = true;
        return {
            kind: InvalidatedProjectKind.UpdateOutputFileStamps,
            project: project,
            projectPath: projectPath,
            buildOrder: buildOrder,
            getCompilerOptions: function () { return config.options; },
            getCurrentDirectory: function () { return state.currentDirectory; },
            updateOutputFileStatmps: function () {
                updateOutputTimestamps(state, config, projectPath);
                updateOutputFileStampsPending = false;
            },
            done: function () {
                if (updateOutputFileStampsPending) {
                    updateOutputTimestamps(state, config, projectPath);
                }
                return doneInvalidatedProject(state, projectPath);
            }
        };
    }
    var BuildStep;
    (function (BuildStep) {
        BuildStep[BuildStep["CreateProgram"] = 0] = "CreateProgram";
        BuildStep[BuildStep["SyntaxDiagnostics"] = 1] = "SyntaxDiagnostics";
        BuildStep[BuildStep["SemanticDiagnostics"] = 2] = "SemanticDiagnostics";
        BuildStep[BuildStep["Emit"] = 3] = "Emit";
        BuildStep[BuildStep["EmitBundle"] = 4] = "EmitBundle";
        BuildStep[BuildStep["EmitBuildInfo"] = 5] = "EmitBuildInfo";
        BuildStep[BuildStep["BuildInvalidatedProjectOfBundle"] = 6] = "BuildInvalidatedProjectOfBundle";
        BuildStep[BuildStep["QueueReferencingProjects"] = 7] = "QueueReferencingProjects";
        BuildStep[BuildStep["Done"] = 8] = "Done";
    })(BuildStep || (BuildStep = {}));
    function createBuildOrUpdateInvalidedProject(kind, state, project, projectPath, projectIndex, config, buildOrder) {
        var step = kind === InvalidatedProjectKind.Build ? BuildStep.CreateProgram : BuildStep.EmitBundle;
        var program;
        var buildResult;
        var invalidatedProjectOfBundle;
        return kind === InvalidatedProjectKind.Build ?
            {
                kind: kind,
                project: project,
                projectPath: projectPath,
                buildOrder: buildOrder,
                getCompilerOptions: function () { return config.options; },
                getCurrentDirectory: function () { return state.currentDirectory; },
                getBuilderProgram: function () { return withProgramOrUndefined(ts.identity); },
                getProgram: function () {
                    return withProgramOrUndefined(function (program) { return program.getProgramOrUndefined(); });
                },
                getSourceFile: function (fileName) {
                    return withProgramOrUndefined(function (program) { return program.getSourceFile(fileName); });
                },
                getSourceFiles: function () {
                    return withProgramOrEmptyArray(function (program) { return program.getSourceFiles(); });
                },
                getOptionsDiagnostics: function (cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getOptionsDiagnostics(cancellationToken); });
                },
                getGlobalDiagnostics: function (cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getGlobalDiagnostics(cancellationToken); });
                },
                getConfigFileParsingDiagnostics: function () {
                    return withProgramOrEmptyArray(function (program) { return program.getConfigFileParsingDiagnostics(); });
                },
                getSyntacticDiagnostics: function (sourceFile, cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getSyntacticDiagnostics(sourceFile, cancellationToken); });
                },
                getAllDependencies: function (sourceFile) {
                    return withProgramOrEmptyArray(function (program) { return program.getAllDependencies(sourceFile); });
                },
                getSemanticDiagnostics: function (sourceFile, cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getSemanticDiagnostics(sourceFile, cancellationToken); });
                },
                getSemanticDiagnosticsOfNextAffectedFile: function (cancellationToken, ignoreSourceFile) {
                    return withProgramOrUndefined(function (program) {
                        return (program.getSemanticDiagnosticsOfNextAffectedFile) &&
                            program.getSemanticDiagnosticsOfNextAffectedFile(cancellationToken, ignoreSourceFile);
                    });
                },
                emit: function (targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
                    if (targetSourceFile || emitOnlyDtsFiles) {
                        return withProgramOrUndefined(function (program) { var _a, _b; return program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers || ((_b = (_a = state.host).getCustomTransformers) === null || _b === void 0 ? void 0 : _b.call(_a, project))); });
                    }
                    executeSteps(BuildStep.SemanticDiagnostics, cancellationToken);
                    if (step === BuildStep.EmitBuildInfo) {
                        return emitBuildInfo(writeFile, cancellationToken);
                    }
                    if (step !== BuildStep.Emit)
                        return undefined;
                    return emit(writeFile, cancellationToken, customTransformers);
                },
                done: done
            } :
            {
                kind: kind,
                project: project,
                projectPath: projectPath,
                buildOrder: buildOrder,
                getCompilerOptions: function () { return config.options; },
                getCurrentDirectory: function () { return state.currentDirectory; },
                emit: function (writeFile, customTransformers) {
                    if (step !== BuildStep.EmitBundle)
                        return invalidatedProjectOfBundle;
                    return emitBundle(writeFile, customTransformers);
                },
                done: done,
            };
        function done(cancellationToken, writeFile, customTransformers) {
            executeSteps(BuildStep.Done, cancellationToken, writeFile, customTransformers);
            return doneInvalidatedProject(state, projectPath);
        }
        function withProgramOrUndefined(action) {
            executeSteps(BuildStep.CreateProgram);
            return program && action(program);
        }
        function withProgramOrEmptyArray(action) {
            return withProgramOrUndefined(action) || ts.emptyArray;
        }
        function createProgram() {
            var _a, _b;
            ts.Debug.assert(program === undefined);
            if (state.options.dry) {
                reportStatus(state, ts.Diagnostics.A_non_dry_build_would_build_project_0, project);
                buildResult = BuildResultFlags.Success;
                step = BuildStep.QueueReferencingProjects;
                return;
            }
            if (state.options.verbose)
                reportStatus(state, ts.Diagnostics.Building_project_0, project);
            if (config.fileNames.length === 0) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                // Nothing to build - must be a solution file, basically
                buildResult = BuildResultFlags.None;
                step = BuildStep.QueueReferencingProjects;
                return;
            }
            var host = state.host, compilerHost = state.compilerHost;
            state.projectCompilerOptions = config.options;
            // Update module resolution cache if needed
            (_a = state.moduleResolutionCache) === null || _a === void 0 ? void 0 : _a.update(config.options);
            (_b = state.typeReferenceDirectiveResolutionCache) === null || _b === void 0 ? void 0 : _b.update(config.options);
            // Create program
            program = host.createProgram(config.fileNames, config.options, compilerHost, getOldProgram(state, projectPath, config), ts.getConfigFileParsingDiagnostics(config), config.projectReferences);
            if (state.watch) {
                state.lastCachedPackageJsonLookups.set(projectPath, state.moduleResolutionCache && ts.map(state.moduleResolutionCache.getPackageJsonInfoCache().entries(), function (_a) {
                    var path = _a[0], data = _a[1];
                    return [state.host.realpath && data ? toPath(state, state.host.realpath(path)) : path, data];
                }));
                state.builderPrograms.set(projectPath, program);
            }
            step++;
        }
        function handleDiagnostics(diagnostics, errorFlags, errorType) {
            var _a;
            if (diagnostics.length) {
                (_a = buildErrors(state, projectPath, program, config, diagnostics, errorFlags, errorType), buildResult = _a.buildResult, step = _a.step);
            }
            else {
                step++;
            }
        }
        function getSyntaxDiagnostics(cancellationToken) {
            ts.Debug.assertIsDefined(program);
            handleDiagnostics(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], program.getConfigFileParsingDiagnostics(), true), program.getOptionsDiagnostics(cancellationToken), true), program.getGlobalDiagnostics(cancellationToken), true), program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken), true), BuildResultFlags.SyntaxErrors, "Syntactic");
        }
        function getSemanticDiagnostics(cancellationToken) {
            handleDiagnostics(ts.Debug.checkDefined(program).getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken), BuildResultFlags.TypeErrors, "Semantic");
        }
        function emit(writeFileCallback, cancellationToken, customTransformers) {
            var _a;
            var _b, _c;
            ts.Debug.assertIsDefined(program);
            ts.Debug.assert(step === BuildStep.Emit);
            // Before emitting lets backup state, so we can revert it back if there are declaration errors to handle emit and declaration errors correctly
            program.backupState();
            var declDiagnostics;
            var reportDeclarationDiagnostics = function (d) { return (declDiagnostics || (declDiagnostics = [])).push(d); };
            var outputFiles = [];
            var emitResult = ts.emitFilesAndReportErrors(program, reportDeclarationDiagnostics, 
            /*write*/ undefined, 
            /*reportSummary*/ undefined, function (name, text, writeByteOrderMark) { return outputFiles.push({ name: name, text: text, writeByteOrderMark: writeByteOrderMark }); }, cancellationToken, 
            /*emitOnlyDts*/ false, customTransformers || ((_c = (_b = state.host).getCustomTransformers) === null || _c === void 0 ? void 0 : _c.call(_b, project))).emitResult;
            // Don't emit .d.ts if there are decl file errors
            if (declDiagnostics) {
                program.restoreState();
                (_a = buildErrors(state, projectPath, program, config, declDiagnostics, BuildResultFlags.DeclarationEmitErrors, "Declaration file"), buildResult = _a.buildResult, step = _a.step);
                return {
                    emitSkipped: true,
                    diagnostics: emitResult.diagnostics
                };
            }
            // Actual Emit
            var host = state.host, compilerHost = state.compilerHost;
            var resultFlags = BuildResultFlags.DeclarationOutputUnchanged;
            var newestDeclarationFileContentChangedTime = minimumDate;
            var anyDtsChanged = false;
            var emitterDiagnostics = ts.createDiagnosticCollection();
            var emittedOutputs = new ts.Map();
            outputFiles.forEach(function (_a) {
                var name = _a.name, text = _a.text, writeByteOrderMark = _a.writeByteOrderMark;
                var priorChangeTime;
                if (!anyDtsChanged && ts.isDeclarationFileName(name)) {
                    // Check for unchanged .d.ts files
                    if (host.fileExists(name) && state.readFileWithCache(name) === text) {
                        priorChangeTime = host.getModifiedTime(name);
                    }
                    else {
                        resultFlags &= ~BuildResultFlags.DeclarationOutputUnchanged;
                        anyDtsChanged = true;
                    }
                }
                emittedOutputs.set(toPath(state, name), name);
                ts.writeFile(writeFileCallback ? { writeFile: writeFileCallback } : compilerHost, emitterDiagnostics, name, text, writeByteOrderMark);
                if (priorChangeTime !== undefined) {
                    newestDeclarationFileContentChangedTime = newer(priorChangeTime, newestDeclarationFileContentChangedTime);
                }
            });
            finishEmit(emitterDiagnostics, emittedOutputs, newestDeclarationFileContentChangedTime, 
            /*newestDeclarationFileContentChangedTimeIsMaximumDate*/ anyDtsChanged, outputFiles.length ? outputFiles[0].name : ts.getFirstProjectOutput(config, !host.useCaseSensitiveFileNames()), resultFlags);
            return emitResult;
        }
        function emitBuildInfo(writeFileCallback, cancellationToken) {
            ts.Debug.assertIsDefined(program);
            ts.Debug.assert(step === BuildStep.EmitBuildInfo);
            var emitResult = program.emitBuildInfo(writeFileCallback, cancellationToken);
            if (emitResult.diagnostics.length) {
                reportErrors(state, emitResult.diagnostics);
                state.diagnostics.set(projectPath, __spreadArray(__spreadArray([], state.diagnostics.get(projectPath), true), emitResult.diagnostics, true));
                buildResult = BuildResultFlags.EmitErrors & buildResult;
            }
            if (emitResult.emittedFiles && state.write) {
                emitResult.emittedFiles.forEach(function (name) { return listEmittedFile(state, config, name); });
            }
            afterProgramDone(state, program, config);
            step = BuildStep.QueueReferencingProjects;
            return emitResult;
        }
        function finishEmit(emitterDiagnostics, emittedOutputs, priorNewestUpdateTime, newestDeclarationFileContentChangedTimeIsMaximumDate, oldestOutputFileName, resultFlags) {
            var _a;
            var emitDiagnostics = emitterDiagnostics.getDiagnostics();
            if (emitDiagnostics.length) {
                (_a = buildErrors(state, projectPath, program, config, emitDiagnostics, BuildResultFlags.EmitErrors, "Emit"), buildResult = _a.buildResult, step = _a.step);
                return emitDiagnostics;
            }
            if (state.write) {
                emittedOutputs.forEach(function (name) { return listEmittedFile(state, config, name); });
            }
            // Update time stamps for rest of the outputs
            var newestDeclarationFileContentChangedTime = updateOutputTimestampsWorker(state, config, priorNewestUpdateTime, ts.Diagnostics.Updating_unchanged_output_timestamps_of_project_0, emittedOutputs);
            state.diagnostics.delete(projectPath);
            state.projectStatus.set(projectPath, {
                type: ts.UpToDateStatusType.UpToDate,
                newestDeclarationFileContentChangedTime: newestDeclarationFileContentChangedTimeIsMaximumDate ?
                    maximumDate :
                    newestDeclarationFileContentChangedTime,
                oldestOutputFileName: oldestOutputFileName
            });
            afterProgramDone(state, program, config);
            step = BuildStep.QueueReferencingProjects;
            buildResult = resultFlags;
            return emitDiagnostics;
        }
        function emitBundle(writeFileCallback, customTransformers) {
            var _a, _b;
            ts.Debug.assert(kind === InvalidatedProjectKind.UpdateBundle);
            if (state.options.dry) {
                reportStatus(state, ts.Diagnostics.A_non_dry_build_would_update_output_of_project_0, project);
                buildResult = BuildResultFlags.Success;
                step = BuildStep.QueueReferencingProjects;
                return undefined;
            }
            if (state.options.verbose)
                reportStatus(state, ts.Diagnostics.Updating_output_of_project_0, project);
            // Update js, and source map
            var compilerHost = state.compilerHost;
            state.projectCompilerOptions = config.options;
            var outputFiles = ts.emitUsingBuildInfo(config, compilerHost, function (ref) {
                var refName = resolveProjectName(state, ref.path);
                return parseConfigFile(state, refName, toResolvedConfigFilePath(state, refName));
            }, customTransformers || ((_b = (_a = state.host).getCustomTransformers) === null || _b === void 0 ? void 0 : _b.call(_a, project)));
            if (ts.isString(outputFiles)) {
                reportStatus(state, ts.Diagnostics.Cannot_update_output_of_project_0_because_there_was_error_reading_file_1, project, relName(state, outputFiles));
                step = BuildStep.BuildInvalidatedProjectOfBundle;
                return invalidatedProjectOfBundle = createBuildOrUpdateInvalidedProject(InvalidatedProjectKind.Build, state, project, projectPath, projectIndex, config, buildOrder);
            }
            // Actual Emit
            ts.Debug.assert(!!outputFiles.length);
            var emitterDiagnostics = ts.createDiagnosticCollection();
            var emittedOutputs = new ts.Map();
            outputFiles.forEach(function (_a) {
                var name = _a.name, text = _a.text, writeByteOrderMark = _a.writeByteOrderMark;
                emittedOutputs.set(toPath(state, name), name);
                ts.writeFile(writeFileCallback ? { writeFile: writeFileCallback } : compilerHost, emitterDiagnostics, name, text, writeByteOrderMark);
            });
            var emitDiagnostics = finishEmit(emitterDiagnostics, emittedOutputs, minimumDate, 
            /*newestDeclarationFileContentChangedTimeIsMaximumDate*/ false, outputFiles[0].name, BuildResultFlags.DeclarationOutputUnchanged);
            return { emitSkipped: false, diagnostics: emitDiagnostics };
        }
        function executeSteps(till, cancellationToken, writeFile, customTransformers) {
            while (step <= till && step < BuildStep.Done) {
                var currentStep = step;
                switch (step) {
                    case BuildStep.CreateProgram:
                        createProgram();
                        break;
                    case BuildStep.SyntaxDiagnostics:
                        getSyntaxDiagnostics(cancellationToken);
                        break;
                    case BuildStep.SemanticDiagnostics:
                        getSemanticDiagnostics(cancellationToken);
                        break;
                    case BuildStep.Emit:
                        emit(writeFile, cancellationToken, customTransformers);
                        break;
                    case BuildStep.EmitBuildInfo:
                        emitBuildInfo(writeFile, cancellationToken);
                        break;
                    case BuildStep.EmitBundle:
                        emitBundle(writeFile, customTransformers);
                        break;
                    case BuildStep.BuildInvalidatedProjectOfBundle:
                        ts.Debug.checkDefined(invalidatedProjectOfBundle).done(cancellationToken, writeFile, customTransformers);
                        step = BuildStep.Done;
                        break;
                    case BuildStep.QueueReferencingProjects:
                        queueReferencingProjects(state, project, projectPath, projectIndex, config, buildOrder, ts.Debug.checkDefined(buildResult));
                        step++;
                        break;
                    // Should never be done
                    case BuildStep.Done:
                    default:
                        ts.assertType(step);
                }
                ts.Debug.assert(step > currentStep);
            }
        }
    }
    function needsBuild(_a, status, config) {
        var options = _a.options;
        if (status.type !== ts.UpToDateStatusType.OutOfDateWithPrepend || options.force)
            return true;
        return config.fileNames.length === 0 ||
            !!ts.getConfigFileParsingDiagnostics(config).length ||
            !ts.isIncrementalCompilation(config.options);
    }
    function getNextInvalidatedProject(state, buildOrder, reportQueue) {
        if (!state.projectPendingBuild.size)
            return undefined;
        if (isCircularBuildOrder(buildOrder))
            return undefined;
        if (state.currentInvalidatedProject) {
            // Only if same buildOrder the currentInvalidated project can be sent again
            return ts.arrayIsEqualTo(state.currentInvalidatedProject.buildOrder, buildOrder) ?
                state.currentInvalidatedProject :
                undefined;
        }
        var options = state.options, projectPendingBuild = state.projectPendingBuild;
        for (var projectIndex = 0; projectIndex < buildOrder.length; projectIndex++) {
            var project = buildOrder[projectIndex];
            var projectPath = toResolvedConfigFilePath(state, project);
            var reloadLevel = state.projectPendingBuild.get(projectPath);
            if (reloadLevel === undefined)
                continue;
            if (reportQueue) {
                reportQueue = false;
                reportBuildQueue(state, buildOrder);
            }
            var config = parseConfigFile(state, project, projectPath);
            if (!config) {
                reportParseConfigFileDiagnostic(state, projectPath);
                projectPendingBuild.delete(projectPath);
                continue;
            }
            if (reloadLevel === ts.ConfigFileProgramReloadLevel.Full) {
                watchConfigFile(state, project, projectPath, config);
                watchExtendedConfigFiles(state, projectPath, config);
                watchWildCardDirectories(state, project, projectPath, config);
                watchInputFiles(state, project, projectPath, config);
                watchPackageJsonFiles(state, project, projectPath, config);
            }
            else if (reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
                // Update file names
                config.fileNames = ts.getFileNamesFromConfigSpecs(config.options.configFile.configFileSpecs, ts.getDirectoryPath(project), config.options, state.parseConfigFileHost);
                ts.updateErrorForNoInputFiles(config.fileNames, project, config.options.configFile.configFileSpecs, config.errors, ts.canJsonReportNoInputFiles(config.raw));
                watchInputFiles(state, project, projectPath, config);
                watchPackageJsonFiles(state, project, projectPath, config);
            }
            var status = getUpToDateStatus(state, config, projectPath);
            verboseReportProjectStatus(state, project, status);
            if (!options.force) {
                if (status.type === ts.UpToDateStatusType.UpToDate) {
                    reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                    projectPendingBuild.delete(projectPath);
                    // Up to date, skip
                    if (options.dry) {
                        // In a dry build, inform the user of this fact
                        reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date, project);
                    }
                    continue;
                }
                if (status.type === ts.UpToDateStatusType.UpToDateWithUpstreamTypes) {
                    reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                    return createUpdateOutputFileStampsProject(state, project, projectPath, config, buildOrder);
                }
            }
            if (status.type === ts.UpToDateStatusType.UpstreamBlocked) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                projectPendingBuild.delete(projectPath);
                if (options.verbose) {
                    reportStatus(state, status.upstreamProjectBlocked ?
                        ts.Diagnostics.Skipping_build_of_project_0_because_its_dependency_1_was_not_built :
                        ts.Diagnostics.Skipping_build_of_project_0_because_its_dependency_1_has_errors, project, status.upstreamProjectName);
                }
                continue;
            }
            if (status.type === ts.UpToDateStatusType.ContainerOnly) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                projectPendingBuild.delete(projectPath);
                // Do nothing
                continue;
            }
            return createBuildOrUpdateInvalidedProject(needsBuild(state, status, config) ?
                InvalidatedProjectKind.Build :
                InvalidatedProjectKind.UpdateBundle, state, project, projectPath, projectIndex, config, buildOrder);
        }
        return undefined;
    }
    function listEmittedFile(_a, proj, file) {
        var write = _a.write;
        if (write && proj.options.listEmittedFiles) {
            write("TSFILE: ".concat(file));
        }
    }
    function getOldProgram(_a, proj, parsed) {
        var options = _a.options, builderPrograms = _a.builderPrograms, compilerHost = _a.compilerHost;
        if (options.force)
            return undefined;
        var value = builderPrograms.get(proj);
        if (value)
            return value;
        return ts.readBuilderProgram(parsed.options, compilerHost);
    }
    function afterProgramDone(state, program, config) {
        if (program) {
            if (program && state.write)
                ts.listFiles(program, state.write);
            if (state.host.afterProgramEmitAndDiagnostics) {
                state.host.afterProgramEmitAndDiagnostics(program);
            }
            program.releaseProgram();
        }
        else if (state.host.afterEmitBundle) {
            state.host.afterEmitBundle(config);
        }
        state.projectCompilerOptions = state.baseCompilerOptions;
    }
    function buildErrors(state, resolvedPath, program, config, diagnostics, buildResult, errorType) {
        var canEmitBuildInfo = !(buildResult & BuildResultFlags.SyntaxErrors) && program && !ts.outFile(program.getCompilerOptions());
        reportAndStoreErrors(state, resolvedPath, diagnostics);
        state.projectStatus.set(resolvedPath, { type: ts.UpToDateStatusType.Unbuildable, reason: "".concat(errorType, " errors") });
        if (canEmitBuildInfo)
            return { buildResult: buildResult, step: BuildStep.EmitBuildInfo };
        afterProgramDone(state, program, config);
        return { buildResult: buildResult, step: BuildStep.QueueReferencingProjects };
    }
    function checkConfigFileUpToDateStatus(state, configFile, oldestOutputFileTime, oldestOutputFileName) {
        // Check tsconfig time
        var tsconfigTime = ts.getModifiedTime(state.host, configFile);
        if (oldestOutputFileTime < tsconfigTime) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithSelf,
                outOfDateOutputFileName: oldestOutputFileName,
                newerInputFileName: configFile
            };
        }
    }
    function getUpToDateStatusWorker(state, project, resolvedPath) {
        var force = !!state.options.force;
        var newestInputFileName = undefined;
        var newestInputFileTime = minimumDate;
        var host = state.host;
        // Get timestamps of input files
        for (var _i = 0, _a = project.fileNames; _i < _a.length; _i++) {
            var inputFile = _a[_i];
            if (!host.fileExists(inputFile)) {
                return {
                    type: ts.UpToDateStatusType.Unbuildable,
                    reason: "".concat(inputFile, " does not exist")
                };
            }
            if (!force) {
                var inputTime = ts.getModifiedTime(host, inputFile);
                if (inputTime > newestInputFileTime) {
                    newestInputFileName = inputFile;
                    newestInputFileTime = inputTime;
                }
            }
        }
        // Container if no files are specified in the project
        if (!project.fileNames.length && !ts.canJsonReportNoInputFiles(project.raw)) {
            return {
                type: ts.UpToDateStatusType.ContainerOnly
            };
        }
        // Collect the expected outputs of this project
        var outputs = ts.getAllProjectOutputs(project, !host.useCaseSensitiveFileNames());
        // Now see if all outputs are newer than the newest input
        var oldestOutputFileName = "(none)";
        var oldestOutputFileTime = maximumDate;
        var newestOutputFileName = "(none)";
        var newestOutputFileTime = minimumDate;
        var missingOutputFileName;
        var newestDeclarationFileContentChangedTime = minimumDate;
        var isOutOfDateWithInputs = false;
        if (!force) {
            for (var _b = 0, outputs_1 = outputs; _b < outputs_1.length; _b++) {
                var output = outputs_1[_b];
                // Output is missing; can stop checking
                // Don't immediately return because we can still be upstream-blocked, which is a higher-priority status
                if (!host.fileExists(output)) {
                    missingOutputFileName = output;
                    break;
                }
                var outputTime = ts.getModifiedTime(host, output);
                if (outputTime < oldestOutputFileTime) {
                    oldestOutputFileTime = outputTime;
                    oldestOutputFileName = output;
                }
                // If an output is older than the newest input, we can stop checking
                // Don't immediately return because we can still be upstream-blocked, which is a higher-priority status
                if (outputTime < newestInputFileTime) {
                    isOutOfDateWithInputs = true;
                    break;
                }
                if (outputTime > newestOutputFileTime) {
                    newestOutputFileTime = outputTime;
                    newestOutputFileName = output;
                }
                // Keep track of when the most recent time a .d.ts file was changed.
                // In addition to file timestamps, we also keep track of when a .d.ts file
                // had its file touched but not had its contents changed - this allows us
                // to skip a downstream typecheck
                if (ts.isDeclarationFileName(output)) {
                    var outputModifiedTime = ts.getModifiedTime(host, output);
                    newestDeclarationFileContentChangedTime = newer(newestDeclarationFileContentChangedTime, outputModifiedTime);
                }
            }
        }
        var pseudoUpToDate = false;
        var usesPrepend = false;
        var upstreamChangedProject;
        if (project.projectReferences) {
            state.projectStatus.set(resolvedPath, { type: ts.UpToDateStatusType.ComputingUpstream });
            for (var _c = 0, _d = project.projectReferences; _c < _d.length; _c++) {
                var ref = _d[_c];
                usesPrepend = usesPrepend || !!(ref.prepend);
                var resolvedRef = ts.resolveProjectReferencePath(ref);
                var resolvedRefPath = toResolvedConfigFilePath(state, resolvedRef);
                var refStatus = getUpToDateStatus(state, parseConfigFile(state, resolvedRef, resolvedRefPath), resolvedRefPath);
                // Its a circular reference ignore the status of this project
                if (refStatus.type === ts.UpToDateStatusType.ComputingUpstream ||
                    refStatus.type === ts.UpToDateStatusType.ContainerOnly) { // Container only ignore this project
                    continue;
                }
                // An upstream project is blocked
                if (refStatus.type === ts.UpToDateStatusType.Unbuildable ||
                    refStatus.type === ts.UpToDateStatusType.UpstreamBlocked) {
                    return {
                        type: ts.UpToDateStatusType.UpstreamBlocked,
                        upstreamProjectName: ref.path,
                        upstreamProjectBlocked: refStatus.type === ts.UpToDateStatusType.UpstreamBlocked
                    };
                }
                // If the upstream project is out of date, then so are we (someone shouldn't have asked, though?)
                if (refStatus.type !== ts.UpToDateStatusType.UpToDate) {
                    return {
                        type: ts.UpToDateStatusType.UpstreamOutOfDate,
                        upstreamProjectName: ref.path
                    };
                }
                // Check oldest output file name only if there is no missing output file name
                // (a check we will have skipped if this is a forced build)
                if (!force && !missingOutputFileName) {
                    // If the upstream project's newest file is older than our oldest output, we
                    // can't be out of date because of it
                    if (refStatus.newestInputFileTime && refStatus.newestInputFileTime <= oldestOutputFileTime) {
                        continue;
                    }
                    // If the upstream project has only change .d.ts files, and we've built
                    // *after* those files, then we're "psuedo up to date" and eligible for a fast rebuild
                    if (refStatus.newestDeclarationFileContentChangedTime && refStatus.newestDeclarationFileContentChangedTime <= oldestOutputFileTime) {
                        pseudoUpToDate = true;
                        upstreamChangedProject = ref.path;
                        continue;
                    }
                    // We have an output older than an upstream output - we are out of date
                    ts.Debug.assert(oldestOutputFileName !== undefined, "Should have an oldest output filename here");
                    return {
                        type: ts.UpToDateStatusType.OutOfDateWithUpstream,
                        outOfDateOutputFileName: oldestOutputFileName,
                        newerProjectName: ref.path
                    };
                }
            }
        }
        if (missingOutputFileName !== undefined) {
            return {
                type: ts.UpToDateStatusType.OutputMissing,
                missingOutputFileName: missingOutputFileName
            };
        }
        if (isOutOfDateWithInputs) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithSelf,
                outOfDateOutputFileName: oldestOutputFileName,
                newerInputFileName: newestInputFileName
            };
        }
        else {
            // Check tsconfig time
            var configStatus = checkConfigFileUpToDateStatus(state, project.options.configFilePath, oldestOutputFileTime, oldestOutputFileName);
            if (configStatus)
                return configStatus;
            // Check extended config time
            var extendedConfigStatus = ts.forEach(project.options.configFile.extendedSourceFiles || ts.emptyArray, function (configFile) { return checkConfigFileUpToDateStatus(state, configFile, oldestOutputFileTime, oldestOutputFileName); });
            if (extendedConfigStatus)
                return extendedConfigStatus;
            // Check package file time
            var dependentPackageFileStatus = ts.forEach(state.lastCachedPackageJsonLookups.get(resolvedPath) || ts.emptyArray, function (_a) {
                var path = _a[0];
                return checkConfigFileUpToDateStatus(state, path, oldestOutputFileTime, oldestOutputFileName);
            });
            if (dependentPackageFileStatus)
                return dependentPackageFileStatus;
        }
        if (!force && !state.buildInfoChecked.has(resolvedPath)) {
            state.buildInfoChecked.set(resolvedPath, true);
            var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(project.options);
            if (buildInfoPath) {
                var value = state.readFileWithCache(buildInfoPath);
                var buildInfo = value && ts.getBuildInfo(value);
                if (buildInfo && (buildInfo.bundle || buildInfo.program) && buildInfo.version !== ts.version) {
                    return {
                        type: ts.UpToDateStatusType.TsVersionOutputOfDate,
                        version: buildInfo.version
                    };
                }
            }
        }
        if (usesPrepend && pseudoUpToDate) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithPrepend,
                outOfDateOutputFileName: oldestOutputFileName,
                newerProjectName: upstreamChangedProject
            };
        }
        // Up to date
        return {
            type: pseudoUpToDate ? ts.UpToDateStatusType.UpToDateWithUpstreamTypes : ts.UpToDateStatusType.UpToDate,
            newestDeclarationFileContentChangedTime: newestDeclarationFileContentChangedTime,
            newestInputFileTime: newestInputFileTime,
            newestOutputFileTime: newestOutputFileTime,
            newestInputFileName: newestInputFileName,
            newestOutputFileName: newestOutputFileName,
            oldestOutputFileName: oldestOutputFileName
        };
    }
    function getUpToDateStatus(state, project, resolvedPath) {
        if (project === undefined) {
            return { type: ts.UpToDateStatusType.Unbuildable, reason: "File deleted mid-build" };
        }
        var prior = state.projectStatus.get(resolvedPath);
        if (prior !== undefined) {
            return prior;
        }
        var actual = getUpToDateStatusWorker(state, project, resolvedPath);
        state.projectStatus.set(resolvedPath, actual);
        return actual;
    }
    function updateOutputTimestampsWorker(state, proj, priorNewestUpdateTime, verboseMessage, skipOutputs) {
        if (proj.options.noEmit)
            return priorNewestUpdateTime;
        var host = state.host;
        var outputs = ts.getAllProjectOutputs(proj, !host.useCaseSensitiveFileNames());
        if (!skipOutputs || outputs.length !== skipOutputs.size) {
            var reportVerbose = !!state.options.verbose;
            var now = host.now ? host.now() : new Date();
            for (var _i = 0, outputs_2 = outputs; _i < outputs_2.length; _i++) {
                var file = outputs_2[_i];
                if (skipOutputs && skipOutputs.has(toPath(state, file))) {
                    continue;
                }
                if (reportVerbose) {
                    reportVerbose = false;
                    reportStatus(state, verboseMessage, proj.options.configFilePath);
                }
                if (ts.isDeclarationFileName(file)) {
                    priorNewestUpdateTime = newer(priorNewestUpdateTime, ts.getModifiedTime(host, file));
                }
                host.setModifiedTime(file, now);
            }
        }
        return priorNewestUpdateTime;
    }
    function updateOutputTimestamps(state, proj, resolvedPath) {
        if (state.options.dry) {
            return reportStatus(state, ts.Diagnostics.A_non_dry_build_would_update_timestamps_for_output_of_project_0, proj.options.configFilePath);
        }
        var priorNewestUpdateTime = updateOutputTimestampsWorker(state, proj, minimumDate, ts.Diagnostics.Updating_output_timestamps_of_project_0);
        state.projectStatus.set(resolvedPath, {
            type: ts.UpToDateStatusType.UpToDate,
            newestDeclarationFileContentChangedTime: priorNewestUpdateTime,
            oldestOutputFileName: ts.getFirstProjectOutput(proj, !state.host.useCaseSensitiveFileNames())
        });
    }
    function queueReferencingProjects(state, project, projectPath, projectIndex, config, buildOrder, buildResult) {
        // Queue only if there are no errors
        if (buildResult & BuildResultFlags.AnyErrors)
            return;
        // Only composite projects can be referenced by other projects
        if (!config.options.composite)
            return;
        // Always use build order to queue projects
        for (var index = projectIndex + 1; index < buildOrder.length; index++) {
            var nextProject = buildOrder[index];
            var nextProjectPath = toResolvedConfigFilePath(state, nextProject);
            if (state.projectPendingBuild.has(nextProjectPath))
                continue;
            var nextProjectConfig = parseConfigFile(state, nextProject, nextProjectPath);
            if (!nextProjectConfig || !nextProjectConfig.projectReferences)
                continue;
            for (var _i = 0, _a = nextProjectConfig.projectReferences; _i < _a.length; _i++) {
                var ref = _a[_i];
                var resolvedRefPath = resolveProjectName(state, ref.path);
                if (toResolvedConfigFilePath(state, resolvedRefPath) !== projectPath)
                    continue;
                // If the project is referenced with prepend, always build downstream projects,
                // If declaration output is changed, build the project
                // otherwise mark the project UpToDateWithUpstreamTypes so it updates output time stamps
                var status = state.projectStatus.get(nextProjectPath);
                if (status) {
                    switch (status.type) {
                        case ts.UpToDateStatusType.UpToDate:
                            if (buildResult & BuildResultFlags.DeclarationOutputUnchanged) {
                                if (ref.prepend) {
                                    state.projectStatus.set(nextProjectPath, {
                                        type: ts.UpToDateStatusType.OutOfDateWithPrepend,
                                        outOfDateOutputFileName: status.oldestOutputFileName,
                                        newerProjectName: project
                                    });
                                }
                                else {
                                    status.type = ts.UpToDateStatusType.UpToDateWithUpstreamTypes;
                                }
                                break;
                            }
                        // falls through
                        case ts.UpToDateStatusType.UpToDateWithUpstreamTypes:
                        case ts.UpToDateStatusType.OutOfDateWithPrepend:
                            if (!(buildResult & BuildResultFlags.DeclarationOutputUnchanged)) {
                                state.projectStatus.set(nextProjectPath, {
                                    type: ts.UpToDateStatusType.OutOfDateWithUpstream,
                                    outOfDateOutputFileName: status.type === ts.UpToDateStatusType.OutOfDateWithPrepend ? status.outOfDateOutputFileName : status.oldestOutputFileName,
                                    newerProjectName: project
                                });
                            }
                            break;
                        case ts.UpToDateStatusType.UpstreamBlocked:
                            if (toResolvedConfigFilePath(state, resolveProjectName(state, status.upstreamProjectName)) === projectPath) {
                                clearProjectStatus(state, nextProjectPath);
                            }
                            break;
                    }
                }
                addProjToQueue(state, nextProjectPath, ts.ConfigFileProgramReloadLevel.None);
                break;
            }
        }
    }
    function build(state, project, cancellationToken, writeFile, getCustomTransformers, onlyReferences) {
        var buildOrder = getBuildOrderFor(state, project, onlyReferences);
        if (!buildOrder)
            return ts.ExitStatus.InvalidProject_OutputsSkipped;
        setupInitialBuild(state, cancellationToken);
        var reportQueue = true;
        var successfulProjects = 0;
        while (true) {
            var invalidatedProject = getNextInvalidatedProject(state, buildOrder, reportQueue);
            if (!invalidatedProject)
                break;
            reportQueue = false;
            invalidatedProject.done(cancellationToken, writeFile, getCustomTransformers === null || getCustomTransformers === void 0 ? void 0 : getCustomTransformers(invalidatedProject.project));
            if (!state.diagnostics.has(invalidatedProject.projectPath))
                successfulProjects++;
        }
        disableCache(state);
        reportErrorSummary(state, buildOrder);
        startWatching(state, buildOrder);
        return isCircularBuildOrder(buildOrder)
            ? ts.ExitStatus.ProjectReferenceCycle_OutputsSkipped
            : !buildOrder.some(function (p) { return state.diagnostics.has(toResolvedConfigFilePath(state, p)); })
                ? ts.ExitStatus.Success
                : successfulProjects
                    ? ts.ExitStatus.DiagnosticsPresent_OutputsGenerated
                    : ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
    }
    function clean(state, project, onlyReferences) {
        var buildOrder = getBuildOrderFor(state, project, onlyReferences);
        if (!buildOrder)
            return ts.ExitStatus.InvalidProject_OutputsSkipped;
        if (isCircularBuildOrder(buildOrder)) {
            reportErrors(state, buildOrder.circularDiagnostics);
            return ts.ExitStatus.ProjectReferenceCycle_OutputsSkipped;
        }
        var options = state.options, host = state.host;
        var filesToDelete = options.dry ? [] : undefined;
        for (var _i = 0, buildOrder_1 = buildOrder; _i < buildOrder_1.length; _i++) {
            var proj = buildOrder_1[_i];
            var resolvedPath = toResolvedConfigFilePath(state, proj);
            var parsed = parseConfigFile(state, proj, resolvedPath);
            if (parsed === undefined) {
                // File has gone missing; fine to ignore here
                reportParseConfigFileDiagnostic(state, resolvedPath);
                continue;
            }
            var outputs = ts.getAllProjectOutputs(parsed, !host.useCaseSensitiveFileNames());
            if (!outputs.length)
                continue;
            var inputFileNames = new ts.Set(parsed.fileNames.map(function (f) { return toPath(state, f); }));
            for (var _a = 0, outputs_3 = outputs; _a < outputs_3.length; _a++) {
                var output = outputs_3[_a];
                // If output name is same as input file name, do not delete and ignore the error
                if (inputFileNames.has(toPath(state, output)))
                    continue;
                if (host.fileExists(output)) {
                    if (filesToDelete) {
                        filesToDelete.push(output);
                    }
                    else {
                        host.deleteFile(output);
                        invalidateProject(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None);
                    }
                }
            }
        }
        if (filesToDelete) {
            reportStatus(state, ts.Diagnostics.A_non_dry_build_would_delete_the_following_files_Colon_0, filesToDelete.map(function (f) { return "\r\n * ".concat(f); }).join(""));
        }
        return ts.ExitStatus.Success;
    }
    function invalidateProject(state, resolved, reloadLevel) {
        // If host implements getParsedCommandLine, we cant get list of files from parseConfigFileHost
        if (state.host.getParsedCommandLine && reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
        }
        if (reloadLevel === ts.ConfigFileProgramReloadLevel.Full) {
            state.configFileCache.delete(resolved);
            state.buildOrder = undefined;
        }
        state.needsSummary = true;
        clearProjectStatus(state, resolved);
        addProjToQueue(state, resolved, reloadLevel);
        enableCache(state);
    }
    function invalidateProjectAndScheduleBuilds(state, resolvedPath, reloadLevel) {
        state.reportFileChangeDetected = true;
        invalidateProject(state, resolvedPath, reloadLevel);
        scheduleBuildInvalidatedProject(state);
    }
    function scheduleBuildInvalidatedProject(state) {
        var hostWithWatch = state.hostWithWatch;
        if (!hostWithWatch.setTimeout || !hostWithWatch.clearTimeout) {
            return;
        }
        if (state.timerToBuildInvalidatedProject) {
            hostWithWatch.clearTimeout(state.timerToBuildInvalidatedProject);
        }
        state.timerToBuildInvalidatedProject = hostWithWatch.setTimeout(buildNextInvalidatedProject, 250, state);
    }
    function buildNextInvalidatedProject(state) {
        state.timerToBuildInvalidatedProject = undefined;
        if (state.reportFileChangeDetected) {
            state.reportFileChangeDetected = false;
            state.projectErrorsReported.clear();
            reportWatchStatus(state, ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
        }
        var buildOrder = getBuildOrder(state);
        var invalidatedProject = getNextInvalidatedProject(state, buildOrder, /*reportQueue*/ false);
        if (invalidatedProject) {
            invalidatedProject.done();
            if (state.projectPendingBuild.size) {
                // Schedule next project for build
                if (state.watch && !state.timerToBuildInvalidatedProject) {
                    scheduleBuildInvalidatedProject(state);
                }
                return;
            }
        }
        disableCache(state);
        reportErrorSummary(state, buildOrder);
    }
    function watchConfigFile(state, resolved, resolvedPath, parsed) {
        if (!state.watch || state.allWatchedConfigFiles.has(resolvedPath))
            return;
        state.allWatchedConfigFiles.set(resolvedPath, state.watchFile(resolved, function () {
            invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Full);
        }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.ConfigFile, resolved));
    }
    function watchExtendedConfigFiles(state, resolvedPath, parsed) {
        ts.updateSharedExtendedConfigFileWatcher(resolvedPath, parsed === null || parsed === void 0 ? void 0 : parsed.options, state.allWatchedExtendedConfigFiles, function (extendedConfigFileName, extendedConfigFilePath) { return state.watchFile(extendedConfigFileName, function () {
            var _a;
            return (_a = state.allWatchedExtendedConfigFiles.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects.forEach(function (projectConfigFilePath) {
                return invalidateProjectAndScheduleBuilds(state, projectConfigFilePath, ts.ConfigFileProgramReloadLevel.Full);
            });
        }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.ExtendedConfigFile); }, function (fileName) { return toPath(state, fileName); });
    }
    function watchWildCardDirectories(state, resolved, resolvedPath, parsed) {
        if (!state.watch)
            return;
        ts.updateWatchingWildcardDirectories(getOrCreateValueMapFromConfigFileMap(state.allWatchedWildcardDirectories, resolvedPath), new ts.Map(ts.getEntries(parsed.wildcardDirectories)), function (dir, flags) { return state.watchDirectory(dir, function (fileOrDirectory) {
            var _a;
            if (ts.isIgnoredFileFromWildCardWatching({
                watchedDirPath: toPath(state, dir),
                fileOrDirectory: fileOrDirectory,
                fileOrDirectoryPath: toPath(state, fileOrDirectory),
                configFileName: resolved,
                currentDirectory: state.currentDirectory,
                options: parsed.options,
                program: state.builderPrograms.get(resolvedPath) || ((_a = getCachedParsedConfigFile(state, resolvedPath)) === null || _a === void 0 ? void 0 : _a.fileNames),
                useCaseSensitiveFileNames: state.parseConfigFileHost.useCaseSensitiveFileNames,
                writeLog: function (s) { return state.writeLog(s); },
                toPath: function (fileName) { return toPath(state, fileName); }
            }))
                return;
            invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Partial);
        }, flags, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.WildcardDirectory, resolved); });
    }
    function watchInputFiles(state, resolved, resolvedPath, parsed) {
        if (!state.watch)
            return;
        ts.mutateMap(getOrCreateValueMapFromConfigFileMap(state.allWatchedInputFiles, resolvedPath), ts.arrayToMap(parsed.fileNames, function (fileName) { return toPath(state, fileName); }), {
            createNewValue: function (_path, input) { return state.watchFile(input, function () { return invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None); }, ts.PollingInterval.Low, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.SourceFile, resolved); },
            onDeleteValue: ts.closeFileWatcher,
        });
    }
    function watchPackageJsonFiles(state, resolved, resolvedPath, parsed) {
        if (!state.watch || !state.lastCachedPackageJsonLookups)
            return;
        ts.mutateMap(getOrCreateValueMapFromConfigFileMap(state.allWatchedPackageJsonFiles, resolvedPath), new ts.Map(state.lastCachedPackageJsonLookups.get(resolvedPath)), {
            createNewValue: function (path, _input) { return state.watchFile(path, function () { return invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None); }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.PackageJson, resolved); },
            onDeleteValue: ts.closeFileWatcher,
        });
    }
    function startWatching(state, buildOrder) {
        if (!state.watchAllProjectsPending)
            return;
        state.watchAllProjectsPending = false;
        for (var _i = 0, _a = getBuildOrderFromAnyBuildOrder(buildOrder); _i < _a.length; _i++) {
            var resolved = _a[_i];
            var resolvedPath = toResolvedConfigFilePath(state, resolved);
            var cfg = parseConfigFile(state, resolved, resolvedPath);
            // Watch this file
            watchConfigFile(state, resolved, resolvedPath, cfg);
            watchExtendedConfigFiles(state, resolvedPath, cfg);
            if (cfg) {
                // Update watchers for wildcard directories
                watchWildCardDirectories(state, resolved, resolvedPath, cfg);
                // Watch input files
                watchInputFiles(state, resolved, resolvedPath, cfg);
                // Watch package json files
                watchPackageJsonFiles(state, resolved, resolvedPath, cfg);
            }
        }
    }
    function stopWatching(state) {
        ts.clearMap(state.allWatchedConfigFiles, ts.closeFileWatcher);
        ts.clearMap(state.allWatchedExtendedConfigFiles, ts.closeFileWatcherOf);
        ts.clearMap(state.allWatchedWildcardDirectories, function (watchedWildcardDirectories) { return ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf); });
        ts.clearMap(state.allWatchedInputFiles, function (watchedWildcardDirectories) { return ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcher); });
        ts.clearMap(state.allWatchedPackageJsonFiles, function (watchedPacageJsonFiles) { return ts.clearMap(watchedPacageJsonFiles, ts.closeFileWatcher); });
    }
    function createSolutionBuilderWorker(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions) {
        var state = createSolutionBuilderState(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions);
        return {
            build: function (project, cancellationToken, writeFile, getCustomTransformers) { return build(state, project, cancellationToken, writeFile, getCustomTransformers); },
            clean: function (project) { return clean(state, project); },
            buildReferences: function (project, cancellationToken, writeFile, getCustomTransformers) { return build(state, project, cancellationToken, writeFile, getCustomTransformers, /*onlyReferences*/ true); },
            cleanReferences: function (project) { return clean(state, project, /*onlyReferences*/ true); },
            getNextInvalidatedProject: function (cancellationToken) {
                setupInitialBuild(state, cancellationToken);
                return getNextInvalidatedProject(state, getBuildOrder(state), /*reportQueue*/ false);
            },
            getBuildOrder: function () { return getBuildOrder(state); },
            getUpToDateStatusOfProject: function (project) {
                var configFileName = resolveProjectName(state, project);
                var configFilePath = toResolvedConfigFilePath(state, configFileName);
                return getUpToDateStatus(state, parseConfigFile(state, configFileName, configFilePath), configFilePath);
            },
            invalidateProject: function (configFilePath, reloadLevel) { return invalidateProject(state, configFilePath, reloadLevel || ts.ConfigFileProgramReloadLevel.None); },
            buildNextInvalidatedProject: function () { return buildNextInvalidatedProject(state); },
            getAllParsedConfigs: function () { return ts.arrayFrom(ts.mapDefinedIterator(state.configFileCache.values(), function (config) { return isParsedCommandLine(config) ? config : undefined; })); },
            close: function () { return stopWatching(state); },
        };
    }
    function relName(state, path) {
        return ts.convertToRelativePath(path, state.currentDirectory, function (f) { return state.getCanonicalFileName(f); });
    }
    function reportStatus(state, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        state.host.reportSolutionBuilderStatus(ts.createCompilerDiagnostic.apply(void 0, __spreadArray([message], args, false)));
    }
    function reportWatchStatus(state, message) {
        var _a, _b;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        (_b = (_a = state.hostWithWatch).onWatchStatusChange) === null || _b === void 0 ? void 0 : _b.call(_a, ts.createCompilerDiagnostic.apply(void 0, __spreadArray([message], args, false)), state.host.getNewLine(), state.baseCompilerOptions);
    }
    function reportErrors(_a, errors) {
        var host = _a.host;
        errors.forEach(function (err) { return host.reportDiagnostic(err); });
    }
    function reportAndStoreErrors(state, proj, errors) {
        reportErrors(state, errors);
        state.projectErrorsReported.set(proj, true);
        if (errors.length) {
            state.diagnostics.set(proj, errors);
        }
    }
    function reportParseConfigFileDiagnostic(state, proj) {
        reportAndStoreErrors(state, proj, [state.configFileCache.get(proj)]);
    }
    function reportErrorSummary(state, buildOrder) {
        if (!state.needsSummary)
            return;
        state.needsSummary = false;
        var canReportSummary = state.watch || !!state.host.reportErrorSummary;
        var diagnostics = state.diagnostics;
        var totalErrors = 0;
        var filesInError = [];
        if (isCircularBuildOrder(buildOrder)) {
            reportBuildQueue(state, buildOrder.buildOrder);
            reportErrors(state, buildOrder.circularDiagnostics);
            if (canReportSummary)
                totalErrors += ts.getErrorCountForSummary(buildOrder.circularDiagnostics);
            if (canReportSummary)
                filesInError = __spreadArray(__spreadArray([], filesInError, true), ts.getFilesInErrorForSummary(buildOrder.circularDiagnostics), true);
        }
        else {
            // Report errors from the other projects
            buildOrder.forEach(function (project) {
                var projectPath = toResolvedConfigFilePath(state, project);
                if (!state.projectErrorsReported.has(projectPath)) {
                    reportErrors(state, diagnostics.get(projectPath) || ts.emptyArray);
                }
            });
            if (canReportSummary)
                diagnostics.forEach(function (singleProjectErrors) { return totalErrors += ts.getErrorCountForSummary(singleProjectErrors); });
            if (canReportSummary)
                diagnostics.forEach(function (singleProjectErrors) { return __spreadArray(__spreadArray([], filesInError, true), ts.getFilesInErrorForSummary(singleProjectErrors), true); });
        }
        if (state.watch) {
            reportWatchStatus(state, ts.getWatchErrorSummaryDiagnosticMessage(totalErrors), totalErrors);
        }
        else if (state.host.reportErrorSummary) {
            state.host.reportErrorSummary(totalErrors, filesInError);
        }
    }
    /**
     * Report the build ordering inferred from the current project graph if we're in verbose mode
     */
    function reportBuildQueue(state, buildQueue) {
        if (state.options.verbose) {
            reportStatus(state, ts.Diagnostics.Projects_in_this_build_Colon_0, buildQueue.map(function (s) { return "\r\n    * " + relName(state, s); }).join(""));
        }
    }
    function reportUpToDateStatus(state, configFileName, status) {
        if (state.options.force && (status.type === ts.UpToDateStatusType.UpToDate || status.type === ts.UpToDateStatusType.UpToDateWithUpstreamTypes)) {
            return reportStatus(state, ts.Diagnostics.Project_0_is_being_forcibly_rebuilt, relName(state, configFileName));
        }
        switch (status.type) {
            case ts.UpToDateStatusType.OutOfDateWithSelf:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2, relName(state, configFileName), relName(state, status.outOfDateOutputFileName), relName(state, status.newerInputFileName));
            case ts.UpToDateStatusType.OutOfDateWithUpstream:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2, relName(state, configFileName), relName(state, status.outOfDateOutputFileName), relName(state, status.newerProjectName));
            case ts.UpToDateStatusType.OutputMissing:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_file_1_does_not_exist, relName(state, configFileName), relName(state, status.missingOutputFileName));
            case ts.UpToDateStatusType.UpToDate:
                if (status.newestInputFileTime !== undefined) {
                    return reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2, relName(state, configFileName), relName(state, status.newestInputFileName || ""), relName(state, status.oldestOutputFileName || ""));
                }
                // Don't report anything for "up to date because it was already built" -- too verbose
                break;
            case ts.UpToDateStatusType.OutOfDateWithPrepend:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed, relName(state, configFileName), relName(state, status.newerProjectName));
            case ts.UpToDateStatusType.UpToDateWithUpstreamTypes:
                return reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies, relName(state, configFileName));
            case ts.UpToDateStatusType.UpstreamOutOfDate:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date, relName(state, configFileName), relName(state, status.upstreamProjectName));
            case ts.UpToDateStatusType.UpstreamBlocked:
                return reportStatus(state, status.upstreamProjectBlocked ?
                    ts.Diagnostics.Project_0_can_t_be_built_because_its_dependency_1_was_not_built :
                    ts.Diagnostics.Project_0_can_t_be_built_because_its_dependency_1_has_errors, relName(state, configFileName), relName(state, status.upstreamProjectName));
            case ts.UpToDateStatusType.Unbuildable:
                return reportStatus(state, ts.Diagnostics.Failed_to_parse_file_0_Colon_1, relName(state, configFileName), status.reason);
            case ts.UpToDateStatusType.TsVersionOutputOfDate:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2, relName(state, configFileName), status.version, ts.version);
            case ts.UpToDateStatusType.ContainerOnly:
            // Don't report status on "solution" projects
            // falls through
            case ts.UpToDateStatusType.ComputingUpstream:
                // Should never leak from getUptoDateStatusWorker
                break;
            default:
                ts.assertType(status);
        }
    }
    /**
     * Report the up-to-date status of a project if we're in verbose mode
     */
    function verboseReportProjectStatus(state, configFileName, status) {
        if (state.options.verbose) {
            reportUpToDateStatus(state, configFileName, status);
        }
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var server;
    (function (server) {
        /* @internal */
        server.ActionSet = "action::set";
        /* @internal */
        server.ActionInvalidate = "action::invalidate";
        /* @internal */
        server.ActionPackageInstalled = "action::packageInstalled";
        /* @internal */
        server.EventTypesRegistry = "event::typesRegistry";
        /* @internal */
        server.EventBeginInstallTypes = "event::beginInstallTypes";
        /* @internal */
        server.EventEndInstallTypes = "event::endInstallTypes";
        /* @internal */
        server.EventInitializationFailed = "event::initializationFailed";
        /* @internal */
        var Arguments;
        (function (Arguments) {
            Arguments.GlobalCacheLocation = "--globalTypingsCacheLocation";
            Arguments.LogFile = "--logFile";
            Arguments.EnableTelemetry = "--enableTelemetry";
            Arguments.TypingSafeListLocation = "--typingSafeListLocation";
            Arguments.TypesMapLocation = "--typesMapLocation";
            /**
             * This argument specifies the location of the NPM executable.
             * typingsInstaller will run the command with `${npmLocation} install ...`.
             */
            Arguments.NpmLocation = "--npmLocation";
            /**
             * Flag indicating that the typings installer should try to validate the default npm location.
             * If the default npm is not found when this flag is enabled, fallback to `npm install`
             */
            Arguments.ValidateDefaultNpmLocation = "--validateDefaultNpmLocation";
        })(Arguments = server.Arguments || (server.Arguments = {}));
        /* @internal */
        function hasArgument(argumentName) {
            return ts.sys.args.indexOf(argumentName) >= 0;
        }
        server.hasArgument = hasArgument;
        /* @internal */
        function findArgument(argumentName) {
            var index = ts.sys.args.indexOf(argumentName);
            return index >= 0 && index < ts.sys.args.length - 1
                ? ts.sys.args[index + 1]
                : undefined;
        }
        server.findArgument = findArgument;
        /* @internal */
        function nowString() {
            // E.g. "12:34:56.789"
            var d = new Date();
            return "".concat(ts.padLeft(d.getHours().toString(), 2, "0"), ":").concat(ts.padLeft(d.getMinutes().toString(), 2, "0"), ":").concat(ts.padLeft(d.getSeconds().toString(), 2, "0"), ".").concat(ts.padLeft(d.getMilliseconds().toString(), 3, "0"));
        }
        server.nowString = nowString;
    })(server = ts.server || (ts.server = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var JsTyping;
    (function (JsTyping) {
        function isTypingUpToDate(cachedTyping, availableTypingVersions) {
            var availableVersion = new ts.Version(ts.getProperty(availableTypingVersions, "ts".concat(ts.versionMajorMinor)) || ts.getProperty(availableTypingVersions, "latest"));
            return availableVersion.compareTo(cachedTyping.version) <= 0;
        }
        JsTyping.isTypingUpToDate = isTypingUpToDate;
        var unprefixedNodeCoreModuleList = [
            "assert",
            "assert/strict",
            "async_hooks",
            "buffer",
            "child_process",
            "cluster",
            "console",
            "constants",
            "crypto",
            "dgram",
            "diagnostics_channel",
            "dns",
            "dns/promises",
            "domain",
            "events",
            "fs",
            "fs/promises",
            "http",
            "https",
            "http2",
            "inspector",
            "module",
            "net",
            "os",
            "path",
            "perf_hooks",
            "process",
            "punycode",
            "querystring",
            "readline",
            "repl",
            "stream",
            "stream/promises",
            "string_decoder",
            "timers",
            "timers/promises",
            "tls",
            "trace_events",
            "tty",
            "url",
            "util",
            "util/types",
            "v8",
            "vm",
            "wasi",
            "worker_threads",
            "zlib"
        ];
        JsTyping.prefixedNodeCoreModuleList = unprefixedNodeCoreModuleList.map(function (name) { return "node:".concat(name); });
        JsTyping.nodeCoreModuleList = __spreadArray(__spreadArray([], unprefixedNodeCoreModuleList, true), JsTyping.prefixedNodeCoreModuleList, true);
        JsTyping.nodeCoreModules = new ts.Set(JsTyping.nodeCoreModuleList);
        function nonRelativeModuleNameForTypingCache(moduleName) {
            return JsTyping.nodeCoreModules.has(moduleName) ? "node" : moduleName;
        }
        JsTyping.nonRelativeModuleNameForTypingCache = nonRelativeModuleNameForTypingCache;
        function loadSafeList(host, safeListPath) {
            var result = ts.readConfigFile(safeListPath, function (path) { return host.readFile(path); });
            return new ts.Map(ts.getEntries(result.config));
        }
        JsTyping.loadSafeList = loadSafeList;
        function loadTypesMap(host, typesMapPath) {
            var result = ts.readConfigFile(typesMapPath, function (path) { return host.readFile(path); });
            if (result.config) {
                return new ts.Map(ts.getEntries(result.config.simpleMap));
            }
            return undefined;
        }
        JsTyping.loadTypesMap = loadTypesMap;
        /**
         * @param host is the object providing I/O related operations.
         * @param fileNames are the file names that belong to the same project
         * @param projectRootPath is the path to the project root directory
         * @param safeListPath is the path used to retrieve the safe list
         * @param packageNameToTypingLocation is the map of package names to their cached typing locations and installed versions
         * @param typeAcquisition is used to customize the typing acquisition process
         * @param compilerOptions are used as a source for typing inference
         */
        function discoverTypings(host, log, fileNames, projectRootPath, safeList, packageNameToTypingLocation, typeAcquisition, unresolvedImports, typesRegistry) {
            if (!typeAcquisition || !typeAcquisition.enable) {
                return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };
            }
            // A typing name to typing file path mapping
            var inferredTypings = new ts.Map();
            // Only infer typings for .js and .jsx files
            fileNames = ts.mapDefined(fileNames, function (fileName) {
                var path = ts.normalizePath(fileName);
                if (ts.hasJSFileExtension(path)) {
                    return path;
                }
            });
            var filesToWatch = [];
            if (typeAcquisition.include)
                addInferredTypings(typeAcquisition.include, "Explicitly included types");
            var exclude = typeAcquisition.exclude || [];
            // Directories to search for package.json, bower.json and other typing information
            var possibleSearchDirs = new ts.Set(fileNames.map(ts.getDirectoryPath));
            possibleSearchDirs.add(projectRootPath);
            possibleSearchDirs.forEach(function (searchDir) {
                getTypingNames(searchDir, "bower.json", "bower_components", filesToWatch);
                getTypingNames(searchDir, "package.json", "node_modules", filesToWatch);
            });
            if (!typeAcquisition.disableFilenameBasedTypeAcquisition) {
                getTypingNamesFromSourceFileNames(fileNames);
            }
            // add typings for unresolved imports
            if (unresolvedImports) {
                var module_1 = ts.deduplicate(unresolvedImports.map(nonRelativeModuleNameForTypingCache), ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
                addInferredTypings(module_1, "Inferred typings from unresolved imports");
            }
            // Add the cached typing locations for inferred typings that are already installed
            packageNameToTypingLocation.forEach(function (typing, name) {
                var registryEntry = typesRegistry.get(name);
                if (inferredTypings.has(name) && inferredTypings.get(name) === undefined && registryEntry !== undefined && isTypingUpToDate(typing, registryEntry)) {
                    inferredTypings.set(name, typing.typingLocation);
                }
            });
            // Remove typings that the user has added to the exclude list
            for (var _i = 0, exclude_1 = exclude; _i < exclude_1.length; _i++) {
                var excludeTypingName = exclude_1[_i];
                var didDelete = inferredTypings.delete(excludeTypingName);
                if (didDelete && log)
                    log("Typing for ".concat(excludeTypingName, " is in exclude list, will be ignored."));
            }
            var newTypingNames = [];
            var cachedTypingPaths = [];
            inferredTypings.forEach(function (inferred, typing) {
                if (inferred !== undefined) {
                    cachedTypingPaths.push(inferred);
                }
                else {
                    newTypingNames.push(typing);
                }
            });
            var result = { cachedTypingPaths: cachedTypingPaths, newTypingNames: newTypingNames, filesToWatch: filesToWatch };
            if (log)
                log("Result: ".concat(JSON.stringify(result)));
            return result;
            function addInferredTyping(typingName) {
                if (!inferredTypings.has(typingName)) {
                    inferredTypings.set(typingName, undefined); // TODO: GH#18217
                }
            }
            function addInferredTypings(typingNames, message) {
                if (log)
                    log("".concat(message, ": ").concat(JSON.stringify(typingNames)));
                ts.forEach(typingNames, addInferredTyping);
            }
            /**
             * Adds inferred typings from manifest/module pairs (think package.json + node_modules)
             *
             * @param projectRootPath is the path to the directory where to look for package.json, bower.json and other typing information
             * @param manifestName is the name of the manifest (package.json or bower.json)
             * @param modulesDirName is the directory name for modules (node_modules or bower_components). Should be lowercase!
             * @param filesToWatch are the files to watch for changes. We will push things into this array.
             */
            function getTypingNames(projectRootPath, manifestName, modulesDirName, filesToWatch) {
                // First, we check the manifests themselves. They're not
                // _required_, but they allow us to do some filtering when dealing
                // with big flat dep directories.
                var manifestPath = ts.combinePaths(projectRootPath, manifestName);
                var manifest;
                var manifestTypingNames;
                if (host.fileExists(manifestPath)) {
                    filesToWatch.push(manifestPath);
                    manifest = ts.readConfigFile(manifestPath, function (path) { return host.readFile(path); }).config;
                    manifestTypingNames = ts.flatMap([manifest.dependencies, manifest.devDependencies, manifest.optionalDependencies, manifest.peerDependencies], ts.getOwnKeys);
                    addInferredTypings(manifestTypingNames, "Typing names in '".concat(manifestPath, "' dependencies"));
                }
                // Now we scan the directories for typing information in
                // already-installed dependencies (if present). Note that this
                // step happens regardless of whether a manifest was present,
                // which is certainly a valid configuration, if an unusual one.
                var packagesFolderPath = ts.combinePaths(projectRootPath, modulesDirName);
                filesToWatch.push(packagesFolderPath);
                if (!host.directoryExists(packagesFolderPath)) {
                    return;
                }
                // There's two cases we have to take into account here:
                // 1. If manifest is undefined, then we're not using a manifest.
                //    That means that we should scan _all_ dependencies at the top
                //    level of the modulesDir.
                // 2. If manifest is defined, then we can do some special
                //    filtering to reduce the amount of scanning we need to do.
                //
                // Previous versions of this algorithm checked for a `_requiredBy`
                // field in the package.json, but that field is only present in
                // `npm@>=3 <7`.
                // Package names that do **not** provide their own typings, so
                // we'll look them up.
                var packageNames = [];
                var dependencyManifestNames = manifestTypingNames
                    // This is #1 described above.
                    ? manifestTypingNames.map(function (typingName) { return ts.combinePaths(packagesFolderPath, typingName, manifestName); })
                    // And #2. Depth = 3 because scoped packages look like `node_modules/@foo/bar/package.json`
                    : host.readDirectory(packagesFolderPath, [".json" /* Extension.Json */], /*excludes*/ undefined, /*includes*/ undefined, /*depth*/ 3)
                        .filter(function (manifestPath) {
                        if (ts.getBaseFileName(manifestPath) !== manifestName) {
                            return false;
                        }
                        // It's ok to treat
                        // `node_modules/@foo/bar/package.json` as a manifest,
                        // but not `node_modules/jquery/nested/package.json`.
                        // We only assume depth 3 is ok for formally scoped
                        // packages. So that needs this dance here.
                        var pathComponents = ts.getPathComponents(ts.normalizePath(manifestPath));
                        var isScoped = pathComponents[pathComponents.length - 3][0] === "@";
                        return isScoped && pathComponents[pathComponents.length - 4].toLowerCase() === modulesDirName || // `node_modules/@foo/bar`
                            !isScoped && pathComponents[pathComponents.length - 3].toLowerCase() === modulesDirName; // `node_modules/foo`
                    });
                if (log)
                    log("Searching for typing names in ".concat(packagesFolderPath, "; all files: ").concat(JSON.stringify(dependencyManifestNames)));
                // Once we have the names of things to look up, we iterate over
                // and either collect their included typings, or add them to the
                // list of typings we need to look up separately.
                for (var _i = 0, dependencyManifestNames_1 = dependencyManifestNames; _i < dependencyManifestNames_1.length; _i++) {
                    var manifestPath_1 = dependencyManifestNames_1[_i];
                    var normalizedFileName = ts.normalizePath(manifestPath_1);
                    var result_1 = ts.readConfigFile(normalizedFileName, function (path) { return host.readFile(path); });
                    var manifest_1 = result_1.config;
                    // If the package has its own d.ts typings, those will take precedence. Otherwise the package name will be used
                    // to download d.ts files from DefinitelyTyped
                    if (!manifest_1.name) {
                        continue;
                    }
                    var ownTypes = manifest_1.types || manifest_1.typings;
                    if (ownTypes) {
                        var absolutePath = ts.getNormalizedAbsolutePath(ownTypes, ts.getDirectoryPath(normalizedFileName));
                        if (host.fileExists(absolutePath)) {
                            if (log)
                                log("    Package '".concat(manifest_1.name, "' provides its own types."));
                            inferredTypings.set(manifest_1.name, absolutePath);
                        }
                        else {
                            if (log)
                                log("    Package '".concat(manifest_1.name, "' provides its own types but they are missing."));
                        }
                    }
                    else {
                        packageNames.push(manifest_1.name);
                    }
                }
                addInferredTypings(packageNames, "    Found package names");
            }
            /**
             * Infer typing names from given file names. For example, the file name "jquery-min.2.3.4.js"
             * should be inferred to the 'jquery' typing name; and "angular-route.1.2.3.js" should be inferred
             * to the 'angular-route' typing name.
             * @param fileNames are the names for source files in the project
             */
            function getTypingNamesFromSourceFileNames(fileNames) {
                var fromFileNames = ts.mapDefined(fileNames, function (j) {
                    if (!ts.hasJSFileExtension(j))
                        return undefined;
                    var inferredTypingName = ts.removeFileExtension(ts.getBaseFileName(j.toLowerCase()));
                    var cleanedTypingName = ts.removeMinAndVersionNumbers(inferredTypingName);
                    return safeList.get(cleanedTypingName);
                });
                if (fromFileNames.length) {
                    addInferredTypings(fromFileNames, "Inferred typings from file names");
                }
                var hasJsxFile = ts.some(fileNames, function (f) { return ts.fileExtensionIs(f, ".jsx" /* Extension.Jsx */); });
                if (hasJsxFile) {
                    if (log)
                        log("Inferred 'react' typings due to presence of '.jsx' extension");
                    addInferredTyping("react");
                }
            }
        }
        JsTyping.discoverTypings = discoverTypings;
        var NameValidationResult;
        (function (NameValidationResult) {
            NameValidationResult[NameValidationResult["Ok"] = 0] = "Ok";
            NameValidationResult[NameValidationResult["EmptyName"] = 1] = "EmptyName";
            NameValidationResult[NameValidationResult["NameTooLong"] = 2] = "NameTooLong";
            NameValidationResult[NameValidationResult["NameStartsWithDot"] = 3] = "NameStartsWithDot";
            NameValidationResult[NameValidationResult["NameStartsWithUnderscore"] = 4] = "NameStartsWithUnderscore";
            NameValidationResult[NameValidationResult["NameContainsNonURISafeCharacters"] = 5] = "NameContainsNonURISafeCharacters";
        })(NameValidationResult = JsTyping.NameValidationResult || (JsTyping.NameValidationResult = {}));
        var maxPackageNameLength = 214;
        /**
         * Validates package name using rules defined at https://docs.npmjs.com/files/package.json
         */
        function validatePackageName(packageName) {
            return validatePackageNameWorker(packageName, /*supportScopedPackage*/ true);
        }
        JsTyping.validatePackageName = validatePackageName;
        function validatePackageNameWorker(packageName, supportScopedPackage) {
            if (!packageName) {
                return 1 /* NameValidationResult.EmptyName */;
            }
            if (packageName.length > maxPackageNameLength) {
                return 2 /* NameValidationResult.NameTooLong */;
            }
            if (packageName.charCodeAt(0) === 46 /* CharacterCodes.dot */) {
                return 3 /* NameValidationResult.NameStartsWithDot */;
            }
            if (packageName.charCodeAt(0) === 95 /* CharacterCodes._ */) {
                return 4 /* NameValidationResult.NameStartsWithUnderscore */;
            }
            // check if name is scope package like: starts with @ and has one '/' in the middle
            // scoped packages are not currently supported
            if (supportScopedPackage) {
                var matches = /^@([^/]+)\/([^/]+)$/.exec(packageName);
                if (matches) {
                    var scopeResult = validatePackageNameWorker(matches[1], /*supportScopedPackage*/ false);
                    if (scopeResult !== 0 /* NameValidationResult.Ok */) {
                        return { name: matches[1], isScopeName: true, result: scopeResult };
                    }
                    var packageResult = validatePackageNameWorker(matches[2], /*supportScopedPackage*/ false);
                    if (packageResult !== 0 /* NameValidationResult.Ok */) {
                        return { name: matches[2], isScopeName: false, result: packageResult };
                    }
                    return 0 /* NameValidationResult.Ok */;
                }
            }
            if (encodeURIComponent(packageName) !== packageName) {
                return 5 /* NameValidationResult.NameContainsNonURISafeCharacters */;
            }
            return 0 /* NameValidationResult.Ok */;
        }
        function renderPackageNameValidationFailure(result, typing) {
            return typeof result === "object" ?
                renderPackageNameValidationFailureWorker(typing, result.result, result.name, result.isScopeName) :
                renderPackageNameValidationFailureWorker(typing, result, typing, /*isScopeName*/ false);
        }
        JsTyping.renderPackageNameValidationFailure = renderPackageNameValidationFailure;
        function renderPackageNameValidationFailureWorker(typing, result, name, isScopeName) {
            var kind = isScopeName ? "Scope" : "Package";
            switch (result) {
                case 1 /* NameValidationResult.EmptyName */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' cannot be empty");
                case 2 /* NameValidationResult.NameTooLong */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' should be less than ").concat(maxPackageNameLength, " characters");
                case 3 /* NameValidationResult.NameStartsWithDot */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' cannot start with '.'");
                case 4 /* NameValidationResult.NameStartsWithUnderscore */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' cannot start with '_'");
                case 5 /* NameValidationResult.NameContainsNonURISafeCharacters */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' contains non URI safe characters");
                case 0 /* NameValidationResult.Ok */:
                    return ts.Debug.fail(); // Shouldn't have called this.
                default:
                    throw ts.Debug.assertNever(result);
            }
        }
    })(JsTyping = ts.JsTyping || (ts.JsTyping = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ScriptSnapshot;
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = /** @class */ (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return start === 0 && end === this.text.length
                    ? this.text
                    : this.text.substring(start, end);
            };
            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };
            StringScriptSnapshot.prototype.getChangeRange = function () {
                // Text-based snapshots do not support incremental parsing. Return undefined
                // to signal that to the caller.
                return undefined;
            };
            return StringScriptSnapshot;
        }());
        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(ScriptSnapshot = ts.ScriptSnapshot || (ts.ScriptSnapshot = {}));
    /* @internal */
    var PackageJsonDependencyGroup;
    (function (PackageJsonDependencyGroup) {
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["Dependencies"] = 1] = "Dependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["DevDependencies"] = 2] = "DevDependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["PeerDependencies"] = 4] = "PeerDependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["OptionalDependencies"] = 8] = "OptionalDependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["All"] = 15] = "All";
    })(PackageJsonDependencyGroup = ts.PackageJsonDependencyGroup || (ts.PackageJsonDependencyGroup = {}));
    /* @internal */
    var PackageJsonAutoImportPreference;
    (function (PackageJsonAutoImportPreference) {
        PackageJsonAutoImportPreference[PackageJsonAutoImportPreference["Off"] = 0] = "Off";
        PackageJsonAutoImportPreference[PackageJsonAutoImportPreference["On"] = 1] = "On";
        PackageJsonAutoImportPreference[PackageJsonAutoImportPreference["Auto"] = 2] = "Auto";
    })(PackageJsonAutoImportPreference = ts.PackageJsonAutoImportPreference || (ts.PackageJsonAutoImportPreference = {}));
    var LanguageServiceMode;
    (function (LanguageServiceMode) {
        LanguageServiceMode[LanguageServiceMode["Semantic"] = 0] = "Semantic";
        LanguageServiceMode[LanguageServiceMode["PartialSemantic"] = 1] = "PartialSemantic";
        LanguageServiceMode[LanguageServiceMode["Syntactic"] = 2] = "Syntactic";
    })(LanguageServiceMode = ts.LanguageServiceMode || (ts.LanguageServiceMode = {}));
    /* @internal */
    ts.emptyOptions = {};
    var SemanticClassificationFormat;
    (function (SemanticClassificationFormat) {
        SemanticClassificationFormat["Original"] = "original";
        SemanticClassificationFormat["TwentyTwenty"] = "2020";
    })(SemanticClassificationFormat = ts.SemanticClassificationFormat || (ts.SemanticClassificationFormat = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
        CompletionTriggerKind[CompletionTriggerKind["Invoked"] = 1] = "Invoked";
        /** Completion was triggered by a trigger character. */
        CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
        /** Completion was re-triggered as the current completion list is incomplete. */
        CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 3] = "TriggerForIncompleteCompletions";
    })(CompletionTriggerKind = ts.CompletionTriggerKind || (ts.CompletionTriggerKind = {}));
    var InlayHintKind;
    (function (InlayHintKind) {
        InlayHintKind["Type"] = "Type";
        InlayHintKind["Parameter"] = "Parameter";
        InlayHintKind["Enum"] = "Enum";
    })(InlayHintKind = ts.InlayHintKind || (ts.InlayHintKind = {}));
    var HighlightSpanKind;
    (function (HighlightSpanKind) {
        HighlightSpanKind["none"] = "none";
        HighlightSpanKind["definition"] = "definition";
        HighlightSpanKind["reference"] = "reference";
        HighlightSpanKind["writtenReference"] = "writtenReference";
    })(HighlightSpanKind = ts.HighlightSpanKind || (ts.HighlightSpanKind = {}));
    var IndentStyle;
    (function (IndentStyle) {
        IndentStyle[IndentStyle["None"] = 0] = "None";
        IndentStyle[IndentStyle["Block"] = 1] = "Block";
        IndentStyle[IndentStyle["Smart"] = 2] = "Smart";
    })(IndentStyle = ts.IndentStyle || (ts.IndentStyle = {}));
    var SemicolonPreference;
    (function (SemicolonPreference) {
        SemicolonPreference["Ignore"] = "ignore";
        SemicolonPreference["Insert"] = "insert";
        SemicolonPreference["Remove"] = "remove";
    })(SemicolonPreference = ts.SemicolonPreference || (ts.SemicolonPreference = {}));
    function getDefaultFormatCodeSettings(newLineCharacter) {
        return {
            indentSize: 4,
            tabSize: 4,
            newLineCharacter: newLineCharacter || "\n",
            convertTabsToSpaces: true,
            indentStyle: IndentStyle.Smart,
            insertSpaceAfterConstructor: false,
            insertSpaceAfterCommaDelimiter: true,
            insertSpaceAfterSemicolonInForStatements: true,
            insertSpaceBeforeAndAfterBinaryOperators: true,
            insertSpaceAfterKeywordsInControlFlowStatements: true,
            insertSpaceAfterFunctionKeywordForAnonymousFunctions: false,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false,
            insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: false,
            insertSpaceBeforeFunctionParenthesis: false,
            placeOpenBraceOnNewLineForFunctions: false,
            placeOpenBraceOnNewLineForControlBlocks: false,
            semicolons: SemicolonPreference.Ignore,
            trimTrailingWhitespace: true
        };
    }
    ts.getDefaultFormatCodeSettings = getDefaultFormatCodeSettings;
    /* @internal */
    ts.testFormatSettings = getDefaultFormatCodeSettings("\n");
    var SymbolDisplayPartKind;
    (function (SymbolDisplayPartKind) {
        SymbolDisplayPartKind[SymbolDisplayPartKind["aliasName"] = 0] = "aliasName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["className"] = 1] = "className";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumName"] = 2] = "enumName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["fieldName"] = 3] = "fieldName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["interfaceName"] = 4] = "interfaceName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["keyword"] = 5] = "keyword";
        SymbolDisplayPartKind[SymbolDisplayPartKind["lineBreak"] = 6] = "lineBreak";
        SymbolDisplayPartKind[SymbolDisplayPartKind["numericLiteral"] = 7] = "numericLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["stringLiteral"] = 8] = "stringLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["localName"] = 9] = "localName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["methodName"] = 10] = "methodName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["moduleName"] = 11] = "moduleName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["operator"] = 12] = "operator";
        SymbolDisplayPartKind[SymbolDisplayPartKind["parameterName"] = 13] = "parameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["propertyName"] = 14] = "propertyName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["punctuation"] = 15] = "punctuation";
        SymbolDisplayPartKind[SymbolDisplayPartKind["space"] = 16] = "space";
        SymbolDisplayPartKind[SymbolDisplayPartKind["text"] = 17] = "text";
        SymbolDisplayPartKind[SymbolDisplayPartKind["typeParameterName"] = 18] = "typeParameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumMemberName"] = 19] = "enumMemberName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["functionName"] = 20] = "functionName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["regularExpressionLiteral"] = 21] = "regularExpressionLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["link"] = 22] = "link";
        SymbolDisplayPartKind[SymbolDisplayPartKind["linkName"] = 23] = "linkName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["linkText"] = 24] = "linkText";
    })(SymbolDisplayPartKind = ts.SymbolDisplayPartKind || (ts.SymbolDisplayPartKind = {}));
    // Do not change existing values, as they exist in telemetry.
    var CompletionInfoFlags;
    (function (CompletionInfoFlags) {
        CompletionInfoFlags[CompletionInfoFlags["None"] = 0] = "None";
        CompletionInfoFlags[CompletionInfoFlags["MayIncludeAutoImports"] = 1] = "MayIncludeAutoImports";
        CompletionInfoFlags[CompletionInfoFlags["IsImportStatementCompletion"] = 2] = "IsImportStatementCompletion";
        CompletionInfoFlags[CompletionInfoFlags["IsContinuation"] = 4] = "IsContinuation";
        CompletionInfoFlags[CompletionInfoFlags["ResolvedModuleSpecifiers"] = 8] = "ResolvedModuleSpecifiers";
        CompletionInfoFlags[CompletionInfoFlags["ResolvedModuleSpecifiersBeyondLimit"] = 16] = "ResolvedModuleSpecifiersBeyondLimit";
        CompletionInfoFlags[CompletionInfoFlags["MayIncludeMethodSnippets"] = 32] = "MayIncludeMethodSnippets";
    })(CompletionInfoFlags = ts.CompletionInfoFlags || (ts.CompletionInfoFlags = {}));
    var OutliningSpanKind;
    (function (OutliningSpanKind) {
        /** Single or multi-line comments */
        OutliningSpanKind["Comment"] = "comment";
        /** Sections marked by '// #region' and '// #endregion' comments */
        OutliningSpanKind["Region"] = "region";
        /** Declarations and expressions */
        OutliningSpanKind["Code"] = "code";
        /** Contiguous blocks of import declarations */
        OutliningSpanKind["Imports"] = "imports";
    })(OutliningSpanKind = ts.OutliningSpanKind || (ts.OutliningSpanKind = {}));
    var OutputFileType;
    (function (OutputFileType) {
        OutputFileType[OutputFileType["JavaScript"] = 0] = "JavaScript";
        OutputFileType[OutputFileType["SourceMap"] = 1] = "SourceMap";
        OutputFileType[OutputFileType["Declaration"] = 2] = "Declaration";
    })(OutputFileType = ts.OutputFileType || (ts.OutputFileType = {}));
    var EndOfLineState;
    (function (EndOfLineState) {
        EndOfLineState[EndOfLineState["None"] = 0] = "None";
        EndOfLineState[EndOfLineState["InMultiLineCommentTrivia"] = 1] = "InMultiLineCommentTrivia";
        EndOfLineState[EndOfLineState["InSingleQuoteStringLiteral"] = 2] = "InSingleQuoteStringLiteral";
        EndOfLineState[EndOfLineState["InDoubleQuoteStringLiteral"] = 3] = "InDoubleQuoteStringLiteral";
        EndOfLineState[EndOfLineState["InTemplateHeadOrNoSubstitutionTemplate"] = 4] = "InTemplateHeadOrNoSubstitutionTemplate";
        EndOfLineState[EndOfLineState["InTemplateMiddleOrTail"] = 5] = "InTemplateMiddleOrTail";
        EndOfLineState[EndOfLineState["InTemplateSubstitutionPosition"] = 6] = "InTemplateSubstitutionPosition";
    })(EndOfLineState = ts.EndOfLineState || (ts.EndOfLineState = {}));
    var TokenClass;
    (function (TokenClass) {
        TokenClass[TokenClass["Punctuation"] = 0] = "Punctuation";
        TokenClass[TokenClass["Keyword"] = 1] = "Keyword";
        TokenClass[TokenClass["Operator"] = 2] = "Operator";
        TokenClass[TokenClass["Comment"] = 3] = "Comment";
        TokenClass[TokenClass["Whitespace"] = 4] = "Whitespace";
        TokenClass[TokenClass["Identifier"] = 5] = "Identifier";
        TokenClass[TokenClass["NumberLiteral"] = 6] = "NumberLiteral";
        TokenClass[TokenClass["BigIntLiteral"] = 7] = "BigIntLiteral";
        TokenClass[TokenClass["StringLiteral"] = 8] = "StringLiteral";
        TokenClass[TokenClass["RegExpLiteral"] = 9] = "RegExpLiteral";
    })(TokenClass = ts.TokenClass || (ts.TokenClass = {}));
    var ScriptElementKind;
    (function (ScriptElementKind) {
        ScriptElementKind["unknown"] = "";
        ScriptElementKind["warning"] = "warning";
        /** predefined type (void) or keyword (class) */
        ScriptElementKind["keyword"] = "keyword";
        /** top level script node */
        ScriptElementKind["scriptElement"] = "script";
        /** module foo {} */
        ScriptElementKind["moduleElement"] = "module";
        /** class X {} */
        ScriptElementKind["classElement"] = "class";
        /** var x = class X {} */
        ScriptElementKind["localClassElement"] = "local class";
        /** interface Y {} */
        ScriptElementKind["interfaceElement"] = "interface";
        /** type T = ... */
        ScriptElementKind["typeElement"] = "type";
        /** enum E */
        ScriptElementKind["enumElement"] = "enum";
        ScriptElementKind["enumMemberElement"] = "enum member";
        /**
         * Inside module and script only
         * const v = ..
         */
        ScriptElementKind["variableElement"] = "var";
        /** Inside function */
        ScriptElementKind["localVariableElement"] = "local var";
        /**
         * Inside module and script only
         * function f() { }
         */
        ScriptElementKind["functionElement"] = "function";
        /** Inside function */
        ScriptElementKind["localFunctionElement"] = "local function";
        /** class X { [public|private]* foo() {} } */
        ScriptElementKind["memberFunctionElement"] = "method";
        /** class X { [public|private]* [get|set] foo:number; } */
        ScriptElementKind["memberGetAccessorElement"] = "getter";
        ScriptElementKind["memberSetAccessorElement"] = "setter";
        /**
         * class X { [public|private]* foo:number; }
         * interface Y { foo:number; }
         */
        ScriptElementKind["memberVariableElement"] = "property";
        /**
         * class X { constructor() { } }
         * class X { static { } }
         */
        ScriptElementKind["constructorImplementationElement"] = "constructor";
        /** interface Y { ():number; } */
        ScriptElementKind["callSignatureElement"] = "call";
        /** interface Y { []:number; } */
        ScriptElementKind["indexSignatureElement"] = "index";
        /** interface Y { new():Y; } */
        ScriptElementKind["constructSignatureElement"] = "construct";
        /** function foo(*Y*: string) */
        ScriptElementKind["parameterElement"] = "parameter";
        ScriptElementKind["typeParameterElement"] = "type parameter";
        ScriptElementKind["primitiveType"] = "primitive type";
        ScriptElementKind["label"] = "label";
        ScriptElementKind["alias"] = "alias";
        ScriptElementKind["constElement"] = "const";
        ScriptElementKind["letElement"] = "let";
        ScriptElementKind["directory"] = "directory";
        ScriptElementKind["externalModuleName"] = "external module name";
        /**
         * <JsxTagName attribute1 attribute2={0} />
         * @deprecated
         */
        ScriptElementKind["jsxAttribute"] = "JSX attribute";
        /** String literal */
        ScriptElementKind["string"] = "string";
        /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */
        ScriptElementKind["link"] = "link";
        /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */
        ScriptElementKind["linkName"] = "link name";
        /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
        ScriptElementKind["linkText"] = "link text";
    })(ScriptElementKind = ts.ScriptElementKind || (ts.ScriptElementKind = {}));
    var ScriptElementKindModifier;
    (function (ScriptElementKindModifier) {
        ScriptElementKindModifier["none"] = "";
        ScriptElementKindModifier["publicMemberModifier"] = "public";
        ScriptElementKindModifier["privateMemberModifier"] = "private";
        ScriptElementKindModifier["protectedMemberModifier"] = "protected";
        ScriptElementKindModifier["exportedModifier"] = "export";
        ScriptElementKindModifier["ambientModifier"] = "declare";
        ScriptElementKindModifier["staticModifier"] = "static";
        ScriptElementKindModifier["abstractModifier"] = "abstract";
        ScriptElementKindModifier["optionalModifier"] = "optional";
        ScriptElementKindModifier["deprecatedModifier"] = "deprecated";
        ScriptElementKindModifier["dtsModifier"] = ".d.ts";
        ScriptElementKindModifier["tsModifier"] = ".ts";
        ScriptElementKindModifier["tsxModifier"] = ".tsx";
        ScriptElementKindModifier["jsModifier"] = ".js";
        ScriptElementKindModifier["jsxModifier"] = ".jsx";
        ScriptElementKindModifier["jsonModifier"] = ".json";
        ScriptElementKindModifier["dmtsModifier"] = ".d.mts";
        ScriptElementKindModifier["mtsModifier"] = ".mts";
        ScriptElementKindModifier["mjsModifier"] = ".mjs";
        ScriptElementKindModifier["dctsModifier"] = ".d.cts";
        ScriptElementKindModifier["ctsModifier"] = ".cts";
        ScriptElementKindModifier["cjsModifier"] = ".cjs";
    })(ScriptElementKindModifier = ts.ScriptElementKindModifier || (ts.ScriptElementKindModifier = {}));
    var ClassificationTypeNames;
    (function (ClassificationTypeNames) {
        ClassificationTypeNames["comment"] = "comment";
        ClassificationTypeNames["identifier"] = "identifier";
        ClassificationTypeNames["keyword"] = "keyword";
        ClassificationTypeNames["numericLiteral"] = "number";
        ClassificationTypeNames["bigintLiteral"] = "bigint";
        ClassificationTypeNames["operator"] = "operator";
        ClassificationTypeNames["stringLiteral"] = "string";
        ClassificationTypeNames["whiteSpace"] = "whitespace";
        ClassificationTypeNames["text"] = "text";
        ClassificationTypeNames["punctuation"] = "punctuation";
        ClassificationTypeNames["className"] = "class name";
        ClassificationTypeNames["enumName"] = "enum name";
        ClassificationTypeNames["interfaceName"] = "interface name";
        ClassificationTypeNames["moduleName"] = "module name";
        ClassificationTypeNames["typeParameterName"] = "type parameter name";
        ClassificationTypeNames["typeAliasName"] = "type alias name";
        ClassificationTypeNames["parameterName"] = "parameter name";
        ClassificationTypeNames["docCommentTagName"] = "doc comment tag name";
        ClassificationTypeNames["jsxOpenTagName"] = "jsx open tag name";
        ClassificationTypeNames["jsxCloseTagName"] = "jsx close tag name";
        ClassificationTypeNames["jsxSelfClosingTagName"] = "jsx self closing tag name";
        ClassificationTypeNames["jsxAttribute"] = "jsx attribute";
        ClassificationTypeNames["jsxText"] = "jsx text";
        ClassificationTypeNames["jsxAttributeStringLiteralValue"] = "jsx attribute string literal value";
    })(ClassificationTypeNames = ts.ClassificationTypeNames || (ts.ClassificationTypeNames = {}));
    var ClassificationType;
    (function (ClassificationType) {
        ClassificationType[ClassificationType["comment"] = 1] = "comment";
        ClassificationType[ClassificationType["identifier"] = 2] = "identifier";
        ClassificationType[ClassificationType["keyword"] = 3] = "keyword";
        ClassificationType[ClassificationType["numericLiteral"] = 4] = "numericLiteral";
        ClassificationType[ClassificationType["operator"] = 5] = "operator";
        ClassificationType[ClassificationType["stringLiteral"] = 6] = "stringLiteral";
        ClassificationType[ClassificationType["regularExpressionLiteral"] = 7] = "regularExpressionLiteral";
        ClassificationType[ClassificationType["whiteSpace"] = 8] = "whiteSpace";
        ClassificationType[ClassificationType["text"] = 9] = "text";
        ClassificationType[ClassificationType["punctuation"] = 10] = "punctuation";
        ClassificationType[ClassificationType["className"] = 11] = "className";
        ClassificationType[ClassificationType["enumName"] = 12] = "enumName";
        ClassificationType[ClassificationType["interfaceName"] = 13] = "interfaceName";
        ClassificationType[ClassificationType["moduleName"] = 14] = "moduleName";
        ClassificationType[ClassificationType["typeParameterName"] = 15] = "typeParameterName";
        ClassificationType[ClassificationType["typeAliasName"] = 16] = "typeAliasName";
        ClassificationType[ClassificationType["parameterName"] = 17] = "parameterName";
        ClassificationType[ClassificationType["docCommentTagName"] = 18] = "docCommentTagName";
        ClassificationType[ClassificationType["jsxOpenTagName"] = 19] = "jsxOpenTagName";
        ClassificationType[ClassificationType["jsxCloseTagName"] = 20] = "jsxCloseTagName";
        ClassificationType[ClassificationType["jsxSelfClosingTagName"] = 21] = "jsxSelfClosingTagName";
        ClassificationType[ClassificationType["jsxAttribute"] = 22] = "jsxAttribute";
        ClassificationType[ClassificationType["jsxText"] = 23] = "jsxText";
        ClassificationType[ClassificationType["jsxAttributeStringLiteralValue"] = 24] = "jsxAttributeStringLiteralValue";
        ClassificationType[ClassificationType["bigintLiteral"] = 25] = "bigintLiteral";
    })(ClassificationType = ts.ClassificationType || (ts.ClassificationType = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    // These utilities are common to multiple language service features.
    //#region
    ts.scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ true);
    var SemanticMeaning;
    (function (SemanticMeaning) {
        SemanticMeaning[SemanticMeaning["None"] = 0] = "None";
        SemanticMeaning[SemanticMeaning["Value"] = 1] = "Value";
        SemanticMeaning[SemanticMeaning["Type"] = 2] = "Type";
        SemanticMeaning[SemanticMeaning["Namespace"] = 4] = "Namespace";
        SemanticMeaning[SemanticMeaning["All"] = 7] = "All";
    })(SemanticMeaning = ts.SemanticMeaning || (ts.SemanticMeaning = {}));
    function getMeaningFromDeclaration(node) {
        switch (node.kind) {
            case 254 /* SyntaxKind.VariableDeclaration */:
                return ts.isInJSFile(node) && ts.getJSDocEnumTag(node) ? 7 /* SemanticMeaning.All */ : 1 /* SemanticMeaning.Value */;
            case 164 /* SyntaxKind.Parameter */:
            case 203 /* SyntaxKind.BindingElement */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 292 /* SyntaxKind.CatchClause */:
            case 285 /* SyntaxKind.JsxAttribute */:
                return 1 /* SemanticMeaning.Value */;
            case 163 /* SyntaxKind.TypeParameter */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 182 /* SyntaxKind.TypeLiteral */:
                return 2 /* SemanticMeaning.Type */;
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                // If it has no name node, it shares the name with the value declaration below it.
                return node.name === undefined ? 1 /* SemanticMeaning.Value */ | 2 /* SemanticMeaning.Type */ : 2 /* SemanticMeaning.Type */;
            case 299 /* SyntaxKind.EnumMember */:
            case 257 /* SyntaxKind.ClassDeclaration */:
                return 1 /* SemanticMeaning.Value */ | 2 /* SemanticMeaning.Type */;
            case 261 /* SyntaxKind.ModuleDeclaration */:
                if (ts.isAmbientModule(node)) {
                    return 4 /* SemanticMeaning.Namespace */ | 1 /* SemanticMeaning.Value */;
                }
                else if (ts.getModuleInstanceState(node) === 1 /* ModuleInstanceState.Instantiated */) {
                    return 4 /* SemanticMeaning.Namespace */ | 1 /* SemanticMeaning.Value */;
                }
                else {
                    return 4 /* SemanticMeaning.Namespace */;
                }
            case 260 /* SyntaxKind.EnumDeclaration */:
            case 269 /* SyntaxKind.NamedImports */:
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
            case 266 /* SyntaxKind.ImportDeclaration */:
            case 271 /* SyntaxKind.ExportAssignment */:
            case 272 /* SyntaxKind.ExportDeclaration */:
                return 7 /* SemanticMeaning.All */;
            // An external module can be a Value
            case 305 /* SyntaxKind.SourceFile */:
                return 4 /* SemanticMeaning.Namespace */ | 1 /* SemanticMeaning.Value */;
        }
        return 7 /* SemanticMeaning.All */;
    }
    ts.getMeaningFromDeclaration = getMeaningFromDeclaration;
    function getMeaningFromLocation(node) {
        node = getAdjustedReferenceLocation(node);
        var parent = node.parent;
        if (node.kind === 305 /* SyntaxKind.SourceFile */) {
            return 1 /* SemanticMeaning.Value */;
        }
        else if (ts.isExportAssignment(parent)
            || ts.isExportSpecifier(parent)
            || ts.isExternalModuleReference(parent)
            || ts.isImportSpecifier(parent)
            || ts.isImportClause(parent)
            || ts.isImportEqualsDeclaration(parent) && node === parent.name) {
            return 7 /* SemanticMeaning.All */;
        }
        else if (isInRightSideOfInternalImportEqualsDeclaration(node)) {
            return getMeaningFromRightHandSideOfImportEquals(node);
        }
        else if (ts.isDeclarationName(node)) {
            return getMeaningFromDeclaration(parent);
        }
        else if (ts.isEntityName(node) && ts.findAncestor(node, ts.or(ts.isJSDocNameReference, ts.isJSDocLinkLike, ts.isJSDocMemberName))) {
            return 7 /* SemanticMeaning.All */;
        }
        else if (isTypeReference(node)) {
            return 2 /* SemanticMeaning.Type */;
        }
        else if (isNamespaceReference(node)) {
            return 4 /* SemanticMeaning.Namespace */;
        }
        else if (ts.isTypeParameterDeclaration(parent)) {
            ts.Debug.assert(ts.isJSDocTemplateTag(parent.parent)); // Else would be handled by isDeclarationName
            return 2 /* SemanticMeaning.Type */;
        }
        else if (ts.isLiteralTypeNode(parent)) {
            // This might be T["name"], which is actually referencing a property and not a type. So allow both meanings.
            return 2 /* SemanticMeaning.Type */ | 1 /* SemanticMeaning.Value */;
        }
        else {
            return 1 /* SemanticMeaning.Value */;
        }
    }
    ts.getMeaningFromLocation = getMeaningFromLocation;
    function getMeaningFromRightHandSideOfImportEquals(node) {
        //     import a = |b|; // Namespace
        //     import a = |b.c|; // Value, type, namespace
        //     import a = |b.c|.d; // Namespace
        var name = node.kind === 161 /* SyntaxKind.QualifiedName */ ? node : ts.isQualifiedName(node.parent) && node.parent.right === node ? node.parent : undefined;
        return name && name.parent.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ ? 7 /* SemanticMeaning.All */ : 4 /* SemanticMeaning.Namespace */;
    }
    function isInRightSideOfInternalImportEqualsDeclaration(node) {
        while (node.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
            node = node.parent;
        }
        return ts.isInternalModuleImportEqualsDeclaration(node.parent) && node.parent.moduleReference === node;
    }
    ts.isInRightSideOfInternalImportEqualsDeclaration = isInRightSideOfInternalImportEqualsDeclaration;
    function isNamespaceReference(node) {
        return isQualifiedNameNamespaceReference(node) || isPropertyAccessNamespaceReference(node);
    }
    function isQualifiedNameNamespaceReference(node) {
        var root = node;
        var isLastClause = true;
        if (root.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
            while (root.parent && root.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
                root = root.parent;
            }
            isLastClause = root.right === node;
        }
        return root.parent.kind === 178 /* SyntaxKind.TypeReference */ && !isLastClause;
    }
    function isPropertyAccessNamespaceReference(node) {
        var root = node;
        var isLastClause = true;
        if (root.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
            while (root.parent && root.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                root = root.parent;
            }
            isLastClause = root.name === node;
        }
        if (!isLastClause && root.parent.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */ && root.parent.parent.kind === 291 /* SyntaxKind.HeritageClause */) {
            var decl = root.parent.parent.parent;
            return (decl.kind === 257 /* SyntaxKind.ClassDeclaration */ && root.parent.parent.token === 117 /* SyntaxKind.ImplementsKeyword */) ||
                (decl.kind === 258 /* SyntaxKind.InterfaceDeclaration */ && root.parent.parent.token === 94 /* SyntaxKind.ExtendsKeyword */);
        }
        return false;
    }
    function isTypeReference(node) {
        if (ts.isRightSideOfQualifiedNameOrPropertyAccess(node)) {
            node = node.parent;
        }
        switch (node.kind) {
            case 108 /* SyntaxKind.ThisKeyword */:
                return !ts.isExpressionNode(node);
            case 192 /* SyntaxKind.ThisType */:
                return true;
        }
        switch (node.parent.kind) {
            case 178 /* SyntaxKind.TypeReference */:
                return true;
            case 200 /* SyntaxKind.ImportType */:
                return !node.parent.isTypeOf;
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return ts.isPartOfTypeNode(node.parent);
        }
        return false;
    }
    function isCallExpressionTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isCallExpression, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isCallExpressionTarget = isCallExpressionTarget;
    function isNewExpressionTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isNewExpression, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isNewExpressionTarget = isNewExpressionTarget;
    function isCallOrNewExpressionTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isCallOrNewExpression, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isCallOrNewExpressionTarget = isCallOrNewExpressionTarget;
    function isTaggedTemplateTag(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isTaggedTemplateExpression, selectTagOfTaggedTemplateExpression, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isTaggedTemplateTag = isTaggedTemplateTag;
    function isDecoratorTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isDecorator, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isDecoratorTarget = isDecoratorTarget;
    function isJsxOpeningLikeElementTagName(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isJsxOpeningLikeElement, selectTagNameOfJsxOpeningLikeElement, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isJsxOpeningLikeElementTagName = isJsxOpeningLikeElementTagName;
    function selectExpressionOfCallOrNewExpressionOrDecorator(node) {
        return node.expression;
    }
    function selectTagOfTaggedTemplateExpression(node) {
        return node.tag;
    }
    function selectTagNameOfJsxOpeningLikeElement(node) {
        return node.tagName;
    }
    function isCalleeWorker(node, pred, calleeSelector, includeElementAccess, skipPastOuterExpressions) {
        var target = includeElementAccess ? climbPastPropertyOrElementAccess(node) : climbPastPropertyAccess(node);
        if (skipPastOuterExpressions) {
            target = ts.skipOuterExpressions(target);
        }
        return !!target && !!target.parent && pred(target.parent) && calleeSelector(target.parent) === target;
    }
    function climbPastPropertyAccess(node) {
        return isRightSideOfPropertyAccess(node) ? node.parent : node;
    }
    ts.climbPastPropertyAccess = climbPastPropertyAccess;
    function climbPastPropertyOrElementAccess(node) {
        return isRightSideOfPropertyAccess(node) || isArgumentExpressionOfElementAccess(node) ? node.parent : node;
    }
    ts.climbPastPropertyOrElementAccess = climbPastPropertyOrElementAccess;
    function getTargetLabel(referenceNode, labelName) {
        while (referenceNode) {
            if (referenceNode.kind === 250 /* SyntaxKind.LabeledStatement */ && referenceNode.label.escapedText === labelName) {
                return referenceNode.label;
            }
            referenceNode = referenceNode.parent;
        }
        return undefined;
    }
    ts.getTargetLabel = getTargetLabel;
    function hasPropertyAccessExpressionWithName(node, funcName) {
        if (!ts.isPropertyAccessExpression(node.expression)) {
            return false;
        }
        return node.expression.name.text === funcName;
    }
    ts.hasPropertyAccessExpressionWithName = hasPropertyAccessExpressionWithName;
    function isJumpStatementTarget(node) {
        var _a;
        return ts.isIdentifier(node) && ((_a = ts.tryCast(node.parent, ts.isBreakOrContinueStatement)) === null || _a === void 0 ? void 0 : _a.label) === node;
    }
    ts.isJumpStatementTarget = isJumpStatementTarget;
    function isLabelOfLabeledStatement(node) {
        var _a;
        return ts.isIdentifier(node) && ((_a = ts.tryCast(node.parent, ts.isLabeledStatement)) === null || _a === void 0 ? void 0 : _a.label) === node;
    }
    ts.isLabelOfLabeledStatement = isLabelOfLabeledStatement;
    function isLabelName(node) {
        return isLabelOfLabeledStatement(node) || isJumpStatementTarget(node);
    }
    ts.isLabelName = isLabelName;
    function isTagName(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isJSDocTag)) === null || _a === void 0 ? void 0 : _a.tagName) === node;
    }
    ts.isTagName = isTagName;
    function isRightSideOfQualifiedName(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isQualifiedName)) === null || _a === void 0 ? void 0 : _a.right) === node;
    }
    ts.isRightSideOfQualifiedName = isRightSideOfQualifiedName;
    function isRightSideOfPropertyAccess(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isPropertyAccessExpression)) === null || _a === void 0 ? void 0 : _a.name) === node;
    }
    ts.isRightSideOfPropertyAccess = isRightSideOfPropertyAccess;
    function isArgumentExpressionOfElementAccess(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isElementAccessExpression)) === null || _a === void 0 ? void 0 : _a.argumentExpression) === node;
    }
    ts.isArgumentExpressionOfElementAccess = isArgumentExpressionOfElementAccess;
    function isNameOfModuleDeclaration(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isModuleDeclaration)) === null || _a === void 0 ? void 0 : _a.name) === node;
    }
    ts.isNameOfModuleDeclaration = isNameOfModuleDeclaration;
    function isNameOfFunctionDeclaration(node) {
        var _a;
        return ts.isIdentifier(node) && ((_a = ts.tryCast(node.parent, ts.isFunctionLike)) === null || _a === void 0 ? void 0 : _a.name) === node;
    }
    ts.isNameOfFunctionDeclaration = isNameOfFunctionDeclaration;
    function isLiteralNameOfPropertyDeclarationOrIndexAccess(node) {
        switch (node.parent.kind) {
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 299 /* SyntaxKind.EnumMember */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return ts.getNameOfDeclaration(node.parent) === node;
            case 207 /* SyntaxKind.ElementAccessExpression */:
                return node.parent.argumentExpression === node;
            case 162 /* SyntaxKind.ComputedPropertyName */:
                return true;
            case 196 /* SyntaxKind.LiteralType */:
                return node.parent.parent.kind === 194 /* SyntaxKind.IndexedAccessType */;
            default:
                return false;
        }
    }
    ts.isLiteralNameOfPropertyDeclarationOrIndexAccess = isLiteralNameOfPropertyDeclarationOrIndexAccess;
    function isExpressionOfExternalModuleImportEqualsDeclaration(node) {
        return ts.isExternalModuleImportEqualsDeclaration(node.parent.parent) &&
            ts.getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node;
    }
    ts.isExpressionOfExternalModuleImportEqualsDeclaration = isExpressionOfExternalModuleImportEqualsDeclaration;
    function getContainerNode(node) {
        if (ts.isJSDocTypeAlias(node)) {
            // This doesn't just apply to the node immediately under the comment, but to everything in its parent's scope.
            // node.parent = the JSDoc comment, node.parent.parent = the node having the comment.
            // Then we get parent again in the loop.
            node = node.parent.parent;
        }
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case 305 /* SyntaxKind.SourceFile */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    return node;
            }
        }
    }
    ts.getContainerNode = getContainerNode;
    function getNodeKind(node) {
        switch (node.kind) {
            case 305 /* SyntaxKind.SourceFile */:
                return ts.isExternalModule(node) ? "module" /* ScriptElementKind.moduleElement */ : "script" /* ScriptElementKind.scriptElement */;
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return "module" /* ScriptElementKind.moduleElement */;
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return "class" /* ScriptElementKind.classElement */;
            case 258 /* SyntaxKind.InterfaceDeclaration */: return "interface" /* ScriptElementKind.interfaceElement */;
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 338 /* SyntaxKind.JSDocCallbackTag */:
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                return "type" /* ScriptElementKind.typeElement */;
            case 260 /* SyntaxKind.EnumDeclaration */: return "enum" /* ScriptElementKind.enumElement */;
            case 254 /* SyntaxKind.VariableDeclaration */:
                return getKindOfVariableDeclaration(node);
            case 203 /* SyntaxKind.BindingElement */:
                return getKindOfVariableDeclaration(ts.getRootDeclaration(node));
            case 214 /* SyntaxKind.ArrowFunction */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
                return "function" /* ScriptElementKind.functionElement */;
            case 172 /* SyntaxKind.GetAccessor */: return "getter" /* ScriptElementKind.memberGetAccessorElement */;
            case 173 /* SyntaxKind.SetAccessor */: return "setter" /* ScriptElementKind.memberSetAccessorElement */;
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
                return "method" /* ScriptElementKind.memberFunctionElement */;
            case 296 /* SyntaxKind.PropertyAssignment */:
                var initializer = node.initializer;
                return ts.isFunctionLike(initializer) ? "method" /* ScriptElementKind.memberFunctionElement */ : "property" /* ScriptElementKind.memberVariableElement */;
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
            case 298 /* SyntaxKind.SpreadAssignment */:
                return "property" /* ScriptElementKind.memberVariableElement */;
            case 176 /* SyntaxKind.IndexSignature */: return "index" /* ScriptElementKind.indexSignatureElement */;
            case 175 /* SyntaxKind.ConstructSignature */: return "construct" /* ScriptElementKind.constructSignatureElement */;
            case 174 /* SyntaxKind.CallSignature */: return "call" /* ScriptElementKind.callSignatureElement */;
            case 171 /* SyntaxKind.Constructor */:
            case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                return "constructor" /* ScriptElementKind.constructorImplementationElement */;
            case 163 /* SyntaxKind.TypeParameter */: return "type parameter" /* ScriptElementKind.typeParameterElement */;
            case 299 /* SyntaxKind.EnumMember */: return "enum member" /* ScriptElementKind.enumMemberElement */;
            case 164 /* SyntaxKind.Parameter */: return ts.hasSyntacticModifier(node, 16476 /* ModifierFlags.ParameterPropertyModifier */) ? "property" /* ScriptElementKind.memberVariableElement */ : "parameter" /* ScriptElementKind.parameterElement */;
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 275 /* SyntaxKind.ExportSpecifier */:
            case 268 /* SyntaxKind.NamespaceImport */:
            case 274 /* SyntaxKind.NamespaceExport */:
                return "alias" /* ScriptElementKind.alias */;
            case 221 /* SyntaxKind.BinaryExpression */:
                var kind = ts.getAssignmentDeclarationKind(node);
                var right = node.right;
                switch (kind) {
                    case 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */:
                    case 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */:
                    case 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */:
                    case 0 /* AssignmentDeclarationKind.None */:
                        return "" /* ScriptElementKind.unknown */;
                    case 1 /* AssignmentDeclarationKind.ExportsProperty */:
                    case 2 /* AssignmentDeclarationKind.ModuleExports */:
                        var rightKind = getNodeKind(right);
                        return rightKind === "" /* ScriptElementKind.unknown */ ? "const" /* ScriptElementKind.constElement */ : rightKind;
                    case 3 /* AssignmentDeclarationKind.PrototypeProperty */:
                        return ts.isFunctionExpression(right) ? "method" /* ScriptElementKind.memberFunctionElement */ : "property" /* ScriptElementKind.memberVariableElement */;
                    case 4 /* AssignmentDeclarationKind.ThisProperty */:
                        return "property" /* ScriptElementKind.memberVariableElement */; // property
                    case 5 /* AssignmentDeclarationKind.Property */:
                        // static method / property
                        return ts.isFunctionExpression(right) ? "method" /* ScriptElementKind.memberFunctionElement */ : "property" /* ScriptElementKind.memberVariableElement */;
                    case 6 /* AssignmentDeclarationKind.Prototype */:
                        return "local class" /* ScriptElementKind.localClassElement */;
                    default: {
                        ts.assertType(kind);
                        return "" /* ScriptElementKind.unknown */;
                    }
                }
            case 79 /* SyntaxKind.Identifier */:
                return ts.isImportClause(node.parent) ? "alias" /* ScriptElementKind.alias */ : "" /* ScriptElementKind.unknown */;
            case 271 /* SyntaxKind.ExportAssignment */:
                var scriptKind = getNodeKind(node.expression);
                // If the expression didn't come back with something (like it does for an identifiers)
                return scriptKind === "" /* ScriptElementKind.unknown */ ? "const" /* ScriptElementKind.constElement */ : scriptKind;
            default:
                return "" /* ScriptElementKind.unknown */;
        }
        function getKindOfVariableDeclaration(v) {
            return ts.isVarConst(v)
                ? "const" /* ScriptElementKind.constElement */
                : ts.isLet(v)
                    ? "let" /* ScriptElementKind.letElement */
                    : "var" /* ScriptElementKind.variableElement */;
        }
    }
    ts.getNodeKind = getNodeKind;
    function isThis(node) {
        switch (node.kind) {
            case 108 /* SyntaxKind.ThisKeyword */:
                // case SyntaxKind.ThisType: TODO: GH#9267
                return true;
            case 79 /* SyntaxKind.Identifier */:
                // 'this' as a parameter
                return ts.identifierIsThisKeyword(node) && node.parent.kind === 164 /* SyntaxKind.Parameter */;
            default:
                return false;
        }
    }
    ts.isThis = isThis;
    // Matches the beginning of a triple slash directive
    var tripleSlashDirectivePrefixRegex = /^\/\/\/\s*</;
    function getLineStartPositionForPosition(position, sourceFile) {
        var lineStarts = ts.getLineStarts(sourceFile);
        var line = sourceFile.getLineAndCharacterOfPosition(position).line;
        return lineStarts[line];
    }
    ts.getLineStartPositionForPosition = getLineStartPositionForPosition;
    function rangeContainsRange(r1, r2) {
        return startEndContainsRange(r1.pos, r1.end, r2);
    }
    ts.rangeContainsRange = rangeContainsRange;
    function rangeContainsRangeExclusive(r1, r2) {
        return rangeContainsPositionExclusive(r1, r2.pos) && rangeContainsPositionExclusive(r1, r2.end);
    }
    ts.rangeContainsRangeExclusive = rangeContainsRangeExclusive;
    function rangeContainsPosition(r, pos) {
        return r.pos <= pos && pos <= r.end;
    }
    ts.rangeContainsPosition = rangeContainsPosition;
    function rangeContainsPositionExclusive(r, pos) {
        return r.pos < pos && pos < r.end;
    }
    ts.rangeContainsPositionExclusive = rangeContainsPositionExclusive;
    function startEndContainsRange(start, end, range) {
        return start <= range.pos && end >= range.end;
    }
    ts.startEndContainsRange = startEndContainsRange;
    function rangeContainsStartEnd(range, start, end) {
        return range.pos <= start && range.end >= end;
    }
    ts.rangeContainsStartEnd = rangeContainsStartEnd;
    function rangeOverlapsWithStartEnd(r1, start, end) {
        return startEndOverlapsWithStartEnd(r1.pos, r1.end, start, end);
    }
    ts.rangeOverlapsWithStartEnd = rangeOverlapsWithStartEnd;
    function nodeOverlapsWithStartEnd(node, sourceFile, start, end) {
        return startEndOverlapsWithStartEnd(node.getStart(sourceFile), node.end, start, end);
    }
    ts.nodeOverlapsWithStartEnd = nodeOverlapsWithStartEnd;
    function startEndOverlapsWithStartEnd(start1, end1, start2, end2) {
        var start = Math.max(start1, start2);
        var end = Math.min(end1, end2);
        return start < end;
    }
    ts.startEndOverlapsWithStartEnd = startEndOverlapsWithStartEnd;
    /**
     * Assumes `candidate.start <= position` holds.
     */
    function positionBelongsToNode(candidate, position, sourceFile) {
        ts.Debug.assert(candidate.pos <= position);
        return position < candidate.end || !isCompletedNode(candidate, sourceFile);
    }
    ts.positionBelongsToNode = positionBelongsToNode;
    function isCompletedNode(n, sourceFile) {
        if (n === undefined || ts.nodeIsMissing(n)) {
            return false;
        }
        switch (n.kind) {
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 260 /* SyntaxKind.EnumDeclaration */:
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 182 /* SyntaxKind.TypeLiteral */:
            case 235 /* SyntaxKind.Block */:
            case 262 /* SyntaxKind.ModuleBlock */:
            case 263 /* SyntaxKind.CaseBlock */:
            case 269 /* SyntaxKind.NamedImports */:
            case 273 /* SyntaxKind.NamedExports */:
                return nodeEndsWith(n, 19 /* SyntaxKind.CloseBraceToken */, sourceFile);
            case 292 /* SyntaxKind.CatchClause */:
                return isCompletedNode(n.block, sourceFile);
            case 209 /* SyntaxKind.NewExpression */:
                if (!n.arguments) {
                    return true;
                }
            // falls through
            case 208 /* SyntaxKind.CallExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 191 /* SyntaxKind.ParenthesizedType */:
                return nodeEndsWith(n, 21 /* SyntaxKind.CloseParenToken */, sourceFile);
            case 179 /* SyntaxKind.FunctionType */:
            case 180 /* SyntaxKind.ConstructorType */:
                return isCompletedNode(n.type, sourceFile);
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 174 /* SyntaxKind.CallSignature */:
            case 214 /* SyntaxKind.ArrowFunction */:
                if (n.body) {
                    return isCompletedNode(n.body, sourceFile);
                }
                if (n.type) {
                    return isCompletedNode(n.type, sourceFile);
                }
                // Even though type parameters can be unclosed, we can get away with
                // having at least a closing paren.
                return hasChildOfKind(n, 21 /* SyntaxKind.CloseParenToken */, sourceFile);
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return !!n.body && isCompletedNode(n.body, sourceFile);
            case 239 /* SyntaxKind.IfStatement */:
                if (n.elseStatement) {
                    return isCompletedNode(n.elseStatement, sourceFile);
                }
                return isCompletedNode(n.thenStatement, sourceFile);
            case 238 /* SyntaxKind.ExpressionStatement */:
                return isCompletedNode(n.expression, sourceFile) ||
                    hasChildOfKind(n, 26 /* SyntaxKind.SemicolonToken */, sourceFile);
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
            case 162 /* SyntaxKind.ComputedPropertyName */:
            case 184 /* SyntaxKind.TupleType */:
                return nodeEndsWith(n, 23 /* SyntaxKind.CloseBracketToken */, sourceFile);
            case 176 /* SyntaxKind.IndexSignature */:
                if (n.type) {
                    return isCompletedNode(n.type, sourceFile);
                }
                return hasChildOfKind(n, 23 /* SyntaxKind.CloseBracketToken */, sourceFile);
            case 289 /* SyntaxKind.CaseClause */:
            case 290 /* SyntaxKind.DefaultClause */:
                // there is no such thing as terminator token for CaseClause/DefaultClause so for simplicity always consider them non-completed
                return false;
            case 242 /* SyntaxKind.ForStatement */:
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
            case 241 /* SyntaxKind.WhileStatement */:
                return isCompletedNode(n.statement, sourceFile);
            case 240 /* SyntaxKind.DoStatement */:
                // rough approximation: if DoStatement has While keyword - then if node is completed is checking the presence of ')';
                return hasChildOfKind(n, 115 /* SyntaxKind.WhileKeyword */, sourceFile)
                    ? nodeEndsWith(n, 21 /* SyntaxKind.CloseParenToken */, sourceFile)
                    : isCompletedNode(n.statement, sourceFile);
            case 181 /* SyntaxKind.TypeQuery */:
                return isCompletedNode(n.exprName, sourceFile);
            case 216 /* SyntaxKind.TypeOfExpression */:
            case 215 /* SyntaxKind.DeleteExpression */:
            case 217 /* SyntaxKind.VoidExpression */:
            case 224 /* SyntaxKind.YieldExpression */:
            case 225 /* SyntaxKind.SpreadElement */:
                var unaryWordExpression = n;
                return isCompletedNode(unaryWordExpression.expression, sourceFile);
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return isCompletedNode(n.template, sourceFile);
            case 223 /* SyntaxKind.TemplateExpression */:
                var lastSpan = ts.lastOrUndefined(n.templateSpans);
                return isCompletedNode(lastSpan, sourceFile);
            case 233 /* SyntaxKind.TemplateSpan */:
                return ts.nodeIsPresent(n.literal);
            case 272 /* SyntaxKind.ExportDeclaration */:
            case 266 /* SyntaxKind.ImportDeclaration */:
                return ts.nodeIsPresent(n.moduleSpecifier);
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                return isCompletedNode(n.operand, sourceFile);
            case 221 /* SyntaxKind.BinaryExpression */:
                return isCompletedNode(n.right, sourceFile);
            case 222 /* SyntaxKind.ConditionalExpression */:
                return isCompletedNode(n.whenFalse, sourceFile);
            default:
                return true;
        }
    }
    /*
     * Checks if node ends with 'expectedLastToken'.
     * If child at position 'length - 1' is 'SemicolonToken' it is skipped and 'expectedLastToken' is compared with child at position 'length - 2'.
     */
    function nodeEndsWith(n, expectedLastToken, sourceFile) {
        var children = n.getChildren(sourceFile);
        if (children.length) {
            var lastChild = ts.last(children);
            if (lastChild.kind === expectedLastToken) {
                return true;
            }
            else if (lastChild.kind === 26 /* SyntaxKind.SemicolonToken */ && children.length !== 1) {
                return children[children.length - 2].kind === expectedLastToken;
            }
        }
        return false;
    }
    function findListItemInfo(node) {
        var list = findContainingList(node);
        // It is possible at this point for syntaxList to be undefined, either if
        // node.parent had no list child, or if none of its list children contained
        // the span of node. If this happens, return undefined. The caller should
        // handle this case.
        if (!list) {
            return undefined;
        }
        var children = list.getChildren();
        var listItemIndex = ts.indexOfNode(children, node);
        return {
            listItemIndex: listItemIndex,
            list: list
        };
    }
    ts.findListItemInfo = findListItemInfo;
    function hasChildOfKind(n, kind, sourceFile) {
        return !!findChildOfKind(n, kind, sourceFile);
    }
    ts.hasChildOfKind = hasChildOfKind;
    function findChildOfKind(n, kind, sourceFile) {
        return ts.find(n.getChildren(sourceFile), function (c) { return c.kind === kind; });
    }
    ts.findChildOfKind = findChildOfKind;
    function findContainingList(node) {
        // The node might be a list element (nonsynthetic) or a comma (synthetic). Either way, it will
        // be parented by the container of the SyntaxList, not the SyntaxList itself.
        // In order to find the list item index, we first need to locate SyntaxList itself and then search
        // for the position of the relevant node (or comma).
        var syntaxList = ts.find(node.parent.getChildren(), function (c) { return ts.isSyntaxList(c) && rangeContainsRange(c, node); });
        // Either we didn't find an appropriate list, or the list must contain us.
        ts.Debug.assert(!syntaxList || ts.contains(syntaxList.getChildren(), node));
        return syntaxList;
    }
    ts.findContainingList = findContainingList;
    function isDefaultModifier(node) {
        return node.kind === 88 /* SyntaxKind.DefaultKeyword */;
    }
    function isClassKeyword(node) {
        return node.kind === 84 /* SyntaxKind.ClassKeyword */;
    }
    function isFunctionKeyword(node) {
        return node.kind === 98 /* SyntaxKind.FunctionKeyword */;
    }
    function getAdjustedLocationForClass(node) {
        if (ts.isNamedDeclaration(node)) {
            return node.name;
        }
        if (ts.isClassDeclaration(node)) {
            // for class and function declarations, use the `default` modifier
            // when the declaration is unnamed.
            var defaultModifier = node.modifiers && ts.find(node.modifiers, isDefaultModifier);
            if (defaultModifier)
                return defaultModifier;
        }
        if (ts.isClassExpression(node)) {
            // for class expressions, use the `class` keyword when the class is unnamed
            var classKeyword = ts.find(node.getChildren(), isClassKeyword);
            if (classKeyword)
                return classKeyword;
        }
    }
    function getAdjustedLocationForFunction(node) {
        if (ts.isNamedDeclaration(node)) {
            return node.name;
        }
        if (ts.isFunctionDeclaration(node)) {
            // for class and function declarations, use the `default` modifier
            // when the declaration is unnamed.
            var defaultModifier = ts.find(node.modifiers, isDefaultModifier);
            if (defaultModifier)
                return defaultModifier;
        }
        if (ts.isFunctionExpression(node)) {
            // for function expressions, use the `function` keyword when the function is unnamed
            var functionKeyword = ts.find(node.getChildren(), isFunctionKeyword);
            if (functionKeyword)
                return functionKeyword;
        }
    }
    function getAncestorTypeNode(node) {
        var lastTypeNode;
        ts.findAncestor(node, function (a) {
            if (ts.isTypeNode(a)) {
                lastTypeNode = a;
            }
            return !ts.isQualifiedName(a.parent) && !ts.isTypeNode(a.parent) && !ts.isTypeElement(a.parent);
        });
        return lastTypeNode;
    }
    function getContextualTypeFromParentOrAncestorTypeNode(node, checker) {
        var contextualType = getContextualTypeFromParent(node, checker);
        if (contextualType)
            return contextualType;
        var ancestorTypeNode = getAncestorTypeNode(node);
        return ancestorTypeNode && checker.getTypeAtLocation(ancestorTypeNode);
    }
    ts.getContextualTypeFromParentOrAncestorTypeNode = getContextualTypeFromParentOrAncestorTypeNode;
    function getAdjustedLocationForDeclaration(node, forRename) {
        if (!forRename) {
            switch (node.kind) {
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return getAdjustedLocationForClass(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                    return getAdjustedLocationForFunction(node);
            }
        }
        if (ts.isNamedDeclaration(node)) {
            return node.name;
        }
    }
    function getAdjustedLocationForImportDeclaration(node, forRename) {
        if (node.importClause) {
            if (node.importClause.name && node.importClause.namedBindings) {
                // do not adjust if we have both a name and named bindings
                return;
            }
            // /**/import [|name|] from ...;
            // import /**/type [|name|] from ...;
            if (node.importClause.name) {
                return node.importClause.name;
            }
            // /**/import { [|name|] } from ...;
            // /**/import { propertyName as [|name|] } from ...;
            // /**/import * as [|name|] from ...;
            // import /**/type { [|name|] } from ...;
            // import /**/type { propertyName as [|name|] } from ...;
            // import /**/type * as [|name|] from ...;
            if (node.importClause.namedBindings) {
                if (ts.isNamedImports(node.importClause.namedBindings)) {
                    // do nothing if there is more than one binding
                    var onlyBinding = ts.singleOrUndefined(node.importClause.namedBindings.elements);
                    if (!onlyBinding) {
                        return;
                    }
                    return onlyBinding.name;
                }
                else if (ts.isNamespaceImport(node.importClause.namedBindings)) {
                    return node.importClause.namedBindings.name;
                }
            }
        }
        if (!forRename) {
            // /**/import "[|module|]";
            // /**/import ... from "[|module|]";
            // import /**/type ... from "[|module|]";
            return node.moduleSpecifier;
        }
    }
    function getAdjustedLocationForExportDeclaration(node, forRename) {
        if (node.exportClause) {
            // /**/export { [|name|] } ...
            // /**/export { propertyName as [|name|] } ...
            // /**/export * as [|name|] ...
            // export /**/type { [|name|] } from ...
            // export /**/type { propertyName as [|name|] } from ...
            // export /**/type * as [|name|] ...
            if (ts.isNamedExports(node.exportClause)) {
                // do nothing if there is more than one binding
                var onlyBinding = ts.singleOrUndefined(node.exportClause.elements);
                if (!onlyBinding) {
                    return;
                }
                return node.exportClause.elements[0].name;
            }
            else if (ts.isNamespaceExport(node.exportClause)) {
                return node.exportClause.name;
            }
        }
        if (!forRename) {
            // /**/export * from "[|module|]";
            // export /**/type * from "[|module|]";
            return node.moduleSpecifier;
        }
    }
    function getAdjustedLocationForHeritageClause(node) {
        // /**/extends [|name|]
        // /**/implements [|name|]
        if (node.types.length === 1) {
            return node.types[0].expression;
        }
        // /**/extends name1, name2 ...
        // /**/implements name1, name2 ...
    }
    function getAdjustedLocation(node, forRename) {
        var parent = node.parent;
        // /**/<modifier> [|name|] ...
        // /**/<modifier> <class|interface|type|enum|module|namespace|function|get|set> [|name|] ...
        // /**/<class|interface|type|enum|module|namespace|function|get|set> [|name|] ...
        // /**/import [|name|] = ...
        //
        // NOTE: If the node is a modifier, we don't adjust its location if it is the `default` modifier as that is handled
        // specially by `getSymbolAtLocation`.
        if (ts.isModifier(node) && (forRename || node.kind !== 88 /* SyntaxKind.DefaultKeyword */) ? ts.contains(parent.modifiers, node) :
            node.kind === 84 /* SyntaxKind.ClassKeyword */ ? ts.isClassDeclaration(parent) || ts.isClassExpression(node) :
                node.kind === 98 /* SyntaxKind.FunctionKeyword */ ? ts.isFunctionDeclaration(parent) || ts.isFunctionExpression(node) :
                    node.kind === 118 /* SyntaxKind.InterfaceKeyword */ ? ts.isInterfaceDeclaration(parent) :
                        node.kind === 92 /* SyntaxKind.EnumKeyword */ ? ts.isEnumDeclaration(parent) :
                            node.kind === 152 /* SyntaxKind.TypeKeyword */ ? ts.isTypeAliasDeclaration(parent) :
                                node.kind === 142 /* SyntaxKind.NamespaceKeyword */ || node.kind === 141 /* SyntaxKind.ModuleKeyword */ ? ts.isModuleDeclaration(parent) :
                                    node.kind === 100 /* SyntaxKind.ImportKeyword */ ? ts.isImportEqualsDeclaration(parent) :
                                        node.kind === 136 /* SyntaxKind.GetKeyword */ ? ts.isGetAccessorDeclaration(parent) :
                                            node.kind === 149 /* SyntaxKind.SetKeyword */ && ts.isSetAccessorDeclaration(parent)) {
            var location = getAdjustedLocationForDeclaration(parent, forRename);
            if (location) {
                return location;
            }
        }
        // /**/<var|let|const> [|name|] ...
        if ((node.kind === 113 /* SyntaxKind.VarKeyword */ || node.kind === 85 /* SyntaxKind.ConstKeyword */ || node.kind === 119 /* SyntaxKind.LetKeyword */) &&
            ts.isVariableDeclarationList(parent) && parent.declarations.length === 1) {
            var decl = parent.declarations[0];
            if (ts.isIdentifier(decl.name)) {
                return decl.name;
            }
        }
        if (node.kind === 152 /* SyntaxKind.TypeKeyword */) {
            // import /**/type [|name|] from ...;
            // import /**/type { [|name|] } from ...;
            // import /**/type { propertyName as [|name|] } from ...;
            // import /**/type ... from "[|module|]";
            if (ts.isImportClause(parent) && parent.isTypeOnly) {
                var location = getAdjustedLocationForImportDeclaration(parent.parent, forRename);
                if (location) {
                    return location;
                }
            }
            // export /**/type { [|name|] } from ...;
            // export /**/type { propertyName as [|name|] } from ...;
            // export /**/type * from "[|module|]";
            // export /**/type * as ... from "[|module|]";
            if (ts.isExportDeclaration(parent) && parent.isTypeOnly) {
                var location = getAdjustedLocationForExportDeclaration(parent, forRename);
                if (location) {
                    return location;
                }
            }
        }
        // import { propertyName /**/as [|name|] } ...
        // import * /**/as [|name|] ...
        // export { propertyName /**/as [|name|] } ...
        // export * /**/as [|name|] ...
        if (node.kind === 127 /* SyntaxKind.AsKeyword */) {
            if (ts.isImportSpecifier(parent) && parent.propertyName ||
                ts.isExportSpecifier(parent) && parent.propertyName ||
                ts.isNamespaceImport(parent) ||
                ts.isNamespaceExport(parent)) {
                return parent.name;
            }
            if (ts.isExportDeclaration(parent) && parent.exportClause && ts.isNamespaceExport(parent.exportClause)) {
                return parent.exportClause.name;
            }
        }
        // /**/import [|name|] from ...;
        // /**/import { [|name|] } from ...;
        // /**/import { propertyName as [|name|] } from ...;
        // /**/import ... from "[|module|]";
        // /**/import "[|module|]";
        if (node.kind === 100 /* SyntaxKind.ImportKeyword */ && ts.isImportDeclaration(parent)) {
            var location = getAdjustedLocationForImportDeclaration(parent, forRename);
            if (location) {
                return location;
            }
        }
        if (node.kind === 93 /* SyntaxKind.ExportKeyword */) {
            // /**/export { [|name|] } ...;
            // /**/export { propertyName as [|name|] } ...;
            // /**/export * from "[|module|]";
            // /**/export * as ... from "[|module|]";
            if (ts.isExportDeclaration(parent)) {
                var location = getAdjustedLocationForExportDeclaration(parent, forRename);
                if (location) {
                    return location;
                }
            }
            // NOTE: We don't adjust the location of the `default` keyword as that is handled specially by `getSymbolAtLocation`.
            // /**/export default [|name|];
            // /**/export = [|name|];
            if (ts.isExportAssignment(parent)) {
                return ts.skipOuterExpressions(parent.expression);
            }
        }
        // import name = /**/require("[|module|]");
        if (node.kind === 146 /* SyntaxKind.RequireKeyword */ && ts.isExternalModuleReference(parent)) {
            return parent.expression;
        }
        // import ... /**/from "[|module|]";
        // export ... /**/from "[|module|]";
        if (node.kind === 156 /* SyntaxKind.FromKeyword */ && (ts.isImportDeclaration(parent) || ts.isExportDeclaration(parent)) && parent.moduleSpecifier) {
            return parent.moduleSpecifier;
        }
        // class ... /**/extends [|name|] ...
        // class ... /**/implements [|name|] ...
        // class ... /**/implements name1, name2 ...
        // interface ... /**/extends [|name|] ...
        // interface ... /**/extends name1, name2 ...
        if ((node.kind === 94 /* SyntaxKind.ExtendsKeyword */ || node.kind === 117 /* SyntaxKind.ImplementsKeyword */) && ts.isHeritageClause(parent) && parent.token === node.kind) {
            var location = getAdjustedLocationForHeritageClause(parent);
            if (location) {
                return location;
            }
        }
        if (node.kind === 94 /* SyntaxKind.ExtendsKeyword */) {
            // ... <T /**/extends [|U|]> ...
            if (ts.isTypeParameterDeclaration(parent) && parent.constraint && ts.isTypeReferenceNode(parent.constraint)) {
                return parent.constraint.typeName;
            }
            // ... T /**/extends [|U|] ? ...
            if (ts.isConditionalTypeNode(parent) && ts.isTypeReferenceNode(parent.extendsType)) {
                return parent.extendsType.typeName;
            }
        }
        // ... T extends /**/infer [|U|] ? ...
        if (node.kind === 137 /* SyntaxKind.InferKeyword */ && ts.isInferTypeNode(parent)) {
            return parent.typeParameter.name;
        }
        // { [ [|K|] /**/in keyof T]: ... }
        if (node.kind === 101 /* SyntaxKind.InKeyword */ && ts.isTypeParameterDeclaration(parent) && ts.isMappedTypeNode(parent.parent)) {
            return parent.name;
        }
        // /**/keyof [|T|]
        if (node.kind === 140 /* SyntaxKind.KeyOfKeyword */ && ts.isTypeOperatorNode(parent) && parent.operator === 140 /* SyntaxKind.KeyOfKeyword */ &&
            ts.isTypeReferenceNode(parent.type)) {
            return parent.type.typeName;
        }
        // /**/readonly [|name|][]
        if (node.kind === 145 /* SyntaxKind.ReadonlyKeyword */ && ts.isTypeOperatorNode(parent) && parent.operator === 145 /* SyntaxKind.ReadonlyKeyword */ &&
            ts.isArrayTypeNode(parent.type) && ts.isTypeReferenceNode(parent.type.elementType)) {
            return parent.type.elementType.typeName;
        }
        if (!forRename) {
            // /**/new [|name|]
            // /**/void [|name|]
            // /**/void obj.[|name|]
            // /**/typeof [|name|]
            // /**/typeof obj.[|name|]
            // /**/await [|name|]
            // /**/await obj.[|name|]
            // /**/yield [|name|]
            // /**/yield obj.[|name|]
            // /**/delete obj.[|name|]
            if (node.kind === 103 /* SyntaxKind.NewKeyword */ && ts.isNewExpression(parent) ||
                node.kind === 114 /* SyntaxKind.VoidKeyword */ && ts.isVoidExpression(parent) ||
                node.kind === 112 /* SyntaxKind.TypeOfKeyword */ && ts.isTypeOfExpression(parent) ||
                node.kind === 132 /* SyntaxKind.AwaitKeyword */ && ts.isAwaitExpression(parent) ||
                node.kind === 125 /* SyntaxKind.YieldKeyword */ && ts.isYieldExpression(parent) ||
                node.kind === 89 /* SyntaxKind.DeleteKeyword */ && ts.isDeleteExpression(parent)) {
                if (parent.expression) {
                    return ts.skipOuterExpressions(parent.expression);
                }
            }
            // left /**/in [|name|]
            // left /**/instanceof [|name|]
            if ((node.kind === 101 /* SyntaxKind.InKeyword */ || node.kind === 102 /* SyntaxKind.InstanceOfKeyword */) && ts.isBinaryExpression(parent) && parent.operatorToken === node) {
                return ts.skipOuterExpressions(parent.right);
            }
            // left /**/as [|name|]
            if (node.kind === 127 /* SyntaxKind.AsKeyword */ && ts.isAsExpression(parent) && ts.isTypeReferenceNode(parent.type)) {
                return parent.type.typeName;
            }
            // for (... /**/in [|name|])
            // for (... /**/of [|name|])
            if (node.kind === 101 /* SyntaxKind.InKeyword */ && ts.isForInStatement(parent) ||
                node.kind === 160 /* SyntaxKind.OfKeyword */ && ts.isForOfStatement(parent)) {
                return ts.skipOuterExpressions(parent.expression);
            }
        }
        return node;
    }
    /**
     * Adjusts the location used for "find references" and "go to definition" when the cursor was not
     * on a property name.
     */
    function getAdjustedReferenceLocation(node) {
        return getAdjustedLocation(node, /*forRename*/ false);
    }
    ts.getAdjustedReferenceLocation = getAdjustedReferenceLocation;
    /**
     * Adjusts the location used for "rename" when the cursor was not on a property name.
     */
    function getAdjustedRenameLocation(node) {
        return getAdjustedLocation(node, /*forRename*/ true);
    }
    ts.getAdjustedRenameLocation = getAdjustedRenameLocation;
    /**
     * Gets the token whose text has range [start, end) and
     * position >= start and (position < end or (position === end && token is literal or keyword or identifier))
     */
    function getTouchingPropertyName(sourceFile, position) {
        return getTouchingToken(sourceFile, position, function (n) { return ts.isPropertyNameLiteral(n) || ts.isKeyword(n.kind) || ts.isPrivateIdentifier(n); });
    }
    ts.getTouchingPropertyName = getTouchingPropertyName;
    /**
     * Returns the token if position is in [start, end).
     * If position === end, returns the preceding token if includeItemAtEndPosition(previousToken) === true
     */
    function getTouchingToken(sourceFile, position, includePrecedingTokenAtEndPosition) {
        return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ false, includePrecedingTokenAtEndPosition, /*includeEndPosition*/ false);
    }
    ts.getTouchingToken = getTouchingToken;
    /** Returns a token if position is in [start-of-leading-trivia, end) */
    function getTokenAtPosition(sourceFile, position) {
        return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ true, /*includePrecedingTokenAtEndPosition*/ undefined, /*includeEndPosition*/ false);
    }
    ts.getTokenAtPosition = getTokenAtPosition;
    /** Get the token whose text contains the position */
    function getTokenAtPositionWorker(sourceFile, position, allowPositionInLeadingTrivia, includePrecedingTokenAtEndPosition, includeEndPosition) {
        var current = sourceFile;
        var foundToken;
        var _loop_1 = function () {
            // find the child that contains 'position'
            var children = current.getChildren(sourceFile);
            var i = ts.binarySearchKey(children, position, function (_, i) { return i; }, function (middle, _) {
                // This last callback is more of a selector than a comparator -
                // `EqualTo` causes the `middle` result to be returned
                // `GreaterThan` causes recursion on the left of the middle
                // `LessThan` causes recursion on the right of the middle
                // Let's say you have 3 nodes, spanning positons
                // pos: 1, end: 3
                // pos: 3, end: 3
                // pos: 3, end: 5
                // and you're looking for the token at positon 3 - all 3 of these nodes are overlapping with position 3.
                // In fact, there's a _good argument_ that node 2 shouldn't even be allowed to exist - depending on if
                // the start or end of the ranges are considered inclusive, it's either wholly subsumed by the first or the last node.
                // Unfortunately, such nodes do exist. :( - See fourslash/completionsImport_tsx.tsx - empty jsx attributes create
                // a zero-length node.
                // What also you may not expect is that which node we return depends on the includePrecedingTokenAtEndPosition flag.
                // Specifically, if includePrecedingTokenAtEndPosition is set, we return the 1-3 node, while if it's unset, we
                // return the 3-5 node. (The zero length node is never correct.) This is because the includePrecedingTokenAtEndPosition
                // flag causes us to return the first node whose end position matches the position and which produces and acceptable token
                // kind. Meanwhile, if includePrecedingTokenAtEndPosition is unset, we look for the first node whose start is <= the
                // position and whose end is greater than the position.
                var start = allowPositionInLeadingTrivia ? children[middle].getFullStart() : children[middle].getStart(sourceFile, /*includeJsDoc*/ true);
                if (start > position) {
                    return 1 /* Comparison.GreaterThan */;
                }
                // first element whose start position is before the input and whose end position is after or equal to the input
                if (nodeContainsPosition(children[middle])) {
                    if (children[middle - 1]) {
                        // we want the _first_ element that contains the position, so left-recur if the prior node also contains the position
                        if (nodeContainsPosition(children[middle - 1])) {
                            return 1 /* Comparison.GreaterThan */;
                        }
                    }
                    return 0 /* Comparison.EqualTo */;
                }
                // this complex condition makes us left-recur around a zero-length node when includePrecedingTokenAtEndPosition is set, rather than right-recur on it
                if (includePrecedingTokenAtEndPosition && start === position && children[middle - 1] && children[middle - 1].getEnd() === position && nodeContainsPosition(children[middle - 1])) {
                    return 1 /* Comparison.GreaterThan */;
                }
                return -1 /* Comparison.LessThan */;
            });
            if (foundToken) {
                return { value: foundToken };
            }
            if (i >= 0 && children[i]) {
                current = children[i];
                return "continue-outer";
            }
            return { value: current };
        };
        outer: while (true) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
            switch (state_1) {
                case "continue-outer": continue outer;
            }
        }
        function nodeContainsPosition(node) {
            var start = allowPositionInLeadingTrivia ? node.getFullStart() : node.getStart(sourceFile, /*includeJsDoc*/ true);
            if (start > position) {
                // If this child begins after position, then all subsequent children will as well.
                return false;
            }
            var end = node.getEnd();
            if (position < end || (position === end && (node.kind === 1 /* SyntaxKind.EndOfFileToken */ || includeEndPosition))) {
                return true;
            }
            else if (includePrecedingTokenAtEndPosition && end === position) {
                var previousToken = findPrecedingToken(position, sourceFile, node);
                if (previousToken && includePrecedingTokenAtEndPosition(previousToken)) {
                    foundToken = previousToken;
                    return true;
                }
            }
            return false;
        }
    }
    /**
     * Returns the first token where position is in [start, end),
     * excluding `JsxText` tokens containing only whitespace.
     */
    function findFirstNonJsxWhitespaceToken(sourceFile, position) {
        var tokenAtPosition = getTokenAtPosition(sourceFile, position);
        while (isWhiteSpaceOnlyJsxText(tokenAtPosition)) {
            var nextToken = findNextToken(tokenAtPosition, tokenAtPosition.parent, sourceFile);
            if (!nextToken)
                return;
            tokenAtPosition = nextToken;
        }
        return tokenAtPosition;
    }
    ts.findFirstNonJsxWhitespaceToken = findFirstNonJsxWhitespaceToken;
    /**
     * The token on the left of the position is the token that strictly includes the position
     * or sits to the left of the cursor if it is on a boundary. For example
     *
     *   fo|o               -> will return foo
     *   foo <comment> |bar -> will return foo
     *
     */
    function findTokenOnLeftOfPosition(file, position) {
        // Ideally, getTokenAtPosition should return a token. However, it is currently
        // broken, so we do a check to make sure the result was indeed a token.
        var tokenAtPosition = getTokenAtPosition(file, position);
        if (ts.isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {
            return tokenAtPosition;
        }
        return findPrecedingToken(position, file);
    }
    ts.findTokenOnLeftOfPosition = findTokenOnLeftOfPosition;
    function findNextToken(previousToken, parent, sourceFile) {
        return find(parent);
        function find(n) {
            if (ts.isToken(n) && n.pos === previousToken.end) {
                // this is token that starts at the end of previous token - return it
                return n;
            }
            return ts.firstDefined(n.getChildren(sourceFile), function (child) {
                var shouldDiveInChildNode = 
                // previous token is enclosed somewhere in the child
                (child.pos <= previousToken.pos && child.end > previousToken.end) ||
                    // previous token ends exactly at the beginning of child
                    (child.pos === previousToken.end);
                return shouldDiveInChildNode && nodeHasTokens(child, sourceFile) ? find(child) : undefined;
            });
        }
    }
    ts.findNextToken = findNextToken;
    function findPrecedingToken(position, sourceFile, startNode, excludeJsdoc) {
        var result = find((startNode || sourceFile));
        ts.Debug.assert(!(result && isWhiteSpaceOnlyJsxText(result)));
        return result;
        function find(n) {
            if (isNonWhitespaceToken(n) && n.kind !== 1 /* SyntaxKind.EndOfFileToken */) {
                return n;
            }
            var children = n.getChildren(sourceFile);
            var i = ts.binarySearchKey(children, position, function (_, i) { return i; }, function (middle, _) {
                // This last callback is more of a selector than a comparator -
                // `EqualTo` causes the `middle` result to be returned
                // `GreaterThan` causes recursion on the left of the middle
                // `LessThan` causes recursion on the right of the middle
                if (position < children[middle].end) {
                    // first element whose end position is greater than the input position
                    if (!children[middle - 1] || position >= children[middle - 1].end) {
                        return 0 /* Comparison.EqualTo */;
                    }
                    return 1 /* Comparison.GreaterThan */;
                }
                return -1 /* Comparison.LessThan */;
            });
            if (i >= 0 && children[i]) {
                var child = children[i];
                // Note that the span of a node's tokens is [node.getStart(...), node.end).
                // Given that `position < child.end` and child has constituent tokens, we distinguish these cases:
                // 1) `position` precedes `child`'s tokens or `child` has no tokens (ie: in a comment or whitespace preceding `child`):
                // we need to find the last token in a previous child.
                // 2) `position` is within the same span: we recurse on `child`.
                if (position < child.end) {
                    var start = child.getStart(sourceFile, /*includeJsDoc*/ !excludeJsdoc);
                    var lookInPreviousChild = (start >= position) || // cursor in the leading trivia
                        !nodeHasTokens(child, sourceFile) ||
                        isWhiteSpaceOnlyJsxText(child);
                    if (lookInPreviousChild) {
                        // actual start of the node is past the position - previous token should be at the end of previous child
                        var candidate_1 = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ i, sourceFile, n.kind);
                        return candidate_1 && findRightmostToken(candidate_1, sourceFile);
                    }
                    else {
                        // candidate should be in this node
                        return find(child);
                    }
                }
            }
            ts.Debug.assert(startNode !== undefined || n.kind === 305 /* SyntaxKind.SourceFile */ || n.kind === 1 /* SyntaxKind.EndOfFileToken */ || ts.isJSDocCommentContainingNode(n));
            // Here we know that none of child token nodes embrace the position,
            // the only known case is when position is at the end of the file.
            // Try to find the rightmost token in the file without filtering.
            // Namely we are skipping the check: 'position < node.end'
            var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ children.length, sourceFile, n.kind);
            return candidate && findRightmostToken(candidate, sourceFile);
        }
    }
    ts.findPrecedingToken = findPrecedingToken;
    function isNonWhitespaceToken(n) {
        return ts.isToken(n) && !isWhiteSpaceOnlyJsxText(n);
    }
    function findRightmostToken(n, sourceFile) {
        if (isNonWhitespaceToken(n)) {
            return n;
        }
        var children = n.getChildren(sourceFile);
        if (children.length === 0) {
            return n;
        }
        var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ children.length, sourceFile, n.kind);
        return candidate && findRightmostToken(candidate, sourceFile);
    }
    /**
     * Finds the rightmost child to the left of `children[exclusiveStartPosition]` which is a non-all-whitespace token or has constituent tokens.
     */
    function findRightmostChildNodeWithTokens(children, exclusiveStartPosition, sourceFile, parentKind) {
        for (var i = exclusiveStartPosition - 1; i >= 0; i--) {
            var child = children[i];
            if (isWhiteSpaceOnlyJsxText(child)) {
                if (i === 0 && (parentKind === 11 /* SyntaxKind.JsxText */ || parentKind === 279 /* SyntaxKind.JsxSelfClosingElement */)) {
                    ts.Debug.fail("`JsxText` tokens should not be the first child of `JsxElement | JsxSelfClosingElement`");
                }
            }
            else if (nodeHasTokens(children[i], sourceFile)) {
                return children[i];
            }
        }
    }
    function isInString(sourceFile, position, previousToken) {
        if (previousToken === void 0) { previousToken = findPrecedingToken(position, sourceFile); }
        if (previousToken && ts.isStringTextContainingNode(previousToken)) {
            var start = previousToken.getStart(sourceFile);
            var end = previousToken.getEnd();
            // To be "in" one of these literals, the position has to be:
            //   1. entirely within the token text.
            //   2. at the end position of an unterminated token.
            //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
            if (start < position && position < end) {
                return true;
            }
            if (position === end) {
                return !!previousToken.isUnterminated;
            }
        }
        return false;
    }
    ts.isInString = isInString;
    /**
     * returns true if the position is in between the open and close elements of an JSX expression.
     */
    function isInsideJsxElementOrAttribute(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        if (!token) {
            return false;
        }
        if (token.kind === 11 /* SyntaxKind.JsxText */) {
            return true;
        }
        // <div>Hello |</div>
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 11 /* SyntaxKind.JsxText */) {
            return true;
        }
        // <div> { | </div> or <div a={| </div>
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 288 /* SyntaxKind.JsxExpression */) {
            return true;
        }
        // <div> {
        // |
        // } < /div>
        if (token && token.kind === 19 /* SyntaxKind.CloseBraceToken */ && token.parent.kind === 288 /* SyntaxKind.JsxExpression */) {
            return true;
        }
        // <div>|</div>
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 281 /* SyntaxKind.JsxClosingElement */) {
            return true;
        }
        return false;
    }
    ts.isInsideJsxElementOrAttribute = isInsideJsxElementOrAttribute;
    function isWhiteSpaceOnlyJsxText(node) {
        return ts.isJsxText(node) && node.containsOnlyTriviaWhiteSpaces;
    }
    function isInTemplateString(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        return ts.isTemplateLiteralKind(token.kind) && position > token.getStart(sourceFile);
    }
    ts.isInTemplateString = isInTemplateString;
    function isInJSXText(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        if (ts.isJsxText(token)) {
            return true;
        }
        if (token.kind === 18 /* SyntaxKind.OpenBraceToken */ && ts.isJsxExpression(token.parent) && ts.isJsxElement(token.parent.parent)) {
            return true;
        }
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && ts.isJsxOpeningLikeElement(token.parent) && ts.isJsxElement(token.parent.parent)) {
            return true;
        }
        return false;
    }
    ts.isInJSXText = isInJSXText;
    function isInsideJsxElement(sourceFile, position) {
        function isInsideJsxElementTraversal(node) {
            while (node) {
                if (node.kind >= 279 /* SyntaxKind.JsxSelfClosingElement */ && node.kind <= 288 /* SyntaxKind.JsxExpression */
                    || node.kind === 11 /* SyntaxKind.JsxText */
                    || node.kind === 29 /* SyntaxKind.LessThanToken */
                    || node.kind === 31 /* SyntaxKind.GreaterThanToken */
                    || node.kind === 79 /* SyntaxKind.Identifier */
                    || node.kind === 19 /* SyntaxKind.CloseBraceToken */
                    || node.kind === 18 /* SyntaxKind.OpenBraceToken */
                    || node.kind === 43 /* SyntaxKind.SlashToken */) {
                    node = node.parent;
                }
                else if (node.kind === 278 /* SyntaxKind.JsxElement */) {
                    if (position > node.getStart(sourceFile))
                        return true;
                    node = node.parent;
                }
                else {
                    return false;
                }
            }
            return false;
        }
        return isInsideJsxElementTraversal(getTokenAtPosition(sourceFile, position));
    }
    ts.isInsideJsxElement = isInsideJsxElement;
    function findPrecedingMatchingToken(token, matchingTokenKind, sourceFile) {
        var closeTokenText = ts.tokenToString(token.kind);
        var matchingTokenText = ts.tokenToString(matchingTokenKind);
        var tokenFullStart = token.getFullStart();
        // Text-scan based fast path - can be bamboozled by comments and other trivia, but often provides
        // a good, fast approximation without too much extra work in the cases where it fails.
        var bestGuessIndex = sourceFile.text.lastIndexOf(matchingTokenText, tokenFullStart);
        if (bestGuessIndex === -1) {
            return undefined; // if the token text doesn't appear in the file, there can't be a match - super fast bail
        }
        // we can only use the textual result directly if we didn't have to count any close tokens within the range
        if (sourceFile.text.lastIndexOf(closeTokenText, tokenFullStart - 1) < bestGuessIndex) {
            var nodeAtGuess = findPrecedingToken(bestGuessIndex + 1, sourceFile);
            if (nodeAtGuess && nodeAtGuess.kind === matchingTokenKind) {
                return nodeAtGuess;
            }
        }
        var tokenKind = token.kind;
        var remainingMatchingTokens = 0;
        while (true) {
            var preceding = findPrecedingToken(token.getFullStart(), sourceFile);
            if (!preceding) {
                return undefined;
            }
            token = preceding;
            if (token.kind === matchingTokenKind) {
                if (remainingMatchingTokens === 0) {
                    return token;
                }
                remainingMatchingTokens--;
            }
            else if (token.kind === tokenKind) {
                remainingMatchingTokens++;
            }
        }
    }
    ts.findPrecedingMatchingToken = findPrecedingMatchingToken;
    function removeOptionality(type, isOptionalExpression, isOptionalChain) {
        return isOptionalExpression ? type.getNonNullableType() :
            isOptionalChain ? type.getNonOptionalType() :
                type;
    }
    ts.removeOptionality = removeOptionality;
    function isPossiblyTypeArgumentPosition(token, sourceFile, checker) {
        var info = getPossibleTypeArgumentsInfo(token, sourceFile);
        return info !== undefined && (ts.isPartOfTypeNode(info.called) ||
            getPossibleGenericSignatures(info.called, info.nTypeArguments, checker).length !== 0 ||
            isPossiblyTypeArgumentPosition(info.called, sourceFile, checker));
    }
    ts.isPossiblyTypeArgumentPosition = isPossiblyTypeArgumentPosition;
    function getPossibleGenericSignatures(called, typeArgumentCount, checker) {
        var type = checker.getTypeAtLocation(called);
        if (ts.isOptionalChain(called.parent)) {
            type = removeOptionality(type, ts.isOptionalChainRoot(called.parent), /*isOptionalChain*/ true);
        }
        var signatures = ts.isNewExpression(called.parent) ? type.getConstructSignatures() : type.getCallSignatures();
        return signatures.filter(function (candidate) { return !!candidate.typeParameters && candidate.typeParameters.length >= typeArgumentCount; });
    }
    ts.getPossibleGenericSignatures = getPossibleGenericSignatures;
    // Get info for an expression like `f <` that may be the start of type arguments.
    function getPossibleTypeArgumentsInfo(tokenIn, sourceFile) {
        // This is a rare case, but one that saves on a _lot_ of work if true - if the source file has _no_ `<` character,
        // then there obviously can't be any type arguments - no expensive brace-matching backwards scanning required
        if (sourceFile.text.lastIndexOf("<", tokenIn ? tokenIn.pos : sourceFile.text.length) === -1) {
            return undefined;
        }
        var token = tokenIn;
        // This function determines if the node could be type argument position
        // Since during editing, when type argument list is not complete,
        // the tree could be of any shape depending on the tokens parsed before current node,
        // scanning of the previous identifier followed by "<" before current node would give us better result
        // Note that we also balance out the already provided type arguments, arrays, object literals while doing so
        var remainingLessThanTokens = 0;
        var nTypeArguments = 0;
        while (token) {
            switch (token.kind) {
                case 29 /* SyntaxKind.LessThanToken */:
                    // Found the beginning of the generic argument expression
                    token = findPrecedingToken(token.getFullStart(), sourceFile);
                    if (token && token.kind === 28 /* SyntaxKind.QuestionDotToken */) {
                        token = findPrecedingToken(token.getFullStart(), sourceFile);
                    }
                    if (!token || !ts.isIdentifier(token))
                        return undefined;
                    if (!remainingLessThanTokens) {
                        return ts.isDeclarationName(token) ? undefined : { called: token, nTypeArguments: nTypeArguments };
                    }
                    remainingLessThanTokens--;
                    break;
                case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
                    remainingLessThanTokens = +3;
                    break;
                case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
                    remainingLessThanTokens = +2;
                    break;
                case 31 /* SyntaxKind.GreaterThanToken */:
                    remainingLessThanTokens++;
                    break;
                case 19 /* SyntaxKind.CloseBraceToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 18 /* SyntaxKind.OpenBraceToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                case 21 /* SyntaxKind.CloseParenToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 20 /* SyntaxKind.OpenParenToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                case 23 /* SyntaxKind.CloseBracketToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 22 /* SyntaxKind.OpenBracketToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                // Valid tokens in a type name. Skip.
                case 27 /* SyntaxKind.CommaToken */:
                    nTypeArguments++;
                    break;
                case 38 /* SyntaxKind.EqualsGreaterThanToken */:
                // falls through
                case 79 /* SyntaxKind.Identifier */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                // falls through
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 94 /* SyntaxKind.ExtendsKeyword */:
                case 140 /* SyntaxKind.KeyOfKeyword */:
                case 24 /* SyntaxKind.DotToken */:
                case 51 /* SyntaxKind.BarToken */:
                case 57 /* SyntaxKind.QuestionToken */:
                case 58 /* SyntaxKind.ColonToken */:
                    break;
                default:
                    if (ts.isTypeNode(token)) {
                        break;
                    }
                    // Invalid token in type
                    return undefined;
            }
            token = findPrecedingToken(token.getFullStart(), sourceFile);
        }
        return undefined;
    }
    ts.getPossibleTypeArgumentsInfo = getPossibleTypeArgumentsInfo;
    /**
     * Returns true if the cursor at position in sourceFile is within a comment.
     *
     * @param tokenAtPosition Must equal `getTokenAtPosition(sourceFile, position)
     * @param predicate Additional predicate to test on the comment range.
     */
    function isInComment(sourceFile, position, tokenAtPosition) {
        return ts.formatting.getRangeOfEnclosingComment(sourceFile, position, /*precedingToken*/ undefined, tokenAtPosition);
    }
    ts.isInComment = isInComment;
    function hasDocComment(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        return !!ts.findAncestor(token, ts.isJSDoc);
    }
    ts.hasDocComment = hasDocComment;
    function nodeHasTokens(n, sourceFile) {
        // If we have a token or node that has a non-zero width, it must have tokens.
        // Note: getWidth() does not take trivia into account.
        return n.kind === 1 /* SyntaxKind.EndOfFileToken */ ? !!n.jsDoc : n.getWidth(sourceFile) !== 0;
    }
    function getNodeModifiers(node, excludeFlags) {
        if (excludeFlags === void 0) { excludeFlags = 0 /* ModifierFlags.None */; }
        var result = [];
        var flags = ts.isDeclaration(node)
            ? ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(node) & ~excludeFlags
            : 0 /* ModifierFlags.None */;
        if (flags & 8 /* ModifierFlags.Private */)
            result.push("private" /* ScriptElementKindModifier.privateMemberModifier */);
        if (flags & 16 /* ModifierFlags.Protected */)
            result.push("protected" /* ScriptElementKindModifier.protectedMemberModifier */);
        if (flags & 4 /* ModifierFlags.Public */)
            result.push("public" /* ScriptElementKindModifier.publicMemberModifier */);
        if (flags & 32 /* ModifierFlags.Static */ || ts.isClassStaticBlockDeclaration(node))
            result.push("static" /* ScriptElementKindModifier.staticModifier */);
        if (flags & 128 /* ModifierFlags.Abstract */)
            result.push("abstract" /* ScriptElementKindModifier.abstractModifier */);
        if (flags & 1 /* ModifierFlags.Export */)
            result.push("export" /* ScriptElementKindModifier.exportedModifier */);
        if (flags & 8192 /* ModifierFlags.Deprecated */)
            result.push("deprecated" /* ScriptElementKindModifier.deprecatedModifier */);
        if (node.flags & 16777216 /* NodeFlags.Ambient */)
            result.push("declare" /* ScriptElementKindModifier.ambientModifier */);
        if (node.kind === 271 /* SyntaxKind.ExportAssignment */)
            result.push("export" /* ScriptElementKindModifier.exportedModifier */);
        return result.length > 0 ? result.join(",") : "" /* ScriptElementKindModifier.none */;
    }
    ts.getNodeModifiers = getNodeModifiers;
    function getTypeArgumentOrTypeParameterList(node) {
        if (node.kind === 178 /* SyntaxKind.TypeReference */ || node.kind === 208 /* SyntaxKind.CallExpression */) {
            return node.typeArguments;
        }
        if (ts.isFunctionLike(node) || node.kind === 257 /* SyntaxKind.ClassDeclaration */ || node.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
            return node.typeParameters;
        }
        return undefined;
    }
    ts.getTypeArgumentOrTypeParameterList = getTypeArgumentOrTypeParameterList;
    function isComment(kind) {
        return kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ || kind === 3 /* SyntaxKind.MultiLineCommentTrivia */;
    }
    ts.isComment = isComment;
    function isStringOrRegularExpressionOrTemplateLiteral(kind) {
        if (kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 13 /* SyntaxKind.RegularExpressionLiteral */
            || ts.isTemplateLiteralKind(kind)) {
            return true;
        }
        return false;
    }
    ts.isStringOrRegularExpressionOrTemplateLiteral = isStringOrRegularExpressionOrTemplateLiteral;
    function isPunctuation(kind) {
        return 18 /* SyntaxKind.FirstPunctuation */ <= kind && kind <= 78 /* SyntaxKind.LastPunctuation */;
    }
    ts.isPunctuation = isPunctuation;
    function isInsideTemplateLiteral(node, position, sourceFile) {
        return ts.isTemplateLiteralKind(node.kind)
            && (node.getStart(sourceFile) < position && position < node.end) || (!!node.isUnterminated && position === node.end);
    }
    ts.isInsideTemplateLiteral = isInsideTemplateLiteral;
    function isAccessibilityModifier(kind) {
        switch (kind) {
            case 123 /* SyntaxKind.PublicKeyword */:
            case 121 /* SyntaxKind.PrivateKeyword */:
            case 122 /* SyntaxKind.ProtectedKeyword */:
                return true;
        }
        return false;
    }
    ts.isAccessibilityModifier = isAccessibilityModifier;
    function cloneCompilerOptions(options) {
        var result = ts.clone(options);
        ts.setConfigFileInOptions(result, options && options.configFile);
        return result;
    }
    ts.cloneCompilerOptions = cloneCompilerOptions;
    function isArrayLiteralOrObjectLiteralDestructuringPattern(node) {
        if (node.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ ||
            node.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
            // [a,b,c] from:
            // [a, b, c] = someExpression;
            if (node.parent.kind === 221 /* SyntaxKind.BinaryExpression */ &&
                node.parent.left === node &&
                node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
                return true;
            }
            // [a, b, c] from:
            // for([a, b, c] of expression)
            if (node.parent.kind === 244 /* SyntaxKind.ForOfStatement */ &&
                node.parent.initializer === node) {
                return true;
            }
            // [a, b, c] of
            // [x, [a, b, c] ] = someExpression
            // or
            // {x, a: {a, b, c} } = someExpression
            if (isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent.kind === 296 /* SyntaxKind.PropertyAssignment */ ? node.parent.parent : node.parent)) {
                return true;
            }
        }
        return false;
    }
    ts.isArrayLiteralOrObjectLiteralDestructuringPattern = isArrayLiteralOrObjectLiteralDestructuringPattern;
    function isInReferenceComment(sourceFile, position) {
        return isInReferenceCommentWorker(sourceFile, position, /*shouldBeReference*/ true);
    }
    ts.isInReferenceComment = isInReferenceComment;
    function isInNonReferenceComment(sourceFile, position) {
        return isInReferenceCommentWorker(sourceFile, position, /*shouldBeReference*/ false);
    }
    ts.isInNonReferenceComment = isInNonReferenceComment;
    function isInReferenceCommentWorker(sourceFile, position, shouldBeReference) {
        var range = isInComment(sourceFile, position, /*tokenAtPosition*/ undefined);
        return !!range && shouldBeReference === tripleSlashDirectivePrefixRegex.test(sourceFile.text.substring(range.pos, range.end));
    }
    function getReplacementSpanForContextToken(contextToken) {
        if (!contextToken)
            return undefined;
        switch (contextToken.kind) {
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                return createTextSpanFromStringLiteralLikeContent(contextToken);
            default:
                return createTextSpanFromNode(contextToken);
        }
    }
    ts.getReplacementSpanForContextToken = getReplacementSpanForContextToken;
    function createTextSpanFromNode(node, sourceFile, endNode) {
        return ts.createTextSpanFromBounds(node.getStart(sourceFile), (endNode || node).getEnd());
    }
    ts.createTextSpanFromNode = createTextSpanFromNode;
    function createTextSpanFromStringLiteralLikeContent(node) {
        if (node.isUnterminated)
            return undefined;
        return ts.createTextSpanFromBounds(node.getStart() + 1, node.getEnd() - 1);
    }
    ts.createTextSpanFromStringLiteralLikeContent = createTextSpanFromStringLiteralLikeContent;
    function createTextRangeFromNode(node, sourceFile) {
        return ts.createRange(node.getStart(sourceFile), node.end);
    }
    ts.createTextRangeFromNode = createTextRangeFromNode;
    function createTextSpanFromRange(range) {
        return ts.createTextSpanFromBounds(range.pos, range.end);
    }
    ts.createTextSpanFromRange = createTextSpanFromRange;
    function createTextRangeFromSpan(span) {
        return ts.createRange(span.start, span.start + span.length);
    }
    ts.createTextRangeFromSpan = createTextRangeFromSpan;
    function createTextChangeFromStartLength(start, length, newText) {
        return createTextChange(ts.createTextSpan(start, length), newText);
    }
    ts.createTextChangeFromStartLength = createTextChangeFromStartLength;
    function createTextChange(span, newText) {
        return { span: span, newText: newText };
    }
    ts.createTextChange = createTextChange;
    ts.typeKeywords = [
        130 /* SyntaxKind.AnyKeyword */,
        128 /* SyntaxKind.AssertsKeyword */,
        158 /* SyntaxKind.BigIntKeyword */,
        133 /* SyntaxKind.BooleanKeyword */,
        95 /* SyntaxKind.FalseKeyword */,
        137 /* SyntaxKind.InferKeyword */,
        140 /* SyntaxKind.KeyOfKeyword */,
        143 /* SyntaxKind.NeverKeyword */,
        104 /* SyntaxKind.NullKeyword */,
        147 /* SyntaxKind.NumberKeyword */,
        148 /* SyntaxKind.ObjectKeyword */,
        145 /* SyntaxKind.ReadonlyKeyword */,
        150 /* SyntaxKind.StringKeyword */,
        151 /* SyntaxKind.SymbolKeyword */,
        110 /* SyntaxKind.TrueKeyword */,
        114 /* SyntaxKind.VoidKeyword */,
        153 /* SyntaxKind.UndefinedKeyword */,
        154 /* SyntaxKind.UniqueKeyword */,
        155 /* SyntaxKind.UnknownKeyword */,
    ];
    function isTypeKeyword(kind) {
        return ts.contains(ts.typeKeywords, kind);
    }
    ts.isTypeKeyword = isTypeKeyword;
    function isTypeKeywordToken(node) {
        return node.kind === 152 /* SyntaxKind.TypeKeyword */;
    }
    ts.isTypeKeywordToken = isTypeKeywordToken;
    function isTypeKeywordTokenOrIdentifier(node) {
        return isTypeKeywordToken(node) || ts.isIdentifier(node) && node.text === "type";
    }
    ts.isTypeKeywordTokenOrIdentifier = isTypeKeywordTokenOrIdentifier;
    /** True if the symbol is for an external module, as opposed to a namespace. */
    function isExternalModuleSymbol(moduleSymbol) {
        return !!(moduleSymbol.flags & 1536 /* SymbolFlags.Module */) && moduleSymbol.name.charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */;
    }
    ts.isExternalModuleSymbol = isExternalModuleSymbol;
    function nodeSeenTracker() {
        var seen = [];
        return function (node) {
            var id = ts.getNodeId(node);
            return !seen[id] && (seen[id] = true);
        };
    }
    ts.nodeSeenTracker = nodeSeenTracker;
    function getSnapshotText(snap) {
        return snap.getText(0, snap.getLength());
    }
    ts.getSnapshotText = getSnapshotText;
    function repeatString(str, count) {
        var result = "";
        for (var i = 0; i < count; i++) {
            result += str;
        }
        return result;
    }
    ts.repeatString = repeatString;
    function skipConstraint(type) {
        return type.isTypeParameter() ? type.getConstraint() || type : type;
    }
    ts.skipConstraint = skipConstraint;
    function getNameFromPropertyName(name) {
        return name.kind === 162 /* SyntaxKind.ComputedPropertyName */
            // treat computed property names where expression is string/numeric literal as just string/numeric literal
            ? ts.isStringOrNumericLiteralLike(name.expression) ? name.expression.text : undefined
            : ts.isPrivateIdentifier(name) ? ts.idText(name) : ts.getTextOfIdentifierOrLiteral(name);
    }
    ts.getNameFromPropertyName = getNameFromPropertyName;
    function programContainsModules(program) {
        return program.getSourceFiles().some(function (s) { return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!(s.externalModuleIndicator || s.commonJsModuleIndicator); });
    }
    ts.programContainsModules = programContainsModules;
    function programContainsEsModules(program) {
        return program.getSourceFiles().some(function (s) { return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!s.externalModuleIndicator; });
    }
    ts.programContainsEsModules = programContainsEsModules;
    function compilerOptionsIndicateEsModules(compilerOptions) {
        return !!compilerOptions.module || ts.getEmitScriptTarget(compilerOptions) >= 2 /* ScriptTarget.ES2015 */ || !!compilerOptions.noEmit;
    }
    ts.compilerOptionsIndicateEsModules = compilerOptionsIndicateEsModules;
    function createModuleSpecifierResolutionHost(program, host) {
        // Mix in `getSymlinkCache` from Program when host doesn't have it
        // in order for non-Project hosts to have a symlinks cache.
        return {
            fileExists: function (fileName) { return program.fileExists(fileName); },
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            readFile: ts.maybeBind(host, host.readFile),
            useCaseSensitiveFileNames: ts.maybeBind(host, host.useCaseSensitiveFileNames),
            getSymlinkCache: ts.maybeBind(host, host.getSymlinkCache) || program.getSymlinkCache,
            getModuleSpecifierCache: ts.maybeBind(host, host.getModuleSpecifierCache),
            getPackageJsonInfoCache: function () { var _a; return (_a = program.getModuleResolutionCache()) === null || _a === void 0 ? void 0 : _a.getPackageJsonInfoCache(); },
            getGlobalTypingsCacheLocation: ts.maybeBind(host, host.getGlobalTypingsCacheLocation),
            redirectTargetsMap: program.redirectTargetsMap,
            getProjectReferenceRedirect: function (fileName) { return program.getProjectReferenceRedirect(fileName); },
            isSourceOfProjectReferenceRedirect: function (fileName) { return program.isSourceOfProjectReferenceRedirect(fileName); },
            getNearestAncestorDirectoryWithPackageJson: ts.maybeBind(host, host.getNearestAncestorDirectoryWithPackageJson),
            getFileIncludeReasons: function () { return program.getFileIncludeReasons(); },
        };
    }
    ts.createModuleSpecifierResolutionHost = createModuleSpecifierResolutionHost;
    function getModuleSpecifierResolverHost(program, host) {
        return __assign(__assign({}, createModuleSpecifierResolutionHost(program, host)), { getCommonSourceDirectory: function () { return program.getCommonSourceDirectory(); } });
    }
    ts.getModuleSpecifierResolverHost = getModuleSpecifierResolverHost;
    function moduleResolutionRespectsExports(moduleResolution) {
        return moduleResolution >= ts.ModuleResolutionKind.Node16 && moduleResolution <= ts.ModuleResolutionKind.NodeNext;
    }
    ts.moduleResolutionRespectsExports = moduleResolutionRespectsExports;
    function moduleResolutionUsesNodeModules(moduleResolution) {
        return moduleResolution === ts.ModuleResolutionKind.NodeJs || moduleResolution >= ts.ModuleResolutionKind.Node16 && moduleResolution <= ts.ModuleResolutionKind.NodeNext;
    }
    ts.moduleResolutionUsesNodeModules = moduleResolutionUsesNodeModules;
    function makeImportIfNecessary(defaultImport, namedImports, moduleSpecifier, quotePreference) {
        return defaultImport || namedImports && namedImports.length ? makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference) : undefined;
    }
    ts.makeImportIfNecessary = makeImportIfNecessary;
    function makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference, isTypeOnly) {
        return ts.factory.createImportDeclaration(
        /*decorators*/ undefined, 
        /*modifiers*/ undefined, defaultImport || namedImports
            ? ts.factory.createImportClause(!!isTypeOnly, defaultImport, namedImports && namedImports.length ? ts.factory.createNamedImports(namedImports) : undefined)
            : undefined, typeof moduleSpecifier === "string" ? makeStringLiteral(moduleSpecifier, quotePreference) : moduleSpecifier, 
        /*assertClause*/ undefined);
    }
    ts.makeImport = makeImport;
    function makeStringLiteral(text, quotePreference) {
        return ts.factory.createStringLiteral(text, quotePreference === 0 /* QuotePreference.Single */);
    }
    ts.makeStringLiteral = makeStringLiteral;
    var QuotePreference;
    (function (QuotePreference) {
        QuotePreference[QuotePreference["Single"] = 0] = "Single";
        QuotePreference[QuotePreference["Double"] = 1] = "Double";
    })(QuotePreference = ts.QuotePreference || (ts.QuotePreference = {}));
    function quotePreferenceFromString(str, sourceFile) {
        return ts.isStringDoubleQuoted(str, sourceFile) ? 1 /* QuotePreference.Double */ : 0 /* QuotePreference.Single */;
    }
    ts.quotePreferenceFromString = quotePreferenceFromString;
    function getQuotePreference(sourceFile, preferences) {
        if (preferences.quotePreference && preferences.quotePreference !== "auto") {
            return preferences.quotePreference === "single" ? 0 /* QuotePreference.Single */ : 1 /* QuotePreference.Double */;
        }
        else {
            // ignore synthetic import added when importHelpers: true
            var firstModuleSpecifier = sourceFile.imports &&
                ts.find(sourceFile.imports, function (n) { return ts.isStringLiteral(n) && !ts.nodeIsSynthesized(n.parent); });
            return firstModuleSpecifier ? quotePreferenceFromString(firstModuleSpecifier, sourceFile) : 1 /* QuotePreference.Double */;
        }
    }
    ts.getQuotePreference = getQuotePreference;
    function getQuoteFromPreference(qp) {
        switch (qp) {
            case 0 /* QuotePreference.Single */: return "'";
            case 1 /* QuotePreference.Double */: return '"';
            default: return ts.Debug.assertNever(qp);
        }
    }
    ts.getQuoteFromPreference = getQuoteFromPreference;
    function symbolNameNoDefault(symbol) {
        var escaped = symbolEscapedNameNoDefault(symbol);
        return escaped === undefined ? undefined : ts.unescapeLeadingUnderscores(escaped);
    }
    ts.symbolNameNoDefault = symbolNameNoDefault;
    function symbolEscapedNameNoDefault(symbol) {
        if (symbol.escapedName !== "default" /* InternalSymbolName.Default */) {
            return symbol.escapedName;
        }
        return ts.firstDefined(symbol.declarations, function (decl) {
            var name = ts.getNameOfDeclaration(decl);
            return name && name.kind === 79 /* SyntaxKind.Identifier */ ? name.escapedText : undefined;
        });
    }
    ts.symbolEscapedNameNoDefault = symbolEscapedNameNoDefault;
    function isModuleSpecifierLike(node) {
        return ts.isStringLiteralLike(node) && (ts.isExternalModuleReference(node.parent) ||
            ts.isImportDeclaration(node.parent) ||
            ts.isRequireCall(node.parent, /*requireStringLiteralLikeArgument*/ false) && node.parent.arguments[0] === node ||
            ts.isImportCall(node.parent) && node.parent.arguments[0] === node);
    }
    ts.isModuleSpecifierLike = isModuleSpecifierLike;
    function isObjectBindingElementWithoutPropertyName(bindingElement) {
        return ts.isBindingElement(bindingElement) &&
            ts.isObjectBindingPattern(bindingElement.parent) &&
            ts.isIdentifier(bindingElement.name) &&
            !bindingElement.propertyName;
    }
    ts.isObjectBindingElementWithoutPropertyName = isObjectBindingElementWithoutPropertyName;
    function getPropertySymbolFromBindingElement(checker, bindingElement) {
        var typeOfPattern = checker.getTypeAtLocation(bindingElement.parent);
        return typeOfPattern && checker.getPropertyOfType(typeOfPattern, bindingElement.name.text);
    }
    ts.getPropertySymbolFromBindingElement = getPropertySymbolFromBindingElement;
    function getParentNodeInSpan(node, file, span) {
        if (!node)
            return undefined;
        while (node.parent) {
            if (ts.isSourceFile(node.parent) || !spanContainsNode(span, node.parent, file)) {
                return node;
            }
            node = node.parent;
        }
    }
    ts.getParentNodeInSpan = getParentNodeInSpan;
    function spanContainsNode(span, node, file) {
        return ts.textSpanContainsPosition(span, node.getStart(file)) &&
            node.getEnd() <= ts.textSpanEnd(span);
    }
    function findModifier(node, kind) {
        return node.modifiers && ts.find(node.modifiers, function (m) { return m.kind === kind; });
    }
    ts.findModifier = findModifier;
    function insertImports(changes, sourceFile, imports, blankLineBetween) {
        var decl = ts.isArray(imports) ? imports[0] : imports;
        var importKindPredicate = decl.kind === 237 /* SyntaxKind.VariableStatement */ ? ts.isRequireVariableStatement : ts.isAnyImportSyntax;
        var existingImportStatements = ts.filter(sourceFile.statements, importKindPredicate);
        var sortedNewImports = ts.isArray(imports) ? ts.stableSort(imports, ts.OrganizeImports.compareImportsOrRequireStatements) : [imports];
        if (!existingImportStatements.length) {
            changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
        }
        else if (existingImportStatements && ts.OrganizeImports.importsAreSorted(existingImportStatements)) {
            for (var _i = 0, sortedNewImports_1 = sortedNewImports; _i < sortedNewImports_1.length; _i++) {
                var newImport = sortedNewImports_1[_i];
                var insertionIndex = ts.OrganizeImports.getImportDeclarationInsertionIndex(existingImportStatements, newImport);
                if (insertionIndex === 0) {
                    // If the first import is top-of-file, insert after the leading comment which is likely the header.
                    var options = existingImportStatements[0] === sourceFile.statements[0] ?
                        { leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude } : {};
                    changes.insertNodeBefore(sourceFile, existingImportStatements[0], newImport, /*blankLineBetween*/ false, options);
                }
                else {
                    var prevImport = existingImportStatements[insertionIndex - 1];
                    changes.insertNodeAfter(sourceFile, prevImport, newImport);
                }
            }
        }
        else {
            var lastExistingImport = ts.lastOrUndefined(existingImportStatements);
            if (lastExistingImport) {
                changes.insertNodesAfter(sourceFile, lastExistingImport, sortedNewImports);
            }
            else {
                changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
            }
        }
    }
    ts.insertImports = insertImports;
    function getTypeKeywordOfTypeOnlyImport(importClause, sourceFile) {
        ts.Debug.assert(importClause.isTypeOnly);
        return ts.cast(importClause.getChildAt(0, sourceFile), isTypeKeywordToken);
    }
    ts.getTypeKeywordOfTypeOnlyImport = getTypeKeywordOfTypeOnlyImport;
    function textSpansEqual(a, b) {
        return !!a && !!b && a.start === b.start && a.length === b.length;
    }
    ts.textSpansEqual = textSpansEqual;
    function documentSpansEqual(a, b) {
        return a.fileName === b.fileName && textSpansEqual(a.textSpan, b.textSpan);
    }
    ts.documentSpansEqual = documentSpansEqual;
    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     */
    function forEachUnique(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                if (array.indexOf(array[i]) === i) {
                    var result = callback(array[i], i);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return undefined;
    }
    ts.forEachUnique = forEachUnique;
    function isTextWhiteSpaceLike(text, startPos, endPos) {
        for (var i = startPos; i < endPos; i++) {
            if (!ts.isWhiteSpaceLike(text.charCodeAt(i))) {
                return false;
            }
        }
        return true;
    }
    ts.isTextWhiteSpaceLike = isTextWhiteSpaceLike;
    // #endregion
    // Display-part writer helpers
    // #region
    function isFirstDeclarationOfSymbolParameter(symbol) {
        var declaration = symbol.declarations ? ts.firstOrUndefined(symbol.declarations) : undefined;
        return !!ts.findAncestor(declaration, function (n) {
            return ts.isParameter(n) ? true : ts.isBindingElement(n) || ts.isObjectBindingPattern(n) || ts.isArrayBindingPattern(n) ? false : "quit";
        });
    }
    ts.isFirstDeclarationOfSymbolParameter = isFirstDeclarationOfSymbolParameter;
    var displayPartWriter = getDisplayPartWriter();
    function getDisplayPartWriter() {
        var absoluteMaximumLength = ts.defaultMaximumTruncationLength * 10; // A hard cutoff to avoid overloading the messaging channel in worst-case scenarios
        var displayParts;
        var lineStart;
        var indent;
        var length;
        resetWriter();
        var unknownWrite = function (text) { return writeKind(text, ts.SymbolDisplayPartKind.text); };
        return {
            displayParts: function () {
                var finalText = displayParts.length && displayParts[displayParts.length - 1].text;
                if (length > absoluteMaximumLength && finalText && finalText !== "...") {
                    if (!ts.isWhiteSpaceLike(finalText.charCodeAt(finalText.length - 1))) {
                        displayParts.push(displayPart(" ", ts.SymbolDisplayPartKind.space));
                    }
                    displayParts.push(displayPart("...", ts.SymbolDisplayPartKind.punctuation));
                }
                return displayParts;
            },
            writeKeyword: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.keyword); },
            writeOperator: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.operator); },
            writePunctuation: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.punctuation); },
            writeTrailingSemicolon: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.punctuation); },
            writeSpace: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.space); },
            writeStringLiteral: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral); },
            writeParameter: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.parameterName); },
            writeProperty: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.propertyName); },
            writeLiteral: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral); },
            writeSymbol: writeSymbol,
            writeLine: writeLine,
            write: unknownWrite,
            writeComment: unknownWrite,
            getText: function () { return ""; },
            getTextPos: function () { return 0; },
            getColumn: function () { return 0; },
            getLine: function () { return 0; },
            isAtStartOfLine: function () { return false; },
            hasTrailingWhitespace: function () { return false; },
            hasTrailingComment: function () { return false; },
            rawWrite: ts.notImplemented,
            getIndent: function () { return indent; },
            increaseIndent: function () { indent++; },
            decreaseIndent: function () { indent--; },
            clear: resetWriter,
            trackSymbol: function () { return false; },
            reportInaccessibleThisError: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
        };
        function writeIndent() {
            if (length > absoluteMaximumLength)
                return;
            if (lineStart) {
                var indentString = ts.getIndentString(indent);
                if (indentString) {
                    length += indentString.length;
                    displayParts.push(displayPart(indentString, ts.SymbolDisplayPartKind.space));
                }
                lineStart = false;
            }
        }
        function writeKind(text, kind) {
            if (length > absoluteMaximumLength)
                return;
            writeIndent();
            length += text.length;
            displayParts.push(displayPart(text, kind));
        }
        function writeSymbol(text, symbol) {
            if (length > absoluteMaximumLength)
                return;
            writeIndent();
            length += text.length;
            displayParts.push(symbolPart(text, symbol));
        }
        function writeLine() {
            if (length > absoluteMaximumLength)
                return;
            length += 1;
            displayParts.push(lineBreakPart());
            lineStart = true;
        }
        function resetWriter() {
            displayParts = [];
            lineStart = true;
            indent = 0;
            length = 0;
        }
    }
    function symbolPart(text, symbol) {
        return displayPart(text, displayPartKind(symbol));
        function displayPartKind(symbol) {
            var flags = symbol.flags;
            if (flags & 3 /* SymbolFlags.Variable */) {
                return isFirstDeclarationOfSymbolParameter(symbol) ? ts.SymbolDisplayPartKind.parameterName : ts.SymbolDisplayPartKind.localName;
            }
            if (flags & 4 /* SymbolFlags.Property */)
                return ts.SymbolDisplayPartKind.propertyName;
            if (flags & 32768 /* SymbolFlags.GetAccessor */)
                return ts.SymbolDisplayPartKind.propertyName;
            if (flags & 65536 /* SymbolFlags.SetAccessor */)
                return ts.SymbolDisplayPartKind.propertyName;
            if (flags & 8 /* SymbolFlags.EnumMember */)
                return ts.SymbolDisplayPartKind.enumMemberName;
            if (flags & 16 /* SymbolFlags.Function */)
                return ts.SymbolDisplayPartKind.functionName;
            if (flags & 32 /* SymbolFlags.Class */)
                return ts.SymbolDisplayPartKind.className;
            if (flags & 64 /* SymbolFlags.Interface */)
                return ts.SymbolDisplayPartKind.interfaceName;
            if (flags & 384 /* SymbolFlags.Enum */)
                return ts.SymbolDisplayPartKind.enumName;
            if (flags & 1536 /* SymbolFlags.Module */)
                return ts.SymbolDisplayPartKind.moduleName;
            if (flags & 8192 /* SymbolFlags.Method */)
                return ts.SymbolDisplayPartKind.methodName;
            if (flags & 262144 /* SymbolFlags.TypeParameter */)
                return ts.SymbolDisplayPartKind.typeParameterName;
            if (flags & 524288 /* SymbolFlags.TypeAlias */)
                return ts.SymbolDisplayPartKind.aliasName;
            if (flags & 2097152 /* SymbolFlags.Alias */)
                return ts.SymbolDisplayPartKind.aliasName;
            return ts.SymbolDisplayPartKind.text;
        }
    }
    ts.symbolPart = symbolPart;
    function displayPart(text, kind) {
        return { text: text, kind: ts.SymbolDisplayPartKind[kind] };
    }
    ts.displayPart = displayPart;
    function spacePart() {
        return displayPart(" ", ts.SymbolDisplayPartKind.space);
    }
    ts.spacePart = spacePart;
    function keywordPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.keyword);
    }
    ts.keywordPart = keywordPart;
    function punctuationPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.punctuation);
    }
    ts.punctuationPart = punctuationPart;
    function operatorPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.operator);
    }
    ts.operatorPart = operatorPart;
    function parameterNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.parameterName);
    }
    ts.parameterNamePart = parameterNamePart;
    function propertyNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.propertyName);
    }
    ts.propertyNamePart = propertyNamePart;
    function textOrKeywordPart(text) {
        var kind = ts.stringToToken(text);
        return kind === undefined
            ? textPart(text)
            : keywordPart(kind);
    }
    ts.textOrKeywordPart = textOrKeywordPart;
    function textPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.text);
    }
    ts.textPart = textPart;
    function typeAliasNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.aliasName);
    }
    ts.typeAliasNamePart = typeAliasNamePart;
    function typeParameterNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.typeParameterName);
    }
    ts.typeParameterNamePart = typeParameterNamePart;
    function linkTextPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.linkText);
    }
    ts.linkTextPart = linkTextPart;
    function linkNamePart(text, target) {
        return {
            text: text,
            kind: ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.linkName],
            target: {
                fileName: ts.getSourceFileOfNode(target).fileName,
                textSpan: createTextSpanFromNode(target),
            },
        };
    }
    ts.linkNamePart = linkNamePart;
    function linkPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.link);
    }
    ts.linkPart = linkPart;
    function buildLinkParts(link, checker) {
        var _a;
        var prefix = ts.isJSDocLink(link) ? "link"
            : ts.isJSDocLinkCode(link) ? "linkcode"
                : "linkplain";
        var parts = [linkPart("{@".concat(prefix, " "))];
        if (!link.name) {
            if (link.text) {
                parts.push(linkTextPart(link.text));
            }
        }
        else {
            var symbol = checker === null || checker === void 0 ? void 0 : checker.getSymbolAtLocation(link.name);
            var suffix = findLinkNameEnd(link.text);
            var name = ts.getTextOfNode(link.name) + link.text.slice(0, suffix);
            var text = skipSeparatorFromLinkText(link.text.slice(suffix));
            var decl = (symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) || ((_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]);
            if (decl) {
                parts.push(linkNamePart(name, decl));
                if (text)
                    parts.push(linkTextPart(text));
            }
            else {
                parts.push(linkTextPart(name + (suffix || text.indexOf("://") === 0 ? "" : " ") + text));
            }
        }
        parts.push(linkPart("}"));
        return parts;
    }
    ts.buildLinkParts = buildLinkParts;
    function skipSeparatorFromLinkText(text) {
        var pos = 0;
        if (text.charCodeAt(pos++) === 124 /* CharacterCodes.bar */) {
            while (pos < text.length && text.charCodeAt(pos) === 32 /* CharacterCodes.space */)
                pos++;
            return text.slice(pos);
        }
        return text;
    }
    function findLinkNameEnd(text) {
        if (text.indexOf("()") === 0)
            return 2;
        if (text[0] !== "<")
            return 0;
        var brackets = 0;
        var i = 0;
        while (i < text.length) {
            if (text[i] === "<")
                brackets++;
            if (text[i] === ">")
                brackets--;
            i++;
            if (!brackets)
                return i;
        }
        return 0;
    }
    var carriageReturnLineFeed = "\r\n";
    /**
     * The default is CRLF.
     */
    function getNewLineOrDefaultFromHost(host, formatSettings) {
        var _a;
        return (formatSettings === null || formatSettings === void 0 ? void 0 : formatSettings.newLineCharacter) ||
            ((_a = host.getNewLine) === null || _a === void 0 ? void 0 : _a.call(host)) ||
            carriageReturnLineFeed;
    }
    ts.getNewLineOrDefaultFromHost = getNewLineOrDefaultFromHost;
    function lineBreakPart() {
        return displayPart("\n", ts.SymbolDisplayPartKind.lineBreak);
    }
    ts.lineBreakPart = lineBreakPart;
    function mapToDisplayParts(writeDisplayParts) {
        try {
            writeDisplayParts(displayPartWriter);
            return displayPartWriter.displayParts();
        }
        finally {
            displayPartWriter.clear();
        }
    }
    ts.mapToDisplayParts = mapToDisplayParts;
    function typeToDisplayParts(typechecker, type, enclosingDeclaration, flags) {
        if (flags === void 0) { flags = 0 /* TypeFormatFlags.None */; }
        return mapToDisplayParts(function (writer) {
            typechecker.writeType(type, enclosingDeclaration, flags | 1024 /* TypeFormatFlags.MultilineObjectLiterals */ | 16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer);
        });
    }
    ts.typeToDisplayParts = typeToDisplayParts;
    function symbolToDisplayParts(typeChecker, symbol, enclosingDeclaration, meaning, flags) {
        if (flags === void 0) { flags = 0 /* SymbolFormatFlags.None */; }
        return mapToDisplayParts(function (writer) {
            typeChecker.writeSymbol(symbol, enclosingDeclaration, meaning, flags | 8 /* SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer);
        });
    }
    ts.symbolToDisplayParts = symbolToDisplayParts;
    function signatureToDisplayParts(typechecker, signature, enclosingDeclaration, flags) {
        if (flags === void 0) { flags = 0 /* TypeFormatFlags.None */; }
        flags |= 16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */ | 1024 /* TypeFormatFlags.MultilineObjectLiterals */ | 32 /* TypeFormatFlags.WriteTypeArgumentsOfSignature */ | 8192 /* TypeFormatFlags.OmitParameterModifiers */;
        return mapToDisplayParts(function (writer) {
            typechecker.writeSignature(signature, enclosingDeclaration, flags, /*signatureKind*/ undefined, writer);
        });
    }
    ts.signatureToDisplayParts = signatureToDisplayParts;
    function nodeToDisplayParts(node, enclosingDeclaration) {
        var file = enclosingDeclaration.getSourceFile();
        return mapToDisplayParts(function (writer) {
            var printer = ts.createPrinter({ removeComments: true, omitTrailingSemicolon: true });
            printer.writeNode(4 /* EmitHint.Unspecified */, node, file, writer);
        });
    }
    ts.nodeToDisplayParts = nodeToDisplayParts;
    function isImportOrExportSpecifierName(location) {
        return !!location.parent && ts.isImportOrExportSpecifier(location.parent) && location.parent.propertyName === location;
    }
    ts.isImportOrExportSpecifierName = isImportOrExportSpecifierName;
    function getScriptKind(fileName, host) {
        // First check to see if the script kind was specified by the host. Chances are the host
        // may override the default script kind for the file extension.
        return ts.ensureScriptKind(fileName, host.getScriptKind && host.getScriptKind(fileName));
    }
    ts.getScriptKind = getScriptKind;
    function getSymbolTarget(symbol, checker) {
        var next = symbol;
        while (isAliasSymbol(next) || (isTransientSymbol(next) && next.target)) {
            if (isTransientSymbol(next) && next.target) {
                next = next.target;
            }
            else {
                next = ts.skipAlias(next, checker);
            }
        }
        return next;
    }
    ts.getSymbolTarget = getSymbolTarget;
    function isTransientSymbol(symbol) {
        return (symbol.flags & 33554432 /* SymbolFlags.Transient */) !== 0;
    }
    function isAliasSymbol(symbol) {
        return (symbol.flags & 2097152 /* SymbolFlags.Alias */) !== 0;
    }
    function getUniqueSymbolId(symbol, checker) {
        return ts.getSymbolId(ts.skipAlias(symbol, checker));
    }
    ts.getUniqueSymbolId = getUniqueSymbolId;
    function getFirstNonSpaceCharacterPosition(text, position) {
        while (ts.isWhiteSpaceLike(text.charCodeAt(position))) {
            position += 1;
        }
        return position;
    }
    ts.getFirstNonSpaceCharacterPosition = getFirstNonSpaceCharacterPosition;
    function getPrecedingNonSpaceCharacterPosition(text, position) {
        while (position > -1 && ts.isWhiteSpaceSingleLine(text.charCodeAt(position))) {
            position -= 1;
        }
        return position + 1;
    }
    ts.getPrecedingNonSpaceCharacterPosition = getPrecedingNonSpaceCharacterPosition;
    /**
     * Creates a deep, memberwise clone of a node with no source map location.
     *
     * WARNING: This is an expensive operation and is only intended to be used in refactorings
     * and code fixes (because those are triggered by explicit user actions).
     */
    function getSynthesizedDeepClone(node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = true; }
        var clone = node && getSynthesizedDeepCloneWorker(node);
        if (clone && !includeTrivia)
            suppressLeadingAndTrailingTrivia(clone);
        return clone;
    }
    ts.getSynthesizedDeepClone = getSynthesizedDeepClone;
    function getSynthesizedDeepCloneWithReplacements(node, includeTrivia, replaceNode) {
        var clone = replaceNode(node);
        if (clone) {
            ts.setOriginalNode(clone, node);
        }
        else {
            clone = getSynthesizedDeepCloneWorker(node, replaceNode);
        }
        if (clone && !includeTrivia)
            suppressLeadingAndTrailingTrivia(clone);
        return clone;
    }
    ts.getSynthesizedDeepCloneWithReplacements = getSynthesizedDeepCloneWithReplacements;
    function getSynthesizedDeepCloneWorker(node, replaceNode) {
        var nodeClone = replaceNode
            ? function (n) { return getSynthesizedDeepCloneWithReplacements(n, /*includeTrivia*/ true, replaceNode); }
            : getSynthesizedDeepClone;
        var nodesClone = replaceNode
            ? function (ns) { return ns && getSynthesizedDeepClonesWithReplacements(ns, /*includeTrivia*/ true, replaceNode); }
            : function (ns) { return ns && getSynthesizedDeepClones(ns); };
        var visited = ts.visitEachChild(node, nodeClone, ts.nullTransformationContext, nodesClone, nodeClone);
        if (visited === node) {
            // This only happens for leaf nodes - internal nodes always see their children change.
            var clone_1 = ts.isStringLiteral(node) ? ts.setOriginalNode(ts.factory.createStringLiteralFromNode(node), node) :
                ts.isNumericLiteral(node) ? ts.setOriginalNode(ts.factory.createNumericLiteral(node.text, node.numericLiteralFlags), node) :
                    ts.factory.cloneNode(node);
            return ts.setTextRange(clone_1, node);
        }
        // PERF: As an optimization, rather than calling factory.cloneNode, we'll update
        // the new node created by visitEachChild with the extra changes factory.cloneNode
        // would have made.
        visited.parent = undefined;
        return visited;
    }
    function getSynthesizedDeepClones(nodes, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = true; }
        return nodes && ts.factory.createNodeArray(nodes.map(function (n) { return getSynthesizedDeepClone(n, includeTrivia); }), nodes.hasTrailingComma);
    }
    ts.getSynthesizedDeepClones = getSynthesizedDeepClones;
    function getSynthesizedDeepClonesWithReplacements(nodes, includeTrivia, replaceNode) {
        return ts.factory.createNodeArray(nodes.map(function (n) { return getSynthesizedDeepCloneWithReplacements(n, includeTrivia, replaceNode); }), nodes.hasTrailingComma);
    }
    ts.getSynthesizedDeepClonesWithReplacements = getSynthesizedDeepClonesWithReplacements;
    /**
     * Sets EmitFlags to suppress leading and trailing trivia on the node.
     */
    function suppressLeadingAndTrailingTrivia(node) {
        suppressLeadingTrivia(node);
        suppressTrailingTrivia(node);
    }
    ts.suppressLeadingAndTrailingTrivia = suppressLeadingAndTrailingTrivia;
    /**
     * Sets EmitFlags to suppress leading trivia on the node.
     */
    function suppressLeadingTrivia(node) {
        addEmitFlagsRecursively(node, 512 /* EmitFlags.NoLeadingComments */, getFirstChild);
    }
    ts.suppressLeadingTrivia = suppressLeadingTrivia;
    /**
     * Sets EmitFlags to suppress trailing trivia on the node.
     */
    function suppressTrailingTrivia(node) {
        addEmitFlagsRecursively(node, 1024 /* EmitFlags.NoTrailingComments */, ts.getLastChild);
    }
    ts.suppressTrailingTrivia = suppressTrailingTrivia;
    function copyComments(sourceNode, targetNode) {
        var sourceFile = sourceNode.getSourceFile();
        var text = sourceFile.text;
        if (hasLeadingLineBreak(sourceNode, text)) {
            copyLeadingComments(sourceNode, targetNode, sourceFile);
        }
        else {
            copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile);
        }
        copyTrailingComments(sourceNode, targetNode, sourceFile);
    }
    ts.copyComments = copyComments;
    function hasLeadingLineBreak(node, text) {
        var start = node.getFullStart();
        var end = node.getStart();
        for (var i = start; i < end; i++) {
            if (text.charCodeAt(i) === 10 /* CharacterCodes.lineFeed */)
                return true;
        }
        return false;
    }
    function addEmitFlagsRecursively(node, flag, getChild) {
        ts.addEmitFlags(node, flag);
        var child = getChild(node);
        if (child)
            addEmitFlagsRecursively(child, flag, getChild);
    }
    function getFirstChild(node) {
        return node.forEachChild(function (child) { return child; });
    }
    function getUniqueName(baseName, sourceFile) {
        var nameText = baseName;
        for (var i = 1; !ts.isFileLevelUniqueName(sourceFile, nameText); i++) {
            nameText = "".concat(baseName, "_").concat(i);
        }
        return nameText;
    }
    ts.getUniqueName = getUniqueName;
    /**
     * @return The index of the (only) reference to the extracted symbol.  We want the cursor
     * to be on the reference, rather than the declaration, because it's closer to where the
     * user was before extracting it.
     */
    function getRenameLocation(edits, renameFilename, name, preferLastLocation) {
        var delta = 0;
        var lastPos = -1;
        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
            var _a = edits_1[_i], fileName = _a.fileName, textChanges_2 = _a.textChanges;
            ts.Debug.assert(fileName === renameFilename);
            for (var _b = 0, textChanges_1 = textChanges_2; _b < textChanges_1.length; _b++) {
                var change = textChanges_1[_b];
                var span = change.span, newText = change.newText;
                var index = indexInTextChange(newText, name);
                if (index !== -1) {
                    lastPos = span.start + delta + index;
                    // If the reference comes first, return immediately.
                    if (!preferLastLocation) {
                        return lastPos;
                    }
                }
                delta += newText.length - span.length;
            }
        }
        // If the declaration comes first, return the position of the last occurrence.
        ts.Debug.assert(preferLastLocation);
        ts.Debug.assert(lastPos >= 0);
        return lastPos;
    }
    ts.getRenameLocation = getRenameLocation;
    function copyLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachLeadingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
    }
    ts.copyLeadingComments = copyLeadingComments;
    function copyTrailingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachTrailingCommentRange(sourceFile.text, sourceNode.end, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticTrailingComment));
    }
    ts.copyTrailingComments = copyTrailingComments;
    /**
     * This function copies the trailing comments for the token that comes before `sourceNode`, as leading comments of `targetNode`.
     * This is useful because sometimes a comment that refers to `sourceNode` will be a leading comment for `sourceNode`, according to the
     * notion of trivia ownership, and instead will be a trailing comment for the token before `sourceNode`, e.g.:
     * `function foo(\* not leading comment for a *\ a: string) {}`
     * The comment refers to `a` but belongs to the `(` token, but we might want to copy it.
     */
    function copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachTrailingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
    }
    ts.copyTrailingAsLeadingComments = copyTrailingAsLeadingComments;
    function getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, cb) {
        return function (pos, end, kind, htnl) {
            if (kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
                // Remove leading /*
                pos += 2;
                // Remove trailing */
                end -= 2;
            }
            else {
                // Remove leading //
                pos += 2;
            }
            cb(targetNode, commentKind || kind, sourceFile.text.slice(pos, end), hasTrailingNewLine !== undefined ? hasTrailingNewLine : htnl);
        };
    }
    function indexInTextChange(change, name) {
        if (ts.startsWith(change, name))
            return 0;
        // Add a " " to avoid references inside words
        var idx = change.indexOf(" " + name);
        if (idx === -1)
            idx = change.indexOf("." + name);
        if (idx === -1)
            idx = change.indexOf('"' + name);
        return idx === -1 ? -1 : idx + 1;
    }
    /* @internal */
    function needsParentheses(expression) {
        return ts.isBinaryExpression(expression) && expression.operatorToken.kind === 27 /* SyntaxKind.CommaToken */
            || ts.isObjectLiteralExpression(expression)
            || ts.isAsExpression(expression) && ts.isObjectLiteralExpression(expression.expression);
    }
    ts.needsParentheses = needsParentheses;
    function getContextualTypeFromParent(node, checker) {
        var parent = node.parent;
        switch (parent.kind) {
            case 209 /* SyntaxKind.NewExpression */:
                return checker.getContextualType(parent);
            case 221 /* SyntaxKind.BinaryExpression */: {
                var _a = parent, left = _a.left, operatorToken = _a.operatorToken, right = _a.right;
                return isEqualityOperatorKind(operatorToken.kind)
                    ? checker.getTypeAtLocation(node === right ? left : right)
                    : checker.getContextualType(node);
            }
            case 289 /* SyntaxKind.CaseClause */:
                return parent.expression === node ? getSwitchedType(parent, checker) : undefined;
            default:
                return checker.getContextualType(node);
        }
    }
    ts.getContextualTypeFromParent = getContextualTypeFromParent;
    function quote(sourceFile, preferences, text) {
        // Editors can pass in undefined or empty string - we want to infer the preference in those cases.
        var quotePreference = getQuotePreference(sourceFile, preferences);
        var quoted = JSON.stringify(text);
        return quotePreference === 0 /* QuotePreference.Single */ ? "'".concat(ts.stripQuotes(quoted).replace(/'/g, "\\'").replace(/\\"/g, '"'), "'") : quoted;
    }
    ts.quote = quote;
    function isEqualityOperatorKind(kind) {
        switch (kind) {
            case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
            case 34 /* SyntaxKind.EqualsEqualsToken */:
            case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
            case 35 /* SyntaxKind.ExclamationEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    ts.isEqualityOperatorKind = isEqualityOperatorKind;
    function isStringLiteralOrTemplate(node) {
        switch (node.kind) {
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 223 /* SyntaxKind.TemplateExpression */:
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return true;
            default:
                return false;
        }
    }
    ts.isStringLiteralOrTemplate = isStringLiteralOrTemplate;
    function hasIndexSignature(type) {
        return !!type.getStringIndexType() || !!type.getNumberIndexType();
    }
    ts.hasIndexSignature = hasIndexSignature;
    function getSwitchedType(caseClause, checker) {
        return checker.getTypeAtLocation(caseClause.parent.parent.expression);
    }
    ts.getSwitchedType = getSwitchedType;
    ts.ANONYMOUS = "anonymous function";
    function getTypeNodeIfAccessible(type, enclosingScope, program, host) {
        var checker = program.getTypeChecker();
        var typeIsAccessible = true;
        var notAccessible = function () { return typeIsAccessible = false; };
        var res = checker.typeToTypeNode(type, enclosingScope, 1 /* NodeBuilderFlags.NoTruncation */, {
            trackSymbol: function (symbol, declaration, meaning) {
                typeIsAccessible = typeIsAccessible && checker.isSymbolAccessible(symbol, declaration, meaning, /*shouldComputeAliasToMarkVisible*/ false).accessibility === 0 /* SymbolAccessibility.Accessible */;
                return !typeIsAccessible;
            },
            reportInaccessibleThisError: notAccessible,
            reportPrivateInBaseOfClassExpression: notAccessible,
            reportInaccessibleUniqueSymbolError: notAccessible,
            moduleResolverHost: getModuleSpecifierResolverHost(program, host)
        });
        return typeIsAccessible ? res : undefined;
    }
    ts.getTypeNodeIfAccessible = getTypeNodeIfAccessible;
    function syntaxRequiresTrailingCommaOrSemicolonOrASI(kind) {
        return kind === 174 /* SyntaxKind.CallSignature */
            || kind === 175 /* SyntaxKind.ConstructSignature */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 166 /* SyntaxKind.PropertySignature */
            || kind === 168 /* SyntaxKind.MethodSignature */;
    }
    function syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(kind) {
        return kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 171 /* SyntaxKind.Constructor */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */;
    }
    function syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(kind) {
        return kind === 261 /* SyntaxKind.ModuleDeclaration */;
    }
    function syntaxRequiresTrailingSemicolonOrASI(kind) {
        return kind === 237 /* SyntaxKind.VariableStatement */
            || kind === 238 /* SyntaxKind.ExpressionStatement */
            || kind === 240 /* SyntaxKind.DoStatement */
            || kind === 245 /* SyntaxKind.ContinueStatement */
            || kind === 246 /* SyntaxKind.BreakStatement */
            || kind === 247 /* SyntaxKind.ReturnStatement */
            || kind === 251 /* SyntaxKind.ThrowStatement */
            || kind === 253 /* SyntaxKind.DebuggerStatement */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 266 /* SyntaxKind.ImportDeclaration */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 272 /* SyntaxKind.ExportDeclaration */
            || kind === 264 /* SyntaxKind.NamespaceExportDeclaration */
            || kind === 271 /* SyntaxKind.ExportAssignment */;
    }
    ts.syntaxRequiresTrailingSemicolonOrASI = syntaxRequiresTrailingSemicolonOrASI;
    ts.syntaxMayBeASICandidate = ts.or(syntaxRequiresTrailingCommaOrSemicolonOrASI, syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI, syntaxRequiresTrailingModuleBlockOrSemicolonOrASI, syntaxRequiresTrailingSemicolonOrASI);
    function nodeIsASICandidate(node, sourceFile) {
        var lastToken = node.getLastToken(sourceFile);
        if (lastToken && lastToken.kind === 26 /* SyntaxKind.SemicolonToken */) {
            return false;
        }
        if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
            if (lastToken && lastToken.kind === 27 /* SyntaxKind.CommaToken */) {
                return false;
            }
        }
        else if (syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(node.kind)) {
            var lastChild = ts.last(node.getChildren(sourceFile));
            if (lastChild && ts.isModuleBlock(lastChild)) {
                return false;
            }
        }
        else if (syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(node.kind)) {
            var lastChild = ts.last(node.getChildren(sourceFile));
            if (lastChild && ts.isFunctionBlock(lastChild)) {
                return false;
            }
        }
        else if (!syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
            return false;
        }
        // See comment in parser’s `parseDoStatement`
        if (node.kind === 240 /* SyntaxKind.DoStatement */) {
            return true;
        }
        var topNode = ts.findAncestor(node, function (ancestor) { return !ancestor.parent; });
        var nextToken = findNextToken(node, topNode, sourceFile);
        if (!nextToken || nextToken.kind === 19 /* SyntaxKind.CloseBraceToken */) {
            return true;
        }
        var startLine = sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line;
        var endLine = sourceFile.getLineAndCharacterOfPosition(nextToken.getStart(sourceFile)).line;
        return startLine !== endLine;
    }
    function positionIsASICandidate(pos, context, sourceFile) {
        var contextAncestor = ts.findAncestor(context, function (ancestor) {
            if (ancestor.end !== pos) {
                return "quit";
            }
            return ts.syntaxMayBeASICandidate(ancestor.kind);
        });
        return !!contextAncestor && nodeIsASICandidate(contextAncestor, sourceFile);
    }
    ts.positionIsASICandidate = positionIsASICandidate;
    function probablyUsesSemicolons(sourceFile) {
        var withSemicolon = 0;
        var withoutSemicolon = 0;
        var nStatementsToObserve = 5;
        ts.forEachChild(sourceFile, function visit(node) {
            if (syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
                var lastToken = node.getLastToken(sourceFile);
                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.kind) === 26 /* SyntaxKind.SemicolonToken */) {
                    withSemicolon++;
                }
                else {
                    withoutSemicolon++;
                }
            }
            else if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
                var lastToken = node.getLastToken(sourceFile);
                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.kind) === 26 /* SyntaxKind.SemicolonToken */) {
                    withSemicolon++;
                }
                else if (lastToken && lastToken.kind !== 27 /* SyntaxKind.CommaToken */) {
                    var lastTokenLine = ts.getLineAndCharacterOfPosition(sourceFile, lastToken.getStart(sourceFile)).line;
                    var nextTokenLine = ts.getLineAndCharacterOfPosition(sourceFile, ts.getSpanOfTokenAtPosition(sourceFile, lastToken.end).start).line;
                    // Avoid counting missing semicolon in single-line objects:
                    // `function f(p: { x: string /*no semicolon here is insignificant*/ }) {`
                    if (lastTokenLine !== nextTokenLine) {
                        withoutSemicolon++;
                    }
                }
            }
            if (withSemicolon + withoutSemicolon >= nStatementsToObserve) {
                return true;
            }
            return ts.forEachChild(node, visit);
        });
        // One statement missing a semicolon isn't sufficient evidence to say the user
        // doesn’t want semicolons, because they may not even be done writing that statement.
        if (withSemicolon === 0 && withoutSemicolon <= 1) {
            return true;
        }
        // If even 2/5 places have a semicolon, the user probably wants semicolons
        return withSemicolon / withoutSemicolon > 1 / nStatementsToObserve;
    }
    ts.probablyUsesSemicolons = probablyUsesSemicolons;
    function tryGetDirectories(host, directoryName) {
        return tryIOAndConsumeErrors(host, host.getDirectories, directoryName) || [];
    }
    ts.tryGetDirectories = tryGetDirectories;
    function tryReadDirectory(host, path, extensions, exclude, include) {
        return tryIOAndConsumeErrors(host, host.readDirectory, path, extensions, exclude, include) || ts.emptyArray;
    }
    ts.tryReadDirectory = tryReadDirectory;
    function tryFileExists(host, path) {
        return tryIOAndConsumeErrors(host, host.fileExists, path);
    }
    ts.tryFileExists = tryFileExists;
    function tryDirectoryExists(host, path) {
        return tryAndIgnoreErrors(function () { return ts.directoryProbablyExists(path, host); }) || false;
    }
    ts.tryDirectoryExists = tryDirectoryExists;
    function tryAndIgnoreErrors(cb) {
        try {
            return cb();
        }
        catch (_a) {
            return undefined;
        }
    }
    ts.tryAndIgnoreErrors = tryAndIgnoreErrors;
    function tryIOAndConsumeErrors(host, toApply) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return tryAndIgnoreErrors(function () { return toApply && toApply.apply(host, args); });
    }
    ts.tryIOAndConsumeErrors = tryIOAndConsumeErrors;
    function findPackageJsons(startDirectory, host, stopDirectory) {
        var paths = [];
        ts.forEachAncestorDirectory(startDirectory, function (ancestor) {
            if (ancestor === stopDirectory) {
                return true;
            }
            var currentConfigPath = ts.combinePaths(ancestor, "package.json");
            if (tryFileExists(host, currentConfigPath)) {
                paths.push(currentConfigPath);
            }
        });
        return paths;
    }
    ts.findPackageJsons = findPackageJsons;
    function findPackageJson(directory, host) {
        var packageJson;
        ts.forEachAncestorDirectory(directory, function (ancestor) {
            if (ancestor === "node_modules")
                return true;
            packageJson = ts.findConfigFile(ancestor, function (f) { return tryFileExists(host, f); }, "package.json");
            if (packageJson) {
                return true; // break out
            }
        });
        return packageJson;
    }
    ts.findPackageJson = findPackageJson;
    function getPackageJsonsVisibleToFile(fileName, host) {
        if (!host.fileExists) {
            return [];
        }
        var packageJsons = [];
        ts.forEachAncestorDirectory(ts.getDirectoryPath(fileName), function (ancestor) {
            var packageJsonFileName = ts.combinePaths(ancestor, "package.json");
            if (host.fileExists(packageJsonFileName)) {
                var info = createPackageJsonInfo(packageJsonFileName, host);
                if (info) {
                    packageJsons.push(info);
                }
            }
        });
        return packageJsons;
    }
    ts.getPackageJsonsVisibleToFile = getPackageJsonsVisibleToFile;
    function createPackageJsonInfo(fileName, host) {
        if (!host.readFile) {
            return undefined;
        }
        var dependencyKeys = ["dependencies", "devDependencies", "optionalDependencies", "peerDependencies"];
        var stringContent = host.readFile(fileName) || "";
        var content = tryParseJson(stringContent);
        var info = {};
        if (content) {
            for (var _i = 0, dependencyKeys_1 = dependencyKeys; _i < dependencyKeys_1.length; _i++) {
                var key = dependencyKeys_1[_i];
                var dependencies = content[key];
                if (!dependencies) {
                    continue;
                }
                var dependencyMap = new ts.Map();
                for (var packageName in dependencies) {
                    dependencyMap.set(packageName, dependencies[packageName]);
                }
                info[key] = dependencyMap;
            }
        }
        var dependencyGroups = [
            [1 /* PackageJsonDependencyGroup.Dependencies */, info.dependencies],
            [2 /* PackageJsonDependencyGroup.DevDependencies */, info.devDependencies],
            [8 /* PackageJsonDependencyGroup.OptionalDependencies */, info.optionalDependencies],
            [4 /* PackageJsonDependencyGroup.PeerDependencies */, info.peerDependencies],
        ];
        return __assign(__assign({}, info), { parseable: !!content, fileName: fileName, get: get, has: function (dependencyName, inGroups) {
                return !!get(dependencyName, inGroups);
            } });
        function get(dependencyName, inGroups) {
            if (inGroups === void 0) { inGroups = 15 /* PackageJsonDependencyGroup.All */; }
            for (var _i = 0, dependencyGroups_1 = dependencyGroups; _i < dependencyGroups_1.length; _i++) {
                var _a = dependencyGroups_1[_i], group_1 = _a[0], deps = _a[1];
                if (deps && (inGroups & group_1)) {
                    var dep = deps.get(dependencyName);
                    if (dep !== undefined) {
                        return dep;
                    }
                }
            }
        }
    }
    ts.createPackageJsonInfo = createPackageJsonInfo;
    function createPackageJsonImportFilter(fromFile, preferences, host) {
        var packageJsons = ((host.getPackageJsonsVisibleToFile && host.getPackageJsonsVisibleToFile(fromFile.fileName)) || getPackageJsonsVisibleToFile(fromFile.fileName, host)).filter(function (p) { return p.parseable; });
        var usesNodeCoreModules;
        return { allowsImportingAmbientModule: allowsImportingAmbientModule, allowsImportingSourceFile: allowsImportingSourceFile, allowsImportingSpecifier: allowsImportingSpecifier };
        function moduleSpecifierIsCoveredByPackageJson(specifier) {
            var packageName = getNodeModuleRootSpecifier(specifier);
            for (var _i = 0, packageJsons_1 = packageJsons; _i < packageJsons_1.length; _i++) {
                var packageJson = packageJsons_1[_i];
                if (packageJson.has(packageName) || packageJson.has(ts.getTypesPackageName(packageName))) {
                    return true;
                }
            }
            return false;
        }
        function allowsImportingAmbientModule(moduleSymbol, moduleSpecifierResolutionHost) {
            if (!packageJsons.length || !moduleSymbol.valueDeclaration) {
                return true;
            }
            var declaringSourceFile = moduleSymbol.valueDeclaration.getSourceFile();
            var declaringNodeModuleName = getNodeModulesPackageNameFromFileName(declaringSourceFile.fileName, moduleSpecifierResolutionHost);
            if (typeof declaringNodeModuleName === "undefined") {
                return true;
            }
            var declaredModuleSpecifier = ts.stripQuotes(moduleSymbol.getName());
            if (isAllowedCoreNodeModulesImport(declaredModuleSpecifier)) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(declaringNodeModuleName)
                || moduleSpecifierIsCoveredByPackageJson(declaredModuleSpecifier);
        }
        function allowsImportingSourceFile(sourceFile, moduleSpecifierResolutionHost) {
            if (!packageJsons.length) {
                return true;
            }
            var moduleSpecifier = getNodeModulesPackageNameFromFileName(sourceFile.fileName, moduleSpecifierResolutionHost);
            if (!moduleSpecifier) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
        }
        function allowsImportingSpecifier(moduleSpecifier) {
            if (!packageJsons.length || isAllowedCoreNodeModulesImport(moduleSpecifier)) {
                return true;
            }
            if (ts.pathIsRelative(moduleSpecifier) || ts.isRootedDiskPath(moduleSpecifier)) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
        }
        function isAllowedCoreNodeModulesImport(moduleSpecifier) {
            // If we’re in JavaScript, it can be difficult to tell whether the user wants to import
            // from Node core modules or not. We can start by seeing if the user is actually using
            // any node core modules, as opposed to simply having @types/node accidentally as a
            // dependency of a dependency.
            if (ts.isSourceFileJS(fromFile) && ts.JsTyping.nodeCoreModules.has(moduleSpecifier)) {
                if (usesNodeCoreModules === undefined) {
                    usesNodeCoreModules = consumesNodeCoreModules(fromFile);
                }
                if (usesNodeCoreModules) {
                    return true;
                }
            }
            return false;
        }
        function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
            if (!ts.stringContains(importedFileName, "node_modules")) {
                return undefined;
            }
            var specifier = ts.moduleSpecifiers.getNodeModulesPackageName(host.getCompilationSettings(), fromFile, importedFileName, moduleSpecifierResolutionHost, preferences);
            if (!specifier) {
                return undefined;
            }
            // Paths here are not node_modules, so we don’t care about them;
            // returning anything will trigger a lookup in package.json.
            if (!ts.pathIsRelative(specifier) && !ts.isRootedDiskPath(specifier)) {
                return getNodeModuleRootSpecifier(specifier);
            }
        }
        function getNodeModuleRootSpecifier(fullSpecifier) {
            var components = ts.getPathComponents(ts.getPackageNameFromTypesPackageName(fullSpecifier)).slice(1);
            // Scoped packages
            if (ts.startsWith(components[0], "@")) {
                return "".concat(components[0], "/").concat(components[1]);
            }
            return components[0];
        }
    }
    ts.createPackageJsonImportFilter = createPackageJsonImportFilter;
    function tryParseJson(text) {
        try {
            return JSON.parse(text);
        }
        catch (_a) {
            return undefined;
        }
    }
    function consumesNodeCoreModules(sourceFile) {
        return ts.some(sourceFile.imports, function (_a) {
            var text = _a.text;
            return ts.JsTyping.nodeCoreModules.has(text);
        });
    }
    ts.consumesNodeCoreModules = consumesNodeCoreModules;
    function isInsideNodeModules(fileOrDirectory) {
        return ts.contains(ts.getPathComponents(fileOrDirectory), "node_modules");
    }
    ts.isInsideNodeModules = isInsideNodeModules;
    function isDiagnosticWithLocation(diagnostic) {
        return diagnostic.file !== undefined && diagnostic.start !== undefined && diagnostic.length !== undefined;
    }
    ts.isDiagnosticWithLocation = isDiagnosticWithLocation;
    function findDiagnosticForNode(node, sortedFileDiagnostics) {
        var span = createTextSpanFromNode(node);
        var index = ts.binarySearchKey(sortedFileDiagnostics, span, ts.identity, ts.compareTextSpans);
        if (index >= 0) {
            var diagnostic = sortedFileDiagnostics[index];
            ts.Debug.assertEqual(diagnostic.file, node.getSourceFile(), "Diagnostics proided to 'findDiagnosticForNode' must be from a single SourceFile");
            return ts.cast(diagnostic, isDiagnosticWithLocation);
        }
    }
    ts.findDiagnosticForNode = findDiagnosticForNode;
    function getDiagnosticsWithinSpan(span, sortedFileDiagnostics) {
        var _a;
        var index = ts.binarySearchKey(sortedFileDiagnostics, span.start, function (diag) { return diag.start; }, ts.compareValues);
        if (index < 0) {
            index = ~index;
        }
        while (((_a = sortedFileDiagnostics[index - 1]) === null || _a === void 0 ? void 0 : _a.start) === span.start) {
            index--;
        }
        var result = [];
        var end = ts.textSpanEnd(span);
        while (true) {
            var diagnostic = ts.tryCast(sortedFileDiagnostics[index], isDiagnosticWithLocation);
            if (!diagnostic || diagnostic.start > end) {
                break;
            }
            if (ts.textSpanContainsTextSpan(span, diagnostic)) {
                result.push(diagnostic);
            }
            index++;
        }
        return result;
    }
    ts.getDiagnosticsWithinSpan = getDiagnosticsWithinSpan;
    /* @internal */
    function getRefactorContextSpan(_a) {
        var startPosition = _a.startPosition, endPosition = _a.endPosition;
        return ts.createTextSpanFromBounds(startPosition, endPosition === undefined ? startPosition : endPosition);
    }
    ts.getRefactorContextSpan = getRefactorContextSpan;
    /* @internal */
    function getFixableErrorSpanExpression(sourceFile, span) {
        var token = getTokenAtPosition(sourceFile, span.start);
        // Checker has already done work to determine that await might be possible, and has attached
        // related info to the node, so start by finding the expression that exactly matches up
        // with the diagnostic range.
        var expression = ts.findAncestor(token, function (node) {
            if (node.getStart(sourceFile) < span.start || node.getEnd() > ts.textSpanEnd(span)) {
                return "quit";
            }
            return ts.isExpression(node) && textSpansEqual(span, createTextSpanFromNode(node, sourceFile));
        });
        return expression;
    }
    ts.getFixableErrorSpanExpression = getFixableErrorSpanExpression;
    function mapOneOrMany(valueOrArray, f, resultSelector) {
        if (resultSelector === void 0) { resultSelector = ts.identity; }
        return valueOrArray ? ts.isArray(valueOrArray) ? resultSelector(ts.map(valueOrArray, f)) : f(valueOrArray, 0) : undefined;
    }
    ts.mapOneOrMany = mapOneOrMany;
    /**
     * If the provided value is an array, the first element of the array is returned; otherwise, the provided value is returned instead.
     */
    function firstOrOnly(valueOrArray) {
        return ts.isArray(valueOrArray) ? ts.first(valueOrArray) : valueOrArray;
    }
    ts.firstOrOnly = firstOrOnly;
    function getNamesForExportedSymbol(symbol, scriptTarget) {
        if (needsNameFromDeclaration(symbol)) {
            var fromDeclaration = getDefaultLikeExportNameFromDeclaration(symbol);
            if (fromDeclaration)
                return fromDeclaration;
            var fileNameCase = ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, /*preferCapitalized*/ false);
            var capitalized = ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, /*preferCapitalized*/ true);
            if (fileNameCase === capitalized)
                return fileNameCase;
            return [fileNameCase, capitalized];
        }
        return symbol.name;
    }
    ts.getNamesForExportedSymbol = getNamesForExportedSymbol;
    function getNameForExportedSymbol(symbol, scriptTarget, preferCapitalized) {
        if (needsNameFromDeclaration(symbol)) {
            // Name of "export default foo;" is "foo". Name of "export default 0" is the filename converted to camelCase.
            return getDefaultLikeExportNameFromDeclaration(symbol)
                || ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, !!preferCapitalized);
        }
        return symbol.name;
    }
    ts.getNameForExportedSymbol = getNameForExportedSymbol;
    function needsNameFromDeclaration(symbol) {
        return !(symbol.flags & 33554432 /* SymbolFlags.Transient */) && (symbol.escapedName === "export=" /* InternalSymbolName.ExportEquals */ || symbol.escapedName === "default" /* InternalSymbolName.Default */);
    }
    function getDefaultLikeExportNameFromDeclaration(symbol) {
        return ts.firstDefined(symbol.declarations, function (d) { var _a; return ts.isExportAssignment(d) ? (_a = ts.tryCast(ts.skipOuterExpressions(d.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text : undefined; });
    }
    function getSymbolParentOrFail(symbol) {
        var _a;
        return ts.Debug.checkDefined(symbol.parent, "Symbol parent was undefined. Flags: ".concat(ts.Debug.formatSymbolFlags(symbol.flags), ". ") +
            "Declarations: ".concat((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.map(function (d) {
                var kind = ts.Debug.formatSyntaxKind(d.kind);
                var inJS = ts.isInJSFile(d);
                var expression = d.expression;
                return (inJS ? "[JS]" : "") + kind + (expression ? " (expression: ".concat(ts.Debug.formatSyntaxKind(expression.kind), ")") : "");
            }).join(", "), "."));
    }
    /**
     * Useful to check whether a string contains another string at a specific index
     * without allocating another string or traversing the entire contents of the outer string.
     *
     * This function is useful in place of either of the following:
     *
     * ```ts
     * // Allocates
     * haystack.substr(startIndex, needle.length) === needle
     *
     * // Full traversal
     * haystack.indexOf(needle, startIndex) === startIndex
     * ```
     *
     * @param haystack The string that potentially contains `needle`.
     * @param needle The string whose content might sit within `haystack`.
     * @param startIndex The index within `haystack` to start searching for `needle`.
     */
    function stringContainsAt(haystack, needle, startIndex) {
        var needleLength = needle.length;
        if (needleLength + startIndex > haystack.length) {
            return false;
        }
        for (var i = 0; i < needleLength; i++) {
            if (needle.charCodeAt(i) !== haystack.charCodeAt(i + startIndex))
                return false;
        }
        return true;
    }
    ts.stringContainsAt = stringContainsAt;
    function startsWithUnderscore(name) {
        return name.charCodeAt(0) === 95 /* CharacterCodes._ */;
    }
    ts.startsWithUnderscore = startsWithUnderscore;
    function isGlobalDeclaration(declaration) {
        return !isNonGlobalDeclaration(declaration);
    }
    ts.isGlobalDeclaration = isGlobalDeclaration;
    function isNonGlobalDeclaration(declaration) {
        var sourceFile = declaration.getSourceFile();
        // If the file is not a module, the declaration is global
        if (!sourceFile.externalModuleIndicator && !sourceFile.commonJsModuleIndicator) {
            return false;
        }
        // If the file is a module written in TypeScript, it still might be in a `declare global` augmentation
        return ts.isInJSFile(declaration) || !ts.findAncestor(declaration, ts.isGlobalScopeAugmentation);
    }
    ts.isNonGlobalDeclaration = isNonGlobalDeclaration;
    function isDeprecatedDeclaration(decl) {
        return !!(ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(decl) & 8192 /* ModifierFlags.Deprecated */);
    }
    ts.isDeprecatedDeclaration = isDeprecatedDeclaration;
    function shouldUseUriStyleNodeCoreModules(file, program) {
        var decisionFromFile = ts.firstDefined(file.imports, function (node) {
            if (ts.JsTyping.nodeCoreModules.has(node.text)) {
                return ts.startsWith(node.text, "node:");
            }
        });
        return decisionFromFile !== null && decisionFromFile !== void 0 ? decisionFromFile : program.usesUriStyleNodeCoreModules;
    }
    ts.shouldUseUriStyleNodeCoreModules = shouldUseUriStyleNodeCoreModules;
    function getNewLineKind(newLineCharacter) {
        return newLineCharacter === "\n" ? 1 /* NewLineKind.LineFeed */ : 0 /* NewLineKind.CarriageReturnLineFeed */;
    }
    ts.getNewLineKind = getNewLineKind;
    function diagnosticToString(diag) {
        return ts.isArray(diag)
            ? ts.formatStringFromArgs(ts.getLocaleSpecificMessage(diag[0]), diag.slice(1))
            : ts.getLocaleSpecificMessage(diag);
    }
    ts.diagnosticToString = diagnosticToString;
    /**
     * Get format code settings for a code writing context (e.g. when formatting text changes or completions code).
     */
    function getFormatCodeSettingsForWriting(_a, sourceFile) {
        var options = _a.options;
        var shouldAutoDetectSemicolonPreference = !options.semicolons || options.semicolons === ts.SemicolonPreference.Ignore;
        var shouldRemoveSemicolons = options.semicolons === ts.SemicolonPreference.Remove || shouldAutoDetectSemicolonPreference && !probablyUsesSemicolons(sourceFile);
        return __assign(__assign({}, options), { semicolons: shouldRemoveSemicolons ? ts.SemicolonPreference.Remove : ts.SemicolonPreference.Ignore });
    }
    ts.getFormatCodeSettingsForWriting = getFormatCodeSettingsForWriting;
    function jsxModeNeedsExplicitImport(jsx) {
        return jsx === 2 /* JsxEmit.React */ || jsx === 3 /* JsxEmit.ReactNative */;
    }
    ts.jsxModeNeedsExplicitImport = jsxModeNeedsExplicitImport;
    // #endregion
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ImportKind;
    (function (ImportKind) {
        ImportKind[ImportKind["Named"] = 0] = "Named";
        ImportKind[ImportKind["Default"] = 1] = "Default";
        ImportKind[ImportKind["Namespace"] = 2] = "Namespace";
        ImportKind[ImportKind["CommonJS"] = 3] = "CommonJS";
    })(ImportKind = ts.ImportKind || (ts.ImportKind = {}));
    var ExportKind;
    (function (ExportKind) {
        ExportKind[ExportKind["Named"] = 0] = "Named";
        ExportKind[ExportKind["Default"] = 1] = "Default";
        ExportKind[ExportKind["ExportEquals"] = 2] = "ExportEquals";
        ExportKind[ExportKind["UMD"] = 3] = "UMD";
    })(ExportKind = ts.ExportKind || (ts.ExportKind = {}));
    function createCacheableExportInfoMap(host) {
        var exportInfoId = 1;
        var exportInfo = ts.createMultiMap();
        var symbols = new ts.Map();
        /**
         * Key: node_modules package name (no @types).
         * Value: path to deepest node_modules folder seen that is
         * both visible to `usableByFileName` and contains the package.
         *
         * Later, we can see if a given SymbolExportInfo is shadowed by
         * a another installation of the same package in a deeper
         * node_modules folder by seeing if its path starts with the
         * value stored here.
         */
        var packages = new ts.Map();
        var usableByFileName;
        var cache = {
            isUsableByFile: function (importingFile) { return importingFile === usableByFileName; },
            isEmpty: function () { return !exportInfo.size; },
            clear: function () {
                exportInfo.clear();
                symbols.clear();
                usableByFileName = undefined;
            },
            add: function (importingFile, symbol, symbolTableKey, moduleSymbol, moduleFile, exportKind, isFromPackageJson, checker) {
                if (importingFile !== usableByFileName) {
                    cache.clear();
                    usableByFileName = importingFile;
                }
                var packageName;
                if (moduleFile) {
                    var nodeModulesPathParts = ts.getNodeModulePathParts(moduleFile.fileName);
                    if (nodeModulesPathParts) {
                        var topLevelNodeModulesIndex = nodeModulesPathParts.topLevelNodeModulesIndex, topLevelPackageNameIndex = nodeModulesPathParts.topLevelPackageNameIndex, packageRootIndex = nodeModulesPathParts.packageRootIndex;
                        packageName = ts.unmangleScopedPackageName(ts.getPackageNameFromTypesPackageName(moduleFile.fileName.substring(topLevelPackageNameIndex + 1, packageRootIndex)));
                        if (ts.startsWith(importingFile, moduleFile.path.substring(0, topLevelNodeModulesIndex))) {
                            var prevDeepestNodeModulesPath = packages.get(packageName);
                            var nodeModulesPath = moduleFile.fileName.substring(0, topLevelPackageNameIndex + 1);
                            if (prevDeepestNodeModulesPath) {
                                var prevDeepestNodeModulesIndex = prevDeepestNodeModulesPath.indexOf(ts.nodeModulesPathPart);
                                if (topLevelNodeModulesIndex > prevDeepestNodeModulesIndex) {
                                    packages.set(packageName, nodeModulesPath);
                                }
                            }
                            else {
                                packages.set(packageName, nodeModulesPath);
                            }
                        }
                    }
                }
                var isDefault = exportKind === 1 /* ExportKind.Default */;
                var namedSymbol = isDefault && ts.getLocalSymbolForExportDefault(symbol) || symbol;
                // 1. A named export must be imported by its key in `moduleSymbol.exports` or `moduleSymbol.members`.
                // 2. A re-export merged with an export from a module augmentation can result in `symbol`
                //    being an external module symbol; the name it is re-exported by will be `symbolTableKey`
                //    (which comes from the keys of `moduleSymbol.exports`.)
                // 3. Otherwise, we have a default/namespace import that can be imported by any name, and
                //    `symbolTableKey` will be something undesirable like `export=` or `default`, so we try to
                //    get a better name.
                var names = exportKind === 0 /* ExportKind.Named */ || ts.isExternalModuleSymbol(namedSymbol)
                    ? ts.unescapeLeadingUnderscores(symbolTableKey)
                    : ts.getNamesForExportedSymbol(namedSymbol, /*scriptTarget*/ undefined);
                var symbolName = typeof names === "string" ? names : names[0];
                var capitalizedSymbolName = typeof names === "string" ? undefined : names[1];
                var moduleName = ts.stripQuotes(moduleSymbol.name);
                var id = exportInfoId++;
                var target = ts.skipAlias(symbol, checker);
                var storedSymbol = symbol.flags & 33554432 /* SymbolFlags.Transient */ ? undefined : symbol;
                var storedModuleSymbol = moduleSymbol.flags & 33554432 /* SymbolFlags.Transient */ ? undefined : moduleSymbol;
                if (!storedSymbol || !storedModuleSymbol)
                    symbols.set(id, [symbol, moduleSymbol]);
                exportInfo.add(key(symbolName, symbol, ts.isExternalModuleNameRelative(moduleName) ? undefined : moduleName, checker), {
                    id: id,
                    symbolTableKey: symbolTableKey,
                    symbolName: symbolName,
                    capitalizedSymbolName: capitalizedSymbolName,
                    moduleName: moduleName,
                    moduleFile: moduleFile,
                    moduleFileName: moduleFile === null || moduleFile === void 0 ? void 0 : moduleFile.fileName,
                    packageName: packageName,
                    exportKind: exportKind,
                    targetFlags: target.flags,
                    isFromPackageJson: isFromPackageJson,
                    symbol: storedSymbol,
                    moduleSymbol: storedModuleSymbol,
                });
            },
            get: function (importingFile, key) {
                if (importingFile !== usableByFileName)
                    return;
                var result = exportInfo.get(key);
                return result === null || result === void 0 ? void 0 : result.map(rehydrateCachedInfo);
            },
            search: function (importingFile, preferCapitalized, matches, action) {
                if (importingFile !== usableByFileName)
                    return;
                exportInfo.forEach(function (info, key) {
                    var _a = parseKey(key), symbolName = _a.symbolName, ambientModuleName = _a.ambientModuleName;
                    var name = preferCapitalized && info[0].capitalizedSymbolName || symbolName;
                    if (matches(name, info[0].targetFlags)) {
                        var rehydrated = info.map(rehydrateCachedInfo);
                        var filtered = rehydrated.filter(function (r, i) { return isNotShadowedByDeeperNodeModulesPackage(r, info[i].packageName); });
                        if (filtered.length) {
                            action(filtered, name, !!ambientModuleName, key);
                        }
                    }
                });
            },
            releaseSymbols: function () {
                symbols.clear();
            },
            onFileChanged: function (oldSourceFile, newSourceFile, typeAcquisitionEnabled) {
                if (fileIsGlobalOnly(oldSourceFile) && fileIsGlobalOnly(newSourceFile)) {
                    // File is purely global; doesn't affect export map
                    return false;
                }
                if (usableByFileName && usableByFileName !== newSourceFile.path ||
                    // If ATA is enabled, auto-imports uses existing imports to guess whether you want auto-imports from node.
                    // Adding or removing imports from node could change the outcome of that guess, so could change the suggestions list.
                    typeAcquisitionEnabled && ts.consumesNodeCoreModules(oldSourceFile) !== ts.consumesNodeCoreModules(newSourceFile) ||
                    // Module agumentation and ambient module changes can add or remove exports available to be auto-imported.
                    // Changes elsewhere in the file can change the *type* of an export in a module augmentation,
                    // but type info is gathered in getCompletionEntryDetails, which doesn’t use the cache.
                    !ts.arrayIsEqualTo(oldSourceFile.moduleAugmentations, newSourceFile.moduleAugmentations) ||
                    !ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile)) {
                    cache.clear();
                    return true;
                }
                usableByFileName = newSourceFile.path;
                return false;
            },
        };
        if (ts.Debug.isDebugging) {
            Object.defineProperty(cache, "__cache", { get: function () { return exportInfo; } });
        }
        return cache;
        function rehydrateCachedInfo(info) {
            if (info.symbol && info.moduleSymbol)
                return info;
            var id = info.id, exportKind = info.exportKind, targetFlags = info.targetFlags, isFromPackageJson = info.isFromPackageJson, moduleFileName = info.moduleFileName;
            var _a = symbols.get(id) || ts.emptyArray, cachedSymbol = _a[0], cachedModuleSymbol = _a[1];
            if (cachedSymbol && cachedModuleSymbol) {
                return {
                    symbol: cachedSymbol,
                    moduleSymbol: cachedModuleSymbol,
                    moduleFileName: moduleFileName,
                    exportKind: exportKind,
                    targetFlags: targetFlags,
                    isFromPackageJson: isFromPackageJson,
                };
            }
            var checker = (isFromPackageJson
                ? host.getPackageJsonAutoImportProvider()
                : host.getCurrentProgram()).getTypeChecker();
            var moduleSymbol = info.moduleSymbol || cachedModuleSymbol || ts.Debug.checkDefined(info.moduleFile
                ? checker.getMergedSymbol(info.moduleFile.symbol)
                : checker.tryFindAmbientModule(info.moduleName));
            var symbol = info.symbol || cachedSymbol || ts.Debug.checkDefined(exportKind === 2 /* ExportKind.ExportEquals */
                ? checker.resolveExternalModuleSymbol(moduleSymbol)
                : checker.tryGetMemberInModuleExportsAndProperties(ts.unescapeLeadingUnderscores(info.symbolTableKey), moduleSymbol), "Could not find symbol '".concat(info.symbolName, "' by key '").concat(info.symbolTableKey, "' in module ").concat(moduleSymbol.name));
            symbols.set(id, [symbol, moduleSymbol]);
            return {
                symbol: symbol,
                moduleSymbol: moduleSymbol,
                moduleFileName: moduleFileName,
                exportKind: exportKind,
                targetFlags: targetFlags,
                isFromPackageJson: isFromPackageJson,
            };
        }
        function key(importedName, symbol, ambientModuleName, checker) {
            var moduleKey = ambientModuleName || "";
            return "".concat(importedName, "|").concat(ts.getSymbolId(ts.skipAlias(symbol, checker)), "|").concat(moduleKey);
        }
        function parseKey(key) {
            var symbolName = key.substring(0, key.indexOf("|"));
            var moduleKey = key.substring(key.lastIndexOf("|") + 1);
            var ambientModuleName = moduleKey === "" ? undefined : moduleKey;
            return { symbolName: symbolName, ambientModuleName: ambientModuleName };
        }
        function fileIsGlobalOnly(file) {
            return !file.commonJsModuleIndicator && !file.externalModuleIndicator && !file.moduleAugmentations && !file.ambientModuleNames;
        }
        function ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile) {
            if (!ts.arrayIsEqualTo(oldSourceFile.ambientModuleNames, newSourceFile.ambientModuleNames)) {
                return false;
            }
            var oldFileStatementIndex = -1;
            var newFileStatementIndex = -1;
            var _loop_2 = function (ambientModuleName) {
                var isMatchingModuleDeclaration = function (node) { return ts.isNonGlobalAmbientModule(node) && node.name.text === ambientModuleName; };
                oldFileStatementIndex = ts.findIndex(oldSourceFile.statements, isMatchingModuleDeclaration, oldFileStatementIndex + 1);
                newFileStatementIndex = ts.findIndex(newSourceFile.statements, isMatchingModuleDeclaration, newFileStatementIndex + 1);
                if (oldSourceFile.statements[oldFileStatementIndex] !== newSourceFile.statements[newFileStatementIndex]) {
                    return { value: false };
                }
            };
            for (var _i = 0, _a = newSourceFile.ambientModuleNames; _i < _a.length; _i++) {
                var ambientModuleName = _a[_i];
                var state_2 = _loop_2(ambientModuleName);
                if (typeof state_2 === "object")
                    return state_2.value;
            }
            return true;
        }
        function isNotShadowedByDeeperNodeModulesPackage(info, packageName) {
            if (!packageName || !info.moduleFileName)
                return true;
            var typingsCacheLocation = host.getGlobalTypingsCacheLocation();
            if (typingsCacheLocation && ts.startsWith(info.moduleFileName, typingsCacheLocation))
                return true;
            var packageDeepestNodeModulesPath = packages.get(packageName);
            return !packageDeepestNodeModulesPath || ts.startsWith(info.moduleFileName, packageDeepestNodeModulesPath);
        }
    }
    ts.createCacheableExportInfoMap = createCacheableExportInfoMap;
    function isImportableFile(program, from, to, preferences, packageJsonFilter, moduleSpecifierResolutionHost, moduleSpecifierCache) {
        var _a;
        if (from === to)
            return false;
        var cachedResult = moduleSpecifierCache === null || moduleSpecifierCache === void 0 ? void 0 : moduleSpecifierCache.get(from.path, to.path, preferences, {});
        if ((cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.isBlockedByPackageJsonDependencies) !== undefined) {
            return !cachedResult.isBlockedByPackageJsonDependencies;
        }
        var getCanonicalFileName = ts.hostGetCanonicalFileName(moduleSpecifierResolutionHost);
        var globalTypingsCache = (_a = moduleSpecifierResolutionHost.getGlobalTypingsCacheLocation) === null || _a === void 0 ? void 0 : _a.call(moduleSpecifierResolutionHost);
        var hasImportablePath = !!ts.moduleSpecifiers.forEachFileNameOfModule(from.fileName, to.fileName, moduleSpecifierResolutionHost, 
        /*preferSymlinks*/ false, function (toPath) {
            var toFile = program.getSourceFile(toPath);
            // Determine to import using toPath only if toPath is what we were looking at
            // or there doesnt exist the file in the program by the symlink
            return (toFile === to || !toFile) &&
                isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);
        });
        if (packageJsonFilter) {
            var isAutoImportable = hasImportablePath && packageJsonFilter.allowsImportingSourceFile(to, moduleSpecifierResolutionHost);
            moduleSpecifierCache === null || moduleSpecifierCache === void 0 ? void 0 : moduleSpecifierCache.setBlockedByPackageJsonDependencies(from.path, to.path, preferences, {}, !isAutoImportable);
            return isAutoImportable;
        }
        return hasImportablePath;
    }
    ts.isImportableFile = isImportableFile;
    /**
     * Don't include something from a `node_modules` that isn't actually reachable by a global import.
     * A relative import to node_modules is usually a bad idea.
     */
    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
        // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
        var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
        var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
        return toNodeModulesParent === undefined
            || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
            || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
    }
    function forEachExternalModuleToImportFrom(program, host, useAutoImportProvider, cb) {
        var _a, _b;
        forEachExternalModule(program.getTypeChecker(), program.getSourceFiles(), function (module, file) { return cb(module, file, program, /*isFromPackageJson*/ false); });
        var autoImportProvider = useAutoImportProvider && ((_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host));
        if (autoImportProvider) {
            var start = ts.timestamp();
            forEachExternalModule(autoImportProvider.getTypeChecker(), autoImportProvider.getSourceFiles(), function (module, file) { return cb(module, file, autoImportProvider, /*isFromPackageJson*/ true); });
            (_b = host.log) === null || _b === void 0 ? void 0 : _b.call(host, "forEachExternalModuleToImportFrom autoImportProvider: ".concat(ts.timestamp() - start));
        }
    }
    ts.forEachExternalModuleToImportFrom = forEachExternalModuleToImportFrom;
    function forEachExternalModule(checker, allSourceFiles, cb) {
        for (var _i = 0, _a = checker.getAmbientModules(); _i < _a.length; _i++) {
            var ambient = _a[_i];
            if (!ts.stringContains(ambient.name, "*")) {
                cb(ambient, /*sourceFile*/ undefined);
            }
        }
        for (var _b = 0, allSourceFiles_1 = allSourceFiles; _b < allSourceFiles_1.length; _b++) {
            var sourceFile = allSourceFiles_1[_b];
            if (ts.isExternalOrCommonJsModule(sourceFile)) {
                cb(checker.getMergedSymbol(sourceFile.symbol), sourceFile);
            }
        }
    }
    function getExportInfoMap(importingFile, host, program, cancellationToken) {
        var _a, _b, _c, _d, _e;
        var start = ts.timestamp();
        // Pulling the AutoImportProvider project will trigger its updateGraph if pending,
        // which will invalidate the export map cache if things change, so pull it before
        // checking the cache.
        (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
        var cache = ((_b = host.getCachedExportInfoMap) === null || _b === void 0 ? void 0 : _b.call(host)) || createCacheableExportInfoMap({
            getCurrentProgram: function () { return program; },
            getPackageJsonAutoImportProvider: function () { var _a; return (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host); },
            getGlobalTypingsCacheLocation: function () { var _a; return (_a = host.getGlobalTypingsCacheLocation) === null || _a === void 0 ? void 0 : _a.call(host); },
        });
        if (cache.isUsableByFile(importingFile.path)) {
            (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, "getExportInfoMap: cache hit");
            return cache;
        }
        (_d = host.log) === null || _d === void 0 ? void 0 : _d.call(host, "getExportInfoMap: cache miss or empty; calculating new results");
        var compilerOptions = program.getCompilerOptions();
        var moduleCount = 0;
        try {
            forEachExternalModuleToImportFrom(program, host, /*useAutoImportProvider*/ true, function (moduleSymbol, moduleFile, program, isFromPackageJson) {
                if (++moduleCount % 100 === 0)
                    cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.throwIfCancellationRequested();
                var seenExports = new ts.Map();
                var checker = program.getTypeChecker();
                var defaultInfo = getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
                // Note: I think we shouldn't actually see resolved module symbols here, but weird merges
                // can cause it to happen: see 'completionsImport_mergedReExport.ts'
                if (defaultInfo && isImportableSymbol(defaultInfo.symbol, checker)) {
                    cache.add(importingFile.path, defaultInfo.symbol, defaultInfo.exportKind === 1 /* ExportKind.Default */ ? "default" /* InternalSymbolName.Default */ : "export=" /* InternalSymbolName.ExportEquals */, moduleSymbol, moduleFile, defaultInfo.exportKind, isFromPackageJson, checker);
                }
                checker.forEachExportAndPropertyOfModule(moduleSymbol, function (exported, key) {
                    if (exported !== (defaultInfo === null || defaultInfo === void 0 ? void 0 : defaultInfo.symbol) && isImportableSymbol(exported, checker) && ts.addToSeen(seenExports, key)) {
                        cache.add(importingFile.path, exported, key, moduleSymbol, moduleFile, 0 /* ExportKind.Named */, isFromPackageJson, checker);
                    }
                });
            });
        }
        catch (err) {
            // Ensure cache is reset if operation is cancelled
            cache.clear();
            throw err;
        }
        (_e = host.log) === null || _e === void 0 ? void 0 : _e.call(host, "getExportInfoMap: done in ".concat(ts.timestamp() - start, " ms"));
        return cache;
    }
    ts.getExportInfoMap = getExportInfoMap;
    function getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions) {
        var exported = getDefaultLikeExportWorker(moduleSymbol, checker);
        if (!exported)
            return undefined;
        var symbol = exported.symbol, exportKind = exported.exportKind;
        var info = getDefaultExportInfoWorker(symbol, checker, compilerOptions);
        return info && __assign({ symbol: symbol, exportKind: exportKind }, info);
    }
    ts.getDefaultLikeExportInfo = getDefaultLikeExportInfo;
    function isImportableSymbol(symbol, checker) {
        return !checker.isUndefinedSymbol(symbol) && !checker.isUnknownSymbol(symbol) && !ts.isKnownSymbol(symbol) && !ts.isPrivateIdentifierSymbol(symbol);
    }
    function getDefaultLikeExportWorker(moduleSymbol, checker) {
        var exportEquals = checker.resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol)
            return { symbol: exportEquals, exportKind: 2 /* ExportKind.ExportEquals */ };
        var defaultExport = checker.tryGetMemberInModuleExports("default" /* InternalSymbolName.Default */, moduleSymbol);
        if (defaultExport)
            return { symbol: defaultExport, exportKind: 1 /* ExportKind.Default */ };
    }
    function getDefaultExportInfoWorker(defaultExport, checker, compilerOptions) {
        var localSymbol = ts.getLocalSymbolForExportDefault(defaultExport);
        if (localSymbol)
            return { symbolForMeaning: localSymbol, name: localSymbol.name };
        var name = getNameForExportDefault(defaultExport);
        if (name !== undefined)
            return { symbolForMeaning: defaultExport, name: name };
        if (defaultExport.flags & 2097152 /* SymbolFlags.Alias */) {
            var aliased = checker.getImmediateAliasedSymbol(defaultExport);
            if (aliased && aliased.parent) {
                // - `aliased` will be undefined if the module is exporting an unresolvable name,
                //    but we can still offer completions for it.
                // - `aliased.parent` will be undefined if the module is exporting `globalThis.something`,
                //    or another expression that resolves to a global.
                return getDefaultExportInfoWorker(aliased, checker, compilerOptions);
            }
        }
        if (defaultExport.escapedName !== "default" /* InternalSymbolName.Default */ &&
            defaultExport.escapedName !== "export=" /* InternalSymbolName.ExportEquals */) {
            return { symbolForMeaning: defaultExport, name: defaultExport.getName() };
        }
        return { symbolForMeaning: defaultExport, name: ts.getNameForExportedSymbol(defaultExport, compilerOptions.target) };
    }
    function getNameForExportDefault(symbol) {
        return symbol.declarations && ts.firstDefined(symbol.declarations, function (declaration) {
            var _a;
            if (ts.isExportAssignment(declaration)) {
                return (_a = ts.tryCast(ts.skipOuterExpressions(declaration.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text;
            }
            else if (ts.isExportSpecifier(declaration)) {
                ts.Debug.assert(declaration.name.text === "default" /* InternalSymbolName.Default */, "Expected the specifier to be a default export");
                return declaration.propertyName && declaration.propertyName.text;
            }
        });
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    /** The classifier is used for syntactic highlighting in editors via the TSServer */
    function createClassifier() {
        var scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ false);
        function getClassificationsForLine(text, lexState, syntacticClassifierAbsent) {
            return convertClassificationsToResult(getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent), text);
        }
        // If there is a syntactic classifier ('syntacticClassifierAbsent' is false),
        // we will be more conservative in order to avoid conflicting with the syntactic classifier.
        function getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent) {
            var token = 0 /* SyntaxKind.Unknown */;
            var lastNonTriviaToken = 0 /* SyntaxKind.Unknown */;
            // Just a stack of TemplateHeads and OpenCurlyBraces, used to perform rudimentary (inexact)
            // classification on template strings. Because of the context free nature of templates,
            // the only precise way to classify a template portion would be by propagating the stack across
            // lines, just as we do with the end-of-line state. However, this is a burden for implementers,
            // and the behavior is entirely subsumed by the syntactic classifier anyway, so we instead
            // flatten any nesting when the template stack is non-empty and encode it in the end-of-line state.
            // Situations in which this fails are
            //  1) When template strings are nested across different lines:
            //          `hello ${ `world
            //          ` }`
            //
            //     Where on the second line, you will get the closing of a template,
            //     a closing curly, and a new template.
            //
            //  2) When substitution expressions have curly braces and the curly brace falls on the next line:
            //          `hello ${ () => {
            //          return "world" } } `
            //
            //     Where on the second line, you will get the 'return' keyword,
            //     a string literal, and a template end consisting of '} } `'.
            var templateStack = [];
            var _a = getPrefixFromLexState(lexState), prefix = _a.prefix, pushTemplate = _a.pushTemplate;
            text = prefix + text;
            var offset = prefix.length;
            if (pushTemplate) {
                templateStack.push(15 /* SyntaxKind.TemplateHead */);
            }
            scanner.setText(text);
            var endOfLineState = 0 /* EndOfLineState.None */;
            var spans = [];
            // We can run into an unfortunate interaction between the lexical and syntactic classifier
            // when the user is typing something generic.  Consider the case where the user types:
            //
            //      Foo<number
            //
            // From the lexical classifier's perspective, 'number' is a keyword, and so the word will
            // be classified as such.  However, from the syntactic classifier's tree-based perspective
            // this is simply an expression with the identifier 'number' on the RHS of the less than
            // token.  So the classification will go back to being an identifier.  The moment the user
            // types again, number will become a keyword, then an identifier, etc. etc.
            //
            // To try to avoid this problem, we avoid classifying contextual keywords as keywords
            // when the user is potentially typing something generic.  We just can't do a good enough
            // job at the lexical level, and so well leave it up to the syntactic classifier to make
            // the determination.
            //
            // In order to determine if the user is potentially typing something generic, we use a
            // weak heuristic where we track < and > tokens.  It's a weak heuristic, but should
            // work well enough in practice.
            var angleBracketStack = 0;
            do {
                token = scanner.scan();
                if (!ts.isTrivia(token)) {
                    handleToken();
                    lastNonTriviaToken = token;
                }
                var end = scanner.getTextPos();
                pushEncodedClassification(scanner.getTokenPos(), end, offset, classFromKind(token), spans);
                if (end >= text.length) {
                    var end_1 = getNewEndOfLineState(scanner, token, ts.lastOrUndefined(templateStack));
                    if (end_1 !== undefined) {
                        endOfLineState = end_1;
                    }
                }
            } while (token !== 1 /* SyntaxKind.EndOfFileToken */);
            function handleToken() {
                switch (token) {
                    case 43 /* SyntaxKind.SlashToken */:
                    case 68 /* SyntaxKind.SlashEqualsToken */:
                        if (!noRegexTable[lastNonTriviaToken] && scanner.reScanSlashToken() === 13 /* SyntaxKind.RegularExpressionLiteral */) {
                            token = 13 /* SyntaxKind.RegularExpressionLiteral */;
                        }
                        break;
                    case 29 /* SyntaxKind.LessThanToken */:
                        if (lastNonTriviaToken === 79 /* SyntaxKind.Identifier */) {
                            // Could be the start of something generic.  Keep track of that by bumping
                            // up the current count of generic contexts we may be in.
                            angleBracketStack++;
                        }
                        break;
                    case 31 /* SyntaxKind.GreaterThanToken */:
                        if (angleBracketStack > 0) {
                            // If we think we're currently in something generic, then mark that that
                            // generic entity is complete.
                            angleBracketStack--;
                        }
                        break;
                    case 130 /* SyntaxKind.AnyKeyword */:
                    case 150 /* SyntaxKind.StringKeyword */:
                    case 147 /* SyntaxKind.NumberKeyword */:
                    case 133 /* SyntaxKind.BooleanKeyword */:
                    case 151 /* SyntaxKind.SymbolKeyword */:
                        if (angleBracketStack > 0 && !syntacticClassifierAbsent) {
                            // If it looks like we're could be in something generic, don't classify this
                            // as a keyword.  We may just get overwritten by the syntactic classifier,
                            // causing a noisy experience for the user.
                            token = 79 /* SyntaxKind.Identifier */;
                        }
                        break;
                    case 15 /* SyntaxKind.TemplateHead */:
                        templateStack.push(token);
                        break;
                    case 18 /* SyntaxKind.OpenBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            templateStack.push(token);
                        }
                        break;
                    case 19 /* SyntaxKind.CloseBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            var lastTemplateStackToken = ts.lastOrUndefined(templateStack);
                            if (lastTemplateStackToken === 15 /* SyntaxKind.TemplateHead */) {
                                token = scanner.reScanTemplateToken(/* isTaggedTemplate */ false);
                                // Only pop on a TemplateTail; a TemplateMiddle indicates there is more for us.
                                if (token === 17 /* SyntaxKind.TemplateTail */) {
                                    templateStack.pop();
                                }
                                else {
                                    ts.Debug.assertEqual(token, 16 /* SyntaxKind.TemplateMiddle */, "Should have been a template middle.");
                                }
                            }
                            else {
                                ts.Debug.assertEqual(lastTemplateStackToken, 18 /* SyntaxKind.OpenBraceToken */, "Should have been an open brace");
                                templateStack.pop();
                            }
                        }
                        break;
                    default:
                        if (!ts.isKeyword(token)) {
                            break;
                        }
                        if (lastNonTriviaToken === 24 /* SyntaxKind.DotToken */) {
                            token = 79 /* SyntaxKind.Identifier */;
                        }
                        else if (ts.isKeyword(lastNonTriviaToken) && ts.isKeyword(token) && !canFollow(lastNonTriviaToken, token)) {
                            // We have two keywords in a row.  Only treat the second as a keyword if
                            // it's a sequence that could legally occur in the language.  Otherwise
                            // treat it as an identifier.  This way, if someone writes "private var"
                            // we recognize that 'var' is actually an identifier here.
                            token = 79 /* SyntaxKind.Identifier */;
                        }
                }
            }
            return { endOfLineState: endOfLineState, spans: spans };
        }
        return { getClassificationsForLine: getClassificationsForLine, getEncodedLexicalClassifications: getEncodedLexicalClassifications };
    }
    ts.createClassifier = createClassifier;
    /// We do not have a full parser support to know when we should parse a regex or not
    /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
    /// we have a series of divide operator. this list allows us to be more accurate by ruling out
    /// locations where a regexp cannot exist.
    var noRegexTable = ts.arrayToNumericMap([
        79 /* SyntaxKind.Identifier */,
        10 /* SyntaxKind.StringLiteral */,
        8 /* SyntaxKind.NumericLiteral */,
        9 /* SyntaxKind.BigIntLiteral */,
        13 /* SyntaxKind.RegularExpressionLiteral */,
        108 /* SyntaxKind.ThisKeyword */,
        45 /* SyntaxKind.PlusPlusToken */,
        46 /* SyntaxKind.MinusMinusToken */,
        21 /* SyntaxKind.CloseParenToken */,
        23 /* SyntaxKind.CloseBracketToken */,
        19 /* SyntaxKind.CloseBraceToken */,
        110 /* SyntaxKind.TrueKeyword */,
        95 /* SyntaxKind.FalseKeyword */,
    ], function (token) { return token; }, function () { return true; });
    function getNewEndOfLineState(scanner, token, lastOnTemplateStack) {
        switch (token) {
            case 10 /* SyntaxKind.StringLiteral */: {
                // Check to see if we finished up on a multiline string literal.
                if (!scanner.isUnterminated())
                    return undefined;
                var tokenText = scanner.getTokenText();
                var lastCharIndex = tokenText.length - 1;
                var numBackslashes = 0;
                while (tokenText.charCodeAt(lastCharIndex - numBackslashes) === 92 /* CharacterCodes.backslash */) {
                    numBackslashes++;
                }
                // If we have an odd number of backslashes, then the multiline string is unclosed
                if ((numBackslashes & 1) === 0)
                    return undefined;
                return tokenText.charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */ ? 3 /* EndOfLineState.InDoubleQuoteStringLiteral */ : 2 /* EndOfLineState.InSingleQuoteStringLiteral */;
            }
            case 3 /* SyntaxKind.MultiLineCommentTrivia */:
                // Check to see if the multiline comment was unclosed.
                return scanner.isUnterminated() ? 1 /* EndOfLineState.InMultiLineCommentTrivia */ : undefined;
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    if (!scanner.isUnterminated()) {
                        return undefined;
                    }
                    switch (token) {
                        case 17 /* SyntaxKind.TemplateTail */:
                            return 5 /* EndOfLineState.InTemplateMiddleOrTail */;
                        case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                            return 4 /* EndOfLineState.InTemplateHeadOrNoSubstitutionTemplate */;
                        default:
                            return ts.Debug.fail("Only 'NoSubstitutionTemplateLiteral's and 'TemplateTail's can be unterminated; got SyntaxKind #" + token);
                    }
                }
                return lastOnTemplateStack === 15 /* SyntaxKind.TemplateHead */ ? 6 /* EndOfLineState.InTemplateSubstitutionPosition */ : undefined;
        }
    }
    function pushEncodedClassification(start, end, offset, classification, result) {
        if (classification === 8 /* ClassificationType.whiteSpace */) {
            // Don't bother with whitespace classifications.  They're not needed.
            return;
        }
        if (start === 0 && offset > 0) {
            // We're classifying the first token, and this was a case where we prepended text.
            // We should consider the start of this token to be at the start of the original text.
            start += offset;
        }
        var length = end - start;
        if (length > 0) {
            // All our tokens are in relation to the augmented text.  Move them back to be
            // relative to the original text.
            result.push(start - offset, length, classification);
        }
    }
    function convertClassificationsToResult(classifications, text) {
        var entries = [];
        var dense = classifications.spans;
        var lastEnd = 0;
        for (var i = 0; i < dense.length; i += 3) {
            var start = dense[i];
            var length_1 = dense[i + 1];
            var type = dense[i + 2];
            // Make a whitespace entry between the last item and this one.
            if (lastEnd >= 0) {
                var whitespaceLength_1 = start - lastEnd;
                if (whitespaceLength_1 > 0) {
                    entries.push({ length: whitespaceLength_1, classification: ts.TokenClass.Whitespace });
                }
            }
            entries.push({ length: length_1, classification: convertClassification(type) });
            lastEnd = start + length_1;
        }
        var whitespaceLength = text.length - lastEnd;
        if (whitespaceLength > 0) {
            entries.push({ length: whitespaceLength, classification: ts.TokenClass.Whitespace });
        }
        return { entries: entries, finalLexState: classifications.endOfLineState };
    }
    function convertClassification(type) {
        switch (type) {
            case 1 /* ClassificationType.comment */: return ts.TokenClass.Comment;
            case 3 /* ClassificationType.keyword */: return ts.TokenClass.Keyword;
            case 4 /* ClassificationType.numericLiteral */: return ts.TokenClass.NumberLiteral;
            case 25 /* ClassificationType.bigintLiteral */: return ts.TokenClass.BigIntLiteral;
            case 5 /* ClassificationType.operator */: return ts.TokenClass.Operator;
            case 6 /* ClassificationType.stringLiteral */: return ts.TokenClass.StringLiteral;
            case 8 /* ClassificationType.whiteSpace */: return ts.TokenClass.Whitespace;
            case 10 /* ClassificationType.punctuation */: return ts.TokenClass.Punctuation;
            case 2 /* ClassificationType.identifier */:
            case 11 /* ClassificationType.className */:
            case 12 /* ClassificationType.enumName */:
            case 13 /* ClassificationType.interfaceName */:
            case 14 /* ClassificationType.moduleName */:
            case 15 /* ClassificationType.typeParameterName */:
            case 16 /* ClassificationType.typeAliasName */:
            case 9 /* ClassificationType.text */:
            case 17 /* ClassificationType.parameterName */:
                return ts.TokenClass.Identifier;
            default:
                return undefined; // TODO: GH#18217 Debug.assertNever(type);
        }
    }
    /** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
    function canFollow(keyword1, keyword2) {
        if (!ts.isAccessibilityModifier(keyword1)) {
            // Assume any other keyword combination is legal.
            // This can be refined in the future if there are more cases we want the classifier to be better at.
            return true;
        }
        switch (keyword2) {
            case 136 /* SyntaxKind.GetKeyword */:
            case 149 /* SyntaxKind.SetKeyword */:
            case 134 /* SyntaxKind.ConstructorKeyword */:
            case 124 /* SyntaxKind.StaticKeyword */:
                return true; // Allow things like "public get", "public constructor" and "public static".
            default:
                return false; // Any other keyword following "public" is actually an identifier, not a real keyword.
        }
    }
    function getPrefixFromLexState(lexState) {
        // If we're in a string literal, then prepend: "\
        // (and a newline).  That way when we lex we'll think we're still in a string literal.
        //
        // If we're in a multiline comment, then prepend: /*
        // (and a newline).  That way when we lex we'll think we're still in a multiline comment.
        switch (lexState) {
            case 3 /* EndOfLineState.InDoubleQuoteStringLiteral */:
                return { prefix: "\"\\\n" };
            case 2 /* EndOfLineState.InSingleQuoteStringLiteral */:
                return { prefix: "'\\\n" };
            case 1 /* EndOfLineState.InMultiLineCommentTrivia */:
                return { prefix: "/*\n" };
            case 4 /* EndOfLineState.InTemplateHeadOrNoSubstitutionTemplate */:
                return { prefix: "`\n" };
            case 5 /* EndOfLineState.InTemplateMiddleOrTail */:
                return { prefix: "}\n", pushTemplate: true };
            case 6 /* EndOfLineState.InTemplateSubstitutionPosition */:
                return { prefix: "", pushTemplate: true };
            case 0 /* EndOfLineState.None */:
                return { prefix: "" };
            default:
                return ts.Debug.assertNever(lexState);
        }
    }
    function isBinaryExpressionOperatorToken(token) {
        switch (token) {
            case 41 /* SyntaxKind.AsteriskToken */:
            case 43 /* SyntaxKind.SlashToken */:
            case 44 /* SyntaxKind.PercentToken */:
            case 39 /* SyntaxKind.PlusToken */:
            case 40 /* SyntaxKind.MinusToken */:
            case 47 /* SyntaxKind.LessThanLessThanToken */:
            case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
            case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
            case 29 /* SyntaxKind.LessThanToken */:
            case 31 /* SyntaxKind.GreaterThanToken */:
            case 32 /* SyntaxKind.LessThanEqualsToken */:
            case 33 /* SyntaxKind.GreaterThanEqualsToken */:
            case 102 /* SyntaxKind.InstanceOfKeyword */:
            case 101 /* SyntaxKind.InKeyword */:
            case 127 /* SyntaxKind.AsKeyword */:
            case 34 /* SyntaxKind.EqualsEqualsToken */:
            case 35 /* SyntaxKind.ExclamationEqualsToken */:
            case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
            case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
            case 50 /* SyntaxKind.AmpersandToken */:
            case 52 /* SyntaxKind.CaretToken */:
            case 51 /* SyntaxKind.BarToken */:
            case 55 /* SyntaxKind.AmpersandAmpersandToken */:
            case 56 /* SyntaxKind.BarBarToken */:
            case 74 /* SyntaxKind.BarEqualsToken */:
            case 73 /* SyntaxKind.AmpersandEqualsToken */:
            case 78 /* SyntaxKind.CaretEqualsToken */:
            case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
            case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
            case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
            case 64 /* SyntaxKind.PlusEqualsToken */:
            case 65 /* SyntaxKind.MinusEqualsToken */:
            case 66 /* SyntaxKind.AsteriskEqualsToken */:
            case 68 /* SyntaxKind.SlashEqualsToken */:
            case 69 /* SyntaxKind.PercentEqualsToken */:
            case 63 /* SyntaxKind.EqualsToken */:
            case 27 /* SyntaxKind.CommaToken */:
            case 60 /* SyntaxKind.QuestionQuestionToken */:
            case 75 /* SyntaxKind.BarBarEqualsToken */:
            case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
            case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    function isPrefixUnaryExpressionOperatorToken(token) {
        switch (token) {
            case 39 /* SyntaxKind.PlusToken */:
            case 40 /* SyntaxKind.MinusToken */:
            case 54 /* SyntaxKind.TildeToken */:
            case 53 /* SyntaxKind.ExclamationToken */:
            case 45 /* SyntaxKind.PlusPlusToken */:
            case 46 /* SyntaxKind.MinusMinusToken */:
                return true;
            default:
                return false;
        }
    }
    function classFromKind(token) {
        if (ts.isKeyword(token)) {
            return 3 /* ClassificationType.keyword */;
        }
        else if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
            return 5 /* ClassificationType.operator */;
        }
        else if (token >= 18 /* SyntaxKind.FirstPunctuation */ && token <= 78 /* SyntaxKind.LastPunctuation */) {
            return 10 /* ClassificationType.punctuation */;
        }
        switch (token) {
            case 8 /* SyntaxKind.NumericLiteral */:
                return 4 /* ClassificationType.numericLiteral */;
            case 9 /* SyntaxKind.BigIntLiteral */:
                return 25 /* ClassificationType.bigintLiteral */;
            case 10 /* SyntaxKind.StringLiteral */:
                return 6 /* ClassificationType.stringLiteral */;
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
                return 7 /* ClassificationType.regularExpressionLiteral */;
            case 7 /* SyntaxKind.ConflictMarkerTrivia */:
            case 3 /* SyntaxKind.MultiLineCommentTrivia */:
            case 2 /* SyntaxKind.SingleLineCommentTrivia */:
                return 1 /* ClassificationType.comment */;
            case 5 /* SyntaxKind.WhitespaceTrivia */:
            case 4 /* SyntaxKind.NewLineTrivia */:
                return 8 /* ClassificationType.whiteSpace */;
            case 79 /* SyntaxKind.Identifier */:
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    return 6 /* ClassificationType.stringLiteral */;
                }
                return 2 /* ClassificationType.identifier */;
        }
    }
    /* @internal */
    function getSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        return convertClassificationsToSpans(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));
    }
    ts.getSemanticClassifications = getSemanticClassifications;
    function checkForClassificationCancellation(cancellationToken, kind) {
        // We don't want to actually call back into our host on every node to find out if we've
        // been canceled.  That would be an enormous amount of chattyness, along with the all
        // the overhead of marshalling the data to/from the host.  So instead we pick a few
        // reasonable node kinds to bother checking on.  These node kinds represent high level
        // constructs that we would expect to see commonly, but just at a far less frequent
        // interval.
        //
        // For example, in checker.ts (around 750k) we only have around 600 of these constructs.
        // That means we're calling back into the host around every 1.2k of the file we process.
        // Lib.d.ts has similar numbers.
        switch (kind) {
            case 261 /* SyntaxKind.ModuleDeclaration */:
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
                cancellationToken.throwIfCancellationRequested();
        }
    }
    /* @internal */
    function getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        var spans = [];
        sourceFile.forEachChild(function cb(node) {
            // Only walk into nodes that intersect the requested span.
            if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth())) {
                return;
            }
            checkForClassificationCancellation(cancellationToken, node.kind);
            // Only bother calling into the typechecker if this is an identifier that
            // could possibly resolve to a type name.  This makes classification run
            // in a third of the time it would normally take.
            if (ts.isIdentifier(node) && !ts.nodeIsMissing(node) && classifiableNames.has(node.escapedText)) {
                var symbol = typeChecker.getSymbolAtLocation(node);
                var type = symbol && classifySymbol(symbol, ts.getMeaningFromLocation(node), typeChecker);
                if (type) {
                    pushClassification(node.getStart(sourceFile), node.getEnd(), type);
                }
            }
            node.forEachChild(cb);
        });
        return { spans: spans, endOfLineState: 0 /* EndOfLineState.None */ };
        function pushClassification(start, end, type) {
            var length = end - start;
            ts.Debug.assert(length > 0, "Classification had non-positive length of ".concat(length));
            spans.push(start);
            spans.push(length);
            spans.push(type);
        }
    }
    ts.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
    function classifySymbol(symbol, meaningAtPosition, checker) {
        var flags = symbol.getFlags();
        if ((flags & 2885600 /* SymbolFlags.Classifiable */) === 0 /* SymbolFlags.None */) {
            return undefined;
        }
        else if (flags & 32 /* SymbolFlags.Class */) {
            return 11 /* ClassificationType.className */;
        }
        else if (flags & 384 /* SymbolFlags.Enum */) {
            return 12 /* ClassificationType.enumName */;
        }
        else if (flags & 524288 /* SymbolFlags.TypeAlias */) {
            return 16 /* ClassificationType.typeAliasName */;
        }
        else if (flags & 1536 /* SymbolFlags.Module */) {
            // Only classify a module as such if
            //  - It appears in a namespace context.
            //  - There exists a module declaration which actually impacts the value side.
            return meaningAtPosition & 4 /* SemanticMeaning.Namespace */ || meaningAtPosition & 1 /* SemanticMeaning.Value */ && hasValueSideModule(symbol) ? 14 /* ClassificationType.moduleName */ : undefined;
        }
        else if (flags & 2097152 /* SymbolFlags.Alias */) {
            return classifySymbol(checker.getAliasedSymbol(symbol), meaningAtPosition, checker);
        }
        else if (meaningAtPosition & 2 /* SemanticMeaning.Type */) {
            return flags & 64 /* SymbolFlags.Interface */ ? 13 /* ClassificationType.interfaceName */ : flags & 262144 /* SymbolFlags.TypeParameter */ ? 15 /* ClassificationType.typeParameterName */ : undefined;
        }
        else {
            return undefined;
        }
    }
    /** Returns true if there exists a module that introduces entities on the value side. */
    function hasValueSideModule(symbol) {
        return ts.some(symbol.declarations, function (declaration) {
            return ts.isModuleDeclaration(declaration) && ts.getModuleInstanceState(declaration) === 1 /* ModuleInstanceState.Instantiated */;
        });
    }
    function getClassificationTypeName(type) {
        switch (type) {
            case 1 /* ClassificationType.comment */: return "comment" /* ClassificationTypeNames.comment */;
            case 2 /* ClassificationType.identifier */: return "identifier" /* ClassificationTypeNames.identifier */;
            case 3 /* ClassificationType.keyword */: return "keyword" /* ClassificationTypeNames.keyword */;
            case 4 /* ClassificationType.numericLiteral */: return "number" /* ClassificationTypeNames.numericLiteral */;
            case 25 /* ClassificationType.bigintLiteral */: return "bigint" /* ClassificationTypeNames.bigintLiteral */;
            case 5 /* ClassificationType.operator */: return "operator" /* ClassificationTypeNames.operator */;
            case 6 /* ClassificationType.stringLiteral */: return "string" /* ClassificationTypeNames.stringLiteral */;
            case 8 /* ClassificationType.whiteSpace */: return "whitespace" /* ClassificationTypeNames.whiteSpace */;
            case 9 /* ClassificationType.text */: return "text" /* ClassificationTypeNames.text */;
            case 10 /* ClassificationType.punctuation */: return "punctuation" /* ClassificationTypeNames.punctuation */;
            case 11 /* ClassificationType.className */: return "class name" /* ClassificationTypeNames.className */;
            case 12 /* ClassificationType.enumName */: return "enum name" /* ClassificationTypeNames.enumName */;
            case 13 /* ClassificationType.interfaceName */: return "interface name" /* ClassificationTypeNames.interfaceName */;
            case 14 /* ClassificationType.moduleName */: return "module name" /* ClassificationTypeNames.moduleName */;
            case 15 /* ClassificationType.typeParameterName */: return "type parameter name" /* ClassificationTypeNames.typeParameterName */;
            case 16 /* ClassificationType.typeAliasName */: return "type alias name" /* ClassificationTypeNames.typeAliasName */;
            case 17 /* ClassificationType.parameterName */: return "parameter name" /* ClassificationTypeNames.parameterName */;
            case 18 /* ClassificationType.docCommentTagName */: return "doc comment tag name" /* ClassificationTypeNames.docCommentTagName */;
            case 19 /* ClassificationType.jsxOpenTagName */: return "jsx open tag name" /* ClassificationTypeNames.jsxOpenTagName */;
            case 20 /* ClassificationType.jsxCloseTagName */: return "jsx close tag name" /* ClassificationTypeNames.jsxCloseTagName */;
            case 21 /* ClassificationType.jsxSelfClosingTagName */: return "jsx self closing tag name" /* ClassificationTypeNames.jsxSelfClosingTagName */;
            case 22 /* ClassificationType.jsxAttribute */: return "jsx attribute" /* ClassificationTypeNames.jsxAttribute */;
            case 23 /* ClassificationType.jsxText */: return "jsx text" /* ClassificationTypeNames.jsxText */;
            case 24 /* ClassificationType.jsxAttributeStringLiteralValue */: return "jsx attribute string literal value" /* ClassificationTypeNames.jsxAttributeStringLiteralValue */;
            default: return undefined; // TODO: GH#18217 throw Debug.assertNever(type);
        }
    }
    function convertClassificationsToSpans(classifications) {
        ts.Debug.assert(classifications.spans.length % 3 === 0);
        var dense = classifications.spans;
        var result = [];
        for (var i = 0; i < dense.length; i += 3) {
            result.push({
                textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
                classificationType: getClassificationTypeName(dense[i + 2])
            });
        }
        return result;
    }
    /* @internal */
    function getSyntacticClassifications(cancellationToken, sourceFile, span) {
        return convertClassificationsToSpans(getEncodedSyntacticClassifications(cancellationToken, sourceFile, span));
    }
    ts.getSyntacticClassifications = getSyntacticClassifications;
    /* @internal */
    function getEncodedSyntacticClassifications(cancellationToken, sourceFile, span) {
        var spanStart = span.start;
        var spanLength = span.length;
        // Make a scanner we can get trivia from.
        var triviaScanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
        var mergeConflictScanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
        var result = [];
        processElement(sourceFile);
        return { spans: result, endOfLineState: 0 /* EndOfLineState.None */ };
        function pushClassification(start, length, type) {
            result.push(start);
            result.push(length);
            result.push(type);
        }
        function classifyLeadingTriviaAndGetTokenStart(token) {
            triviaScanner.setTextPos(token.pos);
            while (true) {
                var start = triviaScanner.getTextPos();
                // only bother scanning if we have something that could be trivia.
                if (!ts.couldStartTrivia(sourceFile.text, start)) {
                    return start;
                }
                var kind = triviaScanner.scan();
                var end = triviaScanner.getTextPos();
                var width = end - start;
                // The moment we get something that isn't trivia, then stop processing.
                if (!ts.isTrivia(kind)) {
                    return start;
                }
                switch (kind) {
                    case 4 /* SyntaxKind.NewLineTrivia */:
                    case 5 /* SyntaxKind.WhitespaceTrivia */:
                        // Don't bother with newlines/whitespace.
                        continue;
                    case 2 /* SyntaxKind.SingleLineCommentTrivia */:
                    case 3 /* SyntaxKind.MultiLineCommentTrivia */:
                        // Only bother with the trivia if it at least intersects the span of interest.
                        classifyComment(token, kind, start, width);
                        // Classifying a comment might cause us to reuse the trivia scanner
                        // (because of jsdoc comments).  So after we classify the comment make
                        // sure we set the scanner position back to where it needs to be.
                        triviaScanner.setTextPos(end);
                        continue;
                    case 7 /* SyntaxKind.ConflictMarkerTrivia */:
                        var text = sourceFile.text;
                        var ch = text.charCodeAt(start);
                        // for the <<<<<<< and >>>>>>> markers, we just add them in as comments
                        // in the classification stream.
                        if (ch === 60 /* CharacterCodes.lessThan */ || ch === 62 /* CharacterCodes.greaterThan */) {
                            pushClassification(start, width, 1 /* ClassificationType.comment */);
                            continue;
                        }
                        // for the ||||||| and ======== markers, add a comment for the first line,
                        // and then lex all subsequent lines up until the end of the conflict marker.
                        ts.Debug.assert(ch === 124 /* CharacterCodes.bar */ || ch === 61 /* CharacterCodes.equals */);
                        classifyDisabledMergeCode(text, start, end);
                        break;
                    case 6 /* SyntaxKind.ShebangTrivia */:
                        // TODO: Maybe we should classify these.
                        break;
                    default:
                        ts.Debug.assertNever(kind);
                }
            }
        }
        function classifyComment(token, kind, start, width) {
            if (kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
                // See if this is a doc comment.  If so, we'll classify certain portions of it
                // specially.
                var docCommentAndDiagnostics = ts.parseIsolatedJSDocComment(sourceFile.text, start, width);
                if (docCommentAndDiagnostics && docCommentAndDiagnostics.jsDoc) {
                    // TODO: This should be predicated on `token["kind"]` being compatible with `HasJSDoc["kind"]`
                    ts.setParent(docCommentAndDiagnostics.jsDoc, token);
                    classifyJSDocComment(docCommentAndDiagnostics.jsDoc);
                    return;
                }
            }
            else if (kind === 2 /* SyntaxKind.SingleLineCommentTrivia */) {
                if (tryClassifyTripleSlashComment(start, width)) {
                    return;
                }
            }
            // Simple comment.  Just add as is.
            pushCommentRange(start, width);
        }
        function pushCommentRange(start, width) {
            pushClassification(start, width, 1 /* ClassificationType.comment */);
        }
        function classifyJSDocComment(docComment) {
            var _a, _b, _c, _d, _e, _f, _g;
            var pos = docComment.pos;
            if (docComment.tags) {
                for (var _i = 0, _h = docComment.tags; _i < _h.length; _i++) {
                    var tag = _h[_i];
                    // As we walk through each tag, classify the portion of text from the end of
                    // the last tag (or the start of the entire doc comment) as 'comment'.
                    if (tag.pos !== pos) {
                        pushCommentRange(pos, tag.pos - pos);
                    }
                    pushClassification(tag.pos, 1, 10 /* ClassificationType.punctuation */); // "@"
                    pushClassification(tag.tagName.pos, tag.tagName.end - tag.tagName.pos, 18 /* ClassificationType.docCommentTagName */); // e.g. "param"
                    pos = tag.tagName.end;
                    var commentStart = tag.tagName.end;
                    switch (tag.kind) {
                        case 340 /* SyntaxKind.JSDocParameterTag */:
                            var param = tag;
                            processJSDocParameterTag(param);
                            commentStart = param.isNameFirst && ((_a = param.typeExpression) === null || _a === void 0 ? void 0 : _a.end) || param.name.end;
                            break;
                        case 347 /* SyntaxKind.JSDocPropertyTag */:
                            var prop = tag;
                            commentStart = prop.isNameFirst && ((_b = prop.typeExpression) === null || _b === void 0 ? void 0 : _b.end) || prop.name.end;
                            break;
                        case 344 /* SyntaxKind.JSDocTemplateTag */:
                            processJSDocTemplateTag(tag);
                            pos = tag.end;
                            commentStart = tag.typeParameters.end;
                            break;
                        case 345 /* SyntaxKind.JSDocTypedefTag */:
                            var type = tag;
                            commentStart = ((_c = type.typeExpression) === null || _c === void 0 ? void 0 : _c.kind) === 309 /* SyntaxKind.JSDocTypeExpression */ && ((_d = type.fullName) === null || _d === void 0 ? void 0 : _d.end) || ((_e = type.typeExpression) === null || _e === void 0 ? void 0 : _e.end) || commentStart;
                            break;
                        case 338 /* SyntaxKind.JSDocCallbackTag */:
                            commentStart = tag.typeExpression.end;
                            break;
                        case 343 /* SyntaxKind.JSDocTypeTag */:
                            processElement(tag.typeExpression);
                            pos = tag.end;
                            commentStart = tag.typeExpression.end;
                            break;
                        case 342 /* SyntaxKind.JSDocThisTag */:
                        case 339 /* SyntaxKind.JSDocEnumTag */:
                            commentStart = tag.typeExpression.end;
                            break;
                        case 341 /* SyntaxKind.JSDocReturnTag */:
                            processElement(tag.typeExpression);
                            pos = tag.end;
                            commentStart = ((_f = tag.typeExpression) === null || _f === void 0 ? void 0 : _f.end) || commentStart;
                            break;
                        case 346 /* SyntaxKind.JSDocSeeTag */:
                            commentStart = ((_g = tag.name) === null || _g === void 0 ? void 0 : _g.end) || commentStart;
                            break;
                        case 328 /* SyntaxKind.JSDocAugmentsTag */:
                        case 329 /* SyntaxKind.JSDocImplementsTag */:
                            commentStart = tag.class.end;
                            break;
                    }
                    if (typeof tag.comment === "object") {
                        pushCommentRange(tag.comment.pos, tag.comment.end - tag.comment.pos);
                    }
                    else if (typeof tag.comment === "string") {
                        pushCommentRange(commentStart, tag.end - commentStart);
                    }
                }
            }
            if (pos !== docComment.end) {
                pushCommentRange(pos, docComment.end - pos);
            }
            return;
            function processJSDocParameterTag(tag) {
                if (tag.isNameFirst) {
                    pushCommentRange(pos, tag.name.pos - pos);
                    pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* ClassificationType.parameterName */);
                    pos = tag.name.end;
                }
                if (tag.typeExpression) {
                    pushCommentRange(pos, tag.typeExpression.pos - pos);
                    processElement(tag.typeExpression);
                    pos = tag.typeExpression.end;
                }
                if (!tag.isNameFirst) {
                    pushCommentRange(pos, tag.name.pos - pos);
                    pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* ClassificationType.parameterName */);
                    pos = tag.name.end;
                }
            }
        }
        function tryClassifyTripleSlashComment(start, width) {
            var tripleSlashXMLCommentRegEx = /^(\/\/\/\s*)(<)(?:(\S+)((?:[^/]|\/[^>])*)(\/>)?)?/im;
            // Require a leading whitespace character (the parser already does) to prevent terrible backtracking performance
            var attributeRegex = /(\s)(\S+)(\s*)(=)(\s*)('[^']+'|"[^"]+")/img;
            var text = sourceFile.text.substr(start, width);
            var match = tripleSlashXMLCommentRegEx.exec(text);
            if (!match) {
                return false;
            }
            // Limiting classification to exactly the elements and attributes
            // defined in `ts.commentPragmas` would be excessive, but we can avoid
            // some obvious false positives (e.g. in XML-like doc comments) by
            // checking the element name.
            // eslint-disable-next-line no-in-operator
            if (!match[3] || !(match[3] in ts.commentPragmas)) {
                return false;
            }
            var pos = start;
            pushCommentRange(pos, match[1].length); // ///
            pos += match[1].length;
            pushClassification(pos, match[2].length, 10 /* ClassificationType.punctuation */); // <
            pos += match[2].length;
            pushClassification(pos, match[3].length, 21 /* ClassificationType.jsxSelfClosingTagName */); // element name
            pos += match[3].length;
            var attrText = match[4];
            var attrPos = pos;
            while (true) {
                var attrMatch = attributeRegex.exec(attrText);
                if (!attrMatch) {
                    break;
                }
                var newAttrPos = pos + attrMatch.index + attrMatch[1].length; // whitespace
                if (newAttrPos > attrPos) {
                    pushCommentRange(attrPos, newAttrPos - attrPos);
                    attrPos = newAttrPos;
                }
                pushClassification(attrPos, attrMatch[2].length, 22 /* ClassificationType.jsxAttribute */); // attribute name
                attrPos += attrMatch[2].length;
                if (attrMatch[3].length) {
                    pushCommentRange(attrPos, attrMatch[3].length); // whitespace
                    attrPos += attrMatch[3].length;
                }
                pushClassification(attrPos, attrMatch[4].length, 5 /* ClassificationType.operator */); // =
                attrPos += attrMatch[4].length;
                if (attrMatch[5].length) {
                    pushCommentRange(attrPos, attrMatch[5].length); // whitespace
                    attrPos += attrMatch[5].length;
                }
                pushClassification(attrPos, attrMatch[6].length, 24 /* ClassificationType.jsxAttributeStringLiteralValue */); // attribute value
                attrPos += attrMatch[6].length;
            }
            pos += match[4].length;
            if (pos > attrPos) {
                pushCommentRange(attrPos, pos - attrPos);
            }
            if (match[5]) {
                pushClassification(pos, match[5].length, 10 /* ClassificationType.punctuation */); // />
                pos += match[5].length;
            }
            var end = start + width;
            if (pos < end) {
                pushCommentRange(pos, end - pos);
            }
            return true;
        }
        function processJSDocTemplateTag(tag) {
            for (var _i = 0, _a = tag.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                processElement(child);
            }
        }
        function classifyDisabledMergeCode(text, start, end) {
            // Classify the line that the ||||||| or ======= marker is on as a comment.
            // Then just lex all further tokens and add them to the result.
            var i;
            for (i = start; i < end; i++) {
                if (ts.isLineBreak(text.charCodeAt(i))) {
                    break;
                }
            }
            pushClassification(start, i - start, 1 /* ClassificationType.comment */);
            mergeConflictScanner.setTextPos(i);
            while (mergeConflictScanner.getTextPos() < end) {
                classifyDisabledCodeToken();
            }
        }
        function classifyDisabledCodeToken() {
            var start = mergeConflictScanner.getTextPos();
            var tokenKind = mergeConflictScanner.scan();
            var end = mergeConflictScanner.getTextPos();
            var type = classifyTokenType(tokenKind);
            if (type) {
                pushClassification(start, end - start, type);
            }
        }
        /**
         * Returns true if node should be treated as classified and no further processing is required.
         * False will mean that node is not classified and traverse routine should recurse into node contents.
         */
        function tryClassifyNode(node) {
            if (ts.isJSDoc(node)) {
                return true;
            }
            if (ts.nodeIsMissing(node)) {
                return true;
            }
            var classifiedElementName = tryClassifyJsxElementName(node);
            if (!ts.isToken(node) && node.kind !== 11 /* SyntaxKind.JsxText */ && classifiedElementName === undefined) {
                return false;
            }
            var tokenStart = node.kind === 11 /* SyntaxKind.JsxText */ ? node.pos : classifyLeadingTriviaAndGetTokenStart(node);
            var tokenWidth = node.end - tokenStart;
            ts.Debug.assert(tokenWidth >= 0);
            if (tokenWidth > 0) {
                var type = classifiedElementName || classifyTokenType(node.kind, node);
                if (type) {
                    pushClassification(tokenStart, tokenWidth, type);
                }
            }
            return true;
        }
        function tryClassifyJsxElementName(token) {
            switch (token.parent && token.parent.kind) {
                case 280 /* SyntaxKind.JsxOpeningElement */:
                    if (token.parent.tagName === token) {
                        return 19 /* ClassificationType.jsxOpenTagName */;
                    }
                    break;
                case 281 /* SyntaxKind.JsxClosingElement */:
                    if (token.parent.tagName === token) {
                        return 20 /* ClassificationType.jsxCloseTagName */;
                    }
                    break;
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    if (token.parent.tagName === token) {
                        return 21 /* ClassificationType.jsxSelfClosingTagName */;
                    }
                    break;
                case 285 /* SyntaxKind.JsxAttribute */:
                    if (token.parent.name === token) {
                        return 22 /* ClassificationType.jsxAttribute */;
                    }
                    break;
            }
            return undefined;
        }
        // for accurate classification, the actual token should be passed in.  however, for
        // cases like 'disabled merge code' classification, we just get the token kind and
        // classify based on that instead.
        function classifyTokenType(tokenKind, token) {
            if (ts.isKeyword(tokenKind)) {
                return 3 /* ClassificationType.keyword */;
            }
            // Special case `<` and `>`: If they appear in a generic context they are punctuation,
            // not operators.
            if (tokenKind === 29 /* SyntaxKind.LessThanToken */ || tokenKind === 31 /* SyntaxKind.GreaterThanToken */) {
                // If the node owning the token has a type argument list or type parameter list, then
                // we can effectively assume that a '<' and '>' belong to those lists.
                if (token && ts.getTypeArgumentOrTypeParameterList(token.parent)) {
                    return 10 /* ClassificationType.punctuation */;
                }
            }
            if (ts.isPunctuation(tokenKind)) {
                if (token) {
                    var parent = token.parent;
                    if (tokenKind === 63 /* SyntaxKind.EqualsToken */) {
                        // the '=' in a variable declaration is special cased here.
                        if (parent.kind === 254 /* SyntaxKind.VariableDeclaration */ ||
                            parent.kind === 167 /* SyntaxKind.PropertyDeclaration */ ||
                            parent.kind === 164 /* SyntaxKind.Parameter */ ||
                            parent.kind === 285 /* SyntaxKind.JsxAttribute */) {
                            return 5 /* ClassificationType.operator */;
                        }
                    }
                    if (parent.kind === 221 /* SyntaxKind.BinaryExpression */ ||
                        parent.kind === 219 /* SyntaxKind.PrefixUnaryExpression */ ||
                        parent.kind === 220 /* SyntaxKind.PostfixUnaryExpression */ ||
                        parent.kind === 222 /* SyntaxKind.ConditionalExpression */) {
                        return 5 /* ClassificationType.operator */;
                    }
                }
                return 10 /* ClassificationType.punctuation */;
            }
            else if (tokenKind === 8 /* SyntaxKind.NumericLiteral */) {
                return 4 /* ClassificationType.numericLiteral */;
            }
            else if (tokenKind === 9 /* SyntaxKind.BigIntLiteral */) {
                return 25 /* ClassificationType.bigintLiteral */;
            }
            else if (tokenKind === 10 /* SyntaxKind.StringLiteral */) {
                return token && token.parent.kind === 285 /* SyntaxKind.JsxAttribute */ ? 24 /* ClassificationType.jsxAttributeStringLiteralValue */ : 6 /* ClassificationType.stringLiteral */;
            }
            else if (tokenKind === 13 /* SyntaxKind.RegularExpressionLiteral */) {
                // TODO: we should get another classification type for these literals.
                return 6 /* ClassificationType.stringLiteral */;
            }
            else if (ts.isTemplateLiteralKind(tokenKind)) {
                // TODO (drosen): we should *also* get another classification type for these literals.
                return 6 /* ClassificationType.stringLiteral */;
            }
            else if (tokenKind === 11 /* SyntaxKind.JsxText */) {
                return 23 /* ClassificationType.jsxText */;
            }
            else if (tokenKind === 79 /* SyntaxKind.Identifier */) {
                if (token) {
                    switch (token.parent.kind) {
                        case 257 /* SyntaxKind.ClassDeclaration */:
                            if (token.parent.name === token) {
                                return 11 /* ClassificationType.className */;
                            }
                            return;
                        case 163 /* SyntaxKind.TypeParameter */:
                            if (token.parent.name === token) {
                                return 15 /* ClassificationType.typeParameterName */;
                            }
                            return;
                        case 258 /* SyntaxKind.InterfaceDeclaration */:
                            if (token.parent.name === token) {
                                return 13 /* ClassificationType.interfaceName */;
                            }
                            return;
                        case 260 /* SyntaxKind.EnumDeclaration */:
                            if (token.parent.name === token) {
                                return 12 /* ClassificationType.enumName */;
                            }
                            return;
                        case 261 /* SyntaxKind.ModuleDeclaration */:
                            if (token.parent.name === token) {
                                return 14 /* ClassificationType.moduleName */;
                            }
                            return;
                        case 164 /* SyntaxKind.Parameter */:
                            if (token.parent.name === token) {
                                return ts.isThisIdentifier(token) ? 3 /* ClassificationType.keyword */ : 17 /* ClassificationType.parameterName */;
                            }
                            return;
                    }
                    if (ts.isConstTypeReference(token.parent)) {
                        return 3 /* ClassificationType.keyword */;
                    }
                }
                return 2 /* ClassificationType.identifier */;
            }
        }
        function processElement(element) {
            if (!element) {
                return;
            }
            // Ignore nodes that don't intersect the original span to classify.
            if (ts.decodedTextSpanIntersectsWith(spanStart, spanLength, element.pos, element.getFullWidth())) {
                checkForClassificationCancellation(cancellationToken, element.kind);
                for (var _i = 0, _a = element.getChildren(sourceFile); _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (!tryClassifyNode(child)) {
                        // Recurse into our child nodes.
                        processElement(child);
                    }
                }
            }
        }
    }
    ts.getEncodedSyntacticClassifications = getEncodedSyntacticClassifications;
})(ts || (ts = {}));
/** @internal */
var ts;
(function (ts) {
    var classifier;
    (function (classifier) {
        var v2020;
        (function (v2020) {
            var TokenEncodingConsts;
            (function (TokenEncodingConsts) {
                TokenEncodingConsts[TokenEncodingConsts["typeOffset"] = 8] = "typeOffset";
                TokenEncodingConsts[TokenEncodingConsts["modifierMask"] = 255] = "modifierMask";
            })(TokenEncodingConsts = v2020.TokenEncodingConsts || (v2020.TokenEncodingConsts = {}));
            var TokenType;
            (function (TokenType) {
                TokenType[TokenType["class"] = 0] = "class";
                TokenType[TokenType["enum"] = 1] = "enum";
                TokenType[TokenType["interface"] = 2] = "interface";
                TokenType[TokenType["namespace"] = 3] = "namespace";
                TokenType[TokenType["typeParameter"] = 4] = "typeParameter";
                TokenType[TokenType["type"] = 5] = "type";
                TokenType[TokenType["parameter"] = 6] = "parameter";
                TokenType[TokenType["variable"] = 7] = "variable";
                TokenType[TokenType["enumMember"] = 8] = "enumMember";
                TokenType[TokenType["property"] = 9] = "property";
                TokenType[TokenType["function"] = 10] = "function";
                TokenType[TokenType["member"] = 11] = "member";
            })(TokenType = v2020.TokenType || (v2020.TokenType = {}));
            var TokenModifier;
            (function (TokenModifier) {
                TokenModifier[TokenModifier["declaration"] = 0] = "declaration";
                TokenModifier[TokenModifier["static"] = 1] = "static";
                TokenModifier[TokenModifier["async"] = 2] = "async";
                TokenModifier[TokenModifier["readonly"] = 3] = "readonly";
                TokenModifier[TokenModifier["defaultLibrary"] = 4] = "defaultLibrary";
                TokenModifier[TokenModifier["local"] = 5] = "local";
            })(TokenModifier = v2020.TokenModifier || (v2020.TokenModifier = {}));
            /** This is mainly used internally for testing */
            function getSemanticClassifications(program, cancellationToken, sourceFile, span) {
                var classifications = getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span);
                ts.Debug.assert(classifications.spans.length % 3 === 0);
                var dense = classifications.spans;
                var result = [];
                for (var i = 0; i < dense.length; i += 3) {
                    result.push({
                        textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
                        classificationType: dense[i + 2]
                    });
                }
                return result;
            }
            v2020.getSemanticClassifications = getSemanticClassifications;
            function getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span) {
                return {
                    spans: getSemanticTokens(program, sourceFile, span, cancellationToken),
                    endOfLineState: 0 /* EndOfLineState.None */
                };
            }
            v2020.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
            function getSemanticTokens(program, sourceFile, span, cancellationToken) {
                var resultTokens = [];
                var collector = function (node, typeIdx, modifierSet) {
                    resultTokens.push(node.getStart(sourceFile), node.getWidth(sourceFile), ((typeIdx + 1) << 8 /* TokenEncodingConsts.typeOffset */) + modifierSet);
                };
                if (program && sourceFile) {
                    collectTokens(program, sourceFile, span, collector, cancellationToken);
                }
                return resultTokens;
            }
            function collectTokens(program, sourceFile, span, collector, cancellationToken) {
                var typeChecker = program.getTypeChecker();
                var inJSXElement = false;
                function visit(node) {
                    switch (node.kind) {
                        case 261 /* SyntaxKind.ModuleDeclaration */:
                        case 257 /* SyntaxKind.ClassDeclaration */:
                        case 258 /* SyntaxKind.InterfaceDeclaration */:
                        case 256 /* SyntaxKind.FunctionDeclaration */:
                        case 226 /* SyntaxKind.ClassExpression */:
                        case 213 /* SyntaxKind.FunctionExpression */:
                        case 214 /* SyntaxKind.ArrowFunction */:
                            cancellationToken.throwIfCancellationRequested();
                    }
                    if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth()) || node.getFullWidth() === 0) {
                        return;
                    }
                    var prevInJSXElement = inJSXElement;
                    if (ts.isJsxElement(node) || ts.isJsxSelfClosingElement(node)) {
                        inJSXElement = true;
                    }
                    if (ts.isJsxExpression(node)) {
                        inJSXElement = false;
                    }
                    if (ts.isIdentifier(node) && !inJSXElement && !inImportClause(node) && !ts.isInfinityOrNaNString(node.escapedText)) {
                        var symbol = typeChecker.getSymbolAtLocation(node);
                        if (symbol) {
                            if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                                symbol = typeChecker.getAliasedSymbol(symbol);
                            }
                            var typeIdx = classifySymbol(symbol, ts.getMeaningFromLocation(node));
                            if (typeIdx !== undefined) {
                                var modifierSet = 0;
                                if (node.parent) {
                                    var parentIsDeclaration = (ts.isBindingElement(node.parent) || tokenFromDeclarationMapping.get(node.parent.kind) === typeIdx);
                                    if (parentIsDeclaration && node.parent.name === node) {
                                        modifierSet = 1 << 0 /* TokenModifier.declaration */;
                                    }
                                }
                                // property declaration in constructor
                                if (typeIdx === 6 /* TokenType.parameter */ && isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                                    typeIdx = 9 /* TokenType.property */;
                                }
                                typeIdx = reclassifyByType(typeChecker, node, typeIdx);
                                var decl = symbol.valueDeclaration;
                                if (decl) {
                                    var modifiers = ts.getCombinedModifierFlags(decl);
                                    var nodeFlags = ts.getCombinedNodeFlags(decl);
                                    if (modifiers & 32 /* ModifierFlags.Static */) {
                                        modifierSet |= 1 << 1 /* TokenModifier.static */;
                                    }
                                    if (modifiers & 256 /* ModifierFlags.Async */) {
                                        modifierSet |= 1 << 2 /* TokenModifier.async */;
                                    }
                                    if (typeIdx !== 0 /* TokenType.class */ && typeIdx !== 2 /* TokenType.interface */) {
                                        if ((modifiers & 64 /* ModifierFlags.Readonly */) || (nodeFlags & 2 /* NodeFlags.Const */) || (symbol.getFlags() & 8 /* SymbolFlags.EnumMember */)) {
                                            modifierSet |= 1 << 3 /* TokenModifier.readonly */;
                                        }
                                    }
                                    if ((typeIdx === 7 /* TokenType.variable */ || typeIdx === 10 /* TokenType.function */) && isLocalDeclaration(decl, sourceFile)) {
                                        modifierSet |= 1 << 5 /* TokenModifier.local */;
                                    }
                                    if (program.isSourceFileDefaultLibrary(decl.getSourceFile())) {
                                        modifierSet |= 1 << 4 /* TokenModifier.defaultLibrary */;
                                    }
                                }
                                else if (symbol.declarations && symbol.declarations.some(function (d) { return program.isSourceFileDefaultLibrary(d.getSourceFile()); })) {
                                    modifierSet |= 1 << 4 /* TokenModifier.defaultLibrary */;
                                }
                                collector(node, typeIdx, modifierSet);
                            }
                        }
                    }
                    ts.forEachChild(node, visit);
                    inJSXElement = prevInJSXElement;
                }
                visit(sourceFile);
            }
            function classifySymbol(symbol, meaning) {
                var flags = symbol.getFlags();
                if (flags & 32 /* SymbolFlags.Class */) {
                    return 0 /* TokenType.class */;
                }
                else if (flags & 384 /* SymbolFlags.Enum */) {
                    return 1 /* TokenType.enum */;
                }
                else if (flags & 524288 /* SymbolFlags.TypeAlias */) {
                    return 5 /* TokenType.type */;
                }
                else if (flags & 64 /* SymbolFlags.Interface */) {
                    if (meaning & 2 /* SemanticMeaning.Type */) {
                        return 2 /* TokenType.interface */;
                    }
                }
                else if (flags & 262144 /* SymbolFlags.TypeParameter */) {
                    return 4 /* TokenType.typeParameter */;
                }
                var decl = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];
                if (decl && ts.isBindingElement(decl)) {
                    decl = getDeclarationForBindingElement(decl);
                }
                return decl && tokenFromDeclarationMapping.get(decl.kind);
            }
            function reclassifyByType(typeChecker, node, typeIdx) {
                // type based classifications
                if (typeIdx === 7 /* TokenType.variable */ || typeIdx === 9 /* TokenType.property */ || typeIdx === 6 /* TokenType.parameter */) {
                    var type_1 = typeChecker.getTypeAtLocation(node);
                    if (type_1) {
                        var test = function (condition) {
                            return condition(type_1) || type_1.isUnion() && type_1.types.some(condition);
                        };
                        if (typeIdx !== 6 /* TokenType.parameter */ && test(function (t) { return t.getConstructSignatures().length > 0; })) {
                            return 0 /* TokenType.class */;
                        }
                        if (test(function (t) { return t.getCallSignatures().length > 0; }) && !test(function (t) { return t.getProperties().length > 0; }) || isExpressionInCallExpression(node)) {
                            return typeIdx === 9 /* TokenType.property */ ? 11 /* TokenType.member */ : 10 /* TokenType.function */;
                        }
                    }
                }
                return typeIdx;
            }
            function isLocalDeclaration(decl, sourceFile) {
                if (ts.isBindingElement(decl)) {
                    decl = getDeclarationForBindingElement(decl);
                }
                if (ts.isVariableDeclaration(decl)) {
                    return (!ts.isSourceFile(decl.parent.parent.parent) || ts.isCatchClause(decl.parent)) && decl.getSourceFile() === sourceFile;
                }
                else if (ts.isFunctionDeclaration(decl)) {
                    return !ts.isSourceFile(decl.parent) && decl.getSourceFile() === sourceFile;
                }
                return false;
            }
            function getDeclarationForBindingElement(element) {
                while (true) {
                    if (ts.isBindingElement(element.parent.parent)) {
                        element = element.parent.parent;
                    }
                    else {
                        return element.parent.parent;
                    }
                }
            }
            function inImportClause(node) {
                var parent = node.parent;
                return parent && (ts.isImportClause(parent) || ts.isImportSpecifier(parent) || ts.isNamespaceImport(parent));
            }
            function isExpressionInCallExpression(node) {
                while (isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                    node = node.parent;
                }
                return ts.isCallExpression(node.parent) && node.parent.expression === node;
            }
            function isRightSideOfQualifiedNameOrPropertyAccess(node) {
                return (ts.isQualifiedName(node.parent) && node.parent.right === node) || (ts.isPropertyAccessExpression(node.parent) && node.parent.name === node);
            }
            var tokenFromDeclarationMapping = new ts.Map([
                [254 /* SyntaxKind.VariableDeclaration */, 7 /* TokenType.variable */],
                [164 /* SyntaxKind.Parameter */, 6 /* TokenType.parameter */],
                [167 /* SyntaxKind.PropertyDeclaration */, 9 /* TokenType.property */],
                [261 /* SyntaxKind.ModuleDeclaration */, 3 /* TokenType.namespace */],
                [260 /* SyntaxKind.EnumDeclaration */, 1 /* TokenType.enum */],
                [299 /* SyntaxKind.EnumMember */, 8 /* TokenType.enumMember */],
                [257 /* SyntaxKind.ClassDeclaration */, 0 /* TokenType.class */],
                [169 /* SyntaxKind.MethodDeclaration */, 11 /* TokenType.member */],
                [256 /* SyntaxKind.FunctionDeclaration */, 10 /* TokenType.function */],
                [213 /* SyntaxKind.FunctionExpression */, 10 /* TokenType.function */],
                [168 /* SyntaxKind.MethodSignature */, 11 /* TokenType.member */],
                [172 /* SyntaxKind.GetAccessor */, 9 /* TokenType.property */],
                [173 /* SyntaxKind.SetAccessor */, 9 /* TokenType.property */],
                [166 /* SyntaxKind.PropertySignature */, 9 /* TokenType.property */],
                [258 /* SyntaxKind.InterfaceDeclaration */, 2 /* TokenType.interface */],
                [259 /* SyntaxKind.TypeAliasDeclaration */, 5 /* TokenType.type */],
                [163 /* SyntaxKind.TypeParameter */, 4 /* TokenType.typeParameter */],
                [296 /* SyntaxKind.PropertyAssignment */, 9 /* TokenType.property */],
                [297 /* SyntaxKind.ShorthandPropertyAssignment */, 9 /* TokenType.property */]
            ]);
        })(v2020 = classifier.v2020 || (classifier.v2020 = {}));
    })(classifier = ts.classifier || (ts.classifier = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var Completions;
    (function (Completions) {
        var StringCompletions;
        (function (StringCompletions) {
            function getStringLiteralCompletions(sourceFile, position, contextToken, options, host, program, log, preferences) {
                if (ts.isInReferenceComment(sourceFile, position)) {
                    var entries = getTripleSlashReferenceCompletion(sourceFile, position, options, host);
                    return entries && convertPathCompletions(entries);
                }
                if (ts.isInString(sourceFile, position, contextToken)) {
                    if (!contextToken || !ts.isStringLiteralLike(contextToken))
                        return undefined;
                    var entries = getStringLiteralCompletionEntries(sourceFile, contextToken, position, program.getTypeChecker(), options, host, preferences);
                    return convertStringLiteralCompletions(entries, contextToken, sourceFile, host, program, log, options, preferences);
                }
            }
            StringCompletions.getStringLiteralCompletions = getStringLiteralCompletions;
            function convertStringLiteralCompletions(completion, contextToken, sourceFile, host, program, log, options, preferences) {
                if (completion === undefined) {
                    return undefined;
                }
                var optionalReplacementSpan = ts.createTextSpanFromStringLiteralLikeContent(contextToken);
                switch (completion.kind) {
                    case 0 /* StringLiteralCompletionKind.Paths */:
                        return convertPathCompletions(completion.paths);
                    case 1 /* StringLiteralCompletionKind.Properties */: {
                        var entries = ts.createSortedArray();
                        Completions.getCompletionEntriesFromSymbols(completion.symbols, entries, contextToken, contextToken, sourceFile, sourceFile, host, program, 99 /* ScriptTarget.ESNext */, log, 4 /* CompletionKind.String */, preferences, options, 
                        /*formatContext*/ undefined); // Target will not be used, so arbitrary
                        return { isGlobalCompletion: false, isMemberCompletion: true, isNewIdentifierLocation: completion.hasIndexSignature, optionalReplacementSpan: optionalReplacementSpan, entries: entries };
                    }
                    case 2 /* StringLiteralCompletionKind.Types */: {
                        var entries = completion.types.map(function (type) { return ({
                            name: type.value,
                            kindModifiers: "" /* ScriptElementKindModifier.none */,
                            kind: "string" /* ScriptElementKind.string */,
                            sortText: Completions.SortText.LocationPriority,
                            replacementSpan: ts.getReplacementSpanForContextToken(contextToken)
                        }); });
                        return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: completion.isNewIdentifier, optionalReplacementSpan: optionalReplacementSpan, entries: entries };
                    }
                    default:
                        return ts.Debug.assertNever(completion);
                }
            }
            function getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, checker, options, host, cancellationToken, preferences) {
                if (!contextToken || !ts.isStringLiteralLike(contextToken))
                    return undefined;
                var completions = getStringLiteralCompletionEntries(sourceFile, contextToken, position, checker, options, host, preferences);
                return completions && stringLiteralCompletionDetails(name, contextToken, completions, sourceFile, checker, cancellationToken);
            }
            StringCompletions.getStringLiteralCompletionDetails = getStringLiteralCompletionDetails;
            function stringLiteralCompletionDetails(name, location, completion, sourceFile, checker, cancellationToken) {
                switch (completion.kind) {
                    case 0 /* StringLiteralCompletionKind.Paths */: {
                        var match = ts.find(completion.paths, function (p) { return p.name === name; });
                        return match && Completions.createCompletionDetails(name, kindModifiersFromExtension(match.extension), match.kind, [ts.textPart(name)]);
                    }
                    case 1 /* StringLiteralCompletionKind.Properties */: {
                        var match = ts.find(completion.symbols, function (s) { return s.name === name; });
                        return match && Completions.createCompletionDetailsForSymbol(match, checker, sourceFile, location, cancellationToken);
                    }
                    case 2 /* StringLiteralCompletionKind.Types */:
                        return ts.find(completion.types, function (t) { return t.value === name; }) ? Completions.createCompletionDetails(name, "" /* ScriptElementKindModifier.none */, "type" /* ScriptElementKind.typeElement */, [ts.textPart(name)]) : undefined;
                    default:
                        return ts.Debug.assertNever(completion);
                }
            }
            function convertPathCompletions(pathCompletions) {
                var isGlobalCompletion = false; // We don't want the editor to offer any other completions, such as snippets, inside a comment.
                var isNewIdentifierLocation = true; // The user may type in a path that doesn't yet exist, creating a "new identifier" with respect to the collection of identifiers the server is aware of.
                var entries = pathCompletions.map(function (_a) {
                    var name = _a.name, kind = _a.kind, span = _a.span, extension = _a.extension;
                    return ({ name: name, kind: kind, kindModifiers: kindModifiersFromExtension(extension), sortText: Completions.SortText.LocationPriority, replacementSpan: span });
                });
                return { isGlobalCompletion: isGlobalCompletion, isMemberCompletion: false, isNewIdentifierLocation: isNewIdentifierLocation, entries: entries };
            }
            function kindModifiersFromExtension(extension) {
                switch (extension) {
                    case ".d.ts" /* Extension.Dts */: return ".d.ts" /* ScriptElementKindModifier.dtsModifier */;
                    case ".js" /* Extension.Js */: return ".js" /* ScriptElementKindModifier.jsModifier */;
                    case ".json" /* Extension.Json */: return ".json" /* ScriptElementKindModifier.jsonModifier */;
                    case ".jsx" /* Extension.Jsx */: return ".jsx" /* ScriptElementKindModifier.jsxModifier */;
                    case ".ts" /* Extension.Ts */: return ".ts" /* ScriptElementKindModifier.tsModifier */;
                    case ".tsx" /* Extension.Tsx */: return ".tsx" /* ScriptElementKindModifier.tsxModifier */;
                    case ".d.mts" /* Extension.Dmts */: return ".d.mts" /* ScriptElementKindModifier.dmtsModifier */;
                    case ".mjs" /* Extension.Mjs */: return ".mjs" /* ScriptElementKindModifier.mjsModifier */;
                    case ".mts" /* Extension.Mts */: return ".mts" /* ScriptElementKindModifier.mtsModifier */;
                    case ".d.cts" /* Extension.Dcts */: return ".d.cts" /* ScriptElementKindModifier.dctsModifier */;
                    case ".cjs" /* Extension.Cjs */: return ".cjs" /* ScriptElementKindModifier.cjsModifier */;
                    case ".cts" /* Extension.Cts */: return ".cts" /* ScriptElementKindModifier.ctsModifier */;
                    case ".tsbuildinfo" /* Extension.TsBuildInfo */: return ts.Debug.fail("Extension ".concat(".tsbuildinfo" /* Extension.TsBuildInfo */, " is unsupported."));
                    case undefined: return "" /* ScriptElementKindModifier.none */;
                    default:
                        return ts.Debug.assertNever(extension);
                }
            }
            var StringLiteralCompletionKind;
            (function (StringLiteralCompletionKind) {
                StringLiteralCompletionKind[StringLiteralCompletionKind["Paths"] = 0] = "Paths";
                StringLiteralCompletionKind[StringLiteralCompletionKind["Properties"] = 1] = "Properties";
                StringLiteralCompletionKind[StringLiteralCompletionKind["Types"] = 2] = "Types";
            })(StringLiteralCompletionKind || (StringLiteralCompletionKind = {}));
            function getStringLiteralCompletionEntries(sourceFile, node, position, typeChecker, compilerOptions, host, preferences) {
                var parent = walkUpParentheses(node.parent);
                switch (parent.kind) {
                    case 196 /* SyntaxKind.LiteralType */: {
                        var grandParent = walkUpParentheses(parent.parent);
                        switch (grandParent.kind) {
                            case 178 /* SyntaxKind.TypeReference */: {
                                var typeReference_1 = grandParent;
                                var typeArgument = ts.findAncestor(parent, function (n) { return n.parent === typeReference_1; });
                                if (typeArgument) {
                                    return { kind: 2 /* StringLiteralCompletionKind.Types */, types: getStringLiteralTypes(typeChecker.getTypeArgumentConstraint(typeArgument)), isNewIdentifier: false };
                                }
                                return undefined;
                            }
                            case 194 /* SyntaxKind.IndexedAccessType */:
                                // Get all apparent property names
                                // i.e. interface Foo {
                                //          foo: string;
                                //          bar: string;
                                //      }
                                //      let x: Foo["/*completion position*/"]
                                var _a = grandParent, indexType = _a.indexType, objectType = _a.objectType;
                                if (!ts.rangeContainsPosition(indexType, position)) {
                                    return undefined;
                                }
                                return stringLiteralCompletionsFromProperties(typeChecker.getTypeFromTypeNode(objectType));
                            case 200 /* SyntaxKind.ImportType */:
                                return { kind: 0 /* StringLiteralCompletionKind.Paths */, paths: getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) };
                            case 187 /* SyntaxKind.UnionType */: {
                                if (!ts.isTypeReferenceNode(grandParent.parent)) {
                                    return undefined;
                                }
                                var alreadyUsedTypes_1 = getAlreadyUsedTypesInStringLiteralUnion(grandParent, parent);
                                var types = getStringLiteralTypes(typeChecker.getTypeArgumentConstraint(grandParent)).filter(function (t) { return !ts.contains(alreadyUsedTypes_1, t.value); });
                                return { kind: 2 /* StringLiteralCompletionKind.Types */, types: types, isNewIdentifier: false };
                            }
                            default:
                                return undefined;
                        }
                    }
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
                            // Get quoted name of properties of the object literal expression
                            // i.e. interface ConfigFiles {
                            //          'jspm:dev': string
                            //      }
                            //      let files: ConfigFiles = {
                            //          '/*completion position*/'
                            //      }
                            //
                            //      function foo(c: ConfigFiles) {}
                            //      foo({
                            //          '/*completion position*/'
                            //      });
                            return stringLiteralCompletionsForObjectLiteral(typeChecker, parent.parent);
                        }
                        return fromContextualType();
                    case 207 /* SyntaxKind.ElementAccessExpression */: {
                        var _b = parent, expression = _b.expression, argumentExpression = _b.argumentExpression;
                        if (node === ts.skipParentheses(argumentExpression)) {
                            // Get all names of properties on the expression
                            // i.e. interface A {
                            //      'prop1': string
                            // }
                            // let a: A;
                            // a['/*completion position*/']
                            return stringLiteralCompletionsFromProperties(typeChecker.getTypeAtLocation(expression));
                        }
                        return undefined;
                    }
                    case 208 /* SyntaxKind.CallExpression */:
                    case 209 /* SyntaxKind.NewExpression */:
                    case 285 /* SyntaxKind.JsxAttribute */:
                        if (!isRequireCallArgument(node) && !ts.isImportCall(parent)) {
                            var argumentInfo = ts.SignatureHelp.getArgumentInfoForCompletions(parent.kind === 285 /* SyntaxKind.JsxAttribute */ ? parent.parent : node, position, sourceFile);
                            // Get string literal completions from specialized signatures of the target
                            // i.e. declare function f(a: 'A');
                            // f("/*completion position*/")
                            return argumentInfo ? getStringLiteralCompletionsFromSignature(argumentInfo.invocation, node, argumentInfo, typeChecker) : fromContextualType();
                        }
                    // falls through (is `require("")` or `require(""` or `import("")`)
                    case 266 /* SyntaxKind.ImportDeclaration */:
                    case 272 /* SyntaxKind.ExportDeclaration */:
                    case 277 /* SyntaxKind.ExternalModuleReference */:
                        // Get all known external module names or complete a path to a module
                        // i.e. import * as ns from "/*completion position*/";
                        //      var y = import("/*completion position*/");
                        //      import x = require("/*completion position*/");
                        //      var y = require("/*completion position*/");
                        //      export * from "/*completion position*/";
                        return { kind: 0 /* StringLiteralCompletionKind.Paths */, paths: getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) };
                    default:
                        return fromContextualType();
                }
                function fromContextualType() {
                    // Get completion for string literal from string literal type
                    // i.e. var x: "hi" | "hello" = "/*completion position*/"
                    return { kind: 2 /* StringLiteralCompletionKind.Types */, types: getStringLiteralTypes(ts.getContextualTypeFromParent(node, typeChecker)), isNewIdentifier: false };
                }
            }
            function walkUpParentheses(node) {
                switch (node.kind) {
                    case 191 /* SyntaxKind.ParenthesizedType */:
                        return ts.walkUpParenthesizedTypes(node);
                    case 212 /* SyntaxKind.ParenthesizedExpression */:
                        return ts.walkUpParenthesizedExpressions(node);
                    default:
                        return node;
                }
            }
            function getAlreadyUsedTypesInStringLiteralUnion(union, current) {
                return ts.mapDefined(union.types, function (type) {
                    return type !== current && ts.isLiteralTypeNode(type) && ts.isStringLiteral(type.literal) ? type.literal.text : undefined;
                });
            }
            function getStringLiteralCompletionsFromSignature(call, arg, argumentInfo, checker) {
                var isNewIdentifier = false;
                var uniques = new ts.Map();
                var candidates = [];
                var editingArgument = ts.isJsxOpeningLikeElement(call) ? ts.Debug.checkDefined(ts.findAncestor(arg.parent, ts.isJsxAttribute)) : arg;
                checker.getResolvedSignatureForStringLiteralCompletions(call, editingArgument, candidates);
                var types = ts.flatMap(candidates, function (candidate) {
                    if (!ts.signatureHasRestParameter(candidate) && argumentInfo.argumentCount > candidate.parameters.length)
                        return;
                    var type = candidate.getTypeParameterAtPosition(argumentInfo.argumentIndex);
                    if (ts.isJsxOpeningLikeElement(call)) {
                        var propType = checker.getTypeOfPropertyOfType(type, editingArgument.name.text);
                        if (propType) {
                            type = propType;
                        }
                    }
                    isNewIdentifier = isNewIdentifier || !!(type.flags & 4 /* TypeFlags.String */);
                    return getStringLiteralTypes(type, uniques);
                });
                return { kind: 2 /* StringLiteralCompletionKind.Types */, types: types, isNewIdentifier: isNewIdentifier };
            }
            function stringLiteralCompletionsFromProperties(type) {
                return type && {
                    kind: 1 /* StringLiteralCompletionKind.Properties */,
                    symbols: ts.filter(type.getApparentProperties(), function (prop) { return !(prop.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(prop.valueDeclaration)); }),
                    hasIndexSignature: ts.hasIndexSignature(type)
                };
            }
            function stringLiteralCompletionsForObjectLiteral(checker, objectLiteralExpression) {
                var contextualType = checker.getContextualType(objectLiteralExpression);
                if (!contextualType)
                    return undefined;
                var completionsType = checker.getContextualType(objectLiteralExpression, 4 /* ContextFlags.Completions */);
                var symbols = Completions.getPropertiesForObjectExpression(contextualType, completionsType, objectLiteralExpression, checker);
                return {
                    kind: 1 /* StringLiteralCompletionKind.Properties */,
                    symbols: symbols,
                    hasIndexSignature: ts.hasIndexSignature(contextualType)
                };
            }
            function getStringLiteralTypes(type, uniques) {
                if (uniques === void 0) { uniques = new ts.Map(); }
                if (!type)
                    return ts.emptyArray;
                type = ts.skipConstraint(type);
                return type.isUnion() ? ts.flatMap(type.types, function (t) { return getStringLiteralTypes(t, uniques); }) :
                    type.isStringLiteral() && !(type.flags & 1024 /* TypeFlags.EnumLiteral */) && ts.addToSeen(uniques, type.value) ? [type] : ts.emptyArray;
            }
            function nameAndKind(name, kind, extension) {
                return { name: name, kind: kind, extension: extension };
            }
            function directoryResult(name) {
                return nameAndKind(name, "directory" /* ScriptElementKind.directory */, /*extension*/ undefined);
            }
            function addReplacementSpans(text, textStart, names) {
                var span = getDirectoryFragmentTextSpan(text, textStart);
                var wholeSpan = text.length === 0 ? undefined : ts.createTextSpan(textStart, text.length);
                return names.map(function (_a) {
                    var name = _a.name, kind = _a.kind, extension = _a.extension;
                    return Math.max(name.indexOf(ts.directorySeparator), name.indexOf(ts.altDirectorySeparator)) !== -1 ? { name: name, kind: kind, extension: extension, span: wholeSpan } : { name: name, kind: kind, extension: extension, span: span };
                });
            }
            function getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) {
                return addReplacementSpans(node.text, node.getStart(sourceFile) + 1, getStringLiteralCompletionsFromModuleNamesWorker(sourceFile, node, compilerOptions, host, typeChecker, preferences));
            }
            function getStringLiteralCompletionsFromModuleNamesWorker(sourceFile, node, compilerOptions, host, typeChecker, preferences) {
                var literalValue = ts.normalizeSlashes(node.text);
                var scriptPath = sourceFile.path;
                var scriptDirectory = ts.getDirectoryPath(scriptPath);
                return isPathRelativeToScript(literalValue) || !compilerOptions.baseUrl && (ts.isRootedDiskPath(literalValue) || ts.isUrl(literalValue))
                    ? getCompletionEntriesForRelativeModules(literalValue, scriptDirectory, compilerOptions, host, scriptPath, getIncludeExtensionOption())
                    : getCompletionEntriesForNonRelativeModules(literalValue, scriptDirectory, compilerOptions, host, typeChecker);
                function getIncludeExtensionOption() {
                    var mode = ts.isStringLiteralLike(node) ? ts.getModeForUsageLocation(sourceFile, node) : undefined;
                    return preferences.importModuleSpecifierEnding === "js" || mode === ts.ModuleKind.ESNext ? 2 /* IncludeExtensionsOption.ModuleSpecifierCompletion */ : 0 /* IncludeExtensionsOption.Exclude */;
                }
            }
            function getExtensionOptions(compilerOptions, includeExtensionsOption) {
                if (includeExtensionsOption === void 0) { includeExtensionsOption = 0 /* IncludeExtensionsOption.Exclude */; }
                return { extensions: ts.flatten(getSupportedExtensionsForModuleResolution(compilerOptions)), includeExtensionsOption: includeExtensionsOption };
            }
            function getCompletionEntriesForRelativeModules(literalValue, scriptDirectory, compilerOptions, host, scriptPath, includeExtensions) {
                var extensionOptions = getExtensionOptions(compilerOptions, includeExtensions);
                if (compilerOptions.rootDirs) {
                    return getCompletionEntriesForDirectoryFragmentWithRootDirs(compilerOptions.rootDirs, literalValue, scriptDirectory, extensionOptions, compilerOptions, host, scriptPath);
                }
                else {
                    return getCompletionEntriesForDirectoryFragment(literalValue, scriptDirectory, extensionOptions, host, scriptPath);
                }
            }
            function isEmitResolutionKindUsingNodeModules(compilerOptions) {
                return ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs ||
                    ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Node16 ||
                    ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeNext;
            }
            function isEmitModuleResolutionRespectingExportMaps(compilerOptions) {
                return ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Node16 ||
                    ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeNext;
            }
            function getSupportedExtensionsForModuleResolution(compilerOptions) {
                var extensions = ts.getSupportedExtensions(compilerOptions);
                return isEmitResolutionKindUsingNodeModules(compilerOptions) ?
                    ts.getSupportedExtensionsWithJsonIfResolveJsonModule(compilerOptions, extensions) :
                    extensions;
            }
            /**
             * Takes a script path and returns paths for all potential folders that could be merged with its
             * containing folder via the "rootDirs" compiler option
             */
            function getBaseDirectoriesFromRootDirs(rootDirs, basePath, scriptDirectory, ignoreCase) {
                // Make all paths absolute/normalized if they are not already
                rootDirs = rootDirs.map(function (rootDirectory) { return ts.normalizePath(ts.isRootedDiskPath(rootDirectory) ? rootDirectory : ts.combinePaths(basePath, rootDirectory)); });
                // Determine the path to the directory containing the script relative to the root directory it is contained within
                var relativeDirectory = ts.firstDefined(rootDirs, function (rootDirectory) {
                    return ts.containsPath(rootDirectory, scriptDirectory, basePath, ignoreCase) ? scriptDirectory.substr(rootDirectory.length) : undefined;
                }); // TODO: GH#18217
                // Now find a path for each potential directory that is to be merged with the one containing the script
                return ts.deduplicate(__spreadArray(__spreadArray([], rootDirs.map(function (rootDirectory) { return ts.combinePaths(rootDirectory, relativeDirectory); }), true), [scriptDirectory], false), ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
            }
            function getCompletionEntriesForDirectoryFragmentWithRootDirs(rootDirs, fragment, scriptDirectory, extensionOptions, compilerOptions, host, exclude) {
                var basePath = compilerOptions.project || host.getCurrentDirectory();
                var ignoreCase = !(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames());
                var baseDirectories = getBaseDirectoriesFromRootDirs(rootDirs, basePath, scriptDirectory, ignoreCase);
                return ts.flatMap(baseDirectories, function (baseDirectory) { return getCompletionEntriesForDirectoryFragment(fragment, baseDirectory, extensionOptions, host, exclude); });
            }
            var IncludeExtensionsOption;
            (function (IncludeExtensionsOption) {
                IncludeExtensionsOption[IncludeExtensionsOption["Exclude"] = 0] = "Exclude";
                IncludeExtensionsOption[IncludeExtensionsOption["Include"] = 1] = "Include";
                IncludeExtensionsOption[IncludeExtensionsOption["ModuleSpecifierCompletion"] = 2] = "ModuleSpecifierCompletion";
            })(IncludeExtensionsOption || (IncludeExtensionsOption = {}));
            /**
             * Given a path ending at a directory, gets the completions for the path, and filters for those entries containing the basename.
             */
            function getCompletionEntriesForDirectoryFragment(fragment, scriptPath, _a, host, exclude, result) {
                var extensions = _a.extensions, includeExtensionsOption = _a.includeExtensionsOption;
                if (result === void 0) { result = []; }
                if (fragment === undefined) {
                    fragment = "";
                }
                fragment = ts.normalizeSlashes(fragment);
                /**
                 * Remove the basename from the path. Note that we don't use the basename to filter completions;
                 * the client is responsible for refining completions.
                 */
                if (!ts.hasTrailingDirectorySeparator(fragment)) {
                    fragment = ts.getDirectoryPath(fragment);
                }
                if (fragment === "") {
                    fragment = "." + ts.directorySeparator;
                }
                fragment = ts.ensureTrailingDirectorySeparator(fragment);
                // const absolutePath = normalizeAndPreserveTrailingSlash(isRootedDiskPath(fragment) ? fragment : combinePaths(scriptPath, fragment)); // TODO(rbuckton): should use resolvePaths
                var absolutePath = ts.resolvePath(scriptPath, fragment);
                var baseDirectory = ts.hasTrailingDirectorySeparator(absolutePath) ? absolutePath : ts.getDirectoryPath(absolutePath);
                var ignoreCase = !(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames());
                if (!ts.tryDirectoryExists(host, baseDirectory))
                    return result;
                // Enumerate the available files if possible
                var files = ts.tryReadDirectory(host, baseDirectory, extensions, /*exclude*/ undefined, /*include*/ ["./*"]);
                if (files) {
                    /**
                     * Multiple file entries might map to the same truncated name once we remove extensions
                     * (happens iff includeExtensionsOption === includeExtensionsOption.Exclude) so we use a set-like data structure. Eg:
                     *
                     * both foo.ts and foo.tsx become foo
                     */
                    var foundFiles = new ts.Map(); // maps file to its extension
                    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                        var filePath = files_1[_i];
                        filePath = ts.normalizePath(filePath);
                        if (exclude && ts.comparePaths(filePath, exclude, scriptPath, ignoreCase) === 0 /* Comparison.EqualTo */) {
                            continue;
                        }
                        var foundFileName = void 0;
                        var outputExtension = ts.moduleSpecifiers.tryGetJSExtensionForFile(filePath, host.getCompilationSettings());
                        if (includeExtensionsOption === 0 /* IncludeExtensionsOption.Exclude */ && !ts.fileExtensionIsOneOf(filePath, [".json" /* Extension.Json */, ".mts" /* Extension.Mts */, ".cts" /* Extension.Cts */, ".d.mts" /* Extension.Dmts */, ".d.cts" /* Extension.Dcts */, ".mjs" /* Extension.Mjs */, ".cjs" /* Extension.Cjs */])) {
                            foundFileName = ts.removeFileExtension(ts.getBaseFileName(filePath));
                            foundFiles.set(foundFileName, ts.tryGetExtensionFromPath(filePath));
                        }
                        else if ((ts.fileExtensionIsOneOf(filePath, [".mts" /* Extension.Mts */, ".cts" /* Extension.Cts */, ".d.mts" /* Extension.Dmts */, ".d.cts" /* Extension.Dcts */, ".mjs" /* Extension.Mjs */, ".cjs" /* Extension.Cjs */]) || includeExtensionsOption === 2 /* IncludeExtensionsOption.ModuleSpecifierCompletion */) && outputExtension) {
                            foundFileName = ts.changeExtension(ts.getBaseFileName(filePath), outputExtension);
                            foundFiles.set(foundFileName, outputExtension);
                        }
                        else {
                            foundFileName = ts.getBaseFileName(filePath);
                            foundFiles.set(foundFileName, ts.tryGetExtensionFromPath(filePath));
                        }
                    }
                    foundFiles.forEach(function (ext, foundFile) {
                        result.push(nameAndKind(foundFile, "script" /* ScriptElementKind.scriptElement */, ext));
                    });
                }
                // If possible, get folder completion as well
                var directories = ts.tryGetDirectories(host, baseDirectory);
                if (directories) {
                    for (var _b = 0, directories_1 = directories; _b < directories_1.length; _b++) {
                        var directory = directories_1[_b];
                        var directoryName = ts.getBaseFileName(ts.normalizePath(directory));
                        if (directoryName !== "@types") {
                            result.push(directoryResult(directoryName));
                        }
                    }
                }
                // check for a version redirect
                var packageJsonPath = ts.findPackageJson(baseDirectory, host);
                if (packageJsonPath) {
                    var packageJson = ts.readJson(packageJsonPath, host);
                    var typesVersions = packageJson.typesVersions;
                    if (typeof typesVersions === "object") {
                        var versionResult = ts.getPackageJsonTypesVersionsPaths(typesVersions);
                        var versionPaths = versionResult && versionResult.paths;
                        var rest = absolutePath.slice(ts.ensureTrailingDirectorySeparator(baseDirectory).length);
                        if (versionPaths) {
                            addCompletionEntriesFromPaths(result, rest, baseDirectory, extensions, versionPaths, host);
                        }
                    }
                }
                return result;
            }
            function addCompletionEntriesFromPaths(result, fragment, baseDirectory, fileExtensions, paths, host) {
                for (var path in paths) {
                    if (!ts.hasProperty(paths, path))
                        continue;
                    var patterns = paths[path];
                    if (patterns) {
                        var _loop_3 = function (name, kind, extension) {
                            // Path mappings may provide a duplicate way to get to something we've already added, so don't add again.
                            if (!result.some(function (entry) { return entry.name === name; })) {
                                result.push(nameAndKind(name, kind, extension));
                            }
                        };
                        for (var _i = 0, _a = getCompletionsForPathMapping(path, patterns, fragment, baseDirectory, fileExtensions, host); _i < _a.length; _i++) {
                            var _b = _a[_i], name = _b.name, kind = _b.kind, extension = _b.extension;
                            _loop_3(name, kind, extension);
                        }
                    }
                }
            }
            /**
             * Check all of the declared modules and those in node modules. Possible sources of modules:
             *      Modules that are found by the type checker
             *      Modules found relative to "baseUrl" compliler options (including patterns from "paths" compiler option)
             *      Modules from node_modules (i.e. those listed in package.json)
             *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
             */
            function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, compilerOptions, host, typeChecker) {
                var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                var result = [];
                var extensionOptions = getExtensionOptions(compilerOptions);
                if (baseUrl) {
                    var projectDir = compilerOptions.project || host.getCurrentDirectory();
                    var absolute = ts.normalizePath(ts.combinePaths(projectDir, baseUrl));
                    getCompletionEntriesForDirectoryFragment(fragment, absolute, extensionOptions, host, /*exclude*/ undefined, result);
                    if (paths) {
                        addCompletionEntriesFromPaths(result, fragment, absolute, extensionOptions.extensions, paths, host);
                    }
                }
                var fragmentDirectory = getFragmentDirectory(fragment);
                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
                    var ambientName = _a[_i];
                    result.push(nameAndKind(ambientName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                }
                getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
                if (isEmitResolutionKindUsingNodeModules(compilerOptions)) {
                    // If looking for a global package name, don't just include everything in `node_modules` because that includes dependencies' own dependencies.
                    // (But do if we didn't find anything, e.g. 'package.json' missing.)
                    var foundGlobal = false;
                    if (fragmentDirectory === undefined) {
                        var _loop_4 = function (moduleName) {
                            if (!result.some(function (entry) { return entry.name === moduleName; })) {
                                foundGlobal = true;
                                result.push(nameAndKind(moduleName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                            }
                        };
                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
                            var moduleName = _c[_b];
                            _loop_4(moduleName);
                        }
                    }
                    if (!foundGlobal) {
                        var ancestorLookup = function (ancestor) {
                            var nodeModules = ts.combinePaths(ancestor, "node_modules");
                            if (ts.tryDirectoryExists(host, nodeModules)) {
                                getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                            }
                        };
                        if (fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions)) {
                            var nodeModulesDirectoryLookup_1 = ancestorLookup;
                            ancestorLookup = function (ancestor) {
                                var components = ts.getPathComponents(fragment);
                                components.shift(); // shift off empty root
                                var packagePath = components.shift();
                                if (!packagePath) {
                                    return nodeModulesDirectoryLookup_1(ancestor);
                                }
                                if (ts.startsWith(packagePath, "@")) {
                                    var subName = components.shift();
                                    if (!subName) {
                                        return nodeModulesDirectoryLookup_1(ancestor);
                                    }
                                    packagePath = ts.combinePaths(packagePath, subName);
                                }
                                var packageFile = ts.combinePaths(ancestor, "node_modules", packagePath, "package.json");
                                if (ts.tryFileExists(host, packageFile)) {
                                    var packageJson = ts.readJson(packageFile, host);
                                    var exports = packageJson.exports;
                                    if (exports) {
                                        if (typeof exports !== "object" || exports === null) { // eslint-disable-line no-null/no-null
                                            return; // null exports or entrypoint only, no sub-modules available
                                        }
                                        var keys = ts.getOwnKeys(exports);
                                        var fragmentSubpath_1 = components.join("/");
                                        var processedKeys = ts.mapDefined(keys, function (k) {
                                            if (k === ".")
                                                return undefined;
                                            if (!ts.startsWith(k, "./"))
                                                return undefined;
                                            var subpath = k.substring(2);
                                            if (!ts.startsWith(subpath, fragmentSubpath_1))
                                                return undefined;
                                            // subpath is a valid export (barring conditions, which we don't currently check here)
                                            if (!ts.stringContains(subpath, "*")) {
                                                return subpath;
                                            }
                                            // pattern export - only return everything up to the `*`, so the user can autocomplete, then
                                            // keep filling in the pattern (we could speculatively return a list of options by hitting disk,
                                            // but conditions will make that somewhat awkward, as each condition may have a different set of possible
                                            // options for the `*`.
                                            return subpath.slice(0, subpath.indexOf("*"));
                                        });
                                        ts.forEach(processedKeys, function (k) {
                                            if (k) {
                                                result.push(nameAndKind(k, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                                            }
                                        });
                                        return;
                                    }
                                }
                                return nodeModulesDirectoryLookup_1(ancestor);
                            };
                        }
                        ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
                    }
                }
                return result;
            }
            function getFragmentDirectory(fragment) {
                return containsSlash(fragment) ? ts.hasTrailingDirectorySeparator(fragment) ? fragment : ts.getDirectoryPath(fragment) : undefined;
            }
            function getCompletionsForPathMapping(path, patterns, fragment, baseUrl, fileExtensions, host) {
                if (!ts.endsWith(path, "*")) {
                    // For a path mapping "foo": ["/x/y/z.ts"], add "foo" itself as a completion.
                    return !ts.stringContains(path, "*") ? justPathMappingName(path) : ts.emptyArray;
                }
                var pathPrefix = path.slice(0, path.length - 1);
                var remainingFragment = ts.tryRemovePrefix(fragment, pathPrefix);
                return remainingFragment === undefined ? justPathMappingName(pathPrefix) : ts.flatMap(patterns, function (pattern) {
                    return getModulesForPathsPattern(remainingFragment, baseUrl, pattern, fileExtensions, host);
                });
                function justPathMappingName(name) {
                    return ts.startsWith(name, fragment) ? [directoryResult(name)] : ts.emptyArray;
                }
            }
            function getModulesForPathsPattern(fragment, baseUrl, pattern, fileExtensions, host) {
                if (!host.readDirectory) {
                    return undefined;
                }
                var parsed = ts.tryParsePattern(pattern);
                if (parsed === undefined || ts.isString(parsed)) {
                    return undefined;
                }
                // The prefix has two effective parts: the directory path and the base component after the filepath that is not a
                // full directory component. For example: directory/path/of/prefix/base*
                var normalizedPrefix = ts.resolvePath(parsed.prefix);
                var normalizedPrefixDirectory = ts.hasTrailingDirectorySeparator(parsed.prefix) ? normalizedPrefix : ts.getDirectoryPath(normalizedPrefix);
                var normalizedPrefixBase = ts.hasTrailingDirectorySeparator(parsed.prefix) ? "" : ts.getBaseFileName(normalizedPrefix);
                var fragmentHasPath = containsSlash(fragment);
                var fragmentDirectory = fragmentHasPath ? ts.hasTrailingDirectorySeparator(fragment) ? fragment : ts.getDirectoryPath(fragment) : undefined;
                // Try and expand the prefix to include any path from the fragment so that we can limit the readDirectory call
                var expandedPrefixDirectory = fragmentHasPath ? ts.combinePaths(normalizedPrefixDirectory, normalizedPrefixBase + fragmentDirectory) : normalizedPrefixDirectory;
                var normalizedSuffix = ts.normalizePath(parsed.suffix);
                // Need to normalize after combining: If we combinePaths("a", "../b"), we want "b" and not "a/../b".
                var baseDirectory = ts.normalizePath(ts.combinePaths(baseUrl, expandedPrefixDirectory));
                var completePrefix = fragmentHasPath ? baseDirectory : ts.ensureTrailingDirectorySeparator(baseDirectory) + normalizedPrefixBase;
                // If we have a suffix, then we need to read the directory all the way down. We could create a glob
                // that encodes the suffix, but we would have to escape the character "?" which readDirectory
                // doesn't support. For now, this is safer but slower
                var includeGlob = normalizedSuffix ? "**/*" : "./*";
                var matches = ts.mapDefined(ts.tryReadDirectory(host, baseDirectory, fileExtensions, /*exclude*/ undefined, [includeGlob]), function (match) {
                    var extension = ts.tryGetExtensionFromPath(match);
                    var name = trimPrefixAndSuffix(match);
                    return name === undefined ? undefined : nameAndKind(ts.removeFileExtension(name), "script" /* ScriptElementKind.scriptElement */, extension);
                });
                var directories = ts.mapDefined(ts.tryGetDirectories(host, baseDirectory).map(function (d) { return ts.combinePaths(baseDirectory, d); }), function (dir) {
                    var name = trimPrefixAndSuffix(dir);
                    return name === undefined ? undefined : directoryResult(name);
                });
                return __spreadArray(__spreadArray([], matches, true), directories, true);
                function trimPrefixAndSuffix(path) {
                    var inner = withoutStartAndEnd(ts.normalizePath(path), completePrefix, normalizedSuffix);
                    return inner === undefined ? undefined : removeLeadingDirectorySeparator(inner);
                }
            }
            function withoutStartAndEnd(s, start, end) {
                return ts.startsWith(s, start) && ts.endsWith(s, end) ? s.slice(start.length, s.length - end.length) : undefined;
            }
            function removeLeadingDirectorySeparator(path) {
                return path[0] === ts.directorySeparator ? path.slice(1) : path;
            }
            function getAmbientModuleCompletions(fragment, fragmentDirectory, checker) {
                // Get modules that the type checker picked up
                var ambientModules = checker.getAmbientModules().map(function (sym) { return ts.stripQuotes(sym.name); });
                var nonRelativeModuleNames = ambientModules.filter(function (moduleName) { return ts.startsWith(moduleName, fragment); });
                // Nested modules of the form "module-name/sub" need to be adjusted to only return the string
                // after the last '/' that appears in the fragment because that's where the replacement span
                // starts
                if (fragmentDirectory !== undefined) {
                    var moduleNameWithSeparator_1 = ts.ensureTrailingDirectorySeparator(fragmentDirectory);
                    return nonRelativeModuleNames.map(function (nonRelativeModuleName) { return ts.removePrefix(nonRelativeModuleName, moduleNameWithSeparator_1); });
                }
                return nonRelativeModuleNames;
            }
            function getTripleSlashReferenceCompletion(sourceFile, position, compilerOptions, host) {
                var token = ts.getTokenAtPosition(sourceFile, position);
                var commentRanges = ts.getLeadingCommentRanges(sourceFile.text, token.pos);
                var range = commentRanges && ts.find(commentRanges, function (commentRange) { return position >= commentRange.pos && position <= commentRange.end; });
                if (!range) {
                    return undefined;
                }
                var text = sourceFile.text.slice(range.pos, position);
                var match = tripleSlashDirectiveFragmentRegex.exec(text);
                if (!match) {
                    return undefined;
                }
                var prefix = match[1], kind = match[2], toComplete = match[3];
                var scriptPath = ts.getDirectoryPath(sourceFile.path);
                var names = kind === "path" ? getCompletionEntriesForDirectoryFragment(toComplete, scriptPath, getExtensionOptions(compilerOptions, 1 /* IncludeExtensionsOption.Include */), host, sourceFile.path)
                    : kind === "types" ? getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, getFragmentDirectory(toComplete), getExtensionOptions(compilerOptions))
                        : ts.Debug.fail();
                return addReplacementSpans(toComplete, range.pos + prefix.length, names);
            }
            function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
                if (result === void 0) { result = []; }
                // Check for typings specified in compiler options
                var seen = new ts.Map();
                var typeRoots = ts.tryAndIgnoreErrors(function () { return ts.getEffectiveTypeRoots(options, host); }) || ts.emptyArray;
                for (var _i = 0, typeRoots_1 = typeRoots; _i < typeRoots_1.length; _i++) {
                    var root = typeRoots_1[_i];
                    getCompletionEntriesFromDirectories(root);
                }
                // Also get all @types typings installed in visible node_modules directories
                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
                    var packageJson = _b[_a];
                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
                    getCompletionEntriesFromDirectories(typesDir);
                }
                return result;
                function getCompletionEntriesFromDirectories(directory) {
                    if (!ts.tryDirectoryExists(host, directory))
                        return;
                    for (var _i = 0, _a = ts.tryGetDirectories(host, directory); _i < _a.length; _i++) {
                        var typeDirectoryName = _a[_i];
                        var packageName = ts.unmangleScopedPackageName(typeDirectoryName);
                        if (options.types && !ts.contains(options.types, packageName))
                            continue;
                        if (fragmentDirectory === undefined) {
                            if (!seen.has(packageName)) {
                                result.push(nameAndKind(packageName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                                seen.set(packageName, true);
                            }
                        }
                        else {
                            var baseDirectory = ts.combinePaths(directory, typeDirectoryName);
                            var remainingFragment = ts.tryRemoveDirectoryPrefix(fragmentDirectory, packageName, ts.hostGetCanonicalFileName(host));
                            if (remainingFragment !== undefined) {
                                getCompletionEntriesForDirectoryFragment(remainingFragment, baseDirectory, extensionOptions, host, /*exclude*/ undefined, result);
                            }
                        }
                    }
                }
            }
            function enumerateNodeModulesVisibleToScript(host, scriptPath) {
                if (!host.readFile || !host.fileExists)
                    return ts.emptyArray;
                var result = [];
                for (var _i = 0, _a = ts.findPackageJsons(scriptPath, host); _i < _a.length; _i++) {
                    var packageJson = _a[_i];
                    var contents = ts.readJson(packageJson, host); // Cast to assert that readFile is defined
                    // Provide completions for all non @types dependencies
                    for (var _b = 0, nodeModulesDependencyKeys_1 = nodeModulesDependencyKeys; _b < nodeModulesDependencyKeys_1.length; _b++) {
                        var key = nodeModulesDependencyKeys_1[_b];
                        var dependencies = contents[key];
                        if (!dependencies)
                            continue;
                        for (var dep in dependencies) {
                            if (dependencies.hasOwnProperty(dep) && !ts.startsWith(dep, "@types/")) {
                                result.push(dep);
                            }
                        }
                    }
                }
                return result;
            }
            // Replace everything after the last directory separator that appears
            function getDirectoryFragmentTextSpan(text, textStart) {
                var index = Math.max(text.lastIndexOf(ts.directorySeparator), text.lastIndexOf(ts.altDirectorySeparator));
                var offset = index !== -1 ? index + 1 : 0;
                // If the range is an identifier, span is unnecessary.
                var length = text.length - offset;
                return length === 0 || ts.isIdentifierText(text.substr(offset, length), 99 /* ScriptTarget.ESNext */) ? undefined : ts.createTextSpan(textStart + offset, length);
            }
            // Returns true if the path is explicitly relative to the script (i.e. relative to . or ..)
            function isPathRelativeToScript(path) {
                if (path && path.length >= 2 && path.charCodeAt(0) === 46 /* CharacterCodes.dot */) {
                    var slashIndex = path.length >= 3 && path.charCodeAt(1) === 46 /* CharacterCodes.dot */ ? 2 : 1;
                    var slashCharCode = path.charCodeAt(slashIndex);
                    return slashCharCode === 47 /* CharacterCodes.slash */ || slashCharCode === 92 /* CharacterCodes.backslash */;
                }
                return false;
            }
            /**
             * Matches a triple slash reference directive with an incomplete string literal for its path. Used
             * to determine if the caret is currently within the string literal and capture the literal fragment
             * for completions.
             * For example, this matches
             *
             * /// <reference path="fragment
             *
             * but not
             *
             * /// <reference path="fragment"
             */
            var tripleSlashDirectiveFragmentRegex = /^(\/\/\/\s*<reference\s+(path|types)\s*=\s*(?:'|"))([^\3"]*)$/;
            var nodeModulesDependencyKeys = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
            function containsSlash(fragment) {
                return ts.stringContains(fragment, ts.directorySeparator);
            }
            /**
             * Matches
             *   require(""
             *   require("")
             */
            function isRequireCallArgument(node) {
                return ts.isCallExpression(node.parent) && ts.firstOrUndefined(node.parent.arguments) === node
                    && ts.isIdentifier(node.parent.expression) && node.parent.expression.escapedText === "require";
            }
        })(StringCompletions = Completions.StringCompletions || (Completions.StringCompletions = {}));
    })(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var Completions;
    (function (Completions) {
        // Exported only for tests
        Completions.moduleSpecifierResolutionLimit = 100;
        Completions.moduleSpecifierResolutionCacheAttemptLimit = 1000;
        Completions.SortText = {
            // Presets
            LocalDeclarationPriority: "10",
            LocationPriority: "11",
            OptionalMember: "12",
            MemberDeclaredBySpreadAssignment: "13",
            SuggestedClassMembers: "14",
            GlobalsOrKeywords: "15",
            AutoImportSuggestions: "16",
            ClassMemberSnippets: "17",
            JavascriptIdentifiers: "18",
            // Transformations
            Deprecated: function (sortText) {
                return "z" + sortText;
            },
            ObjectLiteralProperty: function (presetSortText, symbolDisplayName) {
                return "".concat(presetSortText, "\0").concat(symbolDisplayName, "\0");
            },
            SortBelow: function (sortText) {
                return sortText + "1";
            },
        };
        /**
         * Special values for `CompletionInfo['source']` used to disambiguate
         * completion items with the same `name`. (Each completion item must
         * have a unique name/source combination, because those two fields
         * comprise `CompletionEntryIdentifier` in `getCompletionEntryDetails`.
         *
         * When the completion item is an auto-import suggestion, the source
         * is the module specifier of the suggestion. To avoid collisions,
         * the values here should not be a module specifier we would ever
         * generate for an auto-import.
         */
        var CompletionSource;
        (function (CompletionSource) {
            /** Completions that require `this.` insertion text */
            CompletionSource["ThisProperty"] = "ThisProperty/";
            /** Auto-import that comes attached to a class member snippet */
            CompletionSource["ClassMemberSnippet"] = "ClassMemberSnippet/";
            /** A type-only import that needs to be promoted in order to be used at the completion location */
            CompletionSource["TypeOnlyAlias"] = "TypeOnlyAlias/";
            /** Auto-import that comes attached to an object literal method snippet */
            CompletionSource["ObjectLiteralMethodSnippet"] = "ObjectLiteralMethodSnippet/";
        })(CompletionSource = Completions.CompletionSource || (Completions.CompletionSource = {}));
        var SymbolOriginInfoKind;
        (function (SymbolOriginInfoKind) {
            SymbolOriginInfoKind[SymbolOriginInfoKind["ThisType"] = 1] = "ThisType";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMember"] = 2] = "SymbolMember";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Export"] = 4] = "Export";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Promise"] = 8] = "Promise";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Nullable"] = 16] = "Nullable";
            SymbolOriginInfoKind[SymbolOriginInfoKind["ResolvedExport"] = 32] = "ResolvedExport";
            SymbolOriginInfoKind[SymbolOriginInfoKind["TypeOnlyAlias"] = 64] = "TypeOnlyAlias";
            SymbolOriginInfoKind[SymbolOriginInfoKind["ObjectLiteralMethod"] = 128] = "ObjectLiteralMethod";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMemberNoExport"] = 2] = "SymbolMemberNoExport";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMemberExport"] = 6] = "SymbolMemberExport";
        })(SymbolOriginInfoKind || (SymbolOriginInfoKind = {}));
        function originIsThisType(origin) {
            return !!(origin.kind & 1 /* SymbolOriginInfoKind.ThisType */);
        }
        function originIsSymbolMember(origin) {
            return !!(origin.kind & 2 /* SymbolOriginInfoKind.SymbolMember */);
        }
        function originIsExport(origin) {
            return !!(origin && origin.kind & 4 /* SymbolOriginInfoKind.Export */);
        }
        function originIsResolvedExport(origin) {
            return !!(origin && origin.kind === 32 /* SymbolOriginInfoKind.ResolvedExport */);
        }
        function originIncludesSymbolName(origin) {
            return originIsExport(origin) || originIsResolvedExport(origin);
        }
        function originIsPackageJsonImport(origin) {
            return (originIsExport(origin) || originIsResolvedExport(origin)) && !!origin.isFromPackageJson;
        }
        function originIsPromise(origin) {
            return !!(origin.kind & 8 /* SymbolOriginInfoKind.Promise */);
        }
        function originIsNullableMember(origin) {
            return !!(origin.kind & 16 /* SymbolOriginInfoKind.Nullable */);
        }
        function originIsTypeOnlyAlias(origin) {
            return !!(origin && origin.kind & 64 /* SymbolOriginInfoKind.TypeOnlyAlias */);
        }
        function originIsObjectLiteralMethod(origin) {
            return !!(origin && origin.kind & 128 /* SymbolOriginInfoKind.ObjectLiteralMethod */);
        }
        var KeywordCompletionFilters;
        (function (KeywordCompletionFilters) {
            KeywordCompletionFilters[KeywordCompletionFilters["None"] = 0] = "None";
            KeywordCompletionFilters[KeywordCompletionFilters["All"] = 1] = "All";
            KeywordCompletionFilters[KeywordCompletionFilters["ClassElementKeywords"] = 2] = "ClassElementKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["InterfaceElementKeywords"] = 3] = "InterfaceElementKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["ConstructorParameterKeywords"] = 4] = "ConstructorParameterKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["FunctionLikeBodyKeywords"] = 5] = "FunctionLikeBodyKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeAssertionKeywords"] = 6] = "TypeAssertionKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeKeywords"] = 7] = "TypeKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeKeyword"] = 8] = "TypeKeyword";
            KeywordCompletionFilters[KeywordCompletionFilters["Last"] = 8] = "Last";
        })(KeywordCompletionFilters || (KeywordCompletionFilters = {}));
        var GlobalsSearch;
        (function (GlobalsSearch) {
            GlobalsSearch[GlobalsSearch["Continue"] = 0] = "Continue";
            GlobalsSearch[GlobalsSearch["Success"] = 1] = "Success";
            GlobalsSearch[GlobalsSearch["Fail"] = 2] = "Fail";
        })(GlobalsSearch || (GlobalsSearch = {}));
        function resolvingModuleSpecifiers(logPrefix, host, resolver, program, position, preferences, isForImportStatementCompletion, isValidTypeOnlyUseSite, cb) {
            var _a, _b, _c;
            var start = ts.timestamp();
            // Under `--moduleResolution nodenext`, we have to resolve module specifiers up front, because
            // package.json exports can mean we *can't* resolve a module specifier (that doesn't include a
            // relative path into node_modules), and we want to filter those completions out entirely.
            // Import statement completions always need specifier resolution because the module specifier is
            // part of their `insertText`, not the `codeActions` creating edits away from the cursor.
            var needsFullResolution = isForImportStatementCompletion || ts.moduleResolutionRespectsExports(ts.getEmitModuleResolutionKind(program.getCompilerOptions()));
            var skippedAny = false;
            var ambientCount = 0;
            var resolvedCount = 0;
            var resolvedFromCacheCount = 0;
            var cacheAttemptCount = 0;
            var result = cb({
                tryResolve: tryResolve,
                skippedAny: function () { return skippedAny; },
                resolvedAny: function () { return resolvedCount > 0; },
                resolvedBeyondLimit: function () { return resolvedCount > Completions.moduleSpecifierResolutionLimit; },
            });
            var hitRateMessage = cacheAttemptCount ? " (".concat((resolvedFromCacheCount / cacheAttemptCount * 100).toFixed(1), "% hit rate)") : "";
            (_a = host.log) === null || _a === void 0 ? void 0 : _a.call(host, "".concat(logPrefix, ": resolved ").concat(resolvedCount, " module specifiers, plus ").concat(ambientCount, " ambient and ").concat(resolvedFromCacheCount, " from cache").concat(hitRateMessage));
            (_b = host.log) === null || _b === void 0 ? void 0 : _b.call(host, "".concat(logPrefix, ": response is ").concat(skippedAny ? "incomplete" : "complete"));
            (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, "".concat(logPrefix, ": ").concat(ts.timestamp() - start));
            return result;
            function tryResolve(exportInfo, symbolName, isFromAmbientModule) {
                if (isFromAmbientModule) {
                    var result_1 = resolver.getModuleSpecifierForBestExportInfo(exportInfo, symbolName, position, isValidTypeOnlyUseSite);
                    if (result_1) {
                        ambientCount++;
                    }
                    return result_1 || "failed";
                }
                var shouldResolveModuleSpecifier = needsFullResolution || preferences.allowIncompleteCompletions && resolvedCount < Completions.moduleSpecifierResolutionLimit;
                var shouldGetModuleSpecifierFromCache = !shouldResolveModuleSpecifier && preferences.allowIncompleteCompletions && cacheAttemptCount < Completions.moduleSpecifierResolutionCacheAttemptLimit;
                var result = (shouldResolveModuleSpecifier || shouldGetModuleSpecifierFromCache)
                    ? resolver.getModuleSpecifierForBestExportInfo(exportInfo, symbolName, position, isValidTypeOnlyUseSite, shouldGetModuleSpecifierFromCache)
                    : undefined;
                if (!shouldResolveModuleSpecifier && !shouldGetModuleSpecifierFromCache || shouldGetModuleSpecifierFromCache && !result) {
                    skippedAny = true;
                }
                resolvedCount += (result === null || result === void 0 ? void 0 : result.computedWithoutCacheCount) || 0;
                resolvedFromCacheCount += exportInfo.length - ((result === null || result === void 0 ? void 0 : result.computedWithoutCacheCount) || 0);
                if (shouldGetModuleSpecifierFromCache) {
                    cacheAttemptCount++;
                }
                return result || (needsFullResolution ? "failed" : "skipped");
            }
        }
        function getCompletionsAtPosition(host, program, log, sourceFile, position, preferences, triggerCharacter, completionKind, cancellationToken, formatContext) {
            var _a;
            var previousToken = getRelevantTokens(position, sourceFile).previousToken;
            if (triggerCharacter && !ts.isInString(sourceFile, position, previousToken) && !isValidTrigger(sourceFile, triggerCharacter, previousToken, position)) {
                return undefined;
            }
            if (triggerCharacter === " ") {
                // `isValidTrigger` ensures we are at `import |`
                if (preferences.includeCompletionsForImportStatements && preferences.includeCompletionsWithInsertText) {
                    return { isGlobalCompletion: true, isMemberCompletion: false, isNewIdentifierLocation: true, isIncomplete: true, entries: [] };
                }
                return undefined;
            }
            // If the request is a continuation of an earlier `isIncomplete` response,
            // we can continue it from the cached previous response.
            var compilerOptions = program.getCompilerOptions();
            var incompleteCompletionsCache = preferences.allowIncompleteCompletions ? (_a = host.getIncompleteCompletionsCache) === null || _a === void 0 ? void 0 : _a.call(host) : undefined;
            if (incompleteCompletionsCache && completionKind === 3 /* CompletionTriggerKind.TriggerForIncompleteCompletions */ && previousToken && ts.isIdentifier(previousToken)) {
                var incompleteContinuation = continuePreviousIncompleteResponse(incompleteCompletionsCache, sourceFile, previousToken, program, host, preferences, cancellationToken);
                if (incompleteContinuation) {
                    return incompleteContinuation;
                }
            }
            else {
                incompleteCompletionsCache === null || incompleteCompletionsCache === void 0 ? void 0 : incompleteCompletionsCache.clear();
            }
            var stringCompletions = Completions.StringCompletions.getStringLiteralCompletions(sourceFile, position, previousToken, compilerOptions, host, program, log, preferences);
            if (stringCompletions) {
                return stringCompletions;
            }
            if (previousToken && ts.isBreakOrContinueStatement(previousToken.parent)
                && (previousToken.kind === 81 /* SyntaxKind.BreakKeyword */ || previousToken.kind === 86 /* SyntaxKind.ContinueKeyword */ || previousToken.kind === 79 /* SyntaxKind.Identifier */)) {
                return getLabelCompletionAtPosition(previousToken.parent);
            }
            var completionData = getCompletionData(program, log, sourceFile, compilerOptions, position, preferences, /*detailsEntryId*/ undefined, host, formatContext, cancellationToken);
            if (!completionData) {
                return undefined;
            }
            switch (completionData.kind) {
                case 0 /* CompletionDataKind.Data */:
                    var response = completionInfoFromData(sourceFile, host, program, compilerOptions, log, completionData, preferences, formatContext, position);
                    if (response === null || response === void 0 ? void 0 : response.isIncomplete) {
                        incompleteCompletionsCache === null || incompleteCompletionsCache === void 0 ? void 0 : incompleteCompletionsCache.set(response);
                    }
                    return response;
                case 1 /* CompletionDataKind.JsDocTagName */:
                    // If the current position is a jsDoc tag name, only tag names should be provided for completion
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocTagNameCompletions());
                case 2 /* CompletionDataKind.JsDocTag */:
                    // If the current position is a jsDoc tag, only tags should be provided for completion
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocTagCompletions());
                case 3 /* CompletionDataKind.JsDocParameterName */:
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocParameterNameCompletions(completionData.tag));
                case 4 /* CompletionDataKind.Keywords */:
                    return specificKeywordCompletionInfo(completionData.keywordCompletions, completionData.isNewIdentifierLocation);
                default:
                    return ts.Debug.assertNever(completionData);
            }
        }
        Completions.getCompletionsAtPosition = getCompletionsAtPosition;
        // Editors will use the `sortText` and then fall back to `name` for sorting, but leave ties in response order.
        // So, it's important that we sort those ties in the order we want them displayed if it matters. We don't
        // strictly need to sort by name or SortText here since clients are going to do it anyway, but we have to
        // do the work of comparing them so we can sort those ties appropriately; plus, it makes the order returned
        // by the language service consistent with what TS Server does and what editors typically do. This also makes
        // completions tests make more sense. We used to sort only alphabetically and only in the server layer, but
        // this made tests really weird, since most fourslash tests don't use the server.
        function compareCompletionEntries(entryInArray, entryToInsert) {
            var _a, _b;
            var result = ts.compareStringsCaseSensitiveUI(entryInArray.sortText, entryToInsert.sortText);
            if (result === 0 /* Comparison.EqualTo */) {
                result = ts.compareStringsCaseSensitiveUI(entryInArray.name, entryToInsert.name);
            }
            if (result === 0 /* Comparison.EqualTo */ && ((_a = entryInArray.data) === null || _a === void 0 ? void 0 : _a.moduleSpecifier) && ((_b = entryToInsert.data) === null || _b === void 0 ? void 0 : _b.moduleSpecifier)) {
                // Sort same-named auto-imports by module specifier
                result = ts.compareNumberOfDirectorySeparators(entryInArray.data.moduleSpecifier, entryToInsert.data.moduleSpecifier);
            }
            if (result === 0 /* Comparison.EqualTo */) {
                // Fall back to symbol order - if we return `EqualTo`, `insertSorted` will put later symbols first.
                return -1 /* Comparison.LessThan */;
            }
            return result;
        }
        function completionEntryDataIsResolved(data) {
            return !!(data === null || data === void 0 ? void 0 : data.moduleSpecifier);
        }
        function continuePreviousIncompleteResponse(cache, file, location, program, host, preferences, cancellationToken) {
            var previousResponse = cache.get();
            if (!previousResponse)
                return undefined;
            var lowerCaseTokenText = location.text.toLowerCase();
            var exportMap = ts.getExportInfoMap(file, host, program, cancellationToken);
            var newEntries = resolvingModuleSpecifiers("continuePreviousIncompleteResponse", host, ts.codefix.createImportSpecifierResolver(file, program, host, preferences), program, location.getStart(), preferences, 
            /*isForImportStatementCompletion*/ false, ts.isValidTypeOnlyAliasUseSite(location), function (context) {
                var entries = ts.mapDefined(previousResponse.entries, function (entry) {
                    var _a;
                    if (!entry.hasAction || !entry.source || !entry.data || completionEntryDataIsResolved(entry.data)) {
                        // Not an auto import or already resolved; keep as is
                        return entry;
                    }
                    if (!charactersFuzzyMatchInString(entry.name, lowerCaseTokenText)) {
                        // No longer matches typed characters; filter out
                        return undefined;
                    }
                    var origin = ts.Debug.checkDefined(getAutoImportSymbolFromCompletionEntryData(entry.name, entry.data, program, host)).origin;
                    var info = exportMap.get(file.path, entry.data.exportMapKey);
                    var result = info && context.tryResolve(info, entry.name, !ts.isExternalModuleNameRelative(ts.stripQuotes(origin.moduleSymbol.name)));
                    if (result === "skipped")
                        return entry;
                    if (!result || result === "failed") {
                        (_a = host.log) === null || _a === void 0 ? void 0 : _a.call(host, "Unexpected failure resolving auto import for '".concat(entry.name, "' from '").concat(entry.source, "'"));
                        return undefined;
                    }
                    var newOrigin = __assign(__assign({}, origin), { kind: 32 /* SymbolOriginInfoKind.ResolvedExport */, moduleSpecifier: result.moduleSpecifier });
                    // Mutating for performance... feels sketchy but nobody else uses the cache,
                    // so why bother allocating a bunch of new objects?
                    entry.data = originToCompletionEntryData(newOrigin);
                    entry.source = getSourceFromOrigin(newOrigin);
                    entry.sourceDisplay = [ts.textPart(newOrigin.moduleSpecifier)];
                    return entry;
                });
                if (!context.skippedAny()) {
                    previousResponse.isIncomplete = undefined;
                }
                return entries;
            });
            previousResponse.entries = newEntries;
            previousResponse.flags = (previousResponse.flags || 0) | 4 /* CompletionInfoFlags.IsContinuation */;
            return previousResponse;
        }
        function jsdocCompletionInfo(entries) {
            return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: entries };
        }
        function keywordToCompletionEntry(keyword) {
            return {
                name: ts.tokenToString(keyword),
                kind: "keyword" /* ScriptElementKind.keyword */,
                kindModifiers: "" /* ScriptElementKindModifier.none */,
                sortText: Completions.SortText.GlobalsOrKeywords,
            };
        }
        function specificKeywordCompletionInfo(entries, isNewIdentifierLocation) {
            return {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: isNewIdentifierLocation,
                entries: entries.slice(),
            };
        }
        function keywordCompletionData(keywordFilters, filterOutTsOnlyKeywords, isNewIdentifierLocation) {
            return {
                kind: 4 /* CompletionDataKind.Keywords */,
                keywordCompletions: getKeywordCompletions(keywordFilters, filterOutTsOnlyKeywords),
                isNewIdentifierLocation: isNewIdentifierLocation,
            };
        }
        function keywordFiltersFromSyntaxKind(keywordCompletion) {
            switch (keywordCompletion) {
                case 152 /* SyntaxKind.TypeKeyword */: return 8 /* KeywordCompletionFilters.TypeKeyword */;
                default: ts.Debug.fail("Unknown mapping from SyntaxKind to KeywordCompletionFilters");
            }
        }
        function getOptionalReplacementSpan(location) {
            // StringLiteralLike locations are handled separately in stringCompletions.ts
            return (location === null || location === void 0 ? void 0 : location.kind) === 79 /* SyntaxKind.Identifier */ ? ts.createTextSpanFromNode(location) : undefined;
        }
        function completionInfoFromData(sourceFile, host, program, compilerOptions, log, completionData, preferences, formatContext, position) {
            var symbols = completionData.symbols, contextToken = completionData.contextToken, completionKind = completionData.completionKind, isInSnippetScope = completionData.isInSnippetScope, isNewIdentifierLocation = completionData.isNewIdentifierLocation, location = completionData.location, propertyAccessToConvert = completionData.propertyAccessToConvert, keywordFilters = completionData.keywordFilters, literals = completionData.literals, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, recommendedCompletion = completionData.recommendedCompletion, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation, isJsxIdentifierExpected = completionData.isJsxIdentifierExpected, isRightOfOpenTag = completionData.isRightOfOpenTag, importCompletionNode = completionData.importCompletionNode, insideJsDocTagTypeExpression = completionData.insideJsDocTagTypeExpression, symbolToSortTextMap = completionData.symbolToSortTextMap, hasUnresolvedAutoImports = completionData.hasUnresolvedAutoImports;
            // Verify if the file is JSX language variant
            if (ts.getLanguageVariant(sourceFile.scriptKind) === 1 /* LanguageVariant.JSX */) {
                var completionInfo = getJsxClosingTagCompletion(location, sourceFile);
                if (completionInfo) {
                    return completionInfo;
                }
            }
            var entries = ts.createSortedArray();
            if (isUncheckedFile(sourceFile, compilerOptions)) {
                var uniqueNames = getCompletionEntriesFromSymbols(symbols, entries, 
                /*replacementToken*/ undefined, contextToken, location, sourceFile, host, program, ts.getEmitScriptTarget(compilerOptions), log, completionKind, preferences, compilerOptions, formatContext, isTypeOnlyLocation, propertyAccessToConvert, isJsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextMap, isJsxIdentifierExpected, isRightOfOpenTag);
                getJSCompletionEntries(sourceFile, location.pos, uniqueNames, ts.getEmitScriptTarget(compilerOptions), entries);
            }
            else {
                if (!isNewIdentifierLocation && (!symbols || symbols.length === 0) && keywordFilters === 0 /* KeywordCompletionFilters.None */) {
                    return undefined;
                }
                getCompletionEntriesFromSymbols(symbols, entries, 
                /*replacementToken*/ undefined, contextToken, location, sourceFile, host, program, ts.getEmitScriptTarget(compilerOptions), log, completionKind, preferences, compilerOptions, formatContext, isTypeOnlyLocation, propertyAccessToConvert, isJsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextMap, isJsxIdentifierExpected, isRightOfOpenTag);
            }
            if (keywordFilters !== 0 /* KeywordCompletionFilters.None */) {
                var entryNames_1 = new ts.Set(entries.map(function (e) { return e.name; }));
                for (var _i = 0, _a = getKeywordCompletions(keywordFilters, !insideJsDocTagTypeExpression && ts.isSourceFileJS(sourceFile)); _i < _a.length; _i++) {
                    var keywordEntry = _a[_i];
                    if (isTypeOnlyLocation && ts.isTypeKeyword(ts.stringToToken(keywordEntry.name)) || !entryNames_1.has(keywordEntry.name)) {
                        ts.insertSorted(entries, keywordEntry, compareCompletionEntries, /*allowDuplicates*/ true);
                    }
                }
            }
            var entryNames = new ts.Set(entries.map(function (e) { return e.name; }));
            for (var _b = 0, _c = getContextualKeywords(contextToken, position); _b < _c.length; _b++) {
                var keywordEntry = _c[_b];
                if (!entryNames.has(keywordEntry.name)) {
                    ts.insertSorted(entries, keywordEntry, compareCompletionEntries, /*allowDuplicates*/ true);
                }
            }
            for (var _d = 0, literals_1 = literals; _d < literals_1.length; _d++) {
                var literal = literals_1[_d];
                ts.insertSorted(entries, createCompletionEntryForLiteral(sourceFile, preferences, literal), compareCompletionEntries, /*allowDuplicates*/ true);
            }
            return {
                flags: completionData.flags,
                isGlobalCompletion: isInSnippetScope,
                isIncomplete: preferences.allowIncompleteCompletions && hasUnresolvedAutoImports ? true : undefined,
                isMemberCompletion: isMemberCompletionKind(completionKind),
                isNewIdentifierLocation: isNewIdentifierLocation,
                optionalReplacementSpan: getOptionalReplacementSpan(location),
                entries: entries,
            };
        }
        function isUncheckedFile(sourceFile, compilerOptions) {
            return ts.isSourceFileJS(sourceFile) && !ts.isCheckJsEnabledForFile(sourceFile, compilerOptions);
        }
        function isMemberCompletionKind(kind) {
            switch (kind) {
                case 0 /* CompletionKind.ObjectPropertyDeclaration */:
                case 3 /* CompletionKind.MemberLike */:
                case 2 /* CompletionKind.PropertyAccess */:
                    return true;
                default:
                    return false;
            }
        }
        function getJsxClosingTagCompletion(location, sourceFile) {
            // We wanna walk up the tree till we find a JSX closing element
            var jsxClosingElement = ts.findAncestor(location, function (node) {
                switch (node.kind) {
                    case 281 /* SyntaxKind.JsxClosingElement */:
                        return true;
                    case 43 /* SyntaxKind.SlashToken */:
                    case 31 /* SyntaxKind.GreaterThanToken */:
                    case 79 /* SyntaxKind.Identifier */:
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        return false;
                    default:
                        return "quit";
                }
            });
            if (jsxClosingElement) {
                // In the TypeScript JSX element, if such element is not defined. When users query for completion at closing tag,
                // instead of simply giving unknown value, the completion will return the tag-name of an associated opening-element.
                // For example:
                //     var x = <div> </ /*1*/
                // The completion list at "1" will contain "div>" with type any
                // And at `<div> </ /*1*/ >` (with a closing `>`), the completion list will contain "div".
                // And at property access expressions `<MainComponent.Child> </MainComponent. /*1*/ >` the completion will
                // return full closing tag with an optional replacement span
                // For example:
                //     var x = <MainComponent.Child> </     MainComponent /*1*/  >
                //     var y = <MainComponent.Child> </   /*2*/   MainComponent >
                // the completion list at "1" and "2" will contain "MainComponent.Child" with a replacement span of closing tag name
                var hasClosingAngleBracket = !!ts.findChildOfKind(jsxClosingElement, 31 /* SyntaxKind.GreaterThanToken */, sourceFile);
                var tagName = jsxClosingElement.parent.openingElement.tagName;
                var closingTag = tagName.getText(sourceFile);
                var fullClosingTag = closingTag + (hasClosingAngleBracket ? "" : ">");
                var replacementSpan = ts.createTextSpanFromNode(jsxClosingElement.tagName);
                var entry = {
                    name: fullClosingTag,
                    kind: "class" /* ScriptElementKind.classElement */,
                    kindModifiers: undefined,
                    sortText: Completions.SortText.LocationPriority,
                };
                return { isGlobalCompletion: false, isMemberCompletion: true, isNewIdentifierLocation: false, optionalReplacementSpan: replacementSpan, entries: [entry] };
            }
            return;
        }
        function getJSCompletionEntries(sourceFile, position, uniqueNames, target, entries) {
            ts.getNameTable(sourceFile).forEach(function (pos, name) {
                // Skip identifiers produced only from the current location
                if (pos === position) {
                    return;
                }
                var realName = ts.unescapeLeadingUnderscores(name);
                if (!uniqueNames.has(realName) && ts.isIdentifierText(realName, target)) {
                    uniqueNames.add(realName);
                    ts.insertSorted(entries, {
                        name: realName,
                        kind: "warning" /* ScriptElementKind.warning */,
                        kindModifiers: "",
                        sortText: Completions.SortText.JavascriptIdentifiers,
                        isFromUncheckedFile: true
                    }, compareCompletionEntries);
                }
            });
        }
        function completionNameForLiteral(sourceFile, preferences, literal) {
            return typeof literal === "object" ? ts.pseudoBigIntToString(literal) + "n" :
                ts.isString(literal) ? ts.quote(sourceFile, preferences, literal) : JSON.stringify(literal);
        }
        function createCompletionEntryForLiteral(sourceFile, preferences, literal) {
            return { name: completionNameForLiteral(sourceFile, preferences, literal), kind: "string" /* ScriptElementKind.string */, kindModifiers: "" /* ScriptElementKindModifier.none */, sortText: Completions.SortText.LocationPriority };
        }
        function createCompletionEntry(symbol, sortText, replacementToken, contextToken, location, sourceFile, host, program, name, needsConvertPropertyAccess, origin, recommendedCompletion, propertyAccessToConvert, isJsxInitializer, importCompletionNode, useSemicolons, options, preferences, completionKind, formatContext, isJsxIdentifierExpected, isRightOfOpenTag) {
            var _a, _b;
            var insertText;
            var replacementSpan = ts.getReplacementSpanForContextToken(replacementToken);
            var data;
            var isSnippet;
            var source = getSourceFromOrigin(origin);
            var sourceDisplay;
            var hasAction;
            var labelDetails;
            var typeChecker = program.getTypeChecker();
            var insertQuestionDot = origin && originIsNullableMember(origin);
            var useBraces = origin && originIsSymbolMember(origin) || needsConvertPropertyAccess;
            if (origin && originIsThisType(origin)) {
                insertText = needsConvertPropertyAccess
                    ? "this".concat(insertQuestionDot ? "?." : "", "[").concat(quotePropertyName(sourceFile, preferences, name), "]")
                    : "this".concat(insertQuestionDot ? "?." : ".").concat(name);
            }
            // We should only have needsConvertPropertyAccess if there's a property access to convert. But see #21790.
            // Somehow there was a global with a non-identifier name. Hopefully someone will complain about getting a "foo bar" global completion and provide a repro.
            else if ((useBraces || insertQuestionDot) && propertyAccessToConvert) {
                insertText = useBraces ? needsConvertPropertyAccess ? "[".concat(quotePropertyName(sourceFile, preferences, name), "]") : "[".concat(name, "]") : name;
                if (insertQuestionDot || propertyAccessToConvert.questionDotToken) {
                    insertText = "?.".concat(insertText);
                }
                var dot = ts.findChildOfKind(propertyAccessToConvert, 24 /* SyntaxKind.DotToken */, sourceFile) ||
                    ts.findChildOfKind(propertyAccessToConvert, 28 /* SyntaxKind.QuestionDotToken */, sourceFile);
                if (!dot) {
                    return undefined;
                }
                // If the text after the '.' starts with this name, write over it. Else, add new text.
                var end = ts.startsWith(name, propertyAccessToConvert.name.text) ? propertyAccessToConvert.name.end : dot.end;
                replacementSpan = ts.createTextSpanFromBounds(dot.getStart(sourceFile), end);
            }
            if (isJsxInitializer) {
                if (insertText === undefined)
                    insertText = name;
                insertText = "{".concat(insertText, "}");
                if (typeof isJsxInitializer !== "boolean") {
                    replacementSpan = ts.createTextSpanFromNode(isJsxInitializer, sourceFile);
                }
            }
            if (origin && originIsPromise(origin) && propertyAccessToConvert) {
                if (insertText === undefined)
                    insertText = name;
                var precedingToken = ts.findPrecedingToken(propertyAccessToConvert.pos, sourceFile);
                var awaitText = "";
                if (precedingToken && ts.positionIsASICandidate(precedingToken.end, precedingToken.parent, sourceFile)) {
                    awaitText = ";";
                }
                awaitText += "(await ".concat(propertyAccessToConvert.expression.getText(), ")");
                insertText = needsConvertPropertyAccess ? "".concat(awaitText).concat(insertText) : "".concat(awaitText).concat(insertQuestionDot ? "?." : ".").concat(insertText);
                replacementSpan = ts.createTextSpanFromBounds(propertyAccessToConvert.getStart(sourceFile), propertyAccessToConvert.end);
            }
            if (originIsResolvedExport(origin)) {
                sourceDisplay = [ts.textPart(origin.moduleSpecifier)];
                if (importCompletionNode) {
                    (_a = getInsertTextAndReplacementSpanForImportCompletion(name, importCompletionNode, contextToken, origin, useSemicolons, options, preferences), insertText = _a.insertText, replacementSpan = _a.replacementSpan);
                    isSnippet = preferences.includeCompletionsWithSnippetText ? true : undefined;
                }
            }
            if ((origin === null || origin === void 0 ? void 0 : origin.kind) === 64 /* SymbolOriginInfoKind.TypeOnlyAlias */) {
                hasAction = true;
            }
            if (preferences.includeCompletionsWithClassMemberSnippets &&
                preferences.includeCompletionsWithInsertText &&
                completionKind === 3 /* CompletionKind.MemberLike */ &&
                isClassLikeMemberCompletion(symbol, location)) {
                var importAdder = void 0;
                (_b = getEntryForMemberCompletion(host, program, options, preferences, name, symbol, location, contextToken, formatContext), insertText = _b.insertText, isSnippet = _b.isSnippet, importAdder = _b.importAdder, replacementSpan = _b.replacementSpan);
                sortText = Completions.SortText.ClassMemberSnippets; // sortText has to be lower priority than the sortText for keywords. See #47852.
                if (importAdder === null || importAdder === void 0 ? void 0 : importAdder.hasFixes()) {
                    hasAction = true;
                    source = CompletionSource.ClassMemberSnippet;
                }
            }
            if (origin && originIsObjectLiteralMethod(origin)) {
                (insertText = origin.insertText, isSnippet = origin.isSnippet, labelDetails = origin.labelDetails);
                if (!preferences.useLabelDetailsInCompletionEntries) {
                    name = name + labelDetails.detail;
                    labelDetails = undefined;
                }
                source = CompletionSource.ObjectLiteralMethodSnippet;
                sortText = Completions.SortText.SortBelow(sortText);
            }
            if (isJsxIdentifierExpected && !isRightOfOpenTag && preferences.includeCompletionsWithSnippetText && preferences.jsxAttributeCompletionStyle && preferences.jsxAttributeCompletionStyle !== "none") {
                var useBraces_1 = preferences.jsxAttributeCompletionStyle === "braces";
                var type = typeChecker.getTypeOfSymbolAtLocation(symbol, location);
                // If is boolean like or undefined, don't return a snippet we want just to return the completion.
                if (preferences.jsxAttributeCompletionStyle === "auto"
                    && !(type.flags & 528 /* TypeFlags.BooleanLike */)
                    && !(type.flags & 1048576 /* TypeFlags.Union */ && ts.find(type.types, function (type) { return !!(type.flags & 528 /* TypeFlags.BooleanLike */); }))) {
                    if (type.flags & 402653316 /* TypeFlags.StringLike */ || (type.flags & 1048576 /* TypeFlags.Union */ && ts.every(type.types, function (type) { return !!(type.flags & (402653316 /* TypeFlags.StringLike */ | 32768 /* TypeFlags.Undefined */)); }))) {
                        // If is string like or undefined use quotes
                        insertText = "".concat(ts.escapeSnippetText(name), "=").concat(ts.quote(sourceFile, preferences, "$1"));
                        isSnippet = true;
                    }
                    else {
                        // Use braces for everything else
                        useBraces_1 = true;
                    }
                }
                if (useBraces_1) {
                    insertText = "".concat(ts.escapeSnippetText(name), "={$1}");
                    isSnippet = true;
                }
            }
            if (insertText !== undefined && !preferences.includeCompletionsWithInsertText) {
                return undefined;
            }
            if (originIsExport(origin) || originIsResolvedExport(origin)) {
                data = originToCompletionEntryData(origin);
                hasAction = !importCompletionNode;
            }
            // TODO(drosen): Right now we just permit *all* semantic meanings when calling
            // 'getSymbolKind' which is permissible given that it is backwards compatible; but
            // really we should consider passing the meaning for the node so that we don't report
            // that a suggestion for a value is an interface.  We COULD also just do what
            // 'getSymbolModifiers' does, which is to use the first declaration.
            // Use a 'sortText' of 0' so that all symbol completion entries come before any other
            // entries (like JavaScript identifier entries).
            return {
                name: name,
                kind: ts.SymbolDisplay.getSymbolKind(typeChecker, symbol, location),
                kindModifiers: ts.SymbolDisplay.getSymbolModifiers(typeChecker, symbol),
                sortText: sortText,
                source: source,
                hasAction: hasAction ? true : undefined,
                isRecommended: isRecommendedCompletionMatch(symbol, recommendedCompletion, typeChecker) || undefined,
                insertText: insertText,
                replacementSpan: replacementSpan,
                sourceDisplay: sourceDisplay,
                labelDetails: labelDetails,
                isSnippet: isSnippet,
                isPackageJsonImport: originIsPackageJsonImport(origin) || undefined,
                isImportStatementCompletion: !!importCompletionNode || undefined,
                data: data,
            };
        }
        function isClassLikeMemberCompletion(symbol, location) {
            // TODO: support JS files.
            if (ts.isInJSFile(location)) {
                return false;
            }
            // Completion symbol must be for a class member.
            var memberFlags = 106500 /* SymbolFlags.ClassMember */
                & 900095 /* SymbolFlags.EnumMemberExcludes */;
            /* In
            `class C {
                |
            }`
            `location` is a class-like declaration.
            In
            `class C {
                m|
            }`
            `location` is an identifier,
            `location.parent` is a class element declaration,
            and `location.parent.parent` is a class-like declaration.
            In
            `abstract class C {
                abstract
                abstract m|
            }`
            `location` is a syntax list (with modifiers as children),
            and `location.parent` is a class-like declaration.
            */
            return !!(symbol.flags & memberFlags) &&
                (ts.isClassLike(location) ||
                    (location.parent &&
                        location.parent.parent &&
                        ts.isClassElement(location.parent) &&
                        location === location.parent.name &&
                        ts.isClassLike(location.parent.parent)) ||
                    (location.parent &&
                        ts.isSyntaxList(location) &&
                        ts.isClassLike(location.parent)));
        }
        function getEntryForMemberCompletion(host, program, options, preferences, name, symbol, location, contextToken, formatContext) {
            var classLikeDeclaration = ts.findAncestor(location, ts.isClassLike);
            if (!classLikeDeclaration) {
                return { insertText: name };
            }
            var isSnippet;
            var replacementSpan;
            var insertText = name;
            var checker = program.getTypeChecker();
            var sourceFile = location.getSourceFile();
            var printer = createSnippetPrinter({
                removeComments: true,
                module: options.module,
                target: options.target,
                omitTrailingSemicolon: false,
                newLine: ts.getNewLineKind(ts.getNewLineCharacter(options, ts.maybeBind(host, host.getNewLine))),
            });
            var importAdder = ts.codefix.createImportAdder(sourceFile, program, preferences, host);
            // Create empty body for possible method implementation.
            var body;
            if (preferences.includeCompletionsWithSnippetText) {
                isSnippet = true;
                // We are adding a tabstop (i.e. `$0`) in the body of the suggested member,
                // if it has one, so that the cursor ends up in the body once the completion is inserted.
                // Note: this assumes we won't have more than one body in the completion nodes, which should be the case.
                var emptyStmt = ts.factory.createEmptyStatement();
                body = ts.factory.createBlock([emptyStmt], /* multiline */ true);
                ts.setSnippetElement(emptyStmt, { kind: 0 /* SnippetKind.TabStop */, order: 0 });
            }
            else {
                body = ts.factory.createBlock([], /* multiline */ true);
            }
            var modifiers = 0 /* ModifierFlags.None */;
            // Whether the suggested member should be abstract.
            // e.g. in `abstract class C { abstract | }`, we should offer abstract method signatures at position `|`.
            var _a = getPresentModifiers(contextToken), presentModifiers = _a.modifiers, modifiersSpan = _a.span;
            var isAbstract = !!(presentModifiers & 128 /* ModifierFlags.Abstract */);
            var completionNodes = [];
            ts.codefix.addNewNodeForMemberSymbol(symbol, classLikeDeclaration, sourceFile, { program: program, host: host }, preferences, importAdder, 
            // `addNewNodeForMemberSymbol` calls this callback function for each new member node
            // it adds for the given member symbol.
            // We store these member nodes in the `completionNodes` array.
            // Note: there might be:
            //  - No nodes if `addNewNodeForMemberSymbol` cannot figure out a node for the member;
            //  - One node;
            //  - More than one node if the member is overloaded (e.g. a method with overload signatures).
            function (node) {
                var requiredModifiers = 0 /* ModifierFlags.None */;
                if (isAbstract) {
                    requiredModifiers |= 128 /* ModifierFlags.Abstract */;
                }
                if (ts.isClassElement(node)
                    && checker.getMemberOverrideModifierStatus(classLikeDeclaration, node) === 1 /* MemberOverrideStatus.NeedsOverride */) {
                    requiredModifiers |= 16384 /* ModifierFlags.Override */;
                }
                if (!completionNodes.length) {
                    // Keep track of added missing required modifiers and modifiers already present.
                    // This is needed when we have overloaded signatures,
                    // so this callback will be called for multiple nodes/signatures,
                    // and we need to make sure the modifiers are uniform for all nodes/signatures.
                    modifiers = node.modifierFlagsCache | requiredModifiers | presentModifiers;
                }
                node = ts.factory.updateModifiers(node, modifiers);
                completionNodes.push(node);
            }, body, 2 /* codefix.PreserveOptionalFlags.Property */, isAbstract);
            if (completionNodes.length) {
                var format = 1 /* ListFormat.MultiLine */ | 131072 /* ListFormat.NoTrailingNewLine */;
                replacementSpan = modifiersSpan;
                // If we have access to formatting settings, we print the nodes using the emitter,
                // and then format the printed text.
                if (formatContext) {
                    insertText = printer.printAndFormatSnippetList(format, ts.factory.createNodeArray(completionNodes), sourceFile, formatContext);
                }
                else { // Otherwise, just use emitter to print the new nodes.
                    insertText = printer.printSnippetList(format, ts.factory.createNodeArray(completionNodes), sourceFile);
                }
            }
            return { insertText: insertText, isSnippet: isSnippet, importAdder: importAdder, replacementSpan: replacementSpan };
        }
        function getPresentModifiers(contextToken) {
            if (!contextToken) {
                return { modifiers: 0 /* ModifierFlags.None */ };
            }
            var modifiers = 0 /* ModifierFlags.None */;
            var span;
            var contextMod;
            /*
            Cases supported:
            In
            `class C {
                public abstract |
            }`
            `contextToken` is ``abstract`` (as an identifier),
            `contextToken.parent` is property declaration,
            `location` is class declaration ``class C { ... }``.
            In
            `class C {
                protected override m|
            }`
                `contextToken` is ``override`` (as a keyword),
            `contextToken.parent` is property declaration,
            `location` is identifier ``m``,
            `location.parent` is property declaration ``protected override m``,
            `location.parent.parent` is class declaration ``class C { ... }``.
            */
            if (contextMod = isModifierLike(contextToken)) {
                modifiers |= ts.modifierToFlag(contextMod);
                span = ts.createTextSpanFromNode(contextToken);
            }
            if (ts.isPropertyDeclaration(contextToken.parent)) {
                modifiers |= ts.modifiersToFlags(contextToken.parent.modifiers);
                span = ts.createTextSpanFromNode(contextToken.parent);
            }
            return { modifiers: modifiers, span: span };
        }
        function isModifierLike(node) {
            if (ts.isModifier(node)) {
                return node.kind;
            }
            if (ts.isIdentifier(node) && node.originalKeywordKind && ts.isModifierKind(node.originalKeywordKind)) {
                return node.originalKeywordKind;
            }
            return undefined;
        }
        function getEntryForObjectLiteralMethodCompletion(symbol, name, enclosingDeclaration, program, host, options, preferences, formatContext) {
            var isSnippet = preferences.includeCompletionsWithSnippetText || undefined;
            var insertText = name;
            var sourceFile = enclosingDeclaration.getSourceFile();
            var method = createObjectLiteralMethod(symbol, enclosingDeclaration, sourceFile, program, host, preferences);
            if (!method) {
                return undefined;
            }
            var printer = createSnippetPrinter({
                removeComments: true,
                module: options.module,
                target: options.target,
                omitTrailingSemicolon: false,
                newLine: ts.getNewLineKind(ts.getNewLineCharacter(options, ts.maybeBind(host, host.getNewLine))),
            });
            if (formatContext) {
                insertText = printer.printAndFormatSnippetList(16 /* ListFormat.CommaDelimited */ | 64 /* ListFormat.AllowTrailingComma */, ts.factory.createNodeArray([method], /*hasTrailingComma*/ true), sourceFile, formatContext);
            }
            else {
                insertText = printer.printSnippetList(16 /* ListFormat.CommaDelimited */ | 64 /* ListFormat.AllowTrailingComma */, ts.factory.createNodeArray([method], /*hasTrailingComma*/ true), sourceFile);
            }
            var signaturePrinter = ts.createPrinter({
                removeComments: true,
                module: options.module,
                target: options.target,
                omitTrailingSemicolon: true,
            });
            // The `labelDetails.detail` will be displayed right beside the method name,
            // so we drop the name (and modifiers) from the signature.
            var methodSignature = ts.factory.createMethodSignature(
            /*modifiers*/ undefined, 
            /*name*/ "", method.questionToken, method.typeParameters, method.parameters, method.type);
            var labelDetails = { detail: signaturePrinter.printNode(4 /* EmitHint.Unspecified */, methodSignature, sourceFile) };
            return { isSnippet: isSnippet, insertText: insertText, labelDetails: labelDetails };
        }
        ;
        function createObjectLiteralMethod(symbol, enclosingDeclaration, sourceFile, program, host, preferences) {
            var declarations = symbol.getDeclarations();
            if (!(declarations && declarations.length)) {
                return undefined;
            }
            var checker = program.getTypeChecker();
            var declaration = declarations[0];
            var name = ts.getSynthesizedDeepClone(ts.getNameOfDeclaration(declaration), /*includeTrivia*/ false);
            var type = checker.getWidenedType(checker.getTypeOfSymbolAtLocation(symbol, enclosingDeclaration));
            var quotePreference = ts.getQuotePreference(sourceFile, preferences);
            var builderFlags = quotePreference === 0 /* QuotePreference.Single */ ? 268435456 /* NodeBuilderFlags.UseSingleQuotesForStringLiteralType */ : undefined;
            switch (declaration.kind) {
                case 166 /* SyntaxKind.PropertySignature */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 169 /* SyntaxKind.MethodDeclaration */: {
                    var effectiveType = type.flags & 1048576 /* TypeFlags.Union */ && type.types.length < 10
                        ? checker.getUnionType(type.types, 2 /* UnionReduction.Subtype */)
                        : type;
                    if (effectiveType.flags & 1048576 /* TypeFlags.Union */) {
                        // Only offer the completion if there's a single function type component.
                        var functionTypes = ts.filter(effectiveType.types, function (type) { return checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */).length > 0; });
                        if (functionTypes.length === 1) {
                            effectiveType = functionTypes[0];
                        }
                        else {
                            return undefined;
                        }
                    }
                    var signatures = checker.getSignaturesOfType(effectiveType, 0 /* SignatureKind.Call */);
                    if (signatures.length !== 1) {
                        // We don't support overloads in object literals.
                        return undefined;
                    }
                    var typeNode = checker.typeToTypeNode(effectiveType, enclosingDeclaration, builderFlags, ts.codefix.getNoopSymbolTrackerWithResolver({ program: program, host: host }));
                    if (!typeNode || !ts.isFunctionTypeNode(typeNode)) {
                        return undefined;
                    }
                    var body = void 0;
                    if (preferences.includeCompletionsWithSnippetText) {
                        var emptyStmt = ts.factory.createEmptyStatement();
                        body = ts.factory.createBlock([emptyStmt], /* multiline */ true);
                        ts.setSnippetElement(emptyStmt, { kind: 0 /* SnippetKind.TabStop */, order: 0 });
                    }
                    else {
                        body = ts.factory.createBlock([], /* multiline */ true);
                    }
                    var parameters = typeNode.parameters.map(function (typedParam) {
                        return ts.factory.createParameterDeclaration(
                        /*decorators*/ undefined, 
                        /*modifiers*/ undefined, typedParam.dotDotDotToken, typedParam.name, typedParam.questionToken, 
                        /*type*/ undefined, typedParam.initializer);
                    });
                    return ts.factory.createMethodDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, 
                    /*asteriskToken*/ undefined, name, 
                    /*questionToken*/ undefined, 
                    /*typeParameters*/ undefined, parameters, 
                    /*type*/ undefined, body);
                }
                default:
                    return undefined;
            }
        }
        function createSnippetPrinter(printerOptions) {
            var escapes;
            var baseWriter = ts.textChanges.createWriter(ts.getNewLineCharacter(printerOptions));
            var printer = ts.createPrinter(printerOptions, baseWriter);
            var writer = __assign(__assign({}, baseWriter), { write: function (s) { return escapingWrite(s, function () { return baseWriter.write(s); }); }, nonEscapingWrite: baseWriter.write, writeLiteral: function (s) { return escapingWrite(s, function () { return baseWriter.writeLiteral(s); }); }, writeStringLiteral: function (s) { return escapingWrite(s, function () { return baseWriter.writeStringLiteral(s); }); }, writeSymbol: function (s, symbol) { return escapingWrite(s, function () { return baseWriter.writeSymbol(s, symbol); }); }, writeParameter: function (s) { return escapingWrite(s, function () { return baseWriter.writeParameter(s); }); }, writeComment: function (s) { return escapingWrite(s, function () { return baseWriter.writeComment(s); }); }, writeProperty: function (s) { return escapingWrite(s, function () { return baseWriter.writeProperty(s); }); } });
            return {
                printSnippetList: printSnippetList,
                printAndFormatSnippetList: printAndFormatSnippetList,
            };
            // The formatter/scanner will have issues with snippet-escaped text,
            // so instead of writing the escaped text directly to the writer,
            // generate a set of changes that can be applied to the unescaped text
            // to escape it post-formatting.
            function escapingWrite(s, write) {
                var escaped = ts.escapeSnippetText(s);
                if (escaped !== s) {
                    var start = baseWriter.getTextPos();
                    write();
                    var end = baseWriter.getTextPos();
                    escapes = ts.append(escapes || (escapes = []), { newText: escaped, span: { start: start, length: end - start } });
                }
                else {
                    write();
                }
            }
            /* Snippet-escaping version of `printer.printList`. */
            function printSnippetList(format, list, sourceFile) {
                var unescaped = printUnescapedSnippetList(format, list, sourceFile);
                return escapes ? ts.textChanges.applyChanges(unescaped, escapes) : unescaped;
            }
            function printUnescapedSnippetList(format, list, sourceFile) {
                escapes = undefined;
                writer.clear();
                printer.writeList(format, list, sourceFile, writer);
                return writer.getText();
            }
            function printAndFormatSnippetList(format, list, sourceFile, formatContext) {
                var syntheticFile = {
                    text: printUnescapedSnippetList(format, list, sourceFile),
                    getLineAndCharacterOfPosition: function (pos) {
                        return ts.getLineAndCharacterOfPosition(this, pos);
                    },
                };
                var formatOptions = ts.getFormatCodeSettingsForWriting(formatContext, sourceFile);
                var changes = ts.flatMap(list, function (node) {
                    var nodeWithPos = ts.textChanges.assignPositionsToNode(node);
                    return ts.formatting.formatNodeGivenIndentation(nodeWithPos, syntheticFile, sourceFile.languageVariant, 
                    /* indentation */ 0, 
                    /* delta */ 0, __assign(__assign({}, formatContext), { options: formatOptions }));
                });
                var allChanges = escapes
                    ? ts.stableSort(ts.concatenate(changes, escapes), function (a, b) { return ts.compareTextSpans(a.span, b.span); })
                    : changes;
                return ts.textChanges.applyChanges(syntheticFile.text, allChanges);
            }
        }
        function originToCompletionEntryData(origin) {
            var ambientModuleName = origin.fileName ? undefined : ts.stripQuotes(origin.moduleSymbol.name);
            var isPackageJsonImport = origin.isFromPackageJson ? true : undefined;
            if (originIsResolvedExport(origin)) {
                var resolvedData = {
                    exportName: origin.exportName,
                    moduleSpecifier: origin.moduleSpecifier,
                    ambientModuleName: ambientModuleName,
                    fileName: origin.fileName,
                    isPackageJsonImport: isPackageJsonImport,
                };
                return resolvedData;
            }
            var unresolvedData = {
                exportName: origin.exportName,
                exportMapKey: origin.exportMapKey,
                fileName: origin.fileName,
                ambientModuleName: origin.fileName ? undefined : ts.stripQuotes(origin.moduleSymbol.name),
                isPackageJsonImport: origin.isFromPackageJson ? true : undefined,
            };
            return unresolvedData;
        }
        function completionEntryDataToSymbolOriginInfo(data, completionName, moduleSymbol) {
            var isDefaultExport = data.exportName === "default" /* InternalSymbolName.Default */;
            var isFromPackageJson = !!data.isPackageJsonImport;
            if (completionEntryDataIsResolved(data)) {
                var resolvedOrigin = {
                    kind: 32 /* SymbolOriginInfoKind.ResolvedExport */,
                    exportName: data.exportName,
                    moduleSpecifier: data.moduleSpecifier,
                    symbolName: completionName,
                    fileName: data.fileName,
                    moduleSymbol: moduleSymbol,
                    isDefaultExport: isDefaultExport,
                    isFromPackageJson: isFromPackageJson,
                };
                return resolvedOrigin;
            }
            var unresolvedOrigin = {
                kind: 4 /* SymbolOriginInfoKind.Export */,
                exportName: data.exportName,
                exportMapKey: data.exportMapKey,
                symbolName: completionName,
                fileName: data.fileName,
                moduleSymbol: moduleSymbol,
                isDefaultExport: isDefaultExport,
                isFromPackageJson: isFromPackageJson,
            };
            return unresolvedOrigin;
        }
        function getInsertTextAndReplacementSpanForImportCompletion(name, importCompletionNode, contextToken, origin, useSemicolons, options, preferences) {
            var _a, _b, _c;
            var sourceFile = importCompletionNode.getSourceFile();
            var replacementSpan = ts.createTextSpanFromNode(ts.findAncestor(importCompletionNode, ts.or(ts.isImportDeclaration, ts.isImportEqualsDeclaration)) || importCompletionNode, sourceFile);
            var quotedModuleSpecifier = ts.quote(sourceFile, preferences, origin.moduleSpecifier);
            var exportKind = origin.isDefaultExport ? 1 /* ExportKind.Default */ :
                origin.exportName === "export=" /* InternalSymbolName.ExportEquals */ ? 2 /* ExportKind.ExportEquals */ :
                    0 /* ExportKind.Named */;
            var tabStop = preferences.includeCompletionsWithSnippetText ? "$1" : "";
            var importKind = ts.codefix.getImportKind(sourceFile, exportKind, options, /*forceImportKeyword*/ true);
            var isTopLevelTypeOnly = ((_b = (_a = ts.tryCast(importCompletionNode, ts.isImportDeclaration)) === null || _a === void 0 ? void 0 : _a.importClause) === null || _b === void 0 ? void 0 : _b.isTypeOnly) || ((_c = ts.tryCast(importCompletionNode, ts.isImportEqualsDeclaration)) === null || _c === void 0 ? void 0 : _c.isTypeOnly);
            var isImportSpecifierTypeOnly = couldBeTypeOnlyImportSpecifier(importCompletionNode, contextToken);
            var topLevelTypeOnlyText = isTopLevelTypeOnly ? " ".concat(ts.tokenToString(152 /* SyntaxKind.TypeKeyword */), " ") : " ";
            var importSpecifierTypeOnlyText = isImportSpecifierTypeOnly ? "".concat(ts.tokenToString(152 /* SyntaxKind.TypeKeyword */), " ") : "";
            var suffix = useSemicolons ? ";" : "";
            switch (importKind) {
                case 3 /* ImportKind.CommonJS */: return { replacementSpan: replacementSpan, insertText: "import".concat(topLevelTypeOnlyText).concat(ts.escapeSnippetText(name)).concat(tabStop, " = require(").concat(quotedModuleSpecifier, ")").concat(suffix) };
                case 1 /* ImportKind.Default */: return { replacementSpan: replacementSpan, insertText: "import".concat(topLevelTypeOnlyText).concat(ts.escapeSnippetText(name)).concat(tabStop, " from ").concat(quotedModuleSpecifier).concat(suffix) };
                case 2 /* ImportKind.Namespace */: return { replacementSpan: replacementSpan, insertText: "import".concat(topLevelTypeOnlyText, "* as ").concat(ts.escapeSnippetText(name), " from ").concat(quotedModuleSpecifier).concat(suffix) };
                case 0 /* ImportKind.Named */: return { replacementSpan: replacementSpan, insertText: "import".concat(topLevelTypeOnlyText, "{ ").concat(importSpecifierTypeOnlyText).concat(ts.escapeSnippetText(name)).concat(tabStop, " } from ").concat(quotedModuleSpecifier).concat(suffix) };
            }
        }
        function quotePropertyName(sourceFile, preferences, name) {
            if (/^\d+$/.test(name)) {
                return name;
            }
            return ts.quote(sourceFile, preferences, name);
        }
        function isRecommendedCompletionMatch(localSymbol, recommendedCompletion, checker) {
            return localSymbol === recommendedCompletion ||
                !!(localSymbol.flags & 1048576 /* SymbolFlags.ExportValue */) && checker.getExportSymbolOfSymbol(localSymbol) === recommendedCompletion;
        }
        function getSourceFromOrigin(origin) {
            if (originIsExport(origin)) {
                return ts.stripQuotes(origin.moduleSymbol.name);
            }
            if (originIsResolvedExport(origin)) {
                return origin.moduleSpecifier;
            }
            if ((origin === null || origin === void 0 ? void 0 : origin.kind) === 1 /* SymbolOriginInfoKind.ThisType */) {
                return CompletionSource.ThisProperty;
            }
            if ((origin === null || origin === void 0 ? void 0 : origin.kind) === 64 /* SymbolOriginInfoKind.TypeOnlyAlias */) {
                return CompletionSource.TypeOnlyAlias;
            }
        }
        function getCompletionEntriesFromSymbols(symbols, entries, replacementToken, contextToken, location, sourceFile, host, program, target, log, kind, preferences, compilerOptions, formatContext, isTypeOnlyLocation, propertyAccessToConvert, jsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextMap, isJsxIdentifierExpected, isRightOfOpenTag) {
            var _a;
            var start = ts.timestamp();
            var variableDeclaration = getVariableDeclaration(location);
            var useSemicolons = ts.probablyUsesSemicolons(sourceFile);
            var typeChecker = program.getTypeChecker();
            // Tracks unique names.
            // Value is set to false for global variables or completions from external module exports, because we can have multiple of those;
            // true otherwise. Based on the order we add things we will always see locals first, then globals, then module exports.
            // So adding a completion for a local will prevent us from adding completions for external module exports sharing the same name.
            var uniques = new ts.Map();
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                var origin = symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, !!jsxIdentifierExpected);
                if (!info || (uniques.get(info.name) && (!origin || !originIsObjectLiteralMethod(origin))) || kind === 1 /* CompletionKind.Global */ && symbolToSortTextMap && !shouldIncludeSymbol(symbol, symbolToSortTextMap)) {
                    continue;
                }
                var name = info.name, needsConvertPropertyAccess = info.needsConvertPropertyAccess;
                var originalSortText = (_a = symbolToSortTextMap === null || symbolToSortTextMap === void 0 ? void 0 : symbolToSortTextMap[ts.getSymbolId(symbol)]) !== null && _a !== void 0 ? _a : Completions.SortText.LocationPriority;
                var sortText = (isDeprecated(symbol, typeChecker) ? Completions.SortText.Deprecated(originalSortText) : originalSortText);
                var entry = createCompletionEntry(symbol, sortText, replacementToken, contextToken, location, sourceFile, host, program, name, needsConvertPropertyAccess, origin, recommendedCompletion, propertyAccessToConvert, isJsxInitializer, importCompletionNode, useSemicolons, compilerOptions, preferences, kind, formatContext, isJsxIdentifierExpected, isRightOfOpenTag);
                if (!entry) {
                    continue;
                }
                /** True for locals; false for globals, module exports from other files, `this.` completions. */
                var shouldShadowLaterSymbols = (!origin || originIsTypeOnlyAlias(origin)) && !(symbol.parent === undefined && !ts.some(symbol.declarations, function (d) { return d.getSourceFile() === location.getSourceFile(); }));
                uniques.set(name, shouldShadowLaterSymbols);
                ts.insertSorted(entries, entry, compareCompletionEntries, /*allowDuplicates*/ true);
            }
            log("getCompletionsAtPosition: getCompletionEntriesFromSymbols: " + (ts.timestamp() - start));
            // Prevent consumers of this map from having to worry about
            // the boolean value. Externally, it should be seen as the
            // set of all names.
            return {
                has: function (name) { return uniques.has(name); },
                add: function (name) { return uniques.set(name, true); },
            };
            function shouldIncludeSymbol(symbol, symbolToSortTextMap) {
                var allFlags = symbol.flags;
                if (!ts.isSourceFile(location)) {
                    // export = /**/ here we want to get all meanings, so any symbol is ok
                    if (ts.isExportAssignment(location.parent)) {
                        return true;
                    }
                    // Filter out variables from their own initializers
                    // `const a = /* no 'a' here */`
                    if (variableDeclaration && symbol.valueDeclaration === variableDeclaration) {
                        return false;
                    }
                    // External modules can have global export declarations that will be
                    // available as global keywords in all scopes. But if the external module
                    // already has an explicit export and user only wants to user explicit
                    // module imports then the global keywords will be filtered out so auto
                    // import suggestions will win in the completion
                    var symbolOrigin = ts.skipAlias(symbol, typeChecker);
                    // We only want to filter out the global keywords
                    // Auto Imports are not available for scripts so this conditional is always false
                    if (!!sourceFile.externalModuleIndicator
                        && !compilerOptions.allowUmdGlobalAccess
                        && symbolToSortTextMap[ts.getSymbolId(symbol)] === Completions.SortText.GlobalsOrKeywords
                        && (symbolToSortTextMap[ts.getSymbolId(symbolOrigin)] === Completions.SortText.AutoImportSuggestions
                            || symbolToSortTextMap[ts.getSymbolId(symbolOrigin)] === Completions.SortText.LocationPriority)) {
                        return false;
                    }
                    allFlags |= ts.getCombinedLocalAndExportSymbolFlags(symbolOrigin);
                    // import m = /**/ <-- It can only access namespace (if typing import = x. this would get member symbols and not namespace)
                    if (ts.isInRightSideOfInternalImportEqualsDeclaration(location)) {
                        return !!(allFlags & 1920 /* SymbolFlags.Namespace */);
                    }
                    if (isTypeOnlyLocation) {
                        // It's a type, but you can reach it by namespace.type as well
                        return symbolCanBeReferencedAtTypeLocation(symbol, typeChecker);
                    }
                }
                // expressions are value space (which includes the value namespaces)
                return !!(allFlags & 111551 /* SymbolFlags.Value */);
            }
        }
        Completions.getCompletionEntriesFromSymbols = getCompletionEntriesFromSymbols;
        function getLabelCompletionAtPosition(node) {
            var entries = getLabelStatementCompletions(node);
            if (entries.length) {
                return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: entries };
            }
        }
        function getLabelStatementCompletions(node) {
            var entries = [];
            var uniques = new ts.Map();
            var current = node;
            while (current) {
                if (ts.isFunctionLike(current)) {
                    break;
                }
                if (ts.isLabeledStatement(current)) {
                    var name = current.label.text;
                    if (!uniques.has(name)) {
                        uniques.set(name, true);
                        entries.push({
                            name: name,
                            kindModifiers: "" /* ScriptElementKindModifier.none */,
                            kind: "label" /* ScriptElementKind.label */,
                            sortText: Completions.SortText.LocationPriority
                        });
                    }
                }
                current = current.parent;
            }
            return entries;
        }
        function getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences) {
            if (entryId.data) {
                var autoImport = getAutoImportSymbolFromCompletionEntryData(entryId.name, entryId.data, program, host);
                if (autoImport) {
                    var _a = getRelevantTokens(position, sourceFile), contextToken_1 = _a.contextToken, previousToken_1 = _a.previousToken;
                    return {
                        type: "symbol",
                        symbol: autoImport.symbol,
                        location: ts.getTouchingPropertyName(sourceFile, position),
                        previousToken: previousToken_1,
                        contextToken: contextToken_1,
                        isJsxInitializer: false,
                        isTypeOnlyLocation: false,
                        origin: autoImport.origin,
                    };
                }
            }
            var compilerOptions = program.getCompilerOptions();
            var completionData = getCompletionData(program, log, sourceFile, compilerOptions, position, { includeCompletionsForModuleExports: true, includeCompletionsWithInsertText: true }, entryId, host, /*formatContext*/ undefined);
            if (!completionData) {
                return { type: "none" };
            }
            if (completionData.kind !== 0 /* CompletionDataKind.Data */) {
                return { type: "request", request: completionData };
            }
            var symbols = completionData.symbols, literals = completionData.literals, location = completionData.location, completionKind = completionData.completionKind, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, contextToken = completionData.contextToken, previousToken = completionData.previousToken, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation;
            var literal = ts.find(literals, function (l) { return completionNameForLiteral(sourceFile, preferences, l) === entryId.name; });
            if (literal !== undefined)
                return { type: "literal", literal: literal };
            // Find the symbol with the matching entry name.
            // We don't need to perform character checks here because we're only comparing the
            // name against 'entryName' (which is known to be good), not building a new
            // completion entry.
            return ts.firstDefined(symbols, function (symbol, index) {
                var origin = symbolToOriginInfoMap[index];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, ts.getEmitScriptTarget(compilerOptions), origin, completionKind, completionData.isJsxIdentifierExpected);
                return info && info.name === entryId.name && (entryId.source === CompletionSource.ClassMemberSnippet && symbol.flags & 106500 /* SymbolFlags.ClassMember */
                    || entryId.source === CompletionSource.ObjectLiteralMethodSnippet && symbol.flags & (4 /* SymbolFlags.Property */ | 8192 /* SymbolFlags.Method */)
                    || getSourceFromOrigin(origin) === entryId.source)
                    ? { type: "symbol", symbol: symbol, location: location, origin: origin, contextToken: contextToken, previousToken: previousToken, isJsxInitializer: isJsxInitializer, isTypeOnlyLocation: isTypeOnlyLocation }
                    : undefined;
            }) || { type: "none" };
        }
        function getCompletionEntryDetails(program, log, sourceFile, position, entryId, host, formatContext, preferences, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var name = entryId.name, source = entryId.source, data = entryId.data;
            var contextToken = ts.findPrecedingToken(position, sourceFile);
            if (ts.isInString(sourceFile, position, contextToken)) {
                return Completions.StringCompletions.getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, typeChecker, compilerOptions, host, cancellationToken, preferences);
            }
            // Compute all the completion symbols again.
            var symbolCompletion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            switch (symbolCompletion.type) {
                case "request": {
                    var request = symbolCompletion.request;
                    switch (request.kind) {
                        case 1 /* CompletionDataKind.JsDocTagName */:
                            return ts.JsDoc.getJSDocTagNameCompletionDetails(name);
                        case 2 /* CompletionDataKind.JsDocTag */:
                            return ts.JsDoc.getJSDocTagCompletionDetails(name);
                        case 3 /* CompletionDataKind.JsDocParameterName */:
                            return ts.JsDoc.getJSDocParameterNameCompletionDetails(name);
                        case 4 /* CompletionDataKind.Keywords */:
                            return ts.some(request.keywordCompletions, function (c) { return c.name === name; }) ? createSimpleDetails(name, "keyword" /* ScriptElementKind.keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                        default:
                            return ts.Debug.assertNever(request);
                    }
                }
                case "symbol": {
                    var symbol = symbolCompletion.symbol, location = symbolCompletion.location, contextToken_2 = symbolCompletion.contextToken, origin = symbolCompletion.origin, previousToken = symbolCompletion.previousToken;
                    var _a = getCompletionEntryCodeActionsAndSourceDisplay(name, location, contextToken_2, origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, data, source), codeActions = _a.codeActions, sourceDisplay = _a.sourceDisplay;
                    return createCompletionDetailsForSymbol(symbol, typeChecker, sourceFile, location, cancellationToken, codeActions, sourceDisplay); // TODO: GH#18217
                }
                case "literal": {
                    var literal = symbolCompletion.literal;
                    return createSimpleDetails(completionNameForLiteral(sourceFile, preferences, literal), "string" /* ScriptElementKind.string */, typeof literal === "string" ? ts.SymbolDisplayPartKind.stringLiteral : ts.SymbolDisplayPartKind.numericLiteral);
                }
                case "none":
                    // Didn't find a symbol with this name.  See if we can find a keyword instead.
                    return allKeywordsCompletions().some(function (c) { return c.name === name; }) ? createSimpleDetails(name, "keyword" /* ScriptElementKind.keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                default:
                    ts.Debug.assertNever(symbolCompletion);
            }
        }
        Completions.getCompletionEntryDetails = getCompletionEntryDetails;
        function createSimpleDetails(name, kind, kind2) {
            return createCompletionDetails(name, "" /* ScriptElementKindModifier.none */, kind, [ts.displayPart(name, kind2)]);
        }
        function createCompletionDetailsForSymbol(symbol, checker, sourceFile, location, cancellationToken, codeActions, sourceDisplay) {
            var _a = checker.runWithCancellationToken(cancellationToken, function (checker) {
                return ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(checker, symbol, sourceFile, location, location, 7 /* SemanticMeaning.All */);
            }), displayParts = _a.displayParts, documentation = _a.documentation, symbolKind = _a.symbolKind, tags = _a.tags;
            return createCompletionDetails(symbol.name, ts.SymbolDisplay.getSymbolModifiers(checker, symbol), symbolKind, displayParts, documentation, tags, codeActions, sourceDisplay);
        }
        Completions.createCompletionDetailsForSymbol = createCompletionDetailsForSymbol;
        function createCompletionDetails(name, kindModifiers, kind, displayParts, documentation, tags, codeActions, source) {
            return { name: name, kindModifiers: kindModifiers, kind: kind, displayParts: displayParts, documentation: documentation, tags: tags, codeActions: codeActions, source: source, sourceDisplay: source };
        }
        Completions.createCompletionDetails = createCompletionDetails;
        function getCompletionEntryCodeActionsAndSourceDisplay(name, location, contextToken, origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, data, source) {
            if (data === null || data === void 0 ? void 0 : data.moduleSpecifier) {
                if (previousToken && getImportStatementCompletionInfo(contextToken || previousToken).replacementNode) {
                    // Import statement completion: 'import c|'
                    return { codeActions: undefined, sourceDisplay: [ts.textPart(data.moduleSpecifier)] };
                }
            }
            if (source === CompletionSource.ClassMemberSnippet) {
                var importAdder = getEntryForMemberCompletion(host, program, compilerOptions, preferences, name, symbol, location, contextToken, formatContext).importAdder;
                if (importAdder) {
                    var changes = ts.textChanges.ChangeTracker.with({ host: host, formatContext: formatContext, preferences: preferences }, importAdder.writeFixes);
                    return {
                        sourceDisplay: undefined,
                        codeActions: [{
                                changes: changes,
                                description: ts.diagnosticToString([ts.Diagnostics.Includes_imports_of_types_referenced_by_0, name]),
                            }],
                    };
                }
            }
            if (originIsTypeOnlyAlias(origin)) {
                var codeAction_1 = ts.codefix.getPromoteTypeOnlyCompletionAction(sourceFile, origin.declaration.name, program, host, formatContext, preferences);
                ts.Debug.assertIsDefined(codeAction_1, "Expected to have a code action for promoting type-only alias");
                return { codeActions: [codeAction_1], sourceDisplay: undefined };
            }
            if (!origin || !(originIsExport(origin) || originIsResolvedExport(origin))) {
                return { codeActions: undefined, sourceDisplay: undefined };
            }
            var checker = origin.isFromPackageJson ? host.getPackageJsonAutoImportProvider().getTypeChecker() : program.getTypeChecker();
            var moduleSymbol = origin.moduleSymbol;
            var targetSymbol = checker.getMergedSymbol(ts.skipAlias(symbol.exportSymbol || symbol, checker));
            var isJsxOpeningTagName = (contextToken === null || contextToken === void 0 ? void 0 : contextToken.kind) === 29 /* SyntaxKind.LessThanToken */ && ts.isJsxOpeningLikeElement(contextToken.parent);
            var _a = ts.codefix.getImportCompletionAction(targetSymbol, moduleSymbol, sourceFile, ts.getNameForExportedSymbol(symbol, ts.getEmitScriptTarget(compilerOptions), isJsxOpeningTagName), isJsxOpeningTagName, host, program, formatContext, previousToken && ts.isIdentifier(previousToken) ? previousToken.getStart(sourceFile) : position, preferences), moduleSpecifier = _a.moduleSpecifier, codeAction = _a.codeAction;
            ts.Debug.assert(!(data === null || data === void 0 ? void 0 : data.moduleSpecifier) || moduleSpecifier === data.moduleSpecifier);
            return { sourceDisplay: [ts.textPart(moduleSpecifier)], codeActions: [codeAction] };
        }
        function getCompletionEntrySymbol(program, log, sourceFile, position, entryId, host, preferences) {
            var completion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            return completion.type === "symbol" ? completion.symbol : undefined;
        }
        Completions.getCompletionEntrySymbol = getCompletionEntrySymbol;
        var CompletionDataKind;
        (function (CompletionDataKind) {
            CompletionDataKind[CompletionDataKind["Data"] = 0] = "Data";
            CompletionDataKind[CompletionDataKind["JsDocTagName"] = 1] = "JsDocTagName";
            CompletionDataKind[CompletionDataKind["JsDocTag"] = 2] = "JsDocTag";
            CompletionDataKind[CompletionDataKind["JsDocParameterName"] = 3] = "JsDocParameterName";
            CompletionDataKind[CompletionDataKind["Keywords"] = 4] = "Keywords";
        })(CompletionDataKind || (CompletionDataKind = {}));
        var CompletionKind;
        (function (CompletionKind) {
            CompletionKind[CompletionKind["ObjectPropertyDeclaration"] = 0] = "ObjectPropertyDeclaration";
            CompletionKind[CompletionKind["Global"] = 1] = "Global";
            CompletionKind[CompletionKind["PropertyAccess"] = 2] = "PropertyAccess";
            CompletionKind[CompletionKind["MemberLike"] = 3] = "MemberLike";
            CompletionKind[CompletionKind["String"] = 4] = "String";
            CompletionKind[CompletionKind["None"] = 5] = "None";
        })(CompletionKind = Completions.CompletionKind || (Completions.CompletionKind = {}));
        function getRecommendedCompletion(previousToken, contextualType, checker) {
            // For a union, return the first one with a recommended completion.
            return ts.firstDefined(contextualType && (contextualType.isUnion() ? contextualType.types : [contextualType]), function (type) {
                var symbol = type && type.symbol;
                // Don't include make a recommended completion for an abstract class
                return symbol && (symbol.flags & (8 /* SymbolFlags.EnumMember */ | 384 /* SymbolFlags.Enum */ | 32 /* SymbolFlags.Class */) && !ts.isAbstractConstructorSymbol(symbol))
                    ? getFirstSymbolInChain(symbol, previousToken, checker)
                    : undefined;
            });
        }
        function getContextualType(previousToken, position, sourceFile, checker) {
            var parent = previousToken.parent;
            switch (previousToken.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return ts.getContextualTypeFromParent(previousToken, checker);
                case 63 /* SyntaxKind.EqualsToken */:
                    switch (parent.kind) {
                        case 254 /* SyntaxKind.VariableDeclaration */:
                            return checker.getContextualType(parent.initializer); // TODO: GH#18217
                        case 221 /* SyntaxKind.BinaryExpression */:
                            return checker.getTypeAtLocation(parent.left);
                        case 285 /* SyntaxKind.JsxAttribute */:
                            return checker.getContextualTypeForJsxAttribute(parent);
                        default:
                            return undefined;
                    }
                case 103 /* SyntaxKind.NewKeyword */:
                    return checker.getContextualType(parent);
                case 82 /* SyntaxKind.CaseKeyword */:
                    var caseClause = ts.tryCast(parent, ts.isCaseClause);
                    return caseClause ? ts.getSwitchedType(caseClause, checker) : undefined;
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return ts.isJsxExpression(parent) && !ts.isJsxElement(parent.parent) && !ts.isJsxFragment(parent.parent) ? checker.getContextualTypeForJsxAttribute(parent.parent) : undefined;
                default:
                    var argInfo = ts.SignatureHelp.getArgumentInfoForCompletions(previousToken, position, sourceFile);
                    return argInfo ?
                        // At `,`, treat this as the next argument after the comma.
                        checker.getContextualTypeForArgumentAtIndex(argInfo.invocation, argInfo.argumentIndex + (previousToken.kind === 27 /* SyntaxKind.CommaToken */ ? 1 : 0)) :
                        ts.isEqualityOperatorKind(previousToken.kind) && ts.isBinaryExpression(parent) && ts.isEqualityOperatorKind(parent.operatorToken.kind) ?
                            // completion at `x ===/**/` should be for the right side
                            checker.getTypeAtLocation(parent.left) :
                            checker.getContextualType(previousToken);
            }
        }
        function getFirstSymbolInChain(symbol, enclosingDeclaration, checker) {
            var chain = checker.getAccessibleSymbolChain(symbol, enclosingDeclaration, /*meaning*/ 67108863 /* SymbolFlags.All */, /*useOnlyExternalAliasing*/ false);
            if (chain)
                return ts.first(chain);
            return symbol.parent && (isModuleSymbol(symbol.parent) ? symbol : getFirstSymbolInChain(symbol.parent, enclosingDeclaration, checker));
        }
        function isModuleSymbol(symbol) {
            var _a;
            return !!((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.kind === 305 /* SyntaxKind.SourceFile */; }));
        }
        function getCompletionData(program, log, sourceFile, compilerOptions, position, preferences, detailsEntryId, host, formatContext, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var inUncheckedFile = isUncheckedFile(sourceFile, compilerOptions);
            var start = ts.timestamp();
            var currentToken = ts.getTokenAtPosition(sourceFile, position); // TODO: GH#15853
            // We will check for jsdoc comments with insideComment and getJsDocTagAtPosition. (TODO: that seems rather inefficient to check the same thing so many times.)
            log("getCompletionData: Get current token: " + (ts.timestamp() - start));
            start = ts.timestamp();
            var insideComment = ts.isInComment(sourceFile, position, currentToken);
            log("getCompletionData: Is inside comment: " + (ts.timestamp() - start));
            var insideJsDocTagTypeExpression = false;
            var isInSnippetScope = false;
            if (insideComment) {
                if (ts.hasDocComment(sourceFile, position)) {
                    if (sourceFile.text.charCodeAt(position - 1) === 64 /* CharacterCodes.at */) {
                        // The current position is next to the '@' sign, when no tag name being provided yet.
                        // Provide a full list of tag names
                        return { kind: 1 /* CompletionDataKind.JsDocTagName */ };
                    }
                    else {
                        // When completion is requested without "@", we will have check to make sure that
                        // there are no comments prefix the request position. We will only allow "*" and space.
                        // e.g
                        //   /** |c| /*
                        //
                        //   /**
                        //     |c|
                        //    */
                        //
                        //   /**
                        //    * |c|
                        //    */
                        //
                        //   /**
                        //    *         |c|
                        //    */
                        var lineStart = ts.getLineStartPositionForPosition(position, sourceFile);
                        if (!/[^\*|\s(/)]/.test(sourceFile.text.substring(lineStart, position))) {
                            return { kind: 2 /* CompletionDataKind.JsDocTag */ };
                        }
                    }
                }
                // Completion should work inside certain JsDoc tags. For example:
                //     /** @type {number | string} */
                // Completion should work in the brackets
                var tag = getJsDocTagAtPosition(currentToken, position);
                if (tag) {
                    if (tag.tagName.pos <= position && position <= tag.tagName.end) {
                        return { kind: 1 /* CompletionDataKind.JsDocTagName */ };
                    }
                    var typeExpression = tryGetTypeExpressionFromTag(tag);
                    if (typeExpression) {
                        currentToken = ts.getTokenAtPosition(sourceFile, position);
                        if (!currentToken ||
                            (!ts.isDeclarationName(currentToken) &&
                                (currentToken.parent.kind !== 347 /* SyntaxKind.JSDocPropertyTag */ ||
                                    currentToken.parent.name !== currentToken))) {
                            // Use as type location if inside tag's type expression
                            insideJsDocTagTypeExpression = isCurrentlyEditingNode(typeExpression);
                        }
                    }
                    if (!insideJsDocTagTypeExpression && ts.isJSDocParameterTag(tag) && (ts.nodeIsMissing(tag.name) || tag.name.pos <= position && position <= tag.name.end)) {
                        return { kind: 3 /* CompletionDataKind.JsDocParameterName */, tag: tag };
                    }
                }
                if (!insideJsDocTagTypeExpression) {
                    // Proceed if the current position is in jsDoc tag expression; otherwise it is a normal
                    // comment or the plain text part of a jsDoc comment, so no completion should be available
                    log("Returning an empty list because completion was inside a regular comment or plain text part of a JsDoc comment.");
                    return undefined;
                }
            }
            start = ts.timestamp();
            // The decision to provide completion depends on the contextToken, which is determined through the previousToken.
            // Note: 'previousToken' (and thus 'contextToken') can be undefined if we are the beginning of the file
            var isJsOnlyLocation = !insideJsDocTagTypeExpression && ts.isSourceFileJS(sourceFile);
            var tokens = getRelevantTokens(position, sourceFile);
            var previousToken = tokens.previousToken;
            var contextToken = tokens.contextToken;
            log("getCompletionData: Get previous token: " + (ts.timestamp() - start));
            // Find the node where completion is requested on.
            // Also determine whether we are trying to complete with members of that node
            // or attributes of a JSX tag.
            var node = currentToken;
            var propertyAccessToConvert;
            var isRightOfDot = false;
            var isRightOfQuestionDot = false;
            var isRightOfOpenTag = false;
            var isStartingCloseTag = false;
            var isJsxInitializer = false;
            var isJsxIdentifierExpected = false;
            var importCompletionNode;
            var location = ts.getTouchingPropertyName(sourceFile, position);
            var keywordFilters = 0 /* KeywordCompletionFilters.None */;
            var isNewIdentifierLocation = false;
            var flags = 0 /* CompletionInfoFlags.None */;
            if (contextToken) {
                var importStatementCompletion = getImportStatementCompletionInfo(contextToken);
                isNewIdentifierLocation = importStatementCompletion.isNewIdentifierLocation;
                if (importStatementCompletion.keywordCompletion) {
                    if (importStatementCompletion.isKeywordOnlyCompletion) {
                        return {
                            kind: 4 /* CompletionDataKind.Keywords */,
                            keywordCompletions: [keywordToCompletionEntry(importStatementCompletion.keywordCompletion)],
                            isNewIdentifierLocation: isNewIdentifierLocation,
                        };
                    }
                    keywordFilters = keywordFiltersFromSyntaxKind(importStatementCompletion.keywordCompletion);
                }
                if (importStatementCompletion.replacementNode && preferences.includeCompletionsForImportStatements && preferences.includeCompletionsWithInsertText) {
                    // Import statement completions use `insertText`, and also require the `data` property of `CompletionEntryIdentifier`
                    // added in TypeScript 4.3 to be sent back from the client during `getCompletionEntryDetails`. Since this feature
                    // is not backward compatible with older clients, the language service defaults to disabling it, allowing newer clients
                    // to opt in with the `includeCompletionsForImportStatements` user preference.
                    importCompletionNode = importStatementCompletion.replacementNode;
                    flags |= 2 /* CompletionInfoFlags.IsImportStatementCompletion */;
                }
                // Bail out if this is a known invalid completion location
                if (!importCompletionNode && isCompletionListBlocker(contextToken)) {
                    log("Returning an empty list because completion was requested in an invalid position.");
                    return keywordFilters
                        ? keywordCompletionData(keywordFilters, isJsOnlyLocation, isNewIdentifierDefinitionLocation())
                        : undefined;
                }
                var parent = contextToken.parent;
                if (contextToken.kind === 24 /* SyntaxKind.DotToken */ || contextToken.kind === 28 /* SyntaxKind.QuestionDotToken */) {
                    isRightOfDot = contextToken.kind === 24 /* SyntaxKind.DotToken */;
                    isRightOfQuestionDot = contextToken.kind === 28 /* SyntaxKind.QuestionDotToken */;
                    switch (parent.kind) {
                        case 206 /* SyntaxKind.PropertyAccessExpression */:
                            propertyAccessToConvert = parent;
                            node = propertyAccessToConvert.expression;
                            var leftmostAccessExpression = ts.getLeftmostAccessExpression(propertyAccessToConvert);
                            if (ts.nodeIsMissing(leftmostAccessExpression) ||
                                ((ts.isCallExpression(node) || ts.isFunctionLike(node)) &&
                                    node.end === contextToken.pos &&
                                    node.getChildCount(sourceFile) &&
                                    ts.last(node.getChildren(sourceFile)).kind !== 21 /* SyntaxKind.CloseParenToken */)) {
                                // This is likely dot from incorrectly parsed expression and user is starting to write spread
                                // eg: Math.min(./**/)
                                // const x = function (./**/) {}
                                // ({./**/})
                                return undefined;
                            }
                            break;
                        case 161 /* SyntaxKind.QualifiedName */:
                            node = parent.left;
                            break;
                        case 261 /* SyntaxKind.ModuleDeclaration */:
                            node = parent.name;
                            break;
                        case 200 /* SyntaxKind.ImportType */:
                            node = parent;
                            break;
                        case 231 /* SyntaxKind.MetaProperty */:
                            node = parent.getFirstToken(sourceFile);
                            ts.Debug.assert(node.kind === 100 /* SyntaxKind.ImportKeyword */ || node.kind === 103 /* SyntaxKind.NewKeyword */);
                            break;
                        default:
                            // There is nothing that precedes the dot, so this likely just a stray character
                            // or leading into a '...' token. Just bail out instead.
                            return undefined;
                    }
                }
                else if (!importCompletionNode && sourceFile.languageVariant === 1 /* LanguageVariant.JSX */) {
                    // <UI.Test /* completion position */ />
                    // If the tagname is a property access expression, we will then walk up to the top most of property access expression.
                    // Then, try to get a JSX container and its associated attributes type.
                    if (parent && parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                        contextToken = parent;
                        parent = parent.parent;
                    }
                    // Fix location
                    if (currentToken.parent === location) {
                        switch (currentToken.kind) {
                            case 31 /* SyntaxKind.GreaterThanToken */:
                                if (currentToken.parent.kind === 278 /* SyntaxKind.JsxElement */ || currentToken.parent.kind === 280 /* SyntaxKind.JsxOpeningElement */) {
                                    location = currentToken;
                                }
                                break;
                            case 43 /* SyntaxKind.SlashToken */:
                                if (currentToken.parent.kind === 279 /* SyntaxKind.JsxSelfClosingElement */) {
                                    location = currentToken;
                                }
                                break;
                        }
                    }
                    switch (parent.kind) {
                        case 281 /* SyntaxKind.JsxClosingElement */:
                            if (contextToken.kind === 43 /* SyntaxKind.SlashToken */) {
                                isStartingCloseTag = true;
                                location = contextToken;
                            }
                            break;
                        case 221 /* SyntaxKind.BinaryExpression */:
                            if (!binaryExpressionMayBeOpenTag(parent)) {
                                break;
                            }
                        // falls through
                        case 279 /* SyntaxKind.JsxSelfClosingElement */:
                        case 278 /* SyntaxKind.JsxElement */:
                        case 280 /* SyntaxKind.JsxOpeningElement */:
                            isJsxIdentifierExpected = true;
                            if (contextToken.kind === 29 /* SyntaxKind.LessThanToken */) {
                                isRightOfOpenTag = true;
                                location = contextToken;
                            }
                            break;
                        case 288 /* SyntaxKind.JsxExpression */:
                        case 287 /* SyntaxKind.JsxSpreadAttribute */:
                            // For `<div foo={true} [||] ></div>`, `parent` will be `{true}` and `previousToken` will be `}`
                            if (previousToken.kind === 19 /* SyntaxKind.CloseBraceToken */ && currentToken.kind === 31 /* SyntaxKind.GreaterThanToken */) {
                                isJsxIdentifierExpected = true;
                            }
                            break;
                        case 285 /* SyntaxKind.JsxAttribute */:
                            // For `<div className="x" [||] ></div>`, `parent` will be JsxAttribute and `previousToken` will be its initializer
                            if (parent.initializer === previousToken &&
                                previousToken.end < position) {
                                isJsxIdentifierExpected = true;
                                break;
                            }
                            switch (previousToken.kind) {
                                case 63 /* SyntaxKind.EqualsToken */:
                                    isJsxInitializer = true;
                                    break;
                                case 79 /* SyntaxKind.Identifier */:
                                    isJsxIdentifierExpected = true;
                                    // For `<div x=[|f/**/|]`, `parent` will be `x` and `previousToken.parent` will be `f` (which is its own JsxAttribute)
                                    // Note for `<div someBool f>` we don't want to treat this as a jsx inializer, instead it's the attribute name.
                                    if (parent !== previousToken.parent &&
                                        !parent.initializer &&
                                        ts.findChildOfKind(parent, 63 /* SyntaxKind.EqualsToken */, sourceFile)) {
                                        isJsxInitializer = previousToken;
                                    }
                            }
                            break;
                    }
                }
            }
            var semanticStart = ts.timestamp();
            var completionKind = 5 /* CompletionKind.None */;
            var isNonContextualObjectLiteral = false;
            var hasUnresolvedAutoImports = false;
            // This also gets mutated in nested-functions after the return
            var symbols = [];
            var importSpecifierResolver;
            var symbolToOriginInfoMap = [];
            var symbolToSortTextMap = [];
            var seenPropertySymbols = new ts.Map();
            var isTypeOnlyLocation = isTypeOnlyCompletion();
            var getModuleSpecifierResolutionHost = ts.memoizeOne(function (isFromPackageJson) {
                return ts.createModuleSpecifierResolutionHost(isFromPackageJson ? host.getPackageJsonAutoImportProvider() : program, host);
            });
            if (isRightOfDot || isRightOfQuestionDot) {
                getTypeScriptMemberSymbols();
            }
            else if (isRightOfOpenTag) {
                symbols = typeChecker.getJsxIntrinsicTagNamesAt(location);
                ts.Debug.assertEachIsDefined(symbols, "getJsxIntrinsicTagNames() should all be defined");
                tryGetGlobalSymbols();
                completionKind = 1 /* CompletionKind.Global */;
                keywordFilters = 0 /* KeywordCompletionFilters.None */;
            }
            else if (isStartingCloseTag) {
                var tagName = contextToken.parent.parent.openingElement.tagName;
                var tagSymbol = typeChecker.getSymbolAtLocation(tagName);
                if (tagSymbol) {
                    symbols = [tagSymbol];
                }
                completionKind = 1 /* CompletionKind.Global */;
                keywordFilters = 0 /* KeywordCompletionFilters.None */;
            }
            else {
                // For JavaScript or TypeScript, if we're not after a dot, then just try to get the
                // global symbols in scope.  These results should be valid for either language as
                // the set of symbols that can be referenced from this location.
                if (!tryGetGlobalSymbols()) {
                    return keywordFilters
                        ? keywordCompletionData(keywordFilters, isJsOnlyLocation, isNewIdentifierLocation)
                        : undefined;
                }
            }
            log("getCompletionData: Semantic work: " + (ts.timestamp() - semanticStart));
            var contextualType = previousToken && getContextualType(previousToken, position, sourceFile, typeChecker);
            var literals = ts.mapDefined(contextualType && (contextualType.isUnion() ? contextualType.types : [contextualType]), function (t) { return t.isLiteral() && !(t.flags & 1024 /* TypeFlags.EnumLiteral */) ? t.value : undefined; });
            var recommendedCompletion = previousToken && contextualType && getRecommendedCompletion(previousToken, contextualType, typeChecker);
            return {
                kind: 0 /* CompletionDataKind.Data */,
                symbols: symbols,
                completionKind: completionKind,
                isInSnippetScope: isInSnippetScope,
                propertyAccessToConvert: propertyAccessToConvert,
                isNewIdentifierLocation: isNewIdentifierLocation,
                location: location,
                keywordFilters: keywordFilters,
                literals: literals,
                symbolToOriginInfoMap: symbolToOriginInfoMap,
                recommendedCompletion: recommendedCompletion,
                previousToken: previousToken,
                contextToken: contextToken,
                isJsxInitializer: isJsxInitializer,
                insideJsDocTagTypeExpression: insideJsDocTagTypeExpression,
                symbolToSortTextMap: symbolToSortTextMap,
                isTypeOnlyLocation: isTypeOnlyLocation,
                isJsxIdentifierExpected: isJsxIdentifierExpected,
                isRightOfOpenTag: isRightOfOpenTag,
                importCompletionNode: importCompletionNode,
                hasUnresolvedAutoImports: hasUnresolvedAutoImports,
                flags: flags,
            };
            function isTagWithTypeExpression(tag) {
                switch (tag.kind) {
                    case 340 /* SyntaxKind.JSDocParameterTag */:
                    case 347 /* SyntaxKind.JSDocPropertyTag */:
                    case 341 /* SyntaxKind.JSDocReturnTag */:
                    case 343 /* SyntaxKind.JSDocTypeTag */:
                    case 345 /* SyntaxKind.JSDocTypedefTag */:
                        return true;
                    case 344 /* SyntaxKind.JSDocTemplateTag */:
                        return !!tag.constraint;
                    default:
                        return false;
                }
            }
            function tryGetTypeExpressionFromTag(tag) {
                if (isTagWithTypeExpression(tag)) {
                    var typeExpression = ts.isJSDocTemplateTag(tag) ? tag.constraint : tag.typeExpression;
                    return typeExpression && typeExpression.kind === 309 /* SyntaxKind.JSDocTypeExpression */ ? typeExpression : undefined;
                }
                return undefined;
            }
            function getTypeScriptMemberSymbols() {
                // Right of dot member completion list
                completionKind = 2 /* CompletionKind.PropertyAccess */;
                // Since this is qualified name check it's a type node location
                var isImportType = ts.isLiteralImportTypeNode(node);
                var isTypeLocation = insideJsDocTagTypeExpression
                    || (isImportType && !node.isTypeOf)
                    || ts.isPartOfTypeNode(node.parent)
                    || ts.isPossiblyTypeArgumentPosition(contextToken, sourceFile, typeChecker);
                var isRhsOfImportDeclaration = ts.isInRightSideOfInternalImportEqualsDeclaration(node);
                if (ts.isEntityName(node) || isImportType || ts.isPropertyAccessExpression(node)) {
                    var isNamespaceName = ts.isModuleDeclaration(node.parent);
                    if (isNamespaceName)
                        isNewIdentifierLocation = true;
                    var symbol = typeChecker.getSymbolAtLocation(node);
                    if (symbol) {
                        symbol = ts.skipAlias(symbol, typeChecker);
                        if (symbol.flags & (1536 /* SymbolFlags.Module */ | 384 /* SymbolFlags.Enum */)) {
                            // Extract module or enum members
                            var exportedSymbols = typeChecker.getExportsOfModule(symbol);
                            ts.Debug.assertEachIsDefined(exportedSymbols, "getExportsOfModule() should all be defined");
                            var isValidValueAccess_1 = function (symbol) { return typeChecker.isValidPropertyAccess(isImportType ? node : node.parent, symbol.name); };
                            var isValidTypeAccess_1 = function (symbol) { return symbolCanBeReferencedAtTypeLocation(symbol, typeChecker); };
                            var isValidAccess = isNamespaceName
                                // At `namespace N.M/**/`, if this is the only declaration of `M`, don't include `M` as a completion.
                                ? function (symbol) { var _a; return !!(symbol.flags & 1920 /* SymbolFlags.Namespace */) && !((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.every(function (d) { return d.parent === node.parent; })); }
                                : isRhsOfImportDeclaration ?
                                    // Any kind is allowed when dotting off namespace in internal import equals declaration
                                    function (symbol) { return isValidTypeAccess_1(symbol) || isValidValueAccess_1(symbol); } :
                                    isTypeLocation ? isValidTypeAccess_1 : isValidValueAccess_1;
                            for (var _i = 0, exportedSymbols_1 = exportedSymbols; _i < exportedSymbols_1.length; _i++) {
                                var exportedSymbol = exportedSymbols_1[_i];
                                if (isValidAccess(exportedSymbol)) {
                                    symbols.push(exportedSymbol);
                                }
                            }
                            // If the module is merged with a value, we must get the type of the class and add its propertes (for inherited static methods).
                            if (!isTypeLocation &&
                                symbol.declarations &&
                                symbol.declarations.some(function (d) { return d.kind !== 305 /* SyntaxKind.SourceFile */ && d.kind !== 261 /* SyntaxKind.ModuleDeclaration */ && d.kind !== 260 /* SyntaxKind.EnumDeclaration */; })) {
                                var type = typeChecker.getTypeOfSymbolAtLocation(symbol, node).getNonOptionalType();
                                var insertQuestionDot = false;
                                if (type.isNullableType()) {
                                    var canCorrectToQuestionDot = isRightOfDot &&
                                        !isRightOfQuestionDot &&
                                        preferences.includeAutomaticOptionalChainCompletions !== false;
                                    if (canCorrectToQuestionDot || isRightOfQuestionDot) {
                                        type = type.getNonNullableType();
                                        if (canCorrectToQuestionDot) {
                                            insertQuestionDot = true;
                                        }
                                    }
                                }
                                addTypeProperties(type, !!(node.flags & 32768 /* NodeFlags.AwaitContext */), insertQuestionDot);
                            }
                            return;
                        }
                    }
                }
                if (!isTypeLocation) {
                    // GH#39946. Pulling on the type of a node inside of a function with a contextual `this` parameter can result in a circularity
                    // if the `node` is part of the exprssion of a `yield` or `return`. This circularity doesn't exist at compile time because
                    // we will check (and cache) the type of `this` *before* checking the type of the node.
                    typeChecker.tryGetThisTypeAt(node, /*includeGlobalThis*/ false);
                    var type = typeChecker.getTypeAtLocation(node).getNonOptionalType();
                    var insertQuestionDot = false;
                    if (type.isNullableType()) {
                        var canCorrectToQuestionDot = isRightOfDot &&
                            !isRightOfQuestionDot &&
                            preferences.includeAutomaticOptionalChainCompletions !== false;
                        if (canCorrectToQuestionDot || isRightOfQuestionDot) {
                            type = type.getNonNullableType();
                            if (canCorrectToQuestionDot) {
                                insertQuestionDot = true;
                            }
                        }
                    }
                    addTypeProperties(type, !!(node.flags & 32768 /* NodeFlags.AwaitContext */), insertQuestionDot);
                }
            }
            function addTypeProperties(type, insertAwait, insertQuestionDot) {
                isNewIdentifierLocation = !!type.getStringIndexType();
                if (isRightOfQuestionDot && ts.some(type.getCallSignatures())) {
                    isNewIdentifierLocation = true;
                }
                var propertyAccess = node.kind === 200 /* SyntaxKind.ImportType */ ? node : node.parent;
                if (inUncheckedFile) {
                    // In javascript files, for union types, we don't just get the members that
                    // the individual types have in common, we also include all the members that
                    // each individual type has. This is because we're going to add all identifiers
                    // anyways. So we might as well elevate the members that were at least part
                    // of the individual types to a higher status since we know what they are.
                    symbols.push.apply(symbols, ts.filter(getPropertiesForCompletion(type, typeChecker), function (s) { return typeChecker.isValidPropertyAccessForCompletions(propertyAccess, type, s); }));
                }
                else {
                    for (var _i = 0, _a = type.getApparentProperties(); _i < _a.length; _i++) {
                        var symbol = _a[_i];
                        if (typeChecker.isValidPropertyAccessForCompletions(propertyAccess, type, symbol)) {
                            addPropertySymbol(symbol, /* insertAwait */ false, insertQuestionDot);
                        }
                    }
                }
                if (insertAwait && preferences.includeCompletionsWithInsertText) {
                    var promiseType = typeChecker.getPromisedTypeOfPromise(type);
                    if (promiseType) {
                        for (var _b = 0, _c = promiseType.getApparentProperties(); _b < _c.length; _b++) {
                            var symbol = _c[_b];
                            if (typeChecker.isValidPropertyAccessForCompletions(propertyAccess, promiseType, symbol)) {
                                addPropertySymbol(symbol, /* insertAwait */ true, insertQuestionDot);
                            }
                        }
                    }
                }
            }
            function addPropertySymbol(symbol, insertAwait, insertQuestionDot) {
                var _a;
                // For a computed property with an accessible name like `Symbol.iterator`,
                // we'll add a completion for the *name* `Symbol` instead of for the property.
                // If this is e.g. [Symbol.iterator], add a completion for `Symbol`.
                var computedPropertyName = ts.firstDefined(symbol.declarations, function (decl) { return ts.tryCast(ts.getNameOfDeclaration(decl), ts.isComputedPropertyName); });
                if (computedPropertyName) {
                    var leftMostName = getLeftMostName(computedPropertyName.expression); // The completion is for `Symbol`, not `iterator`.
                    var nameSymbol = leftMostName && typeChecker.getSymbolAtLocation(leftMostName);
                    // If this is nested like for `namespace N { export const sym = Symbol(); }`, we'll add the completion for `N`.
                    var firstAccessibleSymbol = nameSymbol && getFirstSymbolInChain(nameSymbol, contextToken, typeChecker);
                    if (firstAccessibleSymbol && ts.addToSeen(seenPropertySymbols, ts.getSymbolId(firstAccessibleSymbol))) {
                        var index = symbols.length;
                        symbols.push(firstAccessibleSymbol);
                        var moduleSymbol = firstAccessibleSymbol.parent;
                        if (!moduleSymbol ||
                            !ts.isExternalModuleSymbol(moduleSymbol) ||
                            typeChecker.tryGetMemberInModuleExportsAndProperties(firstAccessibleSymbol.name, moduleSymbol) !== firstAccessibleSymbol) {
                            symbolToOriginInfoMap[index] = { kind: getNullableSymbolOriginInfoKind(2 /* SymbolOriginInfoKind.SymbolMemberNoExport */) };
                        }
                        else {
                            var fileName = ts.isExternalModuleNameRelative(ts.stripQuotes(moduleSymbol.name)) ? (_a = ts.getSourceFileOfModule(moduleSymbol)) === null || _a === void 0 ? void 0 : _a.fileName : undefined;
                            var moduleSpecifier = ((importSpecifierResolver || (importSpecifierResolver = ts.codefix.createImportSpecifierResolver(sourceFile, program, host, preferences))).getModuleSpecifierForBestExportInfo([{
                                    exportKind: 0 /* ExportKind.Named */,
                                    moduleFileName: fileName,
                                    isFromPackageJson: false,
                                    moduleSymbol: moduleSymbol,
                                    symbol: firstAccessibleSymbol,
                                    targetFlags: ts.skipAlias(firstAccessibleSymbol, typeChecker).flags,
                                }], firstAccessibleSymbol.name, position, ts.isValidTypeOnlyAliasUseSite(location)) || {}).moduleSpecifier;
                            if (moduleSpecifier) {
                                var origin = {
                                    kind: getNullableSymbolOriginInfoKind(6 /* SymbolOriginInfoKind.SymbolMemberExport */),
                                    moduleSymbol: moduleSymbol,
                                    isDefaultExport: false,
                                    symbolName: firstAccessibleSymbol.name,
                                    exportName: firstAccessibleSymbol.name,
                                    fileName: fileName,
                                    moduleSpecifier: moduleSpecifier,
                                };
                                symbolToOriginInfoMap[index] = origin;
                            }
                        }
                    }
                    else if (preferences.includeCompletionsWithInsertText) {
                        addSymbolOriginInfo(symbol);
                        addSymbolSortInfo(symbol);
                        symbols.push(symbol);
                    }
                }
                else {
                    addSymbolOriginInfo(symbol);
                    addSymbolSortInfo(symbol);
                    symbols.push(symbol);
                }
                function addSymbolSortInfo(symbol) {
                    if (isStaticProperty(symbol)) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.LocalDeclarationPriority;
                    }
                }
                function addSymbolOriginInfo(symbol) {
                    if (preferences.includeCompletionsWithInsertText) {
                        if (insertAwait && ts.addToSeen(seenPropertySymbols, ts.getSymbolId(symbol))) {
                            symbolToOriginInfoMap[symbols.length] = { kind: getNullableSymbolOriginInfoKind(8 /* SymbolOriginInfoKind.Promise */) };
                        }
                        else if (insertQuestionDot) {
                            symbolToOriginInfoMap[symbols.length] = { kind: 16 /* SymbolOriginInfoKind.Nullable */ };
                        }
                    }
                }
                function getNullableSymbolOriginInfoKind(kind) {
                    return insertQuestionDot ? kind | 16 /* SymbolOriginInfoKind.Nullable */ : kind;
                }
            }
            /** Given 'a.b.c', returns 'a'. */
            function getLeftMostName(e) {
                return ts.isIdentifier(e) ? e : ts.isPropertyAccessExpression(e) ? getLeftMostName(e.expression) : undefined;
            }
            function tryGetGlobalSymbols() {
                var result = tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols()
                    || tryGetObjectLikeCompletionSymbols()
                    || tryGetImportCompletionSymbols()
                    || tryGetImportOrExportClauseCompletionSymbols()
                    || tryGetLocalNamedExportCompletionSymbols()
                    || tryGetConstructorCompletion()
                    || tryGetClassLikeCompletionSymbols()
                    || tryGetJsxCompletionSymbols()
                    || (getGlobalCompletions(), 1 /* GlobalsSearch.Success */);
                return result === 1 /* GlobalsSearch.Success */;
            }
            function tryGetConstructorCompletion() {
                if (!tryGetConstructorLikeCompletionContainer(contextToken))
                    return 0 /* GlobalsSearch.Continue */;
                // no members, only keywords
                completionKind = 5 /* CompletionKind.None */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                // Has keywords for constructor parameter
                keywordFilters = 4 /* KeywordCompletionFilters.ConstructorParameterKeywords */;
                return 1 /* GlobalsSearch.Success */;
            }
            function tryGetJsxCompletionSymbols() {
                var jsxContainer = tryGetContainingJsxElement(contextToken);
                // Cursor is inside a JSX self-closing element or opening element
                var attrsType = jsxContainer && typeChecker.getContextualType(jsxContainer.attributes);
                if (!attrsType)
                    return 0 /* GlobalsSearch.Continue */;
                var completionsType = jsxContainer && typeChecker.getContextualType(jsxContainer.attributes, 4 /* ContextFlags.Completions */);
                symbols = ts.concatenate(symbols, filterJsxAttributes(getPropertiesForObjectExpression(attrsType, completionsType, jsxContainer.attributes, typeChecker), jsxContainer.attributes.properties));
                setSortTextToOptionalMember();
                completionKind = 3 /* CompletionKind.MemberLike */;
                isNewIdentifierLocation = false;
                return 1 /* GlobalsSearch.Success */;
            }
            function tryGetImportCompletionSymbols() {
                if (!importCompletionNode)
                    return 0 /* GlobalsSearch.Continue */;
                isNewIdentifierLocation = true;
                collectAutoImports();
                return 1 /* GlobalsSearch.Success */;
            }
            function getGlobalCompletions() {
                keywordFilters = tryGetFunctionLikeBodyCompletionContainer(contextToken) ? 5 /* KeywordCompletionFilters.FunctionLikeBodyKeywords */ : 1 /* KeywordCompletionFilters.All */;
                // Get all entities in the current scope.
                completionKind = 1 /* CompletionKind.Global */;
                isNewIdentifierLocation = isNewIdentifierDefinitionLocation();
                if (previousToken !== contextToken) {
                    ts.Debug.assert(!!previousToken, "Expected 'contextToken' to be defined when different from 'previousToken'.");
                }
                // We need to find the node that will give us an appropriate scope to begin
                // aggregating completion candidates. This is achieved in 'getScopeNode'
                // by finding the first node that encompasses a position, accounting for whether a node
                // is "complete" to decide whether a position belongs to the node.
                //
                // However, at the end of an identifier, we are interested in the scope of the identifier
                // itself, but fall outside of the identifier. For instance:
                //
                //      xyz => x$
                //
                // the cursor is outside of both the 'x' and the arrow function 'xyz => x',
                // so 'xyz' is not returned in our results.
                //
                // We define 'adjustedPosition' so that we may appropriately account for
                // being at the end of an identifier. The intention is that if requesting completion
                // at the end of an identifier, it should be effectively equivalent to requesting completion
                // anywhere inside/at the beginning of the identifier. So in the previous case, the
                // 'adjustedPosition' will work as if requesting completion in the following:
                //
                //      xyz => $x
                //
                // If previousToken !== contextToken, then
                //   - 'contextToken' was adjusted to the token prior to 'previousToken'
                //      because we were at the end of an identifier.
                //   - 'previousToken' is defined.
                var adjustedPosition = previousToken !== contextToken ?
                    previousToken.getStart() :
                    position;
                var scopeNode = getScopeNode(contextToken, adjustedPosition, sourceFile) || sourceFile;
                isInSnippetScope = isSnippetScope(scopeNode);
                var symbolMeanings = (isTypeOnlyLocation ? 0 /* SymbolFlags.None */ : 111551 /* SymbolFlags.Value */) | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */;
                var typeOnlyAliasNeedsPromotion = previousToken && !ts.isValidTypeOnlyAliasUseSite(previousToken);
                symbols = ts.concatenate(symbols, typeChecker.getSymbolsInScope(scopeNode, symbolMeanings));
                ts.Debug.assertEachIsDefined(symbols, "getSymbolsInScope() should all be defined");
                for (var i = 0; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    if (!typeChecker.isArgumentsSymbol(symbol) &&
                        !ts.some(symbol.declarations, function (d) { return d.getSourceFile() === sourceFile; })) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.GlobalsOrKeywords;
                    }
                    if (typeOnlyAliasNeedsPromotion && !(symbol.flags & 111551 /* SymbolFlags.Value */)) {
                        var typeOnlyAliasDeclaration = symbol.declarations && ts.find(symbol.declarations, ts.isTypeOnlyImportOrExportDeclaration);
                        if (typeOnlyAliasDeclaration) {
                            var origin = { kind: 64 /* SymbolOriginInfoKind.TypeOnlyAlias */, declaration: typeOnlyAliasDeclaration };
                            symbolToOriginInfoMap[i] = origin;
                        }
                    }
                }
                // Need to insert 'this.' before properties of `this` type, so only do that if `includeInsertTextCompletions`
                if (preferences.includeCompletionsWithInsertText && scopeNode.kind !== 305 /* SyntaxKind.SourceFile */) {
                    var thisType = typeChecker.tryGetThisTypeAt(scopeNode, /*includeGlobalThis*/ false);
                    if (thisType && !isProbablyGlobalType(thisType, sourceFile, typeChecker)) {
                        for (var _i = 0, _a = getPropertiesForCompletion(thisType, typeChecker); _i < _a.length; _i++) {
                            var symbol = _a[_i];
                            symbolToOriginInfoMap[symbols.length] = { kind: 1 /* SymbolOriginInfoKind.ThisType */ };
                            symbols.push(symbol);
                            symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.SuggestedClassMembers;
                        }
                    }
                }
                collectAutoImports();
                if (isTypeOnlyLocation) {
                    keywordFilters = contextToken && ts.isAssertionExpression(contextToken.parent)
                        ? 6 /* KeywordCompletionFilters.TypeAssertionKeywords */
                        : 7 /* KeywordCompletionFilters.TypeKeywords */;
                }
            }
            function shouldOfferImportCompletions() {
                // If already typing an import statement, provide completions for it.
                if (importCompletionNode)
                    return true;
                // If current completion is for non-contextual Object literal shortahands, ignore auto-import symbols
                if (isNonContextualObjectLiteral)
                    return false;
                // If not already a module, must have modules enabled.
                if (!preferences.includeCompletionsForModuleExports)
                    return false;
                // If already using ES modules, OK to continue using them.
                if (sourceFile.externalModuleIndicator || sourceFile.commonJsModuleIndicator)
                    return true;
                // If module transpilation is enabled or we're targeting es6 or above, or not emitting, OK.
                if (ts.compilerOptionsIndicateEsModules(program.getCompilerOptions()))
                    return true;
                // If some file is using ES6 modules, assume that it's OK to add more.
                return ts.programContainsModules(program);
            }
            function isSnippetScope(scopeNode) {
                switch (scopeNode.kind) {
                    case 305 /* SyntaxKind.SourceFile */:
                    case 223 /* SyntaxKind.TemplateExpression */:
                    case 288 /* SyntaxKind.JsxExpression */:
                    case 235 /* SyntaxKind.Block */:
                        return true;
                    default:
                        return ts.isStatement(scopeNode);
                }
            }
            function isTypeOnlyCompletion() {
                return insideJsDocTagTypeExpression
                    || !!importCompletionNode && ts.isTypeOnlyImportOrExportDeclaration(location.parent)
                    || !isContextTokenValueLocation(contextToken) &&
                        (ts.isPossiblyTypeArgumentPosition(contextToken, sourceFile, typeChecker)
                            || ts.isPartOfTypeNode(location)
                            || isContextTokenTypeLocation(contextToken));
            }
            function isContextTokenValueLocation(contextToken) {
                return contextToken &&
                    ((contextToken.kind === 112 /* SyntaxKind.TypeOfKeyword */ &&
                        (contextToken.parent.kind === 181 /* SyntaxKind.TypeQuery */ || ts.isTypeOfExpression(contextToken.parent))) ||
                        (contextToken.kind === 128 /* SyntaxKind.AssertsKeyword */ && contextToken.parent.kind === 177 /* SyntaxKind.TypePredicate */));
            }
            function isContextTokenTypeLocation(contextToken) {
                if (contextToken) {
                    var parentKind = contextToken.parent.kind;
                    switch (contextToken.kind) {
                        case 58 /* SyntaxKind.ColonToken */:
                            return parentKind === 167 /* SyntaxKind.PropertyDeclaration */ ||
                                parentKind === 166 /* SyntaxKind.PropertySignature */ ||
                                parentKind === 164 /* SyntaxKind.Parameter */ ||
                                parentKind === 254 /* SyntaxKind.VariableDeclaration */ ||
                                ts.isFunctionLikeKind(parentKind);
                        case 63 /* SyntaxKind.EqualsToken */:
                            return parentKind === 259 /* SyntaxKind.TypeAliasDeclaration */;
                        case 127 /* SyntaxKind.AsKeyword */:
                            return parentKind === 229 /* SyntaxKind.AsExpression */;
                        case 29 /* SyntaxKind.LessThanToken */:
                            return parentKind === 178 /* SyntaxKind.TypeReference */ ||
                                parentKind === 211 /* SyntaxKind.TypeAssertionExpression */;
                        case 94 /* SyntaxKind.ExtendsKeyword */:
                            return parentKind === 163 /* SyntaxKind.TypeParameter */;
                    }
                }
                return false;
            }
            /** Mutates `symbols`, `symbolToOriginInfoMap`, and `symbolToSortTextMap` */
            function collectAutoImports() {
                var _a, _b;
                if (!shouldOfferImportCompletions())
                    return;
                ts.Debug.assert(!(detailsEntryId === null || detailsEntryId === void 0 ? void 0 : detailsEntryId.data), "Should not run 'collectAutoImports' when faster path is available via `data`");
                if (detailsEntryId && !detailsEntryId.source) {
                    // Asking for completion details for an item that is not an auto-import
                    return;
                }
                flags |= 1 /* CompletionInfoFlags.MayIncludeAutoImports */;
                // import { type | -> token text should be blank
                var isAfterTypeOnlyImportSpecifierModifier = previousToken === contextToken
                    && importCompletionNode
                    && couldBeTypeOnlyImportSpecifier(importCompletionNode, contextToken);
                var lowerCaseTokenText = isAfterTypeOnlyImportSpecifierModifier ? "" :
                    previousToken && ts.isIdentifier(previousToken) ? previousToken.text.toLowerCase() :
                        "";
                var moduleSpecifierCache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
                var exportInfo = ts.getExportInfoMap(sourceFile, host, program, cancellationToken);
                var packageJsonAutoImportProvider = (_b = host.getPackageJsonAutoImportProvider) === null || _b === void 0 ? void 0 : _b.call(host);
                var packageJsonFilter = detailsEntryId ? undefined : ts.createPackageJsonImportFilter(sourceFile, preferences, host);
                resolvingModuleSpecifiers("collectAutoImports", host, importSpecifierResolver || (importSpecifierResolver = ts.codefix.createImportSpecifierResolver(sourceFile, program, host, preferences)), program, position, preferences, !!importCompletionNode, ts.isValidTypeOnlyAliasUseSite(location), function (context) {
                    exportInfo.search(sourceFile.path, 
                    /*preferCapitalized*/ isRightOfOpenTag, function (symbolName, targetFlags) {
                        if (!ts.isIdentifierText(symbolName, ts.getEmitScriptTarget(host.getCompilationSettings())))
                            return false;
                        if (!detailsEntryId && ts.isStringANonContextualKeyword(symbolName))
                            return false;
                        if (!isTypeOnlyLocation && !importCompletionNode && !(targetFlags & 111551 /* SymbolFlags.Value */))
                            return false;
                        if (isTypeOnlyLocation && !(targetFlags & (1536 /* SymbolFlags.Module */ | 788968 /* SymbolFlags.Type */)))
                            return false;
                        // Do not try to auto-import something with a lowercase first letter for a JSX tag
                        var firstChar = symbolName.charCodeAt(0);
                        if (isRightOfOpenTag && (firstChar < 65 /* CharacterCodes.A */ || firstChar > 90 /* CharacterCodes.Z */))
                            return false;
                        if (detailsEntryId)
                            return true;
                        return charactersFuzzyMatchInString(symbolName, lowerCaseTokenText);
                    }, function (info, symbolName, isFromAmbientModule, exportMapKey) {
                        var _a;
                        if (detailsEntryId && !ts.some(info, function (i) { return detailsEntryId.source === ts.stripQuotes(i.moduleSymbol.name); })) {
                            return;
                        }
                        // Do a relatively cheap check to bail early if all re-exports are non-importable
                        // due to file location or package.json dependency filtering. For non-node16+
                        // module resolution modes, getting past this point guarantees that we'll be
                        // able to generate a suitable module specifier, so we can safely show a completion,
                        // even if we defer computing the module specifier.
                        var firstImportableExportInfo = ts.find(info, isImportableExportInfo);
                        if (!firstImportableExportInfo) {
                            return;
                        }
                        // In node16+, module specifier resolution can fail due to modules being blocked
                        // by package.json `exports`. If that happens, don't show a completion item.
                        // N.B. in this resolution mode we always try to resolve module specifiers here,
                        // because we have to know now if it's going to fail so we can omit the completion
                        // from the list.
                        var result = context.tryResolve(info, symbolName, isFromAmbientModule) || {};
                        if (result === "failed")
                            return;
                        // If we skipped resolving module specifiers, our selection of which ExportInfo
                        // to use here is arbitrary, since the info shown in the completion list derived from
                        // it should be identical regardless of which one is used. During the subsequent
                        // `CompletionEntryDetails` request, we'll get all the ExportInfos again and pick
                        // the best one based on the module specifier it produces.
                        var exportInfo = firstImportableExportInfo, moduleSpecifier;
                        if (result !== "skipped") {
                            (_a = result.exportInfo, exportInfo = _a === void 0 ? firstImportableExportInfo : _a, moduleSpecifier = result.moduleSpecifier);
                        }
                        var isDefaultExport = exportInfo.exportKind === 1 /* ExportKind.Default */;
                        var symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(exportInfo.symbol) || exportInfo.symbol;
                        pushAutoImportSymbol(symbol, {
                            kind: moduleSpecifier ? 32 /* SymbolOriginInfoKind.ResolvedExport */ : 4 /* SymbolOriginInfoKind.Export */,
                            moduleSpecifier: moduleSpecifier,
                            symbolName: symbolName,
                            exportMapKey: exportMapKey,
                            exportName: exportInfo.exportKind === 2 /* ExportKind.ExportEquals */ ? "export=" /* InternalSymbolName.ExportEquals */ : exportInfo.symbol.name,
                            fileName: exportInfo.moduleFileName,
                            isDefaultExport: isDefaultExport,
                            moduleSymbol: exportInfo.moduleSymbol,
                            isFromPackageJson: exportInfo.isFromPackageJson,
                        });
                    });
                    hasUnresolvedAutoImports = context.skippedAny();
                    flags |= context.resolvedAny() ? 8 /* CompletionInfoFlags.ResolvedModuleSpecifiers */ : 0;
                    flags |= context.resolvedBeyondLimit() ? 16 /* CompletionInfoFlags.ResolvedModuleSpecifiersBeyondLimit */ : 0;
                });
                function isImportableExportInfo(info) {
                    var moduleFile = ts.tryCast(info.moduleSymbol.valueDeclaration, ts.isSourceFile);
                    if (!moduleFile) {
                        var moduleName = ts.stripQuotes(info.moduleSymbol.name);
                        if (ts.JsTyping.nodeCoreModules.has(moduleName) && ts.startsWith(moduleName, "node:") !== ts.shouldUseUriStyleNodeCoreModules(sourceFile, program)) {
                            return false;
                        }
                        return packageJsonFilter
                            ? packageJsonFilter.allowsImportingAmbientModule(info.moduleSymbol, getModuleSpecifierResolutionHost(info.isFromPackageJson))
                            : true;
                    }
                    return ts.isImportableFile(info.isFromPackageJson ? packageJsonAutoImportProvider : program, sourceFile, moduleFile, preferences, packageJsonFilter, getModuleSpecifierResolutionHost(info.isFromPackageJson), moduleSpecifierCache);
                }
            }
            function pushAutoImportSymbol(symbol, origin) {
                var symbolId = ts.getSymbolId(symbol);
                if (symbolToSortTextMap[symbolId] === Completions.SortText.GlobalsOrKeywords) {
                    // If an auto-importable symbol is available as a global, don't add the auto import
                    return;
                }
                symbolToOriginInfoMap[symbols.length] = origin;
                symbolToSortTextMap[symbolId] = importCompletionNode ? Completions.SortText.LocationPriority : Completions.SortText.AutoImportSuggestions;
                symbols.push(symbol);
            }
            /* Mutates `symbols` and `symbolToOriginInfoMap`. */
            function collectObjectLiteralMethodSymbols(members, enclosingDeclaration) {
                // TODO: support JS files.
                if (ts.isInJSFile(location)) {
                    return;
                }
                members.forEach(function (member) {
                    if (!isObjectLiteralMethodSymbol(member)) {
                        return;
                    }
                    var displayName = getCompletionEntryDisplayNameForSymbol(member, ts.getEmitScriptTarget(compilerOptions), 
                    /*origin*/ undefined, 0 /* CompletionKind.ObjectPropertyDeclaration */, 
                    /*jsxIdentifierExpected*/ false);
                    if (!displayName) {
                        return;
                    }
                    var name = displayName.name;
                    var entryProps = getEntryForObjectLiteralMethodCompletion(member, name, enclosingDeclaration, program, host, compilerOptions, preferences, formatContext);
                    if (!entryProps) {
                        return;
                    }
                    var origin = __assign({ kind: 128 /* SymbolOriginInfoKind.ObjectLiteralMethod */ }, entryProps);
                    flags |= 32 /* CompletionInfoFlags.MayIncludeMethodSnippets */;
                    symbolToOriginInfoMap[symbols.length] = origin;
                    symbols.push(member);
                });
            }
            function isObjectLiteralMethodSymbol(symbol) {
                /*
                    For an object type
                    `type Foo = {
                        bar(x: number): void;
                        foo: (x: string) => string;
                    }`,
                    `bar` will have symbol flag `Method`,
                    `foo` will have symbol flag `Property`.
                */
                if (!(symbol.flags & (4 /* SymbolFlags.Property */ | 8192 /* SymbolFlags.Method */))) {
                    return false;
                }
                return true;
            }
            /**
             * Finds the first node that "embraces" the position, so that one may
             * accurately aggregate locals from the closest containing scope.
             */
            function getScopeNode(initialToken, position, sourceFile) {
                var scope = initialToken;
                while (scope && !ts.positionBelongsToNode(scope, position, sourceFile)) {
                    scope = scope.parent;
                }
                return scope;
            }
            function isCompletionListBlocker(contextToken) {
                var start = ts.timestamp();
                var result = isInStringOrRegularExpressionOrTemplateLiteral(contextToken) ||
                    isSolelyIdentifierDefinitionLocation(contextToken) ||
                    isDotOfNumericLiteral(contextToken) ||
                    isInJsxText(contextToken) ||
                    ts.isBigIntLiteral(contextToken);
                log("getCompletionsAtPosition: isCompletionListBlocker: " + (ts.timestamp() - start));
                return result;
            }
            function isInJsxText(contextToken) {
                if (contextToken.kind === 11 /* SyntaxKind.JsxText */) {
                    return true;
                }
                if (contextToken.kind === 31 /* SyntaxKind.GreaterThanToken */ && contextToken.parent) {
                    // <Component<string> /**/ />
                    // <Component<string> /**/ ><Component>
                    // - contextToken: GreaterThanToken (before cursor)
                    // - location: JsxSelfClosingElement or JsxOpeningElement
                    // - contextToken.parent === location
                    if (location === contextToken.parent && (location.kind === 280 /* SyntaxKind.JsxOpeningElement */ || location.kind === 279 /* SyntaxKind.JsxSelfClosingElement */)) {
                        return false;
                    }
                    if (contextToken.parent.kind === 280 /* SyntaxKind.JsxOpeningElement */) {
                        // <div>/**/
                        // - contextToken: GreaterThanToken (before cursor)
                        // - location: JSXElement
                        // - different parents (JSXOpeningElement, JSXElement)
                        return location.parent.kind !== 280 /* SyntaxKind.JsxOpeningElement */;
                    }
                    if (contextToken.parent.kind === 281 /* SyntaxKind.JsxClosingElement */ || contextToken.parent.kind === 279 /* SyntaxKind.JsxSelfClosingElement */) {
                        return !!contextToken.parent.parent && contextToken.parent.parent.kind === 278 /* SyntaxKind.JsxElement */;
                    }
                }
                return false;
            }
            function isNewIdentifierDefinitionLocation() {
                if (contextToken) {
                    var containingNodeKind = contextToken.parent.kind;
                    var tokenKind = keywordForNode(contextToken);
                    // Previous token may have been a keyword that was converted to an identifier.
                    switch (tokenKind) {
                        case 27 /* SyntaxKind.CommaToken */:
                            return containingNodeKind === 208 /* SyntaxKind.CallExpression */ // func( a, |
                                || containingNodeKind === 171 /* SyntaxKind.Constructor */ // constructor( a, |   /* public, protected, private keywords are allowed here, so show completion */
                                || containingNodeKind === 209 /* SyntaxKind.NewExpression */ // new C(a, |
                                || containingNodeKind === 204 /* SyntaxKind.ArrayLiteralExpression */ // [a, |
                                || containingNodeKind === 221 /* SyntaxKind.BinaryExpression */ // const x = (a, |
                                || containingNodeKind === 179 /* SyntaxKind.FunctionType */ // var x: (s: string, list|
                                || containingNodeKind === 205 /* SyntaxKind.ObjectLiteralExpression */; // const obj = { x, |
                        case 20 /* SyntaxKind.OpenParenToken */:
                            return containingNodeKind === 208 /* SyntaxKind.CallExpression */ // func( |
                                || containingNodeKind === 171 /* SyntaxKind.Constructor */ // constructor( |
                                || containingNodeKind === 209 /* SyntaxKind.NewExpression */ // new C(a|
                                || containingNodeKind === 212 /* SyntaxKind.ParenthesizedExpression */ // const x = (a|
                                || containingNodeKind === 191 /* SyntaxKind.ParenthesizedType */; // function F(pred: (a| /* this can become an arrow function, where 'a' is the argument */
                        case 22 /* SyntaxKind.OpenBracketToken */:
                            return containingNodeKind === 204 /* SyntaxKind.ArrayLiteralExpression */ // [ |
                                || containingNodeKind === 176 /* SyntaxKind.IndexSignature */ // [ | : string ]
                                || containingNodeKind === 162 /* SyntaxKind.ComputedPropertyName */; // [ |    /* this can become an index signature */
                        case 141 /* SyntaxKind.ModuleKeyword */: // module |
                        case 142 /* SyntaxKind.NamespaceKeyword */: // namespace |
                        case 100 /* SyntaxKind.ImportKeyword */: // import |
                            return true;
                        case 24 /* SyntaxKind.DotToken */:
                            return containingNodeKind === 261 /* SyntaxKind.ModuleDeclaration */; // module A.|
                        case 18 /* SyntaxKind.OpenBraceToken */:
                            return containingNodeKind === 257 /* SyntaxKind.ClassDeclaration */ // class A { |
                                || containingNodeKind === 205 /* SyntaxKind.ObjectLiteralExpression */; // const obj = { |
                        case 63 /* SyntaxKind.EqualsToken */:
                            return containingNodeKind === 254 /* SyntaxKind.VariableDeclaration */ // const x = a|
                                || containingNodeKind === 221 /* SyntaxKind.BinaryExpression */; // x = a|
                        case 15 /* SyntaxKind.TemplateHead */:
                            return containingNodeKind === 223 /* SyntaxKind.TemplateExpression */; // `aa ${|
                        case 16 /* SyntaxKind.TemplateMiddle */:
                            return containingNodeKind === 233 /* SyntaxKind.TemplateSpan */; // `aa ${10} dd ${|
                        case 131 /* SyntaxKind.AsyncKeyword */:
                            return containingNodeKind === 169 /* SyntaxKind.MethodDeclaration */ // const obj = { async c|()
                                || containingNodeKind === 297 /* SyntaxKind.ShorthandPropertyAssignment */; // const obj = { async c|
                        case 41 /* SyntaxKind.AsteriskToken */:
                            return containingNodeKind === 169 /* SyntaxKind.MethodDeclaration */; // const obj = { * c|
                    }
                    if (isClassMemberCompletionKeyword(tokenKind)) {
                        return true;
                    }
                }
                return false;
            }
            function isInStringOrRegularExpressionOrTemplateLiteral(contextToken) {
                // To be "in" one of these literals, the position has to be:
                //   1. entirely within the token text.
                //   2. at the end position of an unterminated token.
                //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
                return (ts.isRegularExpressionLiteral(contextToken) || ts.isStringTextContainingNode(contextToken)) && (ts.rangeContainsPositionExclusive(ts.createTextRangeFromSpan(ts.createTextSpanFromNode(contextToken)), position) ||
                    position === contextToken.end && (!!contextToken.isUnterminated || ts.isRegularExpressionLiteral(contextToken)));
            }
            function tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols() {
                var typeLiteralNode = tryGetTypeLiteralNode(contextToken);
                if (!typeLiteralNode)
                    return 0 /* GlobalsSearch.Continue */;
                var intersectionTypeNode = ts.isIntersectionTypeNode(typeLiteralNode.parent) ? typeLiteralNode.parent : undefined;
                var containerTypeNode = intersectionTypeNode || typeLiteralNode;
                var containerExpectedType = getConstraintOfTypeArgumentProperty(containerTypeNode, typeChecker);
                if (!containerExpectedType)
                    return 0 /* GlobalsSearch.Continue */;
                var containerActualType = typeChecker.getTypeFromTypeNode(containerTypeNode);
                var members = getPropertiesForCompletion(containerExpectedType, typeChecker);
                var existingMembers = getPropertiesForCompletion(containerActualType, typeChecker);
                var existingMemberEscapedNames = new ts.Set();
                existingMembers.forEach(function (s) { return existingMemberEscapedNames.add(s.escapedName); });
                symbols = ts.concatenate(symbols, ts.filter(members, function (s) { return !existingMemberEscapedNames.has(s.escapedName); }));
                completionKind = 0 /* CompletionKind.ObjectPropertyDeclaration */;
                isNewIdentifierLocation = true;
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in object literals and object binding patterns.
             * Relevant symbols are stored in the captured 'symbols' variable.
             *
             * @returns true if 'symbols' was successfully populated; false otherwise.
             */
            function tryGetObjectLikeCompletionSymbols() {
                var symbolsStartIndex = symbols.length;
                var objectLikeContainer = tryGetObjectLikeCompletionContainer(contextToken);
                if (!objectLikeContainer)
                    return 0 /* GlobalsSearch.Continue */;
                // We're looking up possible property names from contextual/inferred/declared type.
                completionKind = 0 /* CompletionKind.ObjectPropertyDeclaration */;
                var typeMembers;
                var existingMembers;
                if (objectLikeContainer.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    var instantiatedType = tryGetObjectLiteralContextualType(objectLikeContainer, typeChecker);
                    // Check completions for Object property value shorthand
                    if (instantiatedType === undefined) {
                        if (objectLikeContainer.flags & 33554432 /* NodeFlags.InWithStatement */) {
                            return 2 /* GlobalsSearch.Fail */;
                        }
                        isNonContextualObjectLiteral = true;
                        return 0 /* GlobalsSearch.Continue */;
                    }
                    var completionsType = typeChecker.getContextualType(objectLikeContainer, 4 /* ContextFlags.Completions */);
                    var hasStringIndexType = (completionsType || instantiatedType).getStringIndexType();
                    var hasNumberIndextype = (completionsType || instantiatedType).getNumberIndexType();
                    isNewIdentifierLocation = !!hasStringIndexType || !!hasNumberIndextype;
                    typeMembers = getPropertiesForObjectExpression(instantiatedType, completionsType, objectLikeContainer, typeChecker);
                    existingMembers = objectLikeContainer.properties;
                    if (typeMembers.length === 0) {
                        // Edge case: If NumberIndexType exists
                        if (!hasNumberIndextype) {
                            isNonContextualObjectLiteral = true;
                            return 0 /* GlobalsSearch.Continue */;
                        }
                    }
                }
                else {
                    ts.Debug.assert(objectLikeContainer.kind === 201 /* SyntaxKind.ObjectBindingPattern */);
                    // We are *only* completing on properties from the type being destructured.
                    isNewIdentifierLocation = false;
                    var rootDeclaration = ts.getRootDeclaration(objectLikeContainer.parent);
                    if (!ts.isVariableLike(rootDeclaration))
                        return ts.Debug.fail("Root declaration is not variable-like.");
                    // We don't want to complete using the type acquired by the shape
                    // of the binding pattern; we are only interested in types acquired
                    // through type declaration or inference.
                    // Also proceed if rootDeclaration is a parameter and if its containing function expression/arrow function is contextually typed -
                    // type of parameter will flow in from the contextual type of the function
                    var canGetType = ts.hasInitializer(rootDeclaration) || !!ts.getEffectiveTypeAnnotationNode(rootDeclaration) || rootDeclaration.parent.parent.kind === 244 /* SyntaxKind.ForOfStatement */;
                    if (!canGetType && rootDeclaration.kind === 164 /* SyntaxKind.Parameter */) {
                        if (ts.isExpression(rootDeclaration.parent)) {
                            canGetType = !!typeChecker.getContextualType(rootDeclaration.parent);
                        }
                        else if (rootDeclaration.parent.kind === 169 /* SyntaxKind.MethodDeclaration */ || rootDeclaration.parent.kind === 173 /* SyntaxKind.SetAccessor */) {
                            canGetType = ts.isExpression(rootDeclaration.parent.parent) && !!typeChecker.getContextualType(rootDeclaration.parent.parent);
                        }
                    }
                    if (canGetType) {
                        var typeForObject_1 = typeChecker.getTypeAtLocation(objectLikeContainer);
                        if (!typeForObject_1)
                            return 2 /* GlobalsSearch.Fail */;
                        typeMembers = typeChecker.getPropertiesOfType(typeForObject_1).filter(function (propertySymbol) {
                            return typeChecker.isPropertyAccessible(objectLikeContainer, /*isSuper*/ false, /*writing*/ false, typeForObject_1, propertySymbol);
                        });
                        existingMembers = objectLikeContainer.elements;
                    }
                }
                if (typeMembers && typeMembers.length > 0) {
                    // Add filtered items to the completion list
                    var filteredMembers = filterObjectMembersList(typeMembers, ts.Debug.checkDefined(existingMembers));
                    symbols = ts.concatenate(symbols, filteredMembers);
                    setSortTextToOptionalMember();
                    if (objectLikeContainer.kind === 205 /* SyntaxKind.ObjectLiteralExpression */
                        && preferences.includeCompletionsWithObjectLiteralMethodSnippets
                        && preferences.includeCompletionsWithInsertText) {
                        transformObjectLiteralMembersSortText(symbolsStartIndex);
                        collectObjectLiteralMethodSymbols(filteredMembers, objectLikeContainer);
                    }
                }
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in import clauses and export clauses
             * whose declarations have a module specifier; for instance, symbols will be aggregated for
             *
             *      import { | } from "moduleName";
             *      export { a as foo, | } from "moduleName";
             *
             * but not for
             *
             *      export { | };
             *
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetImportOrExportClauseCompletionSymbols() {
                if (!contextToken)
                    return 0 /* GlobalsSearch.Continue */;
                // `import { |` or `import { a as 0, | }` or `import { type | }`
                var namedImportsOrExports = contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ || contextToken.kind === 27 /* SyntaxKind.CommaToken */ ? ts.tryCast(contextToken.parent, ts.isNamedImportsOrExports) :
                    ts.isTypeKeywordTokenOrIdentifier(contextToken) ? ts.tryCast(contextToken.parent.parent, ts.isNamedImportsOrExports) : undefined;
                if (!namedImportsOrExports)
                    return 0 /* GlobalsSearch.Continue */;
                // We can at least offer `type` at `import { |`
                if (!ts.isTypeKeywordTokenOrIdentifier(contextToken)) {
                    keywordFilters = 8 /* KeywordCompletionFilters.TypeKeyword */;
                }
                // try to show exported member for imported/re-exported module
                var moduleSpecifier = (namedImportsOrExports.kind === 269 /* SyntaxKind.NamedImports */ ? namedImportsOrExports.parent.parent : namedImportsOrExports.parent).moduleSpecifier;
                if (!moduleSpecifier) {
                    isNewIdentifierLocation = true;
                    return namedImportsOrExports.kind === 269 /* SyntaxKind.NamedImports */ ? 2 /* GlobalsSearch.Fail */ : 0 /* GlobalsSearch.Continue */;
                }
                var moduleSpecifierSymbol = typeChecker.getSymbolAtLocation(moduleSpecifier); // TODO: GH#18217
                if (!moduleSpecifierSymbol) {
                    isNewIdentifierLocation = true;
                    return 2 /* GlobalsSearch.Fail */;
                }
                completionKind = 3 /* CompletionKind.MemberLike */;
                isNewIdentifierLocation = false;
                var exports = typeChecker.getExportsAndPropertiesOfModule(moduleSpecifierSymbol);
                var existing = new ts.Set(namedImportsOrExports.elements.filter(function (n) { return !isCurrentlyEditingNode(n); }).map(function (n) { return (n.propertyName || n.name).escapedText; }));
                var uniques = exports.filter(function (e) { return e.escapedName !== "default" /* InternalSymbolName.Default */ && !existing.has(e.escapedName); });
                symbols = ts.concatenate(symbols, uniques);
                if (!uniques.length) {
                    // If there's nothing else to import, don't offer `type` either
                    keywordFilters = 0 /* KeywordCompletionFilters.None */;
                }
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Adds local declarations for completions in named exports:
             *
             *   export { | };
             *
             * Does not check for the absence of a module specifier (`export {} from "./other"`)
             * because `tryGetImportOrExportClauseCompletionSymbols` runs first and handles that,
             * preventing this function from running.
             */
            function tryGetLocalNamedExportCompletionSymbols() {
                var _a;
                var namedExports = contextToken && (contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ || contextToken.kind === 27 /* SyntaxKind.CommaToken */)
                    ? ts.tryCast(contextToken.parent, ts.isNamedExports)
                    : undefined;
                if (!namedExports) {
                    return 0 /* GlobalsSearch.Continue */;
                }
                var localsContainer = ts.findAncestor(namedExports, ts.or(ts.isSourceFile, ts.isModuleDeclaration));
                completionKind = 5 /* CompletionKind.None */;
                isNewIdentifierLocation = false;
                (_a = localsContainer.locals) === null || _a === void 0 ? void 0 : _a.forEach(function (symbol, name) {
                    var _a, _b;
                    symbols.push(symbol);
                    if ((_b = (_a = localsContainer.symbol) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has(name)) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.OptionalMember;
                    }
                });
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in class declaration
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetClassLikeCompletionSymbols() {
                var decl = tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position);
                if (!decl)
                    return 0 /* GlobalsSearch.Continue */;
                // We're looking up possible property names from parent type.
                completionKind = 3 /* CompletionKind.MemberLike */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                keywordFilters = contextToken.kind === 41 /* SyntaxKind.AsteriskToken */ ? 0 /* KeywordCompletionFilters.None */ :
                    ts.isClassLike(decl) ? 2 /* KeywordCompletionFilters.ClassElementKeywords */ : 3 /* KeywordCompletionFilters.InterfaceElementKeywords */;
                // If you're in an interface you don't want to repeat things from super-interface. So just stop here.
                if (!ts.isClassLike(decl))
                    return 1 /* GlobalsSearch.Success */;
                var classElement = contextToken.kind === 26 /* SyntaxKind.SemicolonToken */ ? contextToken.parent.parent : contextToken.parent;
                var classElementModifierFlags = ts.isClassElement(classElement) ? ts.getEffectiveModifierFlags(classElement) : 0 /* ModifierFlags.None */;
                // If this is context token is not something we are editing now, consider if this would lead to be modifier
                if (contextToken.kind === 79 /* SyntaxKind.Identifier */ && !isCurrentlyEditingNode(contextToken)) {
                    switch (contextToken.getText()) {
                        case "private":
                            classElementModifierFlags = classElementModifierFlags | 8 /* ModifierFlags.Private */;
                            break;
                        case "static":
                            classElementModifierFlags = classElementModifierFlags | 32 /* ModifierFlags.Static */;
                            break;
                        case "override":
                            classElementModifierFlags = classElementModifierFlags | 16384 /* ModifierFlags.Override */;
                            break;
                    }
                }
                if (ts.isClassStaticBlockDeclaration(classElement)) {
                    classElementModifierFlags |= 32 /* ModifierFlags.Static */;
                }
                // No member list for private methods
                if (!(classElementModifierFlags & 8 /* ModifierFlags.Private */)) {
                    // List of property symbols of base type that are not private and already implemented
                    var baseTypeNodes = ts.isClassLike(decl) && classElementModifierFlags & 16384 /* ModifierFlags.Override */ ? ts.singleElementArray(ts.getEffectiveBaseTypeNode(decl)) : ts.getAllSuperTypeNodes(decl);
                    var baseSymbols = ts.flatMap(baseTypeNodes, function (baseTypeNode) {
                        var type = typeChecker.getTypeAtLocation(baseTypeNode);
                        return classElementModifierFlags & 32 /* ModifierFlags.Static */ ?
                            (type === null || type === void 0 ? void 0 : type.symbol) && typeChecker.getPropertiesOfType(typeChecker.getTypeOfSymbolAtLocation(type.symbol, decl)) :
                            type && typeChecker.getPropertiesOfType(type);
                    });
                    symbols = ts.concatenate(symbols, filterClassMembersList(baseSymbols, decl.members, classElementModifierFlags));
                }
                return 1 /* GlobalsSearch.Success */;
            }
            function isConstructorParameterCompletion(node) {
                return !!node.parent && ts.isParameter(node.parent) && ts.isConstructorDeclaration(node.parent.parent)
                    && (ts.isParameterPropertyModifier(node.kind) || ts.isDeclarationName(node));
            }
            /**
             * Returns the immediate owning class declaration of a context token,
             * on the condition that one exists and that the context implies completion should be given.
             */
            function tryGetConstructorLikeCompletionContainer(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 20 /* SyntaxKind.OpenParenToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                            return ts.isConstructorDeclaration(contextToken.parent) ? contextToken.parent : undefined;
                        default:
                            if (isConstructorParameterCompletion(contextToken)) {
                                return parent.parent;
                            }
                    }
                }
                return undefined;
            }
            function tryGetFunctionLikeBodyCompletionContainer(contextToken) {
                if (contextToken) {
                    var prev_1;
                    var container = ts.findAncestor(contextToken.parent, function (node) {
                        if (ts.isClassLike(node)) {
                            return "quit";
                        }
                        if (ts.isFunctionLikeDeclaration(node) && prev_1 === node.body) {
                            return true;
                        }
                        prev_1 = node;
                        return false;
                    });
                    return container && container;
                }
            }
            function tryGetContainingJsxElement(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 31 /* SyntaxKind.GreaterThanToken */: // End of a type argument list
                        case 30 /* SyntaxKind.LessThanSlashToken */:
                        case 43 /* SyntaxKind.SlashToken */:
                        case 79 /* SyntaxKind.Identifier */:
                        case 206 /* SyntaxKind.PropertyAccessExpression */:
                        case 286 /* SyntaxKind.JsxAttributes */:
                        case 285 /* SyntaxKind.JsxAttribute */:
                        case 287 /* SyntaxKind.JsxSpreadAttribute */:
                            if (parent && (parent.kind === 279 /* SyntaxKind.JsxSelfClosingElement */ || parent.kind === 280 /* SyntaxKind.JsxOpeningElement */)) {
                                if (contextToken.kind === 31 /* SyntaxKind.GreaterThanToken */) {
                                    var precedingToken = ts.findPrecedingToken(contextToken.pos, sourceFile, /*startNode*/ undefined);
                                    if (!parent.typeArguments || (precedingToken && precedingToken.kind === 43 /* SyntaxKind.SlashToken */))
                                        break;
                                }
                                return parent;
                            }
                            else if (parent.kind === 285 /* SyntaxKind.JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        // The context token is the closing } or " of an attribute, which means
                        // its parent is a JsxExpression, whose parent is a JsxAttribute,
                        // whose parent is a JsxOpeningLikeElement
                        case 10 /* SyntaxKind.StringLiteral */:
                            if (parent && ((parent.kind === 285 /* SyntaxKind.JsxAttribute */) || (parent.kind === 287 /* SyntaxKind.JsxSpreadAttribute */))) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        case 19 /* SyntaxKind.CloseBraceToken */:
                            if (parent &&
                                parent.kind === 288 /* SyntaxKind.JsxExpression */ &&
                                parent.parent && parent.parent.kind === 285 /* SyntaxKind.JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                //                  each JsxAttribute can have initializer as JsxExpression
                                return parent.parent.parent.parent;
                            }
                            if (parent && parent.kind === 287 /* SyntaxKind.JsxSpreadAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                    }
                }
                return undefined;
            }
            /**
             * @returns true if we are certain that the currently edited location must define a new location; false otherwise.
             */
            function isSolelyIdentifierDefinitionLocation(contextToken) {
                var parent = contextToken.parent;
                var containingNodeKind = parent.kind;
                switch (contextToken.kind) {
                    case 27 /* SyntaxKind.CommaToken */:
                        return containingNodeKind === 254 /* SyntaxKind.VariableDeclaration */ ||
                            isVariableDeclarationListButNotTypeArgument(contextToken) ||
                            containingNodeKind === 237 /* SyntaxKind.VariableStatement */ ||
                            containingNodeKind === 260 /* SyntaxKind.EnumDeclaration */ || // enum a { foo, |
                            isFunctionLikeButNotConstructor(containingNodeKind) ||
                            containingNodeKind === 258 /* SyntaxKind.InterfaceDeclaration */ || // interface A<T, |
                            containingNodeKind === 202 /* SyntaxKind.ArrayBindingPattern */ || // var [x, y|
                            containingNodeKind === 259 /* SyntaxKind.TypeAliasDeclaration */ || // type Map, K, |
                            // class A<T, |
                            // var C = class D<T, |
                            (ts.isClassLike(parent) &&
                                !!parent.typeParameters &&
                                parent.typeParameters.end >= contextToken.pos);
                    case 24 /* SyntaxKind.DotToken */:
                        return containingNodeKind === 202 /* SyntaxKind.ArrayBindingPattern */; // var [.|
                    case 58 /* SyntaxKind.ColonToken */:
                        return containingNodeKind === 203 /* SyntaxKind.BindingElement */; // var {x :html|
                    case 22 /* SyntaxKind.OpenBracketToken */:
                        return containingNodeKind === 202 /* SyntaxKind.ArrayBindingPattern */; // var [x|
                    case 20 /* SyntaxKind.OpenParenToken */:
                        return containingNodeKind === 292 /* SyntaxKind.CatchClause */ ||
                            isFunctionLikeButNotConstructor(containingNodeKind);
                    case 18 /* SyntaxKind.OpenBraceToken */:
                        return containingNodeKind === 260 /* SyntaxKind.EnumDeclaration */; // enum a { |
                    case 29 /* SyntaxKind.LessThanToken */:
                        return containingNodeKind === 257 /* SyntaxKind.ClassDeclaration */ || // class A< |
                            containingNodeKind === 226 /* SyntaxKind.ClassExpression */ || // var C = class D< |
                            containingNodeKind === 258 /* SyntaxKind.InterfaceDeclaration */ || // interface A< |
                            containingNodeKind === 259 /* SyntaxKind.TypeAliasDeclaration */ || // type List< |
                            ts.isFunctionLikeKind(containingNodeKind);
                    case 124 /* SyntaxKind.StaticKeyword */:
                        return containingNodeKind === 167 /* SyntaxKind.PropertyDeclaration */ && !ts.isClassLike(parent.parent);
                    case 25 /* SyntaxKind.DotDotDotToken */:
                        return containingNodeKind === 164 /* SyntaxKind.Parameter */ ||
                            (!!parent.parent && parent.parent.kind === 202 /* SyntaxKind.ArrayBindingPattern */); // var [...z|
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                        return containingNodeKind === 164 /* SyntaxKind.Parameter */ && !ts.isConstructorDeclaration(parent.parent);
                    case 127 /* SyntaxKind.AsKeyword */:
                        return containingNodeKind === 270 /* SyntaxKind.ImportSpecifier */ ||
                            containingNodeKind === 275 /* SyntaxKind.ExportSpecifier */ ||
                            containingNodeKind === 268 /* SyntaxKind.NamespaceImport */;
                    case 136 /* SyntaxKind.GetKeyword */:
                    case 149 /* SyntaxKind.SetKeyword */:
                        return !isFromObjectTypeDeclaration(contextToken);
                    case 79 /* SyntaxKind.Identifier */:
                        if (containingNodeKind === 270 /* SyntaxKind.ImportSpecifier */ &&
                            contextToken === parent.name &&
                            contextToken.text === "type") {
                            // import { type | }
                            return false;
                        }
                        break;
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 113 /* SyntaxKind.VarKeyword */:
                    case 100 /* SyntaxKind.ImportKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 137 /* SyntaxKind.InferKeyword */:
                        return true;
                    case 152 /* SyntaxKind.TypeKeyword */:
                        // import { type foo| }
                        return containingNodeKind !== 270 /* SyntaxKind.ImportSpecifier */;
                    case 41 /* SyntaxKind.AsteriskToken */:
                        return ts.isFunctionLike(contextToken.parent) && !ts.isMethodDeclaration(contextToken.parent);
                }
                // If the previous token is keyword corresponding to class member completion keyword
                // there will be completion available here
                if (isClassMemberCompletionKeyword(keywordForNode(contextToken)) && isFromObjectTypeDeclaration(contextToken)) {
                    return false;
                }
                if (isConstructorParameterCompletion(contextToken)) {
                    // constructor parameter completion is available only if
                    // - its modifier of the constructor parameter or
                    // - its name of the parameter and not being edited
                    // eg. constructor(a |<- this shouldnt show completion
                    if (!ts.isIdentifier(contextToken) ||
                        ts.isParameterPropertyModifier(keywordForNode(contextToken)) ||
                        isCurrentlyEditingNode(contextToken)) {
                        return false;
                    }
                }
                // Previous token may have been a keyword that was converted to an identifier.
                switch (keywordForNode(contextToken)) {
                    case 126 /* SyntaxKind.AbstractKeyword */:
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 135 /* SyntaxKind.DeclareKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 124 /* SyntaxKind.StaticKeyword */:
                    case 113 /* SyntaxKind.VarKeyword */:
                        return true;
                    case 131 /* SyntaxKind.AsyncKeyword */:
                        return ts.isPropertyDeclaration(contextToken.parent);
                }
                // If we are inside a class declaration, and `constructor` is totally not present,
                // but we request a completion manually at a whitespace...
                var ancestorClassLike = ts.findAncestor(contextToken.parent, ts.isClassLike);
                if (ancestorClassLike && contextToken === previousToken && isPreviousPropertyDeclarationTerminated(contextToken, position)) {
                    return false; // Don't block completions.
                }
                var ancestorPropertyDeclaraion = ts.getAncestor(contextToken.parent, 167 /* SyntaxKind.PropertyDeclaration */);
                // If we are inside a class declaration and typing `constructor` after property declaration...
                if (ancestorPropertyDeclaraion
                    && contextToken !== previousToken
                    && ts.isClassLike(previousToken.parent.parent)
                    // And the cursor is at the token...
                    && position <= previousToken.end) {
                    // If we are sure that the previous property declaration is terminated according to newline or semicolon...
                    if (isPreviousPropertyDeclarationTerminated(contextToken, previousToken.end)) {
                        return false; // Don't block completions.
                    }
                    else if (contextToken.kind !== 63 /* SyntaxKind.EqualsToken */
                        // Should not block: `class C { blah = c/**/ }`
                        // But should block: `class C { blah = somewhat c/**/ }` and `class C { blah: SomeType c/**/ }`
                        && (ts.isInitializedProperty(ancestorPropertyDeclaraion)
                            || ts.hasType(ancestorPropertyDeclaraion))) {
                        return true;
                    }
                }
                return ts.isDeclarationName(contextToken)
                    && !ts.isShorthandPropertyAssignment(contextToken.parent)
                    && !ts.isJsxAttribute(contextToken.parent)
                    // Don't block completions if we're in `class C /**/`, because we're *past* the end of the identifier and might want to complete `extends`.
                    // If `contextToken !== previousToken`, this is `class C ex/**/`.
                    && !(ts.isClassLike(contextToken.parent) && (contextToken !== previousToken || position > previousToken.end));
            }
            function isPreviousPropertyDeclarationTerminated(contextToken, position) {
                return contextToken.kind !== 63 /* SyntaxKind.EqualsToken */ &&
                    (contextToken.kind === 26 /* SyntaxKind.SemicolonToken */
                        || !ts.positionsAreOnSameLine(contextToken.end, position, sourceFile));
            }
            function isFunctionLikeButNotConstructor(kind) {
                return ts.isFunctionLikeKind(kind) && kind !== 171 /* SyntaxKind.Constructor */;
            }
            function isDotOfNumericLiteral(contextToken) {
                if (contextToken.kind === 8 /* SyntaxKind.NumericLiteral */) {
                    var text = contextToken.getFullText();
                    return text.charAt(text.length - 1) === ".";
                }
                return false;
            }
            function isVariableDeclarationListButNotTypeArgument(node) {
                return node.parent.kind === 255 /* SyntaxKind.VariableDeclarationList */
                    && !ts.isPossiblyTypeArgumentPosition(node, sourceFile, typeChecker);
            }
            /**
             * Filters out completion suggestions for named imports or exports.
             *
             * @returns Symbols to be suggested in an object binding pattern or object literal expression, barring those whose declarations
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterObjectMembersList(contextualMemberSymbols, existingMembers) {
                if (existingMembers.length === 0) {
                    return contextualMemberSymbols;
                }
                var membersDeclaredBySpreadAssignment = new ts.Set();
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_1 = existingMembers; _i < existingMembers_1.length; _i++) {
                    var m = existingMembers_1[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 296 /* SyntaxKind.PropertyAssignment */ &&
                        m.kind !== 297 /* SyntaxKind.ShorthandPropertyAssignment */ &&
                        m.kind !== 203 /* SyntaxKind.BindingElement */ &&
                        m.kind !== 169 /* SyntaxKind.MethodDeclaration */ &&
                        m.kind !== 172 /* SyntaxKind.GetAccessor */ &&
                        m.kind !== 173 /* SyntaxKind.SetAccessor */ &&
                        m.kind !== 298 /* SyntaxKind.SpreadAssignment */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    var existingName = void 0;
                    if (ts.isSpreadAssignment(m)) {
                        setMembersDeclaredBySpreadAssignment(m, membersDeclaredBySpreadAssignment);
                    }
                    else if (ts.isBindingElement(m) && m.propertyName) {
                        // include only identifiers in completion list
                        if (m.propertyName.kind === 79 /* SyntaxKind.Identifier */) {
                            existingName = m.propertyName.escapedText;
                        }
                    }
                    else {
                        // TODO: Account for computed property name
                        // NOTE: if one only performs this step when m.name is an identifier,
                        // things like '__proto__' are not filtered out.
                        var name = ts.getNameOfDeclaration(m);
                        existingName = name && ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
                    }
                    if (existingName !== undefined) {
                        existingMemberNames.add(existingName);
                    }
                }
                var filteredSymbols = contextualMemberSymbols.filter(function (m) { return !existingMemberNames.has(m.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function setMembersDeclaredBySpreadAssignment(declaration, membersDeclaredBySpreadAssignment) {
                var expression = declaration.expression;
                var symbol = typeChecker.getSymbolAtLocation(expression);
                var type = symbol && typeChecker.getTypeOfSymbolAtLocation(symbol, expression);
                var properties = type && type.properties;
                if (properties) {
                    properties.forEach(function (property) {
                        membersDeclaredBySpreadAssignment.add(property.name);
                    });
                }
            }
            // Set SortText to OptionalMember if it is an optional member
            function setSortTextToOptionalMember() {
                symbols.forEach(function (m) {
                    var _a;
                    if (m.flags & 16777216 /* SymbolFlags.Optional */) {
                        var symbolId = ts.getSymbolId(m);
                        symbolToSortTextMap[symbolId] = (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.OptionalMember;
                    }
                });
            }
            // Set SortText to MemberDeclaredBySpreadAssignment if it is fulfilled by spread assignment
            function setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, contextualMemberSymbols) {
                if (membersDeclaredBySpreadAssignment.size === 0) {
                    return;
                }
                for (var _i = 0, contextualMemberSymbols_1 = contextualMemberSymbols; _i < contextualMemberSymbols_1.length; _i++) {
                    var contextualMemberSymbol = contextualMemberSymbols_1[_i];
                    if (membersDeclaredBySpreadAssignment.has(contextualMemberSymbol.name)) {
                        symbolToSortTextMap[ts.getSymbolId(contextualMemberSymbol)] = Completions.SortText.MemberDeclaredBySpreadAssignment;
                    }
                }
            }
            function transformObjectLiteralMembersSortText(start) {
                var _a;
                for (var i = start; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    var symbolId = ts.getSymbolId(symbol);
                    var origin = symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
                    var target = ts.getEmitScriptTarget(compilerOptions);
                    var displayName = getCompletionEntryDisplayNameForSymbol(symbol, target, origin, 0 /* CompletionKind.ObjectPropertyDeclaration */, 
                    /*jsxIdentifierExpected*/ false);
                    if (displayName) {
                        var originalSortText = (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.LocationPriority;
                        var name = displayName.name;
                        symbolToSortTextMap[symbolId] = Completions.SortText.ObjectLiteralProperty(originalSortText, name);
                    }
                }
            }
            /**
             * Filters out completion suggestions for class elements.
             *
             * @returns Symbols to be suggested in an class element depending on existing memebers and symbol flags
             */
            function filterClassMembersList(baseSymbols, existingMembers, currentClassElementModifierFlags) {
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_2 = existingMembers; _i < existingMembers_2.length; _i++) {
                    var m = existingMembers_2[_i];
                    // Ignore omitted 