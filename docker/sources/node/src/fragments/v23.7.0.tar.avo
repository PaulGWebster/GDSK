on.js      |  89.86 |    62.50 |  100.00 | 8 13-14 18 34-35 53',
    '# first.test.js  |  83.33 |   100.00 |   50.00 | 5-6',
    '# second.test.js | 100.00 |   100.00 |  100.00 | ',
    '# third.test.js  | 100.00 |   100.00 |  100.00 | ',
    '# -------------------------------------------------------------------',
    '# all files      |  92.11 |    72.73 |   88.89 | ',
    '# -------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');

  if (common.isWindows) {
    report = report.replaceAll('/', '\\');
  }

  const fixture = fixtures.path('v8-coverage', 'combined_coverage');
  const args = [
    '--test',
    '--experimental-test-coverage',
    '--test-coverage-exclude=!test/**',
    '--test-reporter',
    'tap',
  ];
  const result = spawnSync(process.execPath, args, {
    env: { ...process.env, NODE_TEST_TMPDIR: tmpdir.path },
    cwd: fixture,
  });

  assert.strictEqual(result.stderr.toString(), '');
  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
});

test.skip('coverage works with isolation=none', skipIfNoInspector, () => {
  // There is a bug in coverage calculation. The branch % in the common.js
  // fixture is different depending on the test isolation mode. The 'none' mode
  // is closer to what c8 reports here, so the bug is likely in the code that
  // merges reports from different processes.
  let report = [
    '# start of coverage report',
    '# -------------------------------------------------------------------',
    '# file           | line % | branch % | funcs % | uncovered lines',
    '# -------------------------------------------------------------------',
    '# common.js      |  89.86 |    68.42 |  100.00 | 8 13-14 18 34-35 53',
    '# first.test.js  |  83.33 |   100.00 |   50.00 | 5-6',
    '# second.test.js | 100.00 |   100.00 |  100.00 | ',
    '# third.test.js  | 100.00 |   100.00 |  100.00 | ',
    '# -------------------------------------------------------------------',
    '# all files      |  92.11 |    76.00 |   88.89 | ',
    '# -------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');

  if (common.isWindows) {
    report = report.replaceAll('/', '\\');
  }

  const fixture = fixtures.path('v8-coverage', 'combined_coverage');
  const args = [
    '--test',
    '--experimental-test-coverage',
    '--test-reporter',
    'tap',
    '--test-isolation=none',
  ];
  const result = spawnSync(process.execPath, args, {
    env: { ...process.env, NODE_TEST_TMPDIR: tmpdir.path },
    cwd: fixture,
  });

  assert.strictEqual(result.stderr.toString(), '');
  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
});

test('coverage reports on lines, functions, and branches', skipIfNoInspector, async (t) => {
  const fixture = fixtures.path('test-runner', 'coverage.js');
  const child = spawnSync(process.execPath,
                          [
                            '--test',
                            '--experimental-test-coverage',
                            '--test-coverage-exclude=!test/**',
                            '--test-reporter',
                            fixtures.fileURL('test-runner/custom_reporters/coverage.mjs'),
                            fixture,
                          ]);
  assert.strictEqual(child.stderr.toString(), '');
  const stdout = child.stdout.toString();
  const coverage = JSON.parse(stdout);

  await t.test('does not include node_modules', () => {
    assert.strictEqual(coverage.summary.files.length, 3);
    const files = ['coverage.js', 'invalid-tap.js', 'throw.js'];
    coverage.summary.files.forEach((file, index) => {
      assert.ok(file.path.endsWith(files[index]));
    });
  });

  const file = coverage.summary.files[0];

  await t.test('reports on function coverage', () => {
    const uncalledFunction = file.functions.find((f) => f.name === 'uncalledTopLevelFunction');
    assert.strictEqual(uncalledFunction.count, 0);
    assert.strictEqual(uncalledFunction.line, 16);

    const calledTwice = file.functions.find((f) => f.name === 'fnWithControlFlow');
    assert.strictEqual(calledTwice.count, 2);
    assert.strictEqual(calledTwice.line, 35);
  });

  await t.test('reports on branch coverage', () => {
    const uncalledBranch = file.branches.find((b) => b.line === 6);
    assert.strictEqual(uncalledBranch.count, 0);

    const calledTwice = file.branches.find((b) => b.line === 35);
    assert.strictEqual(calledTwice.count, 2);
  });

  await t.test('reports on line coverage', () => {
    [
      { line: 36, count: 2 },
      { line: 37, count: 1 },
      { line: 38, count: 1 },
      { line: 39, count: 0 },
      { line: 40, count: 1 },
      { line: 41, count: 1 },
      { line: 42, count: 1 },
      { line: 43, count: 0 },
      { line: 44, count: 0 },
    ].forEach((line) => {
      const testLine = file.lines.find((l) => l.line === line.line);
      assert.strictEqual(testLine.count, line.count);
    });
  });
});

test('coverage with ESM hook - source irrelevant', skipIfNoInspector, () => {
  let report = [
    '# start of coverage report',
    '# ------------------------------------------------------------------',
    '# file              | line % | branch % | funcs % | uncovered lines',
    '# ------------------------------------------------------------------',
    '# hooks.mjs         | 100.00 |   100.00 |  100.00 | ',
    '# register-hooks.js | 100.00 |   100.00 |  100.00 | ',
    '# virtual.js        | 100.00 |   100.00 |  100.00 | ',
    '# ------------------------------------------------------------------',
    '# all files         | 100.00 |   100.00 |  100.00 | ',
    '# ------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');

  if (common.isWindows) {
    report = report.replaceAll('/', '\\');
  }

  const fixture = fixtures.path('test-runner', 'coverage-loader');
  const args = [
    '--import',
    './register-hooks.js',
    '--test',
    '--experimental-test-coverage',
    '--test-coverage-exclude=!test/**',
    '--test-reporter',
    'tap',
    'virtual.js',
  ];
  const result = spawnSync(process.execPath, args, { cwd: fixture });

  assert.strictEqual(result.stderr.toString(), '');
  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
});

test('coverage with ESM hook - source transpiled', skipIfNoInspector, () => {
  let report = [
    '# start of coverage report',
    '# ------------------------------------------------------------------',
    '# file              | line % | branch % | funcs % | uncovered lines',
    '# ------------------------------------------------------------------',
    '# hooks.mjs         | 100.00 |   100.00 |  100.00 | ',
    '# register-hooks.js | 100.00 |   100.00 |  100.00 | ',
    '# sum.test.ts       | 100.00 |   100.00 |  100.00 | ',
    '# sum.ts            | 100.00 |   100.00 |  100.00 | ',
    '# ------------------------------------------------------------------',
    '# all files         | 100.00 |   100.00 |  100.00 | ',
    '# ------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');

  if (common.isWindows) {
    report = report.replaceAll('/', '\\');
  }

  const fixture = fixtures.path('test-runner', 'coverage-loader');
  const args = [
    '--import', './register-hooks.js',
    '--test',
    '--experimental-test-coverage',
    '--test-coverage-exclude=!test/**',
    '--test-reporter', 'tap', 'sum.test.ts',
  ];
  const result = spawnSync(process.execPath, args, { cwd: fixture });

  assert.strictEqual(result.stderr.toString(), '');
  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
});

test('coverage with excluded files', skipIfNoInspector, () => {
  const fixture = fixtures.path('test-runner', 'coverage.js');
  const args = [
    '--experimental-test-coverage', '--test-reporter', 'tap',
    '--test-coverage-exclude=test/*/test-runner/invalid-tap.js',
    '--test-coverage-exclude=!test/**',
    fixture];
  const result = spawnSync(process.execPath, args);
  const report = [
    '# start of coverage report',
    '# -----------------------------------------------------------------------------------------',
    '# file           | line % | branch % | funcs % | uncovered lines',
    '# -----------------------------------------------------------------------------------------',
    '# test           |        |          |         | ',
    '#  fixtures      |        |          |         | ',
    '#   test-runner  |        |          |         | ',
    '#    coverage.js |  78.65 |    38.46 |   60.00 | 12-13 16-22 27 39 43-44 61-62 66-67 71-72',
    '#   v8-coverage  |        |          |         | ',
    '#    throw.js    |  71.43 |    50.00 |  100.00 | 5-6',
    '# -----------------------------------------------------------------------------------------',
    '# all files      |  78.13 |    40.00 |   60.00 | ',
    '# -----------------------------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');


  if (common.isWindows) {
    return report.replaceAll('/', '\\');
  }

  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
  assert(!findCoverageFileForPid(result.pid));
});

test('coverage with included files', skipIfNoInspector, () => {
  const fixture = fixtures.path('test-runner', 'coverage.js');
  const args = [
    '--experimental-test-coverage', '--test-reporter', 'tap',
    '--test-coverage-include=test/fixtures/test-runner/coverage.js',
    '--test-coverage-include=test/fixtures/v8-coverage/throw.js',
    '--test-coverage-exclude=!test/**',
    fixture,
  ];
  const result = spawnSync(process.execPath, args);
  const report = [
    '# start of coverage report',
    '# -----------------------------------------------------------------------------------------',
    '# file           | line % | branch % | funcs % | uncovered lines',
    '# -----------------------------------------------------------------------------------------',
    '# test           |        |          |         | ',
    '#  fixtures      |        |          |         | ',
    '#   test-runner  |        |          |         | ',
    '#    coverage.js |  78.65 |    38.46 |   60.00 | 12-13 16-22 27 39 43-44 61-62 66-67 71-72',
    '#   v8-coverage  |        |          |         | ',
    '#    throw.js    |  71.43 |    50.00 |  100.00 | 5-6',
    '# -----------------------------------------------------------------------------------------',
    '# all files      |  78.13 |    40.00 |   60.00 | ',
    '# -----------------------------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');


  if (common.isWindows) {
    return report.replaceAll('/', '\\');
  }

  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
  assert(!findCoverageFileForPid(result.pid));
});

test('coverage with included and excluded files', skipIfNoInspector, () => {
  const fixture = fixtures.path('test-runner', 'coverage.js');
  const args = [
    '--experimental-test-coverage', '--test-reporter', 'tap',
    '--test-coverage-include=test/fixtures/test-runner/*.js',
    '--test-coverage-exclude=test/fixtures/test-runner/*-tap.js',
    fixture,
  ];
  const result = spawnSync(process.execPath, args);
  const report = [
    '# start of coverage report',
    '# -----------------------------------------------------------------------------------------',
    '# file           | line % | branch % | funcs % | uncovered lines',
    '# -----------------------------------------------------------------------------------------',
    '# test           |        |          |         | ',
    '#  fixtures      |        |          |         | ',
    '#   test-runner  |        |          |         | ',
    '#    coverage.js |  78.65 |    38.46 |   60.00 | 12-13 16-22 27 39 43-44 61-62 66-67 71-72',
    '# -----------------------------------------------------------------------------------------',
    '# all files      |  78.65 |    38.46 |   60.00 | ',
    '# -----------------------------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');


  if (common.isWindows) {
    return report.replaceAll('/', '\\');
  }

  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
  assert(!findCoverageFileForPid(result.pid));
});

test('correctly prints the coverage report of files contained in parent directories', skipIfNoInspector, () => {
  let report = [
    '# start of coverage report',
    '# --------------------------------------------------------------------------------------------',
    '# file              | line % | branch % | funcs % | uncovered lines',
    '# --------------------------------------------------------------------------------------------',
    '# ..                |        |          |         | ',
    '#  coverage.js      |  78.65 |    38.46 |   60.00 | 12-13 16-22 27 39 43-44 61-62 66-67 71-72',
    '#  invalid-tap.js   | 100.00 |   100.00 |  100.00 | ',
    '#  ..               |        |          |         | ',
    '#   v8-coverage     |        |          |         | ',
    '#    throw.js       |  71.43 |    50.00 |  100.00 | 5-6',
    '# --------------------------------------------------------------------------------------------',
    '# all files         |  78.35 |    43.75 |   60.00 | ',
    '# --------------------------------------------------------------------------------------------',
    '# end of coverage report',
  ].join('\n');

  if (common.isWindows) {
    report = report.replaceAll('/', '\\');
  }
  const fixture = fixtures.path('test-runner', 'coverage.js');
  const args = [
    '--test',
    '--experimental-test-coverage',
    '--test-coverage-exclude=!test/**',
    '--test-reporter',
    'tap',
    fixture,
  ];
  const result = spawnSync(process.execPath, args, {
    env: { ...process.env, NODE_TEST_TMPDIR: tmpdir.path },
    cwd: fixtures.path('test-runner', 'coverage'),
  });

  assert.strictEqual(result.stderr.toString(), '');
  assert(result.stdout.toString().includes(report));
  assert.strictEqual(result.status, 0);
});
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-runner-custom-assertions.js                                          0000664 0000000 0000000 00000003017 14746647661 0023655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('node:assert');
const { test, assert: testAssertions } = require('node:test');

testAssertions.register('isOdd', (n) => {
  assert.strictEqual(n % 2, 1);
});

testAssertions.register('ok', () => {
  return 'ok';
});

testAssertions.register('snapshot', () => {
  return 'snapshot';
});

testAssertions.register('deepStrictEqual', () => {
  return 'deepStrictEqual';
});

testAssertions.register('context', function() {
  return this;
});

test('throws if name is not a string', () => {
  assert.throws(() => {
    testAssertions.register(5);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "name" argument must be of type string. Received type number (5)'
  });
});

test('throws if fn is not a function', () => {
  assert.throws(() => {
    testAssertions.register('foo', 5);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "fn" argument must be of type function. Received type number (5)'
  });
});

test('invokes a custom assertion as part of the test plan', (t) => {
  t.plan(2);
  t.assert.isOdd(5);
  assert.throws(() => {
    t.assert.isOdd(4);
  }, {
    code: 'ERR_ASSERTION',
    message: /Expected values to be strictly equal/
  });
});

test('can override existing assertions', (t) => {
  assert.strictEqual(t.assert.ok(), 'ok');
  assert.strictEqual(t.assert.snapshot(), 'snapshot');
  assert.strictEqual(t.assert.deepStrictEqual(), 'deepStrictEqual');
});

test('"this" is set to the TestContext', (t) => {
  assert.strictEqual(t.assert.context(), t);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-runner-enable-source-maps-issue.js                                   0000664 0000000 0000000 00000001062 14746647661 0024761 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('node:assert');
const { spawnSync } = require('node:child_process');
const { test } = require('node:test');
const fixtures = require('../common/fixtures');

test('ensures --enable-source-maps does not throw an error', () => {
  const fixture = fixtures.path('test-runner', 'coverage', 'stdin.test.js');
  const args = ['--enable-source-maps', fixture];

  const result = spawnSync(process.execPath, args);

  assert.strictEqual(result.stderr.toString(), '');
  assert.strictEqual(result.status, 0);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-runner-error-reporter.js                                             0000664 0000000 0000000 00000002140 14746647661 0023140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const fixtures = require('../common/fixtures');
const assert = require('node:assert');
const { spawnSync } = require('node:child_process');
const { test } = require('node:test');
const cwd = fixtures.path('test-runner', 'error-reporter-fail-fast');

test('all tests failures reported without FAIL_FAST flag', async () => {
  const args = [
    '--test-reporter=./test/common/test-error-reporter.js',
    '--test-concurrency=1',
    '--test',
    `${cwd}/*.mjs`,
  ];
  const cp = spawnSync(process.execPath, args);
  const failureCount = (cp.stdout.toString().match(/Test failure:/g) || []).length;
  assert.strictEqual(failureCount, 2);
});

test('FAIL_FAST stops test execution after first failure', async () => {
  const args = [
    '--test-reporter=./test/common/test-error-reporter.js',
    '--test-concurrency=1',
    '--test',
    `${cwd}/*.mjs`,
  ];
  const cp = spawnSync(process.execPath, args, { env: { ...process.env, FAIL_FAST: 'true' } });
  const failureCount = (cp.stdout.toString().match(/Test failure:/g) || []).length;
  assert.strictEqual(failureCount, 1);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-runner-exit-code.js                                                  0000664 0000000 0000000 00000004527 14746647661 0022043 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');
const { spawnSync, spawn } = require('child_process');
const { once } = require('events');
const { finished } = require('stream/promises');

async function runAndKill(file) {
  if (common.isWindows) {
    common.printSkipMessage(`signals are not supported in windows, skipping ${file}`);
    return;
  }
  let stdout = '';
  const child = spawn(process.execPath, ['--test', '--test-reporter=tap', file]);
  child.stdout.setEncoding('utf8');
  child.stdout.on('data', (chunk) => {
    if (!stdout.length) child.kill('SIGINT');
    stdout += chunk;
  });
  const [code, signal] = await once(child, 'exit');
  await finished(child.stdout);
  assert(stdout.startsWith('TAP version 13\n'));
  assert.strictEqual(signal, null);
  assert.strictEqual(code, 1);
}

if (process.argv[2] === 'child') {
  const test = require('node:test');

  if (process.argv[3] === 'pass') {
    test('passing test', () => {
      assert.strictEqual(true, true);
    });
  } else if (process.argv[3] === 'fail') {
    assert.strictEqual(process.argv[3], 'fail');
    test('failing test', () => {
      assert.strictEqual(true, false);
    });
  } else assert.fail('unreachable');
} else {
  let child = spawnSync(process.execPath, [__filename, 'child', 'pass']);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);

  child = spawnSync(process.execPath, [
    '--test',
    fixtures.path('test-runner', 'default-behavior', 'subdir', 'subdir_test.js'),
  ]);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);


  child = spawnSync(process.execPath, [
    '--test',
    fixtures.path('test-runner', 'todo_exit_code.js'),
  ]);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
  const stdout = child.stdout.toString();
  assert.match(stdout, /tests 3/);
  assert.match(stdout, /pass 0/);
  assert.match(stdout, /fail 0/);
  assert.match(stdout, /todo 3/);

  child = spawnSync(process.execPath, [__filename, 'child', 'fail']);
  assert.strictEqual(child.status, 1);
  assert.strictEqual(child.signal, null);

  runAndKill(fixtures.path('test-runner', 'never_ending_sync.js')).then(common.mustCall());
  runAndKill(fixtures.path('test-runner', 'never_ending_async.js')).then(common.mustCall());
}
                                                                                                                                                                         node-23.7.0/test/parallel/test-runner-extraneous-async-activity.js                                  0000664 0000000 0000000 00000006224 14746647661 0025320 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');
const { spawnSync } = require('child_process');

{
  const child = spawnSync(process.execPath, [
    '--test',
    fixtures.path('test-runner', 'extraneous_set_immediate_async.mjs'),
  ]);
  const stdout = child.stdout.toString();
  assert.match(stdout, /Error: Test "extraneous async activity test" at .+extraneous_set_immediate_async\.mjs:3:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /pass 1/m);
  assert.match(stdout, /fail 1$/m);
  assert.match(stdout, /cancelled 0$/m);
  assert.strictEqual(child.status, 1);
  assert.strictEqual(child.signal, null);
}

{
  const child = spawnSync(process.execPath, [
    '--test',
    fixtures.path('test-runner', 'extraneous_set_timeout_async.mjs'),
  ]);
  const stdout = child.stdout.toString();
  assert.match(stdout, /Error: Test "extraneous async activity test" at .+extraneous_set_timeout_async\.mjs:3:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /pass 1$/m);
  assert.match(stdout, /fail 1$/m);
  assert.match(stdout, /cancelled 0$/m);
  assert.strictEqual(child.status, 1);
  assert.strictEqual(child.signal, null);
}

{
  const child = spawnSync(process.execPath, [
    '--test',
    fixtures.path('test-runner', 'async-error-in-test-hook.mjs'),
  ]);
  const stdout = child.stdout.toString();
  assert.match(stdout, /Error: Test hook "before" at .+async-error-in-test-hook\.mjs:3:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /Error: Test hook "beforeEach" at .+async-error-in-test-hook\.mjs:9:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /Error: Test hook "after" at .+async-error-in-test-hook\.mjs:15:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /Error: Test hook "afterEach" at .+async-error-in-test-hook\.mjs:21:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /pass 1$/m);
  assert.match(stdout, /fail 1$/m);
  assert.match(stdout, /cancelled 0$/m);
  assert.strictEqual(child.status, 1);
  assert.strictEqual(child.signal, null);
}

{
  const child = spawnSync(process.execPath, [
    '--test',
    '--test-isolation=none',
    fixtures.path('test-runner', 'async-error-in-test-hook.mjs'),
  ]);
  const stdout = child.stdout.toString();
  assert.match(stdout, /Error: Test hook "before" at .+async-error-in-test-hook\.mjs:3:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /Error: Test hook "beforeEach" at .+async-error-in-test-hook\.mjs:9:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /Error: Test hook "after" at .+async-error-in-test-hook\.mjs:15:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /Error: Test hook "afterEach" at .+async-error-in-test-hook\.mjs:21:1 generated asynchronous activity after the test ended/m);
  assert.match(stdout, /pass 1$/m);
  assert.match(stdout, /fail 0$/m);
  assert.match(stdout, /cancelled 0$/m);
  assert.strictEqual(child.status, 1);
  assert.strictEqual(child.signal, null);
}
                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-runner-filetest-location.js                                          0000664 0000000 0000000 00000001314 14746647661 0023576 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const { strictEqual } = require('node:assert');
const { relative } = require('node:path');
const { run } = require('node:test');
const fixture = fixtures.path('test-runner', 'never_ending_sync.js');
const relativePath = relative(process.cwd(), fixture);
const stream = run({
  files: [relativePath],
  timeout: common.platformTimeout(100),
});

stream.on('test:fail', common.mustCall((result) => {
  strictEqual(result.name, relativePath);
  strictEqual(result.details.error.failureType, 'testTimeoutFailure');
  strictEqual(result.line, 1);
  strictEqual(result.column, 1);
  strictEqual(result.file, fixture);
}));
                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-runner-filter-warning.js                                             0000664 0000000 0000000 00000000446 14746647661 0023106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --test-only
'use strict';
const common = require('../common');
const { test } = require('node:test');
const { defaultMaxListeners } = require('node:events');

process.on('warning', common.mustNotCall());

for (let i = 0; i < defaultMaxListeners + 1; ++i) {
  test(`test ${i + 1}`);
}
                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-runner-force-exit-failure.js                                         0000664 0000000 0000000 00000001363 14746647661 0023647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { match, doesNotMatch, strictEqual } = require('node:assert');
const { spawnSync } = require('node:child_process');
const fixtures = require('../common/fixtures');
const fixture = fixtures.path('test-runner/throws_sync_and_async.js');

for (const isolation of ['none', 'process']) {
  const args = [
    '--test',
    '--test-reporter=spec',
    '--test-force-exit',
    `--test-isolation=${isolation}`,
    fixture,
  ];
  const r = spawnSync(process.execPath, args);

  strictEqual(r.status, 1);
  strictEqual(r.signal, null);
  strictEqual(r.stderr.toString(), '');

  const stdout = r.stdout.toString();
  match(stdout, /Error: fails/);
  doesNotMatch(stdout, /this should not have a chance to be thrown/);
}
                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-runner-force-exit-flush.js                                           0000664 0000000 0000000 00000002725 14746647661 0023344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const { match, strictEqual } = require('node:assert');
const { spawnSync } = require('node:child_process');
const { readFileSync } = require('node:fs');
const { test } = require('node:test');

function runWithReporter(reporter) {
  const destination = tmpdir.resolve(`${reporter}.out`);
  const args = [
    '--test-force-exit',
    `--test-reporter=${reporter}`,
    `--test-reporter-destination=${destination}`,
    fixtures.path('test-runner', 'reporters.js'),
  ];
  const child = spawnSync(process.execPath, args);
  strictEqual(child.stdout.toString(), '');
  strictEqual(child.stderr.toString(), '');
  strictEqual(child.status, 1);
  return destination;
}

tmpdir.refresh();

test('junit reporter', () => {
  const output = readFileSync(runWithReporter('junit'), 'utf8');
  match(output, /<!-- tests 4 -->/);
  match(output, /<!-- pass 2 -->/);
  match(output, /<!-- fail 2 -->/);
  match(output, /<!-- duration_ms/);
  match(output, /<\/testsuites>/);
});

test('spec reporter', () => {
  const output = readFileSync(runWithReporter('spec'), 'utf8');
  match(output, /tests 4/);
  match(output, /pass 2/);
  match(output, /fail 2/);
});

test('tap reporter', () => {
  const output = readFileSync(runWithReporter('tap'), 'utf8');
  match(output, /# tests 4/);
  match(output, /# pass 2/);
  match(output, /# fail 2/);
  match(output, /# duration_ms/);
});
                                           node-23.7.0/test/parallel/test-runner-import-no-scheme.js                                           0000664 0000000 0000000 00000004622 14746647661 0023344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { createRequire } = require('module');

for (const name in ['test', 'test/reporters']) {
  assert.throws(
    () => require(name),
    common.expectsError({ code: 'MODULE_NOT_FOUND' }),
  );

  (async () => {
    await assert.rejects(
      async () => import(name),
      common.expectsError({ code: 'ERR_MODULE_NOT_FOUND' }),
    );
  })().then(common.mustCall());

  assert.throws(
    () => require.resolve(name),
    common.expectsError({ code: 'MODULE_NOT_FOUND' }),
  );
}

// Verify that files in node_modules can be resolved.
tmpdir.refresh();

const packageRoot = tmpdir.resolve('node_modules', 'test');
const reportersDir = tmpdir.resolve('node_modules', 'test', 'reporters');
const indexFile = path.join(packageRoot, 'index.js');
const reportersIndexFile = path.join(reportersDir, 'index.js');

fs.mkdirSync(reportersDir, { recursive: true });
fs.writeFileSync(indexFile, 'module.exports = { marker: 1 };');
fs.writeFileSync(reportersIndexFile, 'module.exports = { marker: 1 };');

function test(argv, expectedToFail = false) {
  const child = spawnSync(process.execPath, argv, { cwd: tmpdir.path });
  if (expectedToFail) {
    assert.strictEqual(child.status, 1);
    assert.strictEqual(child.stdout.toString().trim(), '');
  } else {
    assert.strictEqual(child.status, 0);
    assert.strictEqual(child.stdout.toString().trim(), '{ marker: 1 }');
  }
}

test(['-e', 'console.log(require("test"))']);
test(['-e', 'console.log(require("test/reporters"))']);
test(['-e', 'import("test").then(m=>console.log(m.default))']);
test(['-e', 'import("test/reporters").then(m=>console.log(m.default))'], true);
test(['--input-type=module', '-e', 'import test from "test";console.log(test)']);
test(['--input-type=module', '-e', 'import test from "test/reporters";console.log(test)'], true);
test(['--input-type=module', '-e', 'console.log((await import("test")).default)']);
test(['--input-type=module', '-e', 'console.log((await import("test/reporters")).default)'], true);

{
  const dummyFile = tmpdir.resolve('file.js');
  const require = createRequire(dummyFile);
  assert.strictEqual(require.resolve('test'), indexFile);
  assert.strictEqual(require.resolve('test/reporters'), reportersIndexFile);
}
                                                                                                              node-23.7.0/test/parallel/test-runner-inspect.mjs                                                   0000664 0000000 0000000 00000006337 14746647661 0022005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import tmpdir from '../common/tmpdir.js';
import assert from 'node:assert';
import path from 'node:path';
import fs from 'node:fs/promises';
import { NodeInstance } from '../common/inspector-helper.js';


common.skipIfInspectorDisabled();
tmpdir.refresh();

{
  const child = new NodeInstance(
    ['--test', '--test-reporter=tap', '--inspect-brk=0'],
    undefined,
    fixtures.path('test-runner/default-behavior/index.test.js')
  );

  let stdout = '';
  let stderr = '';
  child.on('stdout', (line) => stdout += line);
  child.on('stderr', (line) => stderr += line);

  const session = await child.connectInspectorSession();

  await session.send({ method: 'NodeRuntime.enable' });
  await session.waitForNotification('NodeRuntime.waitingForDebugger');
  await session.send([
    { method: 'Runtime.enable' },
    { method: 'Runtime.runIfWaitingForDebugger' }]);
  await session.send({ method: 'NodeRuntime.disable' });

  session.disconnect();
  assert.match(stderr,
               /Warning: Using the inspector with --test forces running at a concurrency of 1\. Use the inspectPort option to run with concurrency/);
}


{
  const args = [
    '--test', '--test-reporter=tap', '--inspect=0',
    fixtures.path('test-runner/index.js'),
  ];
  const { stderr, stdout, code, signal } = await common.spawnPromisified(process.execPath, args);

  assert.match(stderr,
               /Warning: Using the inspector with --test forces running at a concurrency of 1\. Use the inspectPort option to run with concurrency/);
  assert.match(stdout, /not ok 1 - .+index\.js/);
  assert.strictEqual(code, 1);
  assert.strictEqual(signal, null);
}


{
  // File not found.
  const args = ['--test', '--inspect=0', 'a-random-file-that-does-not-exist.js'];
  const { stderr, stdout, code, signal } = await common.spawnPromisified(process.execPath, args);

  assert.strictEqual(stdout, '');
  assert.match(stderr, /^Could not find/);
  assert.doesNotMatch(stderr, /Warning: Using the inspector with --test forces running at a concurrency of 1\. Use the inspectPort option to run with concurrency/);
  assert.strictEqual(code, 1);
  assert.strictEqual(signal, null);
}


// Outputs coverage when event loop is drained, with no async logic.
{
  const coverageDirectory = tmpdir.resolve('coverage');
  async function getCoveredFiles() {
    const coverageFiles = await fs.readdir(coverageDirectory);
    const files = new Set();
    for (const coverageFile of coverageFiles) {
      const coverage = JSON.parse(await fs.readFile(path.join(coverageDirectory, coverageFile)));
      for (const { url } of coverage.result) {
        if (!url.startsWith('node:')) files.add(url);
      }
    }
    return files;
  }

  const { stderr, code, signal } = await common
          .spawnPromisified(process.execPath,
                            ['--test', fixtures.path('v8-coverage/basic.js')],
                            { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });

  assert.strictEqual(stderr, '');
  assert.strictEqual(code, 0);
  assert.strictEqual(signal, null);
  const files = await getCoveredFiles(coverageDirectory);
  assert.ok(files.has(fixtures.fileURL('v8-coverage/basic.js').href));
}
                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-runner-misc.js                                                       0000664 0000000 0000000 00000002565 14746647661 0021115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const { setTimeout } = require('timers/promises');

if (process.argv[2] === 'child') {
  const test = require('node:test');

  if (process.argv[3] === 'abortSignal') {
    assert.throws(() => test({ signal: {} }), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });

    let testSignal;
    test({ timeout: 10 }, common.mustCall(async ({ signal }) => {
      assert.strictEqual(signal.aborted, false);
      testSignal = signal;
      await setTimeout(50);
    })).finally(common.mustCall(() => {
      test(() => assert.strictEqual(testSignal.aborted, true));
    }));

    // TODO(benjamingr) add more tests to describe + AbortSignal
    // this just tests the parameter is passed
    test.describe('Abort Signal in describe', common.mustCall(({ signal }) => {
      test.it('Supports AbortSignal', () => {
        assert.strictEqual(signal.aborted, false);
      });
    }));
  } else assert.fail('unreachable');
} else {
  const child = spawnSync(process.execPath, [__filename, 'child', 'abortSignal']);
  const stdout = child.stdout.toString();
  assert.match(stdout, /pass 2$/m);
  assert.match(stdout, /fail 0$/m);
  assert.match(stdout, /cancelled 1$/m);
  assert.strictEqual(child.status, 1);
  assert.strictEqual(child.signal, null);
}
                                                                                                                                           node-23.7.0/test/parallel/test-runner-mock-timers-date.js                                           0000664 0000000 0000000 00000010260 14746647661 0023316 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
process.env.NODE_TEST_KNOWN_GLOBALS = 0;
require('../common');

const assert = require('node:assert');
const { it, describe } = require('node:test');

describe('Mock Timers Date Test Suite', () => {
  it('should return the initial UNIX epoch if not specified', (t) => {
    t.mock.timers.enable({ apis: ['Date'] });
    const date = new Date();
    assert.strictEqual(date.getTime(), 0);
    assert.strictEqual(Date.now(), 0);
  });

  it('should throw an error if setTime is called without enabling timers', (t) => {
    assert.throws(
      () => {
        t.mock.timers.setTime(100);
      },
      { code: 'ERR_INVALID_STATE' }
    );
  });

  it('should throw an error if epoch passed to enable is not valid', (t) => {
    assert.throws(
      () => {
        t.mock.timers.enable({ now: -1 });
      },
      { code: 'ERR_INVALID_ARG_VALUE' }
    );

    assert.throws(
      () => {
        t.mock.timers.enable({ now: 'string' });
      },
      { code: 'ERR_INVALID_ARG_TYPE' }
    );

    assert.throws(
      () => {
        t.mock.timers.enable({ now: NaN });
      },
      { code: 'ERR_INVALID_ARG_VALUE' }
    );
  });

  it('should replace the original Date with the mocked one', (t) => {
    t.mock.timers.enable({ apis: ['Date'] });
    assert.ok(Date.isMock);
  });

  it('should return the ticked time when calling Date.now after tick', (t) => {
    t.mock.timers.enable({ apis: ['Date'] });
    const time = 100;
    t.mock.timers.tick(time);
    assert.strictEqual(Date.now(), time);
  });

  it('should return the Date as string when calling it as a function', (t) => {
    t.mock.timers.enable({ apis: ['Date'] });
    const returned = Date();
    // Matches the format: 'Mon Jan 01 1970 00:00:00'
    // We don't care about the date, just the format
    assert.ok(/\w{3}\s\w{3}\s\d{1,2}\s\d{2,4}\s\d{1,2}:\d{2}:\d{2}/.test(returned));
  });

  it('should return the date with different argument calls', (t) => {
    t.mock.timers.enable({ apis: ['Date'] });
    assert.strictEqual(new Date(0).getTime(), 0);
    assert.strictEqual(new Date(100).getTime(), 100);
    assert.strictEqual(new Date('1970-01-01T00:00:00.000Z').getTime(), 0);
    assert.strictEqual(new Date(1970, 0).getFullYear(), 1970);
    assert.strictEqual(new Date(1970, 0).getMonth(), 0);
    assert.strictEqual(new Date(1970, 0, 1).getDate(), 1);
    assert.strictEqual(new Date(1970, 0, 1, 11).getHours(), 11);
    assert.strictEqual(new Date(1970, 0, 1, 11, 10).getMinutes(), 10);
    assert.strictEqual(new Date(1970, 0, 1, 11, 10, 45).getSeconds(), 45);
    assert.strictEqual(new Date(1970, 0, 1, 11, 10, 45, 898).getMilliseconds(), 898);
    assert.strictEqual(new Date(1970, 0, 1, 11, 10, 45, 898).toDateString(), 'Thu Jan 01 1970');
  });

  it('should return native code when calling Date.toString', (t) => {
    t.mock.timers.enable({ apis: ['Date'] });
    assert.strictEqual(Date.toString(), 'function Date() { [native code] }');
  });

  it('should start with a custom epoch if the second argument is specified', (t) => {
    t.mock.timers.enable({ apis: ['Date'], now: 100 });
    const date1 = new Date();
    assert.strictEqual(date1.getTime(), 100);

    t.mock.timers.reset();
    t.mock.timers.enable({ apis: ['Date'], now: new Date(200) });
    const date2 = new Date();
    assert.strictEqual(date2.getTime(), 200);
  });

  it('should replace epoch if setTime is lesser than now and not tick', (t) => {
    t.mock.timers.enable();
    const fn = t.mock.fn();
    const id = setTimeout(fn, 1000);
    t.mock.timers.setTime(800);
    assert.strictEqual(Date.now(), 800);
    t.mock.timers.setTime(500);
    assert.strictEqual(Date.now(), 500);
    assert.strictEqual(fn.mock.callCount(), 0);
    clearTimeout(id);
  });

  it('should not tick time when setTime is called', (t) => {
    t.mock.timers.enable();
    const fn = t.mock.fn();
    const id = setTimeout(fn, 1000);
    t.mock.timers.setTime(1200);
    assert.strictEqual(Date.now(), 1200);
    assert.strictEqual(fn.mock.callCount(), 0);
    clearTimeout(id);
  });

  it((t) => {
    t.mock.timers.enable();
    t.test('should throw when a already-mocked Date is mocked', (t2) => {
      assert.throws(() => t2.mock.timers.enable(), { code: 'ERR_INVALID_STATE' });
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-runner-mock-timers-scheduler.js                                      0000664 0000000 0000000 00000007060 14746647661 0024363 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
process.env.NODE_TEST_KNOWN_GLOBALS = 0;
const common = require('../common');

const assert = require('node:assert');
const { it, describe } = require('node:test');
const nodeTimersPromises = require('node:timers/promises');

describe('Mock Timers Scheduler Test Suite', () => {
  it('should advance in time and trigger timers when calling the .tick function', (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });

    const now = Date.now();
    const durationAtMost = 100;

    const p = nodeTimersPromises.scheduler.wait(4000);
    t.mock.timers.tick(4000);

    return p.then(common.mustCall((result) => {
      assert.strictEqual(result, undefined);
      assert.ok(
        Date.now() - now < durationAtMost,
        `time should be advanced less than the ${durationAtMost}ms`
      );
    }));
  });

  it('should advance in time and trigger timers when calling the .tick function multiple times', async (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });

    const fn = t.mock.fn();

    nodeTimersPromises.scheduler.wait(9999).then(fn);

    t.mock.timers.tick(8999);
    assert.strictEqual(fn.mock.callCount(), 0);
    t.mock.timers.tick(500);

    await nodeTimersPromises.setImmediate();

    assert.strictEqual(fn.mock.callCount(), 0);
    t.mock.timers.tick(500);

    await nodeTimersPromises.setImmediate();
    assert.strictEqual(fn.mock.callCount(), 1);
  });

  it('should work with the same params as the original timers/promises/scheduler.wait', async (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });
    const controller = new AbortController();
    const p = nodeTimersPromises.scheduler.wait(2000, {
      ref: true,
      signal: controller.signal,
    });

    t.mock.timers.tick(1000);
    t.mock.timers.tick(500);
    t.mock.timers.tick(500);
    t.mock.timers.tick(500);

    const result = await p;
    assert.strictEqual(result, undefined);
  });

  it('should abort operation if timers/promises/scheduler.wait received an aborted signal', async (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });
    const controller = new AbortController();
    const p = nodeTimersPromises.scheduler.wait(2000, {
      ref: true,
      signal: controller.signal,
    });

    t.mock.timers.tick(1000);
    controller.abort();
    t.mock.timers.tick(500);
    t.mock.timers.tick(500);
    t.mock.timers.tick(500);

    await assert.rejects(() => p, {
      name: 'AbortError',
    });
  });
  it('should abort operation even if the .tick was not called', async (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });
    const controller = new AbortController();
    const p = nodeTimersPromises.scheduler.wait(2000, {
      ref: true,
      signal: controller.signal,
    });

    controller.abort();

    await assert.rejects(() => p, {
      name: 'AbortError',
    });
  });

  it('should abort operation when .abort is called before calling setInterval', async (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });
    const controller = new AbortController();
    controller.abort();
    const p = nodeTimersPromises.scheduler.wait(2000, {
      ref: true,
      signal: controller.signal,
    });

    await assert.rejects(() => p, {
      name: 'AbortError',
    });
  });

  it('should reject given an an invalid signal instance', async (t) => {
    t.mock.timers.enable({ apis: ['scheduler.wait'] });
    const p = nodeTimersPromises.scheduler.wait(2000, {
      ref: true,
      signal: {},
    });

    await assert.rejects(() => p, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-runner-mock-timers.js                                                0000664 0000000 0000000 00000070270 14746647661 0022412 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
process.env.NODE_TEST_KNOWN_GLOBALS = 0;
const common = require('../common');

const assert = require('node:assert');
const { it, mock, describe } = require('node:test');
const nodeTimers = require('node:timers');
const nodeTimersPromises = require('node:timers/promises');
const { TIMEOUT_MAX } = require('internal/timers');

describe('Mock Timers Test Suite', () => {
  describe('MockTimers API', () => {
    it('should throw an error if trying to enable a timer that is not supported', (t) => {
      assert.throws(() => {
        t.mock.timers.enable({ apis: ['DOES_NOT_EXIST'] });
      }, {
        code: 'ERR_INVALID_ARG_VALUE',
      });
    });

    it('should throw an error if data type of trying to enable a timer is not string', (t) => {
      assert.throws(() => {
        t.mock.timers.enable({ apis: [1] });
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
      });
    });

    it('should throw an error if trying to enable a timer twice', (t) => {
      t.mock.timers.enable();
      assert.throws(() => {
        t.mock.timers.enable();
      }, {
        code: 'ERR_INVALID_STATE',
      });
    });

    it('should not throw if calling reset without enabling timers', (t) => {
      t.mock.timers.reset();
    });

    it('should throw an error if calling tick without enabling timers', (t) => {
      assert.throws(() => {
        t.mock.timers.tick();
      }, {
        code: 'ERR_INVALID_STATE',
      });
    });

    it('should throw an error if calling tick with a negative number', (t) => {
      t.mock.timers.enable();
      assert.throws(() => {
        t.mock.timers.tick(-1);
      }, {
        code: 'ERR_INVALID_ARG_VALUE',
      });
    });

    it('should check that propertyDescriptor gets back after resetting timers', (t) => {
      const getDescriptor = (ctx, fn) => Object.getOwnPropertyDescriptor(ctx, fn);
      const getCurrentTimersDescriptors = () => {
        const timers = [
          'setTimeout',
          'clearTimeout',
          'setInterval',
          'clearInterval',
          'setImmediate',
          'clearImmediate',
        ];

        const globalTimersDescriptors = timers.map((fn) => getDescriptor(globalThis, fn));
        const nodeTimersDescriptors = timers.map((fn) => getDescriptor(nodeTimers, fn));
        const nodeTimersPromisesDescriptors = timers
          .filter((fn) => !fn.includes('clear'))
          .map((fn) => getDescriptor(nodeTimersPromises, fn));

        return {
          global: globalTimersDescriptors,
          nodeTimers: nodeTimersDescriptors,
          nodeTimersPromises: nodeTimersPromisesDescriptors,
        };
      };

      const originalDescriptors = getCurrentTimersDescriptors();

      t.mock.timers.enable();
      const during = getCurrentTimersDescriptors();
      t.mock.timers.reset();
      const after = getCurrentTimersDescriptors();

      for (const env in originalDescriptors) {
        for (const prop in originalDescriptors[env]) {
          const originalDescriptor = originalDescriptors[env][prop];
          const afterDescriptor = after[env][prop];

          assert.deepStrictEqual(
            originalDescriptor,
            afterDescriptor,
          );

          assert.notDeepStrictEqual(
            originalDescriptor,
            during[env][prop],
          );

          assert.notDeepStrictEqual(
            during[env][prop],
            after[env][prop],
          );

        }
      }
    });

    it('should reset all timers when calling .reset function', (t) => {
      t.mock.timers.enable();
      const fn = t.mock.fn();
      globalThis.setTimeout(fn, 1000);
      t.mock.timers.reset();
      assert.deepStrictEqual(Date.now, globalThis.Date.now);
      assert.throws(() => {
        t.mock.timers.tick(1000);
      }, {
        code: 'ERR_INVALID_STATE',
      });

      assert.strictEqual(fn.mock.callCount(), 0);
    });

    it('should reset all timers when calling Symbol.dispose', (t) => {
      t.mock.timers.enable();
      const fn = t.mock.fn();
      globalThis.setTimeout(fn, 1000);
      // TODO(benjamingr) refactor to `using`
      t.mock.timers[Symbol.dispose]();
      assert.throws(() => {
        t.mock.timers.tick(1000);
      }, {
        code: 'ERR_INVALID_STATE',
      });

      assert.strictEqual(fn.mock.callCount(), 0);
    });

    it('should execute in order if timeout is the same', (t) => {
      t.mock.timers.enable();
      const order = [];
      const fn1 = t.mock.fn(() => order.push('f1'));
      const fn2 = t.mock.fn(() => order.push('f2'));
      globalThis.setTimeout(fn1, 1000);
      globalThis.setTimeout(fn2, 1000);
      t.mock.timers.tick(1000);
      assert.strictEqual(fn1.mock.callCount(), 1);
      assert.strictEqual(fn2.mock.callCount(), 1);
      assert.deepStrictEqual(order, ['f1', 'f2']);
    });

    describe('runAll Suite', () => {
      it('should throw an error if calling runAll without enabling timers', (t) => {
        assert.throws(() => {
          t.mock.timers.runAll();
        }, {
          code: 'ERR_INVALID_STATE',
        });
      });

      it('should trigger all timers when calling .runAll function', async (t) => {
        const timeoutFn = t.mock.fn();
        const intervalFn = t.mock.fn();

        t.mock.timers.enable();
        globalThis.setTimeout(timeoutFn, 1111);
        const id = globalThis.setInterval(intervalFn, 9999);
        t.mock.timers.runAll();

        globalThis.clearInterval(id);
        assert.strictEqual(timeoutFn.mock.callCount(), 1);
        assert.strictEqual(intervalFn.mock.callCount(), 1);
      });

      it('should increase the epoch as the tick run for runAll', async (t) => {
        const timeoutFn = t.mock.fn();
        const intervalFn = t.mock.fn();

        t.mock.timers.enable();
        globalThis.setTimeout(timeoutFn, 1111);
        const id = globalThis.setInterval(intervalFn, 9999);
        t.mock.timers.runAll();

        globalThis.clearInterval(id);
        assert.strictEqual(timeoutFn.mock.callCount(), 1);
        assert.strictEqual(intervalFn.mock.callCount(), 1);
        assert.strictEqual(Date.now(), 9999);
      });

      it('should not error if there are not timers to run', (t) => {
        t.mock.timers.enable();
        t.mock.timers.runAll();
        // Should not throw
      });
    });
  });

  describe('globals/timers', () => {
    describe('setTimeout Suite', () => {
      it('should advance in time and trigger timers when calling the .tick function', (t) => {
        mock.timers.enable({ apis: ['setTimeout'] });

        const fn = mock.fn();

        globalThis.setTimeout(fn, 4000);

        mock.timers.tick(4000);
        assert.strictEqual(fn.mock.callCount(), 1);
        mock.timers.reset();
      });

      it('should advance in time and trigger timers when calling the .tick function multiple times', (t) => {
        t.mock.timers.enable({ apis: ['setTimeout'] });
        const fn = t.mock.fn();

        globalThis.setTimeout(fn, 2000);

        t.mock.timers.tick(1000);
        assert.strictEqual(fn.mock.callCount(), 0);
        t.mock.timers.tick(500);
        assert.strictEqual(fn.mock.callCount(), 0);
        t.mock.timers.tick(500);
        assert.strictEqual(fn.mock.callCount(), 1);
      });

      it('should work with the same params as the original setTimeout', (t) => {
        t.mock.timers.enable({ apis: ['setTimeout'] });
        const fn = t.mock.fn();
        const args = ['a', 'b', 'c'];
        globalThis.setTimeout(fn, 2000, ...args);

        t.mock.timers.tick(1000);
        t.mock.timers.tick(500);
        t.mock.timers.tick(500);

        assert.strictEqual(fn.mock.callCount(), 1);
        assert.deepStrictEqual(fn.mock.calls[0].arguments, args);
      });

      it('should keep setTimeout working if timers are disabled', (t, done) => {
        const now = Date.now();
        const timeout = 2;
        const expected = () => now - timeout;
        globalThis.setTimeout(common.mustCall(() => {
          assert.strictEqual(now - timeout, expected());
          done();
        }), timeout);
      });

      it('should change timeout to 1ms when it is > TIMEOUT_MAX', (t) => {
        t.mock.timers.enable({ apis: ['setTimeout'] });
        const fn = t.mock.fn();
        globalThis.setTimeout(fn, TIMEOUT_MAX + 1);
        t.mock.timers.tick(1);
        assert.strictEqual(fn.mock.callCount(), 1);
      });

      it('should change the delay to one if timeout < 0', (t) => {
        t.mock.timers.enable({ apis: ['setTimeout'] });
        const fn = t.mock.fn();
        globalThis.setTimeout(fn, -1);
        t.mock.timers.tick(1);
        assert.strictEqual(fn.mock.callCount(), 1);
      });
    });

    describe('clearTimeout Suite', () => {
      it('should not advance in time if clearTimeout was invoked', (t) => {
        t.mock.timers.enable({ apis: ['setTimeout'] });

        const fn = mock.fn();

        const id = globalThis.setTimeout(fn, 4000);
        globalThis.clearTimeout(id);
        t.mock.timers.tick(4000);

        assert.strictEqual(fn.mock.callCount(), 0);
      });

      it('clearTimeout does not throw on null and undefined', (t) => {
        t.mock.timers.enable({ apis: ['setTimeout'] });

        nodeTimers.clearTimeout();
        nodeTimers.clearTimeout(null);
      });
    });

    describe('setInterval Suite', () => {
      it('should tick three times using fake setInterval', (t) => {
        t.mock.timers.enable({ apis: ['setInterval'] });
        const fn = t.mock.fn();

        const id = globalThis.setInterval(fn, 200);

        t.mock.timers.tick(200);
        t.mock.timers.tick(200);
        t.mock.timers.tick(200);

        globalThis.clearInterval(id);

        assert.strictEqual(fn.mock.callCount(), 3);
      });

      it('should work with the same params as the original setInterval', (t) => {
        t.mock.timers.enable({ apis: ['setInterval'] });
        const fn = t.mock.fn();
        const args = ['a', 'b', 'c'];
        const id = globalThis.setInterval(fn, 200, ...args);

        t.mock.timers.tick(200);
        t.mock.timers.tick(200);
        t.mock.timers.tick(200);

        globalThis.clearInterval(id);

        assert.strictEqual(fn.mock.callCount(), 3);
        assert.deepStrictEqual(fn.mock.calls[0].arguments, args);
        assert.deepStrictEqual(fn.mock.calls[1].arguments, args);
        assert.deepStrictEqual(fn.mock.calls[2].arguments, args);
      });
    });

    describe('clearInterval Suite', () => {
      it('should not advance in time if clearInterval was invoked', (t) => {
        t.mock.timers.enable({ apis: ['setInterval'] });

        const fn = mock.fn();
        const id = globalThis.setInterval(fn, 200);
        globalThis.clearInterval(id);
        t.mock.timers.tick(200);

        assert.strictEqual(fn.mock.callCount(), 0);
      });

      it('clearInterval does not throw on null and undefined', (t) => {
        t.mock.timers.enable({ apis: ['setInterval'] });

        nodeTimers.clearInterval();
        nodeTimers.clearInterval(null);
      });
    });

    describe('setImmediate Suite', () => {
      it('should keep setImmediate working if timers are disabled', (t, done) => {
        const now = Date.now();
        const timeout = 2;
        const expected = () => now - timeout;
        globalThis.setImmediate(common.mustCall(() => {
          assert.strictEqual(now - timeout, expected());
          done();
        }));
      });

      it('should work with the same params as the original setImmediate', (t) => {
        t.mock.timers.enable({ apis: ['setImmediate'] });
        const fn = t.mock.fn();
        const args = ['a', 'b', 'c'];
        globalThis.setImmediate(fn, ...args);
        t.mock.timers.tick(9999);

        assert.strictEqual(fn.mock.callCount(), 1);
        assert.deepStrictEqual(fn.mock.calls[0].arguments, args);
      });

      it('should not advance in time if clearImmediate was invoked', (t) => {
        t.mock.timers.enable({ apis: ['setImmediate'] });

        const id = globalThis.setImmediate(common.mustNotCall());
        globalThis.clearImmediate(id);
        t.mock.timers.tick(200);
      });

      it('should advance in time and trigger timers when calling the .tick function', (t) => {
        t.mock.timers.enable({ apis: ['setImmediate'] });
        globalThis.setImmediate(common.mustCall(1));
        t.mock.timers.tick(0);
      });

      it('should execute in order if setImmediate is called multiple times', (t) => {
        t.mock.timers.enable({ apis: ['setImmediate'] });
        const order = [];
        const fn1 = t.mock.fn(common.mustCall(() => order.push('f1'), 1));
        const fn2 = t.mock.fn(common.mustCall(() => order.push('f2'), 1));

        globalThis.setImmediate(fn1);
        globalThis.setImmediate(fn2);

        t.mock.timers.tick(0);

        assert.deepStrictEqual(order, ['f1', 'f2']);
      });

      it('should execute setImmediate first if setTimeout was also called', (t) => {
        t.mock.timers.enable({ apis: ['setImmediate', 'setTimeout'] });
        const order = [];
        const fn1 = t.mock.fn(common.mustCall(() => order.push('f1'), 1));
        const fn2 = t.mock.fn(common.mustCall(() => order.push('f2'), 1));

        globalThis.setTimeout(fn2, 0);
        globalThis.setImmediate(fn1);

        t.mock.timers.tick(100);

        assert.deepStrictEqual(order, ['f1', 'f2']);
      });
    });

    describe('clearImmediate Suite', () => {
      it('clearImmediate does not throw on null and undefined', (t) => {
        t.mock.timers.enable({ apis: ['setImmediate'] });

        nodeTimers.clearImmediate();
        nodeTimers.clearImmediate(null);
      });
    });

    describe('timers/promises', () => {
      describe('setTimeout Suite', () => {
        it('should advance in time and trigger timers when calling the .tick function multiple times', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });

          const p = nodeTimersPromises.setTimeout(2000);

          t.mock.timers.tick(1000);
          t.mock.timers.tick(500);
          t.mock.timers.tick(500);
          t.mock.timers.tick(500);

          p.then(common.mustCall((result) => {
            assert.strictEqual(result, undefined);
          }));
        });

        it('should work with the same params as the original timers/promises/setTimeout', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const expectedResult = 'result';
          const controller = new AbortController();
          const p = nodeTimersPromises.setTimeout(2000, expectedResult, {
            ref: true,
            signal: controller.signal,
          });

          t.mock.timers.tick(1000);
          t.mock.timers.tick(500);
          t.mock.timers.tick(500);
          t.mock.timers.tick(500);

          const result = await p;
          assert.strictEqual(result, expectedResult);
        });

        it('should always return the same result as the original timers/promises/setTimeout', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          for (const expectedResult of [undefined, null, false, true, 0, 0n, 1, 1n, '', 'result', {}]) {
            const p = nodeTimersPromises.setTimeout(2000, expectedResult);
            t.mock.timers.tick(2000);
            const result = await p;
            assert.strictEqual(result, expectedResult);
          }
        });

        it('should abort operation if timers/promises/setTimeout received an aborted signal', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const expectedResult = 'result';
          const controller = new AbortController();
          const p = nodeTimersPromises.setTimeout(2000, expectedResult, {
            ref: true,
            signal: controller.signal,
          });

          t.mock.timers.tick(1000);
          controller.abort();
          t.mock.timers.tick(500);
          t.mock.timers.tick(500);
          t.mock.timers.tick(500);
          await assert.rejects(() => p, {
            name: 'AbortError',
          });
        });
        it('should abort operation even if the .tick was not called', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const expectedResult = 'result';
          const controller = new AbortController();
          const p = nodeTimersPromises.setTimeout(2000, expectedResult, {
            ref: true,
            signal: controller.signal,
          });

          controller.abort();

          await assert.rejects(() => p, {
            name: 'AbortError',
          });
        });

        it('should abort operation when .abort is called before calling setInterval', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const expectedResult = 'result';
          const controller = new AbortController();
          controller.abort();
          const p = nodeTimersPromises.setTimeout(2000, expectedResult, {
            ref: true,
            signal: controller.signal,
          });

          await assert.rejects(() => p, {
            name: 'AbortError',
          });
        });

        it('should reject given an an invalid signal instance', async (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const expectedResult = 'result';
          const p = nodeTimersPromises.setTimeout(2000, expectedResult, {
            ref: true,
            signal: {},
          });

          await assert.rejects(() => p, {
            name: 'TypeError',
            code: 'ERR_INVALID_ARG_TYPE',
          });
        });

        // Test for https://github.com/nodejs/node/issues/50365
        it('should not affect other timers when aborting', async (t) => {
          const f1 = t.mock.fn();
          const f2 = t.mock.fn();
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const ac = new AbortController();

          // id 1 & pos 1 in priority queue
          nodeTimersPromises.setTimeout(100, undefined, { signal: ac.signal }).then(f1, f1);
          // id 2 & pos 1 in priority queue (id 1 is moved to pos 2)
          nodeTimersPromises.setTimeout(50).then(f2, f2);

          ac.abort(); // BUG: will remove timer at pos 1 not timer with id 1!

          t.mock.timers.runAll();
          await nodeTimersPromises.setImmediate(); // let promises settle

          // First setTimeout is aborted
          assert.strictEqual(f1.mock.callCount(), 1);
          assert.strictEqual(f1.mock.calls[0].arguments[0].code, 'ABORT_ERR');

          // Second setTimeout should resolve, but never settles, because it was eronously removed by ac.abort()
          assert.strictEqual(f2.mock.callCount(), 1);
        });

        // Test for https://github.com/nodejs/node/issues/50365
        it('should not affect other timers when aborted after triggering', async (t) => {
          const f1 = t.mock.fn();
          const f2 = t.mock.fn();
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const ac = new AbortController();

          // id 1 & pos 1 in priority queue
          nodeTimersPromises.setTimeout(50, true, { signal: ac.signal }).then(f1, f1);
          // id 2 & pos 2 in priority queue
          nodeTimersPromises.setTimeout(100).then(f2, f2);

          // First setTimeout resolves
          t.mock.timers.tick(50);
          await nodeTimersPromises.setImmediate(); // let promises settle
          assert.strictEqual(f1.mock.callCount(), 1);
          assert.strictEqual(f1.mock.calls[0].arguments.length, 1);
          assert.strictEqual(f1.mock.calls[0].arguments[0], true);

          // Now timer with id 2 will be at pos 1 in priority queue
          ac.abort(); // BUG: will remove timer at pos 1 not timer with id 1!

          // Second setTimeout should resolve, but never settles, because it was eronously removed by ac.abort()
          t.mock.timers.runAll();
          await nodeTimersPromises.setImmediate(); // let promises settle
          assert.strictEqual(f2.mock.callCount(), 1);
        });

        it('should not affect other timers when clearing timeout inside own callback', (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const f = t.mock.fn();

          const timer = nodeTimers.setTimeout(() => {
            f();
            // Clearing the already-expired timeout should do nothing
            nodeTimers.clearTimeout(timer);
          }, 50);
          nodeTimers.setTimeout(f, 50);
          nodeTimers.setTimeout(f, 50);

          t.mock.timers.runAll();
          assert.strictEqual(f.mock.callCount(), 3);
        });

        it('should allow clearing timeout inside own callback', (t) => {
          t.mock.timers.enable({ apis: ['setTimeout'] });
          const f = t.mock.fn();

          const timer = nodeTimers.setTimeout(() => {
            f();
            nodeTimers.clearTimeout(timer);
          }, 50);

          t.mock.timers.runAll();
          assert.strictEqual(f.mock.callCount(), 1);
        });
      });

      describe('setInterval Suite', () => {
        it('should tick three times using fake setInterval', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });

          const interval = 100;
          const intervalIterator = nodeTimersPromises.setInterval(interval, Date.now());

          const first = intervalIterator.next();
          const second = intervalIterator.next();
          const third = intervalIterator.next();

          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);

          const results = await Promise.all([
            first,
            second,
            third,
          ]);

          const finished = await intervalIterator.return();
          assert.deepStrictEqual(finished, { done: true, value: undefined });
          for (const result of results) {
            assert.strictEqual(typeof result.value, 'number');
            assert.strictEqual(result.done, false);
          }
        });
        it('should tick five times testing a real use case', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });

          const expectedIterations = 5;
          const interval = 1000;
          let time = 0;
          async function run() {
            const times = [];
            for await (const _ of nodeTimersPromises.setInterval(interval)) { // eslint-disable-line no-unused-vars
              time += interval;
              times.push(time);
              if (times.length === expectedIterations) break;
            }
            return times;
          }

          const r = run();
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);

          const timeResults = await r;
          assert.strictEqual(timeResults.length, expectedIterations);
          for (let it = 1; it < expectedIterations; it++) {
            assert.strictEqual(timeResults[it - 1], interval * it);
          }
        });

        it('should always return the same result as the original timers/promises/setInterval', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });
          for (const expectedResult of [undefined, null, false, true, 0, 0n, 1, 1n, '', 'result', {}]) {
            const intervalIterator = nodeTimersPromises.setInterval(2000, expectedResult);
            const p = intervalIterator.next();
            t.mock.timers.tick(2000);
            const result = await p;
            await intervalIterator.return();
            assert.strictEqual(result.done, false);
            assert.strictEqual(result.value, expectedResult);
          }
        });

        it('should abort operation given an abort controller signal', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });

          const interval = 100;
          const abortController = new AbortController();
          const intervalIterator = nodeTimersPromises.setInterval(interval, Date.now(), {
            signal: abortController.signal,
          });

          const first = intervalIterator.next();
          const second = intervalIterator.next();

          t.mock.timers.tick(interval);
          abortController.abort();
          t.mock.timers.tick(interval);

          const firstResult = await first;
          // Interval * 2 because value can be a little bit greater than interval
          assert.ok(firstResult.value < Date.now() + interval * 2);
          assert.strictEqual(firstResult.done, false);

          await assert.rejects(() => second, {
            name: 'AbortError',
          });
        });

        it('should abort operation when .abort is called before calling setInterval', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });

          const interval = 100;
          const abortController = new AbortController();
          abortController.abort();
          const intervalIterator = nodeTimersPromises.setInterval(interval, Date.now(), {
            signal: abortController.signal,
          });

          const first = intervalIterator.next();
          t.mock.timers.tick(interval);

          await assert.rejects(() => first, {
            name: 'AbortError',
          });
        });

        it('should abort operation given an abort controller signal on a real use case', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });
          const controller = new AbortController();
          const signal = controller.signal;
          const interval = 200;
          const expectedIterations = 2;
          let numIterations = 0;
          async function run() {
            const it = nodeTimersPromises.setInterval(interval, undefined, { signal });
            for await (const _ of it) { // eslint-disable-line no-unused-vars
              numIterations += 1;
              if (numIterations === 5) break;
            }
          }

          const r = run();
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          controller.abort();
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);
          t.mock.timers.tick(interval);

          await assert.rejects(() => r, {
            name: 'AbortError',
          });
          assert.strictEqual(numIterations, expectedIterations);
        });

        // Test for https://github.com/nodejs/node/issues/50381
        it('should use the mocked interval', (t) => {
          t.mock.timers.enable({ apis: ['setInterval'] });
          const fn = t.mock.fn();
          setInterval(fn, 1000);
          assert.strictEqual(fn.mock.callCount(), 0);
          t.mock.timers.tick(1000);
          assert.strictEqual(fn.mock.callCount(), 1);
          t.mock.timers.tick(1);
          t.mock.timers.tick(1);
          t.mock.timers.tick(1);
          assert.strictEqual(fn.mock.callCount(), 1);
        });

        // Test for https://github.com/nodejs/node/issues/50382
        it('should not prevent due timers to be processed', async (t) => {
          t.mock.timers.enable({ apis: ['setInterval', 'setTimeout'] });
          const f1 = t.mock.fn();
          const f2 = t.mock.fn();

          setInterval(f1, 1000);
          setTimeout(f2, 1001);

          assert.strictEqual(f1.mock.callCount(), 0);
          assert.strictEqual(f2.mock.callCount(), 0);

          t.mock.timers.tick(1001);

          assert.strictEqual(f1.mock.callCount(), 1);
          assert.strictEqual(f2.mock.callCount(), 1);
        });
      });
    });
  });

  describe('Api should have same public properties as original', () => {
    it('should have hasRef', (t) => {
      t.mock.timers.enable();
      const timer = setTimeout();
      assert.strictEqual(typeof timer.hasRef, 'function');
      assert.strictEqual(timer.hasRef(), true);
      clearTimeout(timer);
    });

    it('should have ref', (t) => {
      t.mock.timers.enable();
      const timer = setTimeout();
      assert.ok(typeof timer.ref === 'function');
      assert.deepStrictEqual(timer.ref(), timer);
      clearTimeout(timer);
    });

    it('should have unref', (t) => {
      t.mock.timers.enable();
      const timer = setTimeout();
      assert.ok(typeof timer.unref === 'function');
      assert.deepStrictEqual(timer.unref(), timer);
      clearTimeout(timer);
    });

    it('should have refresh', (t) => {
      t.mock.timers.enable();
      const timer = setTimeout();
      assert.ok(typeof timer.refresh === 'function');
      assert.deepStrictEqual(timer.refresh(), timer);
      clearTimeout(timer);
    });
  });
});
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-runner-mocking.js                                                    0000664 0000000 0000000 00000066770 14746647661 0021621 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('node:assert');
const { mock, test } = require('node:test');
test('spies on a function', (t) => {
  const sum = t.mock.fn((arg1, arg2) => {
    return arg1 + arg2;
  });

  assert.strictEqual(sum.mock.calls.length, 0);
  assert.strictEqual(sum(3, 4), 7);
  assert.strictEqual(sum.call(1000, 9, 1), 10);
  assert.strictEqual(sum.mock.calls.length, 2);

  let call = sum.mock.calls[0];
  assert.deepStrictEqual(call.arguments, [3, 4]);
  assert.strictEqual(call.error, undefined);
  assert.strictEqual(call.result, 7);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);

  call = sum.mock.calls[1];
  assert.deepStrictEqual(call.arguments, [9, 1]);
  assert.strictEqual(call.error, undefined);
  assert.strictEqual(call.result, 10);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, 1000);
});

test('spies on a bound function', (t) => {
  const bound = function(arg1, arg2) {
    return this + arg1 + arg2;
  }.bind(50);
  const sum = t.mock.fn(bound);

  assert.strictEqual(sum.mock.calls.length, 0);
  assert.strictEqual(sum(3, 4), 57);
  assert.strictEqual(sum(9, 1), 60);
  assert.strictEqual(sum.mock.calls.length, 2);

  let call = sum.mock.calls[0];
  assert.deepStrictEqual(call.arguments, [3, 4]);
  assert.strictEqual(call.result, 57);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);

  call = sum.mock.calls[1];
  assert.deepStrictEqual(call.arguments, [9, 1]);
  assert.strictEqual(call.result, 60);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);
});

test('spies on a constructor', (t) => {
  class ParentClazz {
    constructor(c) {
      this.c = c;
    }
  }

  class Clazz extends ParentClazz {
    #privateValue;

    constructor(a, b) {
      super(a + b);
      this.a = a;
      this.#privateValue = b;
    }

    getPrivateValue() {
      return this.#privateValue;
    }
  }

  const ctor = t.mock.fn(Clazz);
  const instance = new ctor(42, 85);

  assert(instance instanceof Clazz);
  assert(instance instanceof ParentClazz);
  assert.strictEqual(instance.a, 42);
  assert.strictEqual(instance.getPrivateValue(), 85);
  assert.strictEqual(instance.c, 127);
  assert.strictEqual(ctor.mock.calls.length, 1);

  const call = ctor.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [42, 85]);
  assert.strictEqual(call.error, undefined);
  assert.strictEqual(call.result, instance);
  assert.strictEqual(call.target, Clazz);
  assert.strictEqual(call.this, instance);
});

test('a no-op spy function is created by default', (t) => {
  const fn = t.mock.fn();

  assert.strictEqual(fn.mock.calls.length, 0);
  assert.strictEqual(fn(3, 4), undefined);
  assert.strictEqual(fn.mock.calls.length, 1);

  const call = fn.mock.calls[0];
  assert.deepStrictEqual(call.arguments, [3, 4]);
  assert.strictEqual(call.result, undefined);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);
});

test('internal no-op function can be reused', (t) => {
  const fn1 = t.mock.fn();
  fn1.prop = true;
  const fn2 = t.mock.fn();

  fn1(1);
  fn2(2);
  fn1(3);

  assert.notStrictEqual(fn1.mock, fn2.mock);
  assert.strictEqual(fn1.mock.calls.length, 2);
  assert.strictEqual(fn2.mock.calls.length, 1);
  assert.strictEqual(fn1.prop, true);
  assert.strictEqual(fn2.prop, undefined);
});

test('functions can be mocked multiple times at once', (t) => {
  function sum(a, b) {
    return a + b;
  }

  function difference(a, b) {
    return a - b;
  }

  function product(a, b) {
    return a * b;
  }

  const fn1 = t.mock.fn(sum, difference);
  const fn2 = t.mock.fn(sum, product);

  assert.strictEqual(fn1(5, 3), 2);
  assert.strictEqual(fn2(5, 3), 15);
  assert.strictEqual(fn2(4, 2), 8);
  assert(!('mock' in sum));
  assert(!('mock' in difference));
  assert(!('mock' in product));
  assert.notStrictEqual(fn1.mock, fn2.mock);
  assert.strictEqual(fn1.mock.calls.length, 1);
  assert.strictEqual(fn2.mock.calls.length, 2);
});

test('internal no-op function can be reused as methods', (t) => {
  const obj = {
    _foo: 5,
    _bar: 9,
    foo() {
      return this._foo;
    },
    bar() {
      return this._bar;
    },
  };

  t.mock.method(obj, 'foo');
  obj.foo.prop = true;
  t.mock.method(obj, 'bar');
  assert.strictEqual(obj.foo(), 5);
  assert.strictEqual(obj.bar(), 9);
  assert.strictEqual(obj.bar(), 9);
  assert.notStrictEqual(obj.foo.mock, obj.bar.mock);
  assert.strictEqual(obj.foo.mock.calls.length, 1);
  assert.strictEqual(obj.bar.mock.calls.length, 2);
  assert.strictEqual(obj.foo.prop, true);
  assert.strictEqual(obj.bar.prop, undefined);
});

test('methods can be mocked multiple times but not at the same time', (t) => {
  const obj = {
    offset: 3,
    sum(a, b) {
      return this.offset + a + b;
    },
  };

  function difference(a, b) {
    return this.offset + (a - b);
  }

  function product(a, b) {
    return this.offset + a * b;
  }

  const originalSum = obj.sum;
  const fn1 = t.mock.method(obj, 'sum', difference);

  assert.strictEqual(obj.sum(5, 3), 5);
  assert.strictEqual(obj.sum(5, 1), 7);
  assert.strictEqual(obj.sum, fn1);
  assert.notStrictEqual(fn1.mock, undefined);
  assert.strictEqual(originalSum.mock, undefined);
  assert.strictEqual(difference.mock, undefined);
  assert.strictEqual(product.mock, undefined);
  assert.strictEqual(fn1.mock.calls.length, 2);

  const fn2 = t.mock.method(obj, 'sum', product);

  assert.strictEqual(obj.sum(5, 3), 18);
  assert.strictEqual(obj.sum, fn2);
  assert.notStrictEqual(fn1, fn2);
  assert.strictEqual(fn2.mock.calls.length, 1);

  obj.sum.mock.restore();
  assert.strictEqual(obj.sum, fn1);
  obj.sum.mock.restore();
  assert.strictEqual(obj.sum, originalSum);
  assert.strictEqual(obj.sum.mock, undefined);
});

test('spies on an object method', (t) => {
  const obj = {
    prop: 5,
    method(a, b) {
      return a + b + this.prop;
    },
  };

  assert.strictEqual(obj.method(1, 3), 9);
  t.mock.method(obj, 'method');
  assert.strictEqual(obj.method.mock.calls.length, 0);
  assert.strictEqual(obj.method(1, 3), 9);

  const call = obj.method.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [1, 3]);
  assert.strictEqual(call.result, 9);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(obj.method.mock.restore(), undefined);
  assert.strictEqual(obj.method(1, 3), 9);
  assert.strictEqual(obj.method.mock, undefined);
});

test('spies on a getter', (t) => {
  const obj = {
    prop: 5,
    get method() {
      return this.prop;
    },
  };

  assert.strictEqual(obj.method, 5);

  const getter = t.mock.method(obj, 'method', { getter: true });

  assert.strictEqual(getter.mock.calls.length, 0);
  assert.strictEqual(obj.method, 5);

  const call = getter.mock.calls[0];

  assert.deepStrictEqual(call.arguments, []);
  assert.strictEqual(call.result, 5);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(getter.mock.restore(), undefined);
  assert.strictEqual(obj.method, 5);
});

test('spies on a setter', (t) => {
  const obj = {
    prop: 100,
    // eslint-disable-next-line accessor-pairs
    set method(val) {
      this.prop = val;
    },
  };

  assert.strictEqual(obj.prop, 100);
  obj.method = 88;
  assert.strictEqual(obj.prop, 88);

  const setter = t.mock.method(obj, 'method', { setter: true });

  assert.strictEqual(setter.mock.calls.length, 0);
  obj.method = 77;
  assert.strictEqual(obj.prop, 77);
  assert.strictEqual(setter.mock.calls.length, 1);

  const call = setter.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [77]);
  assert.strictEqual(call.result, undefined);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(setter.mock.restore(), undefined);
  assert.strictEqual(obj.prop, 77);
  obj.method = 65;
  assert.strictEqual(obj.prop, 65);
});

test('spy functions can be bound', (t) => {
  const sum = t.mock.fn(function(arg1, arg2) {
    return this + arg1 + arg2;
  });
  const bound = sum.bind(1000);

  assert.strictEqual(bound(9, 1), 1010);
  assert.strictEqual(sum.mock.calls.length, 1);

  const call = sum.mock.calls[0];
  assert.deepStrictEqual(call.arguments, [9, 1]);
  assert.strictEqual(call.result, 1010);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, 1000);

  assert.strictEqual(sum.mock.restore(), undefined);
  assert.strictEqual(sum.bind(0)(2, 11), 13);
});

test('mocks prototype methods on an instance', async (t) => {
  class Runner {
    async someTask(msg) {
      return Promise.resolve(msg);
    }

    async method(msg) {
      await this.someTask(msg);
      return msg;
    }
  }
  const msg = 'ok';
  const obj = new Runner();
  assert.strictEqual(await obj.method(msg), msg);

  t.mock.method(obj, obj.someTask.name);
  assert.strictEqual(obj.someTask.mock.calls.length, 0);

  assert.strictEqual(await obj.method(msg), msg);

  const call = obj.someTask.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [msg]);
  assert.strictEqual(await call.result, msg);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  const obj2 = new Runner();
  // Ensure that a brand new instance is not mocked
  assert.strictEqual(
    obj2.someTask.mock,
    undefined
  );

  assert.strictEqual(obj.someTask.mock.restore(), undefined);
  assert.strictEqual(await obj.method(msg), msg);
  assert.strictEqual(obj.someTask.mock, undefined);
  assert.strictEqual(Runner.prototype.someTask.mock, undefined);
});

test('spies on async static class methods', async (t) => {
  class Runner {
    static async someTask(msg) {
      return Promise.resolve(msg);
    }

    static async method(msg) {
      await this.someTask(msg);
      return msg;
    }
  }
  const msg = 'ok';
  assert.strictEqual(await Runner.method(msg), msg);

  t.mock.method(Runner, Runner.someTask.name);
  assert.strictEqual(Runner.someTask.mock.calls.length, 0);

  assert.strictEqual(await Runner.method(msg), msg);

  const call = Runner.someTask.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [msg]);
  assert.strictEqual(await call.result, msg);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, Runner);

  assert.strictEqual(Runner.someTask.mock.restore(), undefined);
  assert.strictEqual(await Runner.method(msg), msg);
  assert.strictEqual(Runner.someTask.mock, undefined);
  assert.strictEqual(Runner.prototype.someTask, undefined);

});

test('given null to a mock.method it throws a invalid argument error', (t) => {
  assert.throws(() => t.mock.method(null, {}), { code: 'ERR_INVALID_ARG_TYPE' });
});

test('it should throw given an inexistent property on a object instance', (t) => {
  assert.throws(() => t.mock.method({ abc: 0 }, 'non-existent'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
});

test('spy functions can be used on classes inheritance', (t) => {
  // Makes sure that having a null-prototype doesn't throw our system off
  class A extends null {
    static someTask(msg) {
      return msg;
    }
    static method(msg) {
      return this.someTask(msg);
    }
  }
  class B extends A {}
  class C extends B {}

  const msg = 'ok';
  assert.strictEqual(C.method(msg), msg);

  t.mock.method(C, C.someTask.name);
  assert.strictEqual(C.someTask.mock.calls.length, 0);

  assert.strictEqual(C.method(msg), msg);

  const call = C.someTask.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [msg]);
  assert.strictEqual(call.result, msg);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, C);

  assert.strictEqual(C.someTask.mock.restore(), undefined);
  assert.strictEqual(C.method(msg), msg);
  assert.strictEqual(C.someTask.mock, undefined);
});

test('spy functions don\'t affect the prototype chain', (t) => {

  class A {
    static someTask(msg) {
      return msg;
    }
  }
  class B extends A {}
  class C extends B {}

  const msg = 'ok';

  const ABeforeMockIsUnchanged = Object.getOwnPropertyDescriptor(A, A.someTask.name);
  const BBeforeMockIsUnchanged = Object.getOwnPropertyDescriptor(B, B.someTask.name);
  const CBeforeMockShouldNotHaveDesc = Object.getOwnPropertyDescriptor(C, C.someTask.name);

  t.mock.method(C, C.someTask.name);
  C.someTask(msg);
  const BAfterMockIsUnchanged = Object.getOwnPropertyDescriptor(B, B.someTask.name);

  const AAfterMockIsUnchanged = Object.getOwnPropertyDescriptor(A, A.someTask.name);
  const CAfterMockHasDescriptor = Object.getOwnPropertyDescriptor(C, C.someTask.name);

  assert.strictEqual(CBeforeMockShouldNotHaveDesc, undefined);
  assert.ok(CAfterMockHasDescriptor);

  assert.deepStrictEqual(ABeforeMockIsUnchanged, AAfterMockIsUnchanged);
  assert.strictEqual(BBeforeMockIsUnchanged, BAfterMockIsUnchanged);
  assert.strictEqual(BBeforeMockIsUnchanged, undefined);

  assert.strictEqual(C.someTask.mock.restore(), undefined);
  const CAfterRestoreKeepsDescriptor = Object.getOwnPropertyDescriptor(C, C.someTask.name);
  assert.ok(CAfterRestoreKeepsDescriptor);
});

test('mocked functions report thrown errors', (t) => {
  const testError = new Error('test error');
  const fn = t.mock.fn(() => {
    throw testError;
  });

  assert.throws(fn, /test error/);
  assert.strictEqual(fn.mock.calls.length, 1);

  const call = fn.mock.calls[0];

  assert.deepStrictEqual(call.arguments, []);
  assert.strictEqual(call.error, testError);
  assert.strictEqual(call.result, undefined);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);
});

test('mocked constructors report thrown errors', (t) => {
  const testError = new Error('test error');
  class Clazz {
    constructor() {
      throw testError;
    }
  }

  const ctor = t.mock.fn(Clazz);

  assert.throws(() => {
    new ctor();
  }, /test error/);
  assert.strictEqual(ctor.mock.calls.length, 1);

  const call = ctor.mock.calls[0];

  assert.deepStrictEqual(call.arguments, []);
  assert.strictEqual(call.error, testError);
  assert.strictEqual(call.result, undefined);
  assert.strictEqual(call.target, Clazz);
  assert.strictEqual(call.this, undefined);
});

test('mocks a function', (t) => {
  const sum = (arg1, arg2) => arg1 + arg2;
  const difference = (arg1, arg2) => arg1 - arg2;
  const fn = t.mock.fn(sum, difference);

  assert.strictEqual(fn.mock.calls.length, 0);
  assert.strictEqual(fn(3, 4), -1);
  assert.strictEqual(fn(9, 1), 8);
  assert.strictEqual(fn.mock.calls.length, 2);

  let call = fn.mock.calls[0];
  assert.deepStrictEqual(call.arguments, [3, 4]);
  assert.strictEqual(call.result, -1);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);

  call = fn.mock.calls[1];
  assert.deepStrictEqual(call.arguments, [9, 1]);
  assert.strictEqual(call.result, 8);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, undefined);

  assert.strictEqual(fn.mock.restore(), undefined);
  assert.strictEqual(fn(2, 11), 13);
});

test('mocks a constructor', (t) => {
  class ParentClazz {
    constructor(c) {
      this.c = c;
    }
  }

  class Clazz extends ParentClazz {
    #privateValue;

    constructor(a, b) {
      super(a + b);
      this.a = a;
      this.#privateValue = b;
    }

    getPrivateValue() {
      return this.#privateValue;
    }
  }

  class MockClazz {
    // eslint-disable-next-line no-unused-private-class-members
    #privateValue;

    constructor(z) {
      this.z = z;
    }
  }

  const ctor = t.mock.fn(Clazz, MockClazz);
  const instance = new ctor(42, 85);

  assert(!(instance instanceof MockClazz));
  assert(instance instanceof Clazz);
  assert(instance instanceof ParentClazz);
  assert.strictEqual(instance.a, undefined);
  assert.strictEqual(instance.c, undefined);
  assert.strictEqual(instance.z, 42);
  assert.strictEqual(ctor.mock.calls.length, 1);

  const call = ctor.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [42, 85]);
  assert.strictEqual(call.result, instance);
  assert.strictEqual(call.target, Clazz);
  assert.strictEqual(call.this, instance);
  assert.throws(() => {
    instance.getPrivateValue();
  }, /TypeError: Cannot read private member #privateValue /);
});

test('mocks an object method', (t) => {
  const obj = {
    prop: 5,
    method(a, b) {
      return a + b + this.prop;
    },
  };

  function mockMethod(a) {
    return a + this.prop;
  }

  assert.strictEqual(obj.method(1, 3), 9);
  t.mock.method(obj, 'method', mockMethod);
  assert.strictEqual(obj.method.mock.calls.length, 0);
  assert.strictEqual(obj.method(1, 3), 6);

  const call = obj.method.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [1, 3]);
  assert.strictEqual(call.result, 6);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(obj.method.mock.restore(), undefined);
  assert.strictEqual(obj.method(1, 3), 9);
  assert.strictEqual(obj.method.mock, undefined);
});

test('mocks a getter', (t) => {
  const obj = {
    prop: 5,
    get method() {
      return this.prop;
    },
  };

  function mockMethod() {
    return this.prop - 1;
  }

  assert.strictEqual(obj.method, 5);

  const getter = t.mock.method(obj, 'method', mockMethod, { getter: true });

  assert.strictEqual(getter.mock.calls.length, 0);
  assert.strictEqual(obj.method, 4);

  const call = getter.mock.calls[0];

  assert.deepStrictEqual(call.arguments, []);
  assert.strictEqual(call.result, 4);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(getter.mock.restore(), undefined);
  assert.strictEqual(obj.method, 5);
});

test('mocks a setter', (t) => {
  const obj = {
    prop: 100,
    // eslint-disable-next-line accessor-pairs
    set method(val) {
      this.prop = val;
    },
  };

  function mockMethod(val) {
    this.prop = -val;
  }

  assert.strictEqual(obj.prop, 100);
  obj.method = 88;
  assert.strictEqual(obj.prop, 88);

  const setter = t.mock.method(obj, 'method', mockMethod, { setter: true });

  assert.strictEqual(setter.mock.calls.length, 0);
  obj.method = 77;
  assert.strictEqual(obj.prop, -77);
  assert.strictEqual(setter.mock.calls.length, 1);

  const call = setter.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [77]);
  assert.strictEqual(call.result, undefined);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(setter.mock.restore(), undefined);
  assert.strictEqual(obj.prop, -77);
  obj.method = 65;
  assert.strictEqual(obj.prop, 65);
});

test('mocks a getter with syntax sugar', (t) => {
  const obj = {
    prop: 5,
    get method() {
      return this.prop;
    },
  };

  function mockMethod() {
    return this.prop - 1;
  }
  const getter = t.mock.getter(obj, 'method', mockMethod);
  assert.strictEqual(getter.mock.calls.length, 0);
  assert.strictEqual(obj.method, 4);

  const call = getter.mock.calls[0];

  assert.deepStrictEqual(call.arguments, []);
  assert.strictEqual(call.result, 4);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(getter.mock.restore(), undefined);
  assert.strictEqual(obj.method, 5);
});

test('mocks a setter with syntax sugar', (t) => {
  const obj = {
    prop: 100,
    // eslint-disable-next-line accessor-pairs
    set method(val) {
      this.prop = val;
    },
  };

  function mockMethod(val) {
    this.prop = -val;
  }

  assert.strictEqual(obj.prop, 100);
  obj.method = 88;
  assert.strictEqual(obj.prop, 88);

  const setter = t.mock.setter(obj, 'method', mockMethod);

  assert.strictEqual(setter.mock.calls.length, 0);
  obj.method = 77;
  assert.strictEqual(obj.prop, -77);
  assert.strictEqual(setter.mock.calls.length, 1);

  const call = setter.mock.calls[0];

  assert.deepStrictEqual(call.arguments, [77]);
  assert.strictEqual(call.result, undefined);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, obj);

  assert.strictEqual(setter.mock.restore(), undefined);
  assert.strictEqual(obj.prop, -77);
  obj.method = 65;
  assert.strictEqual(obj.prop, 65);
});

test('mocked functions match name and length', (t) => {
  function getNameAndLength(fn) {
    return {
      name: Object.getOwnPropertyDescriptor(fn, 'name'),
      length: Object.getOwnPropertyDescriptor(fn, 'length'),
    };
  }

  function func1() {}
  const func2 = function(a) {}; // eslint-disable-line func-style
  const arrow = (a, b, c) => {};
  const obj = { method(a, b) {} };

  assert.deepStrictEqual(
    getNameAndLength(func1),
    getNameAndLength(t.mock.fn(func1))
  );
  assert.deepStrictEqual(
    getNameAndLength(func2),
    getNameAndLength(t.mock.fn(func2))
  );
  assert.deepStrictEqual(
    getNameAndLength(arrow),
    getNameAndLength(t.mock.fn(arrow))
  );
  assert.deepStrictEqual(
    getNameAndLength(obj.method),
    getNameAndLength(t.mock.method(obj, 'method', func1))
  );
});

test('method() fails if method cannot be redefined', (t) => {
  const obj = {
    prop: 5,
  };

  Object.defineProperty(obj, 'method', {
    configurable: false,
    value(a, b) {
      return a + b + this.prop;
    }
  });

  function mockMethod(a) {
    return a + this.prop;
  }

  assert.throws(() => {
    t.mock.method(obj, 'method', mockMethod);
  }, /Cannot redefine property: method/);
  assert.strictEqual(obj.method(1, 3), 9);
  assert.strictEqual(obj.method.mock, undefined);
});

test('method() fails if field is a property instead of a method', (t) => {
  const obj = {
    prop: 5,
    method: 100,
  };

  function mockMethod(a) {
    return a + this.prop;
  }

  assert.throws(() => {
    t.mock.method(obj, 'method', mockMethod);
  }, /The argument 'methodName' must be a method/);
  assert.strictEqual(obj.method, 100);
  assert.strictEqual(obj.method.mock, undefined);
});

test('mocks can be auto-restored', (t) => {
  let cnt = 0;

  function addOne() {
    cnt++;
    return cnt;
  }

  function addTwo() {
    cnt += 2;
    return cnt;
  }

  const fn = t.mock.fn(addOne, addTwo, { times: 2 });

  assert.strictEqual(fn(), 2);
  assert.strictEqual(fn(), 4);
  assert.strictEqual(fn(), 5);
  assert.strictEqual(fn(), 6);
});

test('mock implementation can be changed dynamically', (t) => {
  let cnt = 0;

  function addOne() {
    cnt++;
    return cnt;
  }

  function addTwo() {
    cnt += 2;
    return cnt;
  }

  function addThree() {
    cnt += 3;
    return cnt;
  }

  const fn = t.mock.fn(addOne);

  assert.strictEqual(fn.mock.callCount(), 0);
  assert.strictEqual(fn(), 1);
  assert.strictEqual(fn(), 2);
  assert.strictEqual(fn(), 3);
  assert.strictEqual(fn.mock.callCount(), 3);

  fn.mock.mockImplementation(addTwo);
  assert.strictEqual(fn(), 5);
  assert.strictEqual(fn(), 7);
  assert.strictEqual(fn.mock.callCount(), 5);

  fn.mock.restore();
  assert.strictEqual(fn(), 8);
  assert.strictEqual(fn(), 9);
  assert.strictEqual(fn.mock.callCount(), 7);

  assert.throws(() => {
    fn.mock.mockImplementationOnce(common.mustNotCall(), 6);
  }, /The value of "onCall" is out of range\. It must be >= 7/);

  fn.mock.mockImplementationOnce(addThree, 7);
  fn.mock.mockImplementationOnce(addTwo, 8);
  assert.strictEqual(fn(), 12);
  assert.strictEqual(fn(), 14);
  assert.strictEqual(fn(), 15);
  assert.strictEqual(fn.mock.callCount(), 10);
  fn.mock.mockImplementationOnce(addThree);
  assert.strictEqual(fn(), 18);
  assert.strictEqual(fn(), 19);
  assert.strictEqual(fn.mock.callCount(), 12);
});

test('local mocks are auto restored after the test finishes', async (t) => {
  const obj = {
    foo() {},
    bar() {},
  };
  const originalFoo = obj.foo;
  const originalBar = obj.bar;

  assert.strictEqual(originalFoo, obj.foo);
  assert.strictEqual(originalBar, obj.bar);

  const mockFoo = t.mock.method(obj, 'foo');

  assert.strictEqual(mockFoo, obj.foo);
  assert.notStrictEqual(originalFoo, obj.foo);
  assert.strictEqual(originalBar, obj.bar);

  t.beforeEach(() => {
    assert.strictEqual(mockFoo, obj.foo);
    assert.strictEqual(originalBar, obj.bar);
  });

  t.afterEach(() => {
    assert.strictEqual(mockFoo, obj.foo);
    assert.notStrictEqual(originalBar, obj.bar);
  });

  await t.test('creates mocks that are auto restored', (t) => {
    const mockBar = t.mock.method(obj, 'bar');

    assert.strictEqual(mockFoo, obj.foo);
    assert.strictEqual(mockBar, obj.bar);
    assert.notStrictEqual(originalBar, obj.bar);
  });

  assert.strictEqual(mockFoo, obj.foo);
  assert.strictEqual(originalBar, obj.bar);
});

test('reset mock calls', (t) => {
  const sum = (arg1, arg2) => arg1 + arg2;
  const difference = (arg1, arg2) => arg1 - arg2;
  const fn = t.mock.fn(sum, difference);

  assert.strictEqual(fn(1, 2), -1);
  assert.strictEqual(fn(2, 1), 1);
  assert.strictEqual(fn.mock.calls.length, 2);
  assert.strictEqual(fn.mock.callCount(), 2);

  fn.mock.resetCalls();
  assert.strictEqual(fn.mock.calls.length, 0);
  assert.strictEqual(fn.mock.callCount(), 0);

  assert.strictEqual(fn(3, 2), 1);
});

test('uses top level mock', () => {
  function sum(a, b) {
    return a + b;
  }

  function difference(a, b) {
    return a - b;
  }

  const fn = mock.fn(sum, difference);

  assert.strictEqual(fn.mock.calls.length, 0);
  assert.strictEqual(fn(3, 4), -1);
  assert.strictEqual(fn.mock.calls.length, 1);
  mock.reset();
  assert.strictEqual(fn(3, 4), 7);
  assert.strictEqual(fn.mock.calls.length, 2);
});

test('the getter and setter options cannot be used together', (t) => {
  assert.throws(() => {
    t.mock.method({}, 'method', { getter: true, setter: true });
  }, /The property 'options\.setter' cannot be used with 'options\.getter'/);
});

test('method names must be strings or symbols', (t) => {
  const symbol = Symbol();
  const obj = {
    method() {},
    [symbol]() {},
  };

  t.mock.method(obj, 'method');
  t.mock.method(obj, symbol);

  assert.throws(() => {
    t.mock.method(obj, {});
  }, /The "methodName" argument must be one of type string or symbol/);
});

test('the times option must be an integer >= 1', (t) => {
  assert.throws(() => {
    t.mock.fn({ times: null });
  }, /The "options\.times" property must be of type number/);

  assert.throws(() => {
    t.mock.fn({ times: 0 });
  }, /The value of "options\.times" is out of range/);

  assert.throws(() => {
    t.mock.fn(() => {}, { times: 3.14159 });
  }, /The value of "options\.times" is out of range/);
});

test('spies on a class prototype method', (t) => {
  class Clazz {
    constructor(c) {
      this.c = c;
    }

    getC() {
      return this.c;
    }
  }

  const instance = new Clazz(85);

  assert.strictEqual(instance.getC(), 85);
  t.mock.method(Clazz.prototype, 'getC');

  assert.strictEqual(instance.getC.mock.calls.length, 0);
  assert.strictEqual(instance.getC(), 85);
  assert.strictEqual(instance.getC.mock.calls.length, 1);
  assert.strictEqual(Clazz.prototype.getC.mock.calls.length, 1);

  const call = instance.getC.mock.calls[0];
  assert.deepStrictEqual(call.arguments, []);
  assert.strictEqual(call.result, 85);
  assert.strictEqual(call.error, undefined);
  assert.strictEqual(call.target, undefined);
  assert.strictEqual(call.this, instance);
});

test('getter() fails if getter options set to false', (t) => {
  assert.throws(() => {
    t.mock.getter({}, 'method', { getter: false });
  }, /The property 'options\.getter' cannot be false/);
});

test('setter() fails if setter options set to false', (t) => {
  assert.throws(() => {
    t.mock.setter({}, 'method', { setter: false });
  }, /The property 'options\.setter' cannot be false/);
});

test('getter() fails if setter options is true', (t) => {
  assert.throws(() => {
    t.mock.getter({}, 'method', { setter: true });
  }, /The property 'options\.setter' cannot be used with 'options\.getter'/);
});

test('setter() fails if getter options is true', (t) => {
  assert.throws(() => {
    t.mock.setter({}, 'method', { getter: true });
  }, /The property 'options\.setter' cannot be used with 'options\.getter'/);
});
        node-23.7.0/test/parallel/test-runner-module-mocking.js                                             0000664 0000000 0000000 00000053411 14746647661 0023070 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-test-module-mocks --experimental-require-module
'use strict';
const common = require('../common');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('registering customization hooks in Workers does not work');
}

const fixtures = require('../common/fixtures');
const assert = require('node:assert');
const { relative } = require('node:path');
const { test } = require('node:test');
const { pathToFileURL } = require('node:url');

test('input validation', async (t) => {
  await t.test('throws if specifier is not a string', (t) => {
    assert.throws(() => {
      t.mock.module(5);
    }, { code: 'ERR_INVALID_ARG_TYPE' });
  });

  await t.test('throws if options is not an object', (t) => {
    assert.throws(() => {
      t.mock.module(__filename, null);
    }, { code: 'ERR_INVALID_ARG_TYPE' });
  });

  await t.test('throws if cache is not a boolean', (t) => {
    assert.throws(() => {
      t.mock.module(__filename, { cache: 5 });
    }, { code: 'ERR_INVALID_ARG_TYPE' });
  });

  await t.test('throws if namedExports is not an object', async (t) => {
    assert.throws(() => {
      t.mock.module(__filename, {
        namedExports: null,
      });
    }, { code: 'ERR_INVALID_ARG_TYPE' });
  });
});

test('core module mocking with namedExports option', async (t) => {
  await t.test('does not cache by default', async (t) => {
    const original = require('readline');

    assert.strictEqual(typeof original.cursorTo, 'function');
    assert.strictEqual(original.fn, undefined);

    t.mock.module('readline', {
      namedExports: { fn() { return 42; } },
    });
    const mocked = require('readline');

    assert.notStrictEqual(original, mocked);
    assert.notStrictEqual(mocked, require('readline'));
    assert.notStrictEqual(mocked, require('node:readline'));
    assert.strictEqual(mocked.cursorTo, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, require('readline'));
  });

  await t.test('explicitly enables caching', async (t) => {
    const original = require('readline');

    assert.strictEqual(typeof original.cursorTo, 'function');
    assert.strictEqual(original.fn, undefined);

    t.mock.module('readline', {
      namedExports: { fn() { return 42; } },
      cache: true,
    });
    const mocked = require('readline');

    assert.notStrictEqual(original, mocked);
    assert.strictEqual(mocked, require('readline'));
    assert.strictEqual(mocked, require('node:readline'));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, require('readline'));
  });

  await t.test('explicitly disables caching', async (t) => {
    const original = require('readline');

    assert.strictEqual(typeof original.cursorTo, 'function');
    assert.strictEqual(original.fn, undefined);

    t.mock.module('readline', {
      namedExports: { fn() { return 42; } },
      cache: false,
    });
    const mocked = require('readline');

    assert.notStrictEqual(original, mocked);
    assert.notStrictEqual(mocked, require('readline'));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, require('readline'));
  });

  await t.test('named exports are applied to defaultExport', async (t) => {
    const original = require('readline');

    assert.strictEqual(typeof original.cursorTo, 'function');
    assert.strictEqual(original.val1, undefined);
    assert.strictEqual(original.val2, undefined);

    const defaultExport = { val1: 5, val2: 3 };

    t.mock.module('readline', {
      defaultExport,
      namedExports: { val1: 'mock value' },
    });
    const mocked = require('readline');

    assert.notStrictEqual(original, mocked);
    assert.strictEqual(mocked.cursorTo, undefined);
    assert.strictEqual(mocked.val1, 'mock value');
    assert.strictEqual(mocked.val2, 3);
    t.mock.reset();
    assert.strictEqual(original, require('readline'));
  });

  await t.test('throws if named exports cannot be applied to defaultExport', async (t) => {
    const fixture = 'readline';
    const original = require(fixture);

    assert.strictEqual(typeof original.cursorTo, 'function');
    assert.strictEqual(original.val1, undefined);

    const defaultExport = null;

    t.mock.module(fixture, {
      defaultExport,
      namedExports: { val1: 'mock value' },
    });
    assert.throws(() => {
      require(fixture);
    }, /Cannot create mock/);
    t.mock.reset();
    assert.strictEqual(original, require(fixture));
  });
});

test('CJS mocking with namedExports option', async (t) => {
  await t.test('does not cache by default', async (t) => {
    const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
    const original = require(fixture);

    assert.strictEqual(original.string, 'original cjs string');
    assert.strictEqual(original.fn, undefined);

    t.mock.module(pathToFileURL(fixture), {
      namedExports: { fn() { return 42; } },
    });
    const mocked = require(fixture);

    assert.notStrictEqual(original, mocked);
    assert.notStrictEqual(mocked, require(fixture));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, require(fixture));
  });

  await t.test('explicitly enables caching', async (t) => {
    const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
    const original = require(fixture);

    assert.strictEqual(original.string, 'original cjs string');
    assert.strictEqual(original.fn, undefined);

    t.mock.module(pathToFileURL(fixture), {
      namedExports: { fn() { return 42; } },
      cache: true,
    });
    const mocked = require(fixture);

    assert.notStrictEqual(original, mocked);
    assert.strictEqual(mocked, require(fixture));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, require(fixture));
  });

  await t.test('explicitly disables caching', async (t) => {
    const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
    const original = require(fixture);

    assert.strictEqual(original.string, 'original cjs string');
    assert.strictEqual(original.fn, undefined);

    t.mock.module(pathToFileURL(fixture), {
      namedExports: { fn() { return 42; } },
      cache: false,
    });
    const mocked = require(fixture);

    assert.notStrictEqual(original, mocked);
    assert.notStrictEqual(mocked, require(fixture));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, require(fixture));
  });

  await t.test('named exports are applied to defaultExport', async (t) => {
    const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
    const original = require(fixture);

    assert.strictEqual(original.string, 'original cjs string');
    assert.strictEqual(original.val1, undefined);
    assert.strictEqual(original.val2, undefined);

    const defaultExport = { val1: 5, val2: 3 };

    t.mock.module(pathToFileURL(fixture), {
      defaultExport,
      namedExports: { val1: 'mock value' },
    });
    const mocked = require(fixture);

    assert.notStrictEqual(original, mocked);
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.val1, 'mock value');
    assert.strictEqual(mocked.val2, 3);
    t.mock.reset();
    assert.strictEqual(original, require(fixture));
  });

  await t.test('throws if named exports cannot be applied to defaultExport', async (t) => {
    const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
    const original = require(fixture);

    assert.strictEqual(original.string, 'original cjs string');
    assert.strictEqual(original.val1, undefined);

    const defaultExport = null;

    t.mock.module(pathToFileURL(fixture), {
      defaultExport,
      namedExports: { val1: 'mock value' },
    });
    assert.throws(() => {
      require(fixture);
    }, /Cannot create mock/);
    t.mock.reset();
    assert.strictEqual(original, require(fixture));
  });
});

test('ESM mocking with namedExports option', async (t) => {
  await t.test('does not cache by default', async (t) => {
    const fixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs');
    const original = await import(fixture);

    assert.strictEqual(original.string, 'original esm string');
    assert.strictEqual(original.fn, undefined);

    t.mock.module(fixture, {
      namedExports: { fn() { return 42; } },
    });
    const mocked = await import(fixture);

    assert.notStrictEqual(original, mocked);
    assert.notStrictEqual(mocked, await import(fixture));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, await import(fixture));
  });

  await t.test('explicitly enables caching', async (t) => {
    const fixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs');
    const original = await import(fixture);

    assert.strictEqual(original.string, 'original esm string');
    assert.strictEqual(original.fn, undefined);

    t.mock.module(fixture, {
      namedExports: { fn() { return 42; } },
      cache: true,
    });
    const mocked = await import(fixture);

    assert.notStrictEqual(original, mocked);
    assert.strictEqual(mocked, await import(fixture));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, await import(fixture));
  });

  await t.test('explicitly disables caching', async (t) => {
    const fixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs');
    const original = await import(fixture);

    assert.strictEqual(original.string, 'original esm string');
    assert.strictEqual(original.fn, undefined);

    t.mock.module(fixture, {
      namedExports: { fn() { return 42; } },
      cache: false,
    });
    const mocked = await import(fixture);

    assert.notStrictEqual(original, mocked);
    assert.notStrictEqual(mocked, await import(fixture));
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.fn(), 42);
    t.mock.reset();
    assert.strictEqual(original, await import(fixture));
  });

  await t.test('named exports are not applied to defaultExport', async (t) => {
    const fixturePath = fixtures.path('module-mocking', 'basic-esm.mjs');
    const fixture = pathToFileURL(fixturePath);
    const original = await import(fixture);

    assert.strictEqual(original.string, 'original esm string');
    assert.strictEqual(original.val1, undefined);
    assert.strictEqual(original.val2, undefined);

    const defaultExport = 'mock default';

    t.mock.module(fixture, {
      defaultExport,
      namedExports: { val1: 'mock value' },
    });
    const mocked = await import(fixture);

    assert.notStrictEqual(original, mocked);
    assert.strictEqual(mocked.string, undefined);
    assert.strictEqual(mocked.default, 'mock default');
    assert.strictEqual(mocked.val1, 'mock value');
    t.mock.reset();
    common.expectRequiredModule(require(fixturePath), original);
  });

  await t.test('throws if named exports cannot be applied to defaultExport as CJS', async (t) => {
    const fixture = fixtures.fileURL('module-mocking', 'basic-cjs.js');
    const original = await import(fixture);

    assert.strictEqual(original.default.string, 'original cjs string');
    assert.strictEqual(original.default.val1, undefined);

    const defaultExport = null;

    t.mock.module(fixture, {
      defaultExport,
      namedExports: { val1: 'mock value' },
    });
    await assert.rejects(async () => {
      await import(fixture);
    }, /Cannot create mock/);

    t.mock.reset();
    assert.strictEqual(original, await import(fixture));
  });
});

test('modules cannot be mocked multiple times at once', async (t) => {
  await t.test('CJS', async (t) => {
    const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
    const fixtureURL = pathToFileURL(fixture).href;

    t.mock.module(fixtureURL, {
      namedExports: { fn() { return 42; } },
    });

    assert.throws(() => {
      t.mock.module(fixtureURL, {
        namedExports: { fn() { return 55; } },
      });
    }, {
      code: 'ERR_INVALID_STATE',
      message: /The module is already mocked/,
    });

    const mocked = require(fixture);

    assert.strictEqual(mocked.fn(), 42);
  });

  await t.test('ESM', async (t) => {
    const fixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs').href;

    t.mock.module(fixture, {
      namedExports: { fn() { return 42; } },
    });

    assert.throws(() => {
      t.mock.module(fixture, {
        namedExports: { fn() { return 55; } },
      });
    }, {
      code: 'ERR_INVALID_STATE',
      message: /The module is already mocked/,
    });

    const mocked = await import(fixture);

    assert.strictEqual(mocked.fn(), 42);
  });

  await t.test('Importing a Windows path should fail', { skip: !common.isWindows }, async (t) => {
    const fixture = fixtures.path('module-mocking', 'wrong-path.js');
    t.mock.module(fixture, { namedExports: { fn() { return 42; } } });
    await assert.rejects(import(fixture), { code: 'ERR_UNSUPPORTED_ESM_URL_SCHEME' });
  });

  await t.test('Importing a module with a quote in its URL should work', async (t) => {
    const fixture = fixtures.fileURL('module-mocking', 'don\'t-open.mjs');
    t.mock.module(fixture, { namedExports: { fn() { return 42; } } });

    const mocked = await import(fixture);

    assert.strictEqual(mocked.fn(), 42);
  });
});

test('mocks are automatically restored', async (t) => {
  const cjsFixture = fixtures.path('module-mocking', 'basic-cjs.js');
  const esmFixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs');

  await t.test('CJS', async (t) => {
    t.mock.module(pathToFileURL(cjsFixture), {
      namedExports: { fn() { return 42; } },
    });

    const mocked = require(cjsFixture);

    assert.strictEqual(mocked.fn(), 42);
  });

  await t.test('ESM', async (t) => {
    t.mock.module(esmFixture, {
      namedExports: { fn() { return 43; } },
    });

    const mocked = await import(esmFixture);

    assert.strictEqual(mocked.fn(), 43);
  });

  const cjsMock = require(cjsFixture);
  const esmMock = await import(esmFixture);

  assert.strictEqual(cjsMock.string, 'original cjs string');
  assert.strictEqual(cjsMock.fn, undefined);
  assert.strictEqual(esmMock.string, 'original esm string');
  assert.strictEqual(esmMock.fn, undefined);
});

test('mocks can be restored independently', async (t) => {
  const cjsFixture = fixtures.path('module-mocking', 'basic-cjs.js');
  const esmFixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs');

  const cjsMock = t.mock.module(pathToFileURL(cjsFixture), {
    namedExports: { fn() { return 42; } },
  });

  const esmMock = t.mock.module(esmFixture, {
    namedExports: { fn() { return 43; } },
  });

  let cjsImpl = require(cjsFixture);
  let esmImpl = await import(esmFixture);

  assert.strictEqual(cjsImpl.fn(), 42);
  assert.strictEqual(esmImpl.fn(), 43);

  cjsMock.restore();
  cjsImpl = require(cjsFixture);

  assert.strictEqual(cjsImpl.fn, undefined);
  assert.strictEqual(esmImpl.fn(), 43);

  esmMock.restore();
  esmImpl = await import(esmFixture);

  assert.strictEqual(cjsImpl.fn, undefined);
  assert.strictEqual(esmImpl.fn, undefined);
});

test('core module mocks can be used by both module systems', async (t) => {
  const coreMock = t.mock.module('readline', {
    namedExports: { fn() { return 42; } },
  });

  let esmImpl = await import('readline');
  let cjsImpl = require('readline');

  assert.strictEqual(esmImpl.fn(), 42);
  assert.strictEqual(cjsImpl.fn(), 42);

  coreMock.restore();
  esmImpl = await import('readline');
  cjsImpl = require('readline');

  assert.strictEqual(typeof esmImpl.cursorTo, 'function');
  assert.strictEqual(typeof cjsImpl.cursorTo, 'function');
});

test('node:- core module mocks can be used by both module systems', async (t) => {
  const coreMock = t.mock.module('node:readline', {
    namedExports: { fn() { return 42; } },
  });

  let esmImpl = await import('node:readline');
  let cjsImpl = require('node:readline');

  assert.strictEqual(esmImpl.fn(), 42);
  assert.strictEqual(cjsImpl.fn(), 42);

  coreMock.restore();
  esmImpl = await import('node:readline');
  cjsImpl = require('node:readline');

  assert.strictEqual(typeof esmImpl.cursorTo, 'function');
  assert.strictEqual(typeof cjsImpl.cursorTo, 'function');
});

test('CJS mocks can be used by both module systems', async (t) => {
  const cjsFixture = fixtures.path('module-mocking', 'basic-cjs.js');
  const cjsFixtureURL = pathToFileURL(cjsFixture);
  const cjsMock = t.mock.module(cjsFixtureURL, {
    namedExports: { fn() { return 42; } },
  });
  let esmImpl = await import(cjsFixtureURL);
  let cjsImpl = require(cjsFixture);

  assert.strictEqual(esmImpl.fn(), 42);
  assert.strictEqual(cjsImpl.fn(), 42);

  cjsMock.restore();

  esmImpl = await import(cjsFixtureURL);
  cjsImpl = require(cjsFixture);

  assert.strictEqual(esmImpl.default.string, 'original cjs string');
  assert.strictEqual(cjsImpl.string, 'original cjs string');
});

test('relative paths can be used by both module systems', async (t) => {
  const fixture = relative(
    __dirname, fixtures.path('module-mocking', 'basic-esm.mjs')
  ).replaceAll('\\', '/');
  const mock = t.mock.module(fixture, {
    namedExports: { fn() { return 42; } },
  });
  let cjsImpl = require(fixture);
  let esmImpl = await import(fixture);

  assert.strictEqual(cjsImpl.fn(), 42);
  assert.strictEqual(esmImpl.fn(), 42);

  mock.restore();
  cjsImpl = require(fixture);
  esmImpl = await import(fixture);

  assert.strictEqual(esmImpl.string, 'original esm string');
  assert.strictEqual(cjsImpl.string, 'original esm string');
});

test('node_modules can be used by both module systems', async (t) => {
  const cwd = fixtures.path('test-runner');
  const fixture = fixtures.path('test-runner', 'mock-nm.js');
  const args = ['--experimental-test-module-mocks', fixture];
  const {
    code,
    stdout,
    signal,
  } = await common.spawnPromisified(process.execPath, args, { cwd });

  assert.strictEqual(code, 0);
  assert.strictEqual(signal, null);
  assert.match(stdout, /pass 1/);
});

test('file:// imports are supported in ESM only', async (t) => {
  const fixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs').href;
  const mock = t.mock.module(fixture, {
    namedExports: { fn() { return 42; } },
  });
  let impl = await import(fixture);

  assert.strictEqual(impl.fn(), 42);
  assert.throws(() => {
    require(fixture);
  }, { code: 'MODULE_NOT_FOUND' });
  mock.restore();
  impl = await import(fixture);
  assert.strictEqual(impl.string, 'original esm string');
});

test('mocked modules do not impact unmocked modules', async (t) => {
  const mockedFixture = fixtures.fileURL('module-mocking', 'basic-cjs.js');
  const unmockedFixture = fixtures.fileURL('module-mocking', 'basic-esm.mjs');
  t.mock.module(`${mockedFixture}`, {
    namedExports: { fn() { return 42; } },
  });
  const mockedImpl = await import(mockedFixture);
  const unmockedImpl = await import(unmockedFixture);

  assert.strictEqual(mockedImpl.fn(), 42);
  assert.strictEqual(unmockedImpl.fn, undefined);
  assert.strictEqual(unmockedImpl.string, 'original esm string');
});

test('defaultExports work with CJS mocks in both module systems', async (t) => {
  const fixture = fixtures.path('module-mocking', 'basic-cjs.js');
  const fixtureURL = pathToFileURL(fixture);
  const original = require(fixture);
  const defaultExport = Symbol('default');

  assert.strictEqual(original.string, 'original cjs string');
  t.mock.module(fixtureURL, { defaultExport });
  assert.strictEqual(require(fixture), defaultExport);
  assert.strictEqual((await import(fixtureURL)).default, defaultExport);
});

test('defaultExports work with ESM mocks in both module systems', async (t) => {
  const fixturePath = fixtures.path('module-mocking', 'basic-esm.mjs');
  const fixture = pathToFileURL(fixturePath);
  const original = await import(fixture);
  const defaultExport = Symbol('default');

  assert.strictEqual(original.string, 'original esm string');
  t.mock.module(`${fixture}`, { defaultExport });
  assert.strictEqual((await import(fixture)).default, defaultExport);
  assert.strictEqual(require(fixturePath), defaultExport);
});

test('wrong import syntax should throw error after module mocking', async () => {
  const { stdout, stderr, code } = await common.spawnPromisified(
    process.execPath,
    [
      '--experimental-test-module-mocks',
      fixtures.path('module-mocking/wrong-import-after-module-mocking.js'),
    ]
  );

  assert.strictEqual(stdout, '');
  assert.match(stderr, /Error \[ERR_MODULE_NOT_FOUND\]: Cannot find module/);
  assert.strictEqual(code, 1);
});

test('should throw ERR_ACCESS_DENIED when permission model is enabled', async (t) => {
  const cwd = fixtures.path('test-runner');
  const fixture = fixtures.path('test-runner', 'mock-nm.js');
  const args = [
    '--permission',
    '--allow-fs-read=*',
    '--experimental-test-module-mocks',
    fixture,
  ];
  const {
    code,
    stdout,
  } = await common.spawnPromisified(process.execPath, args, { cwd });

  assert.strictEqual(code, 1);
  assert.match(stdout, /Error: Access to this API has been restricted/);
  assert.match(stdout, /permission: 'WorkerThreads'/);
});

test('should work when --allow-worker is passed and permission model is enabled', async (t) => {
  const cwd = fixtures.path('test-runner');
  const fixture = fixtures.path('test-runner', 'mock-nm.js');
  const args = [
    '--permission',
    '--allow-fs-read=*',
    '--allow-worker',
    '--experimental-test-module-mocks',
    fixture,
  ];
  const {
    code,
    stdout,
    stderr,
    signal,
  } = await common.spawnPromisified(process.execPath, args, { cwd });

  assert.strictEqual(code, 0, stderr);
  assert.strictEqual(signal, null);
  assert.match(stdout, /pass 1/, stderr);
});
                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-runner-no-isolation-different-cwd.mjs                                0000664 0000000 0000000 00000001742 14746647661 0025465 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import { allowGlobals, mustCall } from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import { deepStrictEqual } from 'node:assert';
import { run } from 'node:test';

const stream = run({
  cwd: fixtures.path('test-runner', 'no-isolation'),
  isolation: 'none',
});


stream.on('test:pass', mustCall(4));
// eslint-disable-next-line no-unused-vars
for await (const _ of stream);
allowGlobals(globalThis.GLOBAL_ORDER);
deepStrictEqual(globalThis.GLOBAL_ORDER, [
  'before one: <root>',
  'suite one',
  'before two: <root>',
  'suite two',
  'beforeEach one: suite one - test',
  'beforeEach two: suite one - test',
  'suite one - test',
  'afterEach one: suite one - test',
  'afterEach two: suite one - test',
  'before suite two: suite two',
  'beforeEach one: suite two - test',
  'beforeEach two: suite two - test',
  'suite two - test',
  'afterEach one: suite two - test',
  'afterEach two: suite two - test',
  'after one: <root>',
  'after two: <root>',
]);
                              node-23.7.0/test/parallel/test-runner-no-isolation-filtering.js                                     0000664 0000000 0000000 00000005164 14746647661 0024554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const fixtures = require('../common/fixtures');
const assert = require('node:assert');
const { spawnSync } = require('node:child_process');
const { test } = require('node:test');

const fixture1 = fixtures.path('test-runner', 'no-isolation', 'one.test.js');
const fixture2 = fixtures.path('test-runner', 'no-isolation', 'two.test.js');

test('works with --test-only', () => {
  const args = [
    '--test',
    '--test-reporter=tap',
    '--test-isolation=none',
    '--test-only',
    fixture1,
    fixture2,
  ];
  const child = spawnSync(process.execPath, args);
  const stdout = child.stdout.toString();

  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
  assert.match(stdout, /# tests 2/);
  assert.match(stdout, /# suites 2/);
  assert.match(stdout, /# pass 2/);
  assert.match(stdout, /ok 1 - suite one/);
  assert.match(stdout, /ok 1 - suite one - test/);
  assert.match(stdout, /ok 2 - suite two/);
  assert.match(stdout, /ok 1 - suite two - test/);
});

test('works without --test-only', () => {
  const args = [
    '--test',
    '--test-reporter=tap',
    '--test-isolation=none',
    fixture1,
    fixture2,
  ];
  const child = spawnSync(process.execPath, args);
  const stdout = child.stdout.toString();

  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
  assert.match(stdout, /# tests 2/);
  assert.match(stdout, /# suites 2/);
  assert.match(stdout, /# pass 2/);
  assert.match(stdout, /ok 1 - suite one/);
  assert.match(stdout, /ok 1 - suite one - test/);
  assert.match(stdout, /ok 2 - suite two/);
  assert.match(stdout, /ok 1 - suite two - test/);
});

test('works with --test-name-pattern', () => {
  const args = [
    '--test',
    '--test-reporter=tap',
    '--test-isolation=none',
    '--test-name-pattern=/test one/',
    fixture1,
    fixture2,
  ];
  const child = spawnSync(process.execPath, args);
  const stdout = child.stdout.toString();

  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
  assert.match(stdout, /# tests 0/);
  assert.match(stdout, /# suites 0/);
});

test('works with --test-skip-pattern', () => {
  const args = [
    '--test',
    '--test-reporter=tap',
    '--test-isolation=none',
    '--test-skip-pattern=/one/',
    fixture1,
    fixture2,
  ];
  const child = spawnSync(process.execPath, args);
  const stdout = child.stdout.toString();

  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
  assert.match(stdout, /# tests 1/);
  assert.match(stdout, /# suites 1/);
  assert.match(stdout, /# pass 1/);
  assert.match(stdout, /ok 1 - suite two - test/);
});
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-runner-no-isolation-hooks.mjs                                        0000664 0000000 0000000 00000003220 14746647661 0024060 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import { test } from 'node:test';

const testArguments = [
  '--test',
  '--test-isolation=none',
];

const testFiles = [
  fixtures.path('test-runner', 'no-isolation', 'one.test.js'),
  fixtures.path('test-runner', 'no-isolation', 'two.test.js'),
];

const order = [
  'before(): global',

  'before one: <root>',
  'suite one',

  'before two: <root>',
  'suite two',

  'beforeEach(): global',
  'beforeEach one: suite one - test',
  'beforeEach two: suite one - test',

  'suite one - test',
  'afterEach(): global',
  'afterEach one: suite one - test',
  'afterEach two: suite one - test',

  'before suite two: suite two',
  'beforeEach(): global',
  'beforeEach one: suite two - test',
  'beforeEach two: suite two - test',

  'suite two - test',
  'afterEach(): global',
  'afterEach one: suite two - test',
  'afterEach two: suite two - test',

  'after(): global',
  'after one: <root>',
  'after two: <root>',
];

test('Using --require to define global hooks works', async (t) => {
  const spawned = await common.spawnPromisified(process.execPath, [
    ...testArguments,
    '--require', fixtures.path('test-runner', 'no-isolation', 'global-hooks.js'),
    ...testFiles,
  ]);

  t.assert.ok(spawned.stdout.includes(order.join('\n')));
});

test('Using --import to define global hooks works', async (t) => {
  const spawned = await common.spawnPromisified(process.execPath, [
    ...testArguments,
    '--import', fixtures.fileURL('test-runner', 'no-isolation', 'global-hooks.js'),
    ...testFiles,
  ]);

  t.assert.ok(spawned.stdout.includes(order.join('\n')));
});
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-runner-no-isolation.mjs                                              0000664 0000000 0000000 00000002166 14746647661 0022747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import { allowGlobals, mustCall, mustNotCall } from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import { deepStrictEqual } from 'node:assert';
import { run } from 'node:test';

const stream = run({
  files: [
    fixtures.path('test-runner', 'no-isolation', 'one.test.js'),
    fixtures.path('test-runner', 'no-isolation', 'two.test.js'),
  ],
  isolation: 'none',
});

stream.on('test:fail', mustNotCall());
stream.on('test:pass', mustCall(4));
// eslint-disable-next-line no-unused-vars
for await (const _ of stream);
allowGlobals(globalThis.GLOBAL_ORDER);
deepStrictEqual(globalThis.GLOBAL_ORDER, [
  'before one: <root>',
  'suite one',
  'before two: <root>',
  'suite two',

  'beforeEach one: suite one - test',
  'beforeEach two: suite one - test',
  'suite one - test',
  'afterEach one: suite one - test',
  'afterEach two: suite one - test',

  'before suite two: suite two',

  'beforeEach one: suite two - test',
  'beforeEach two: suite two - test',
  'suite two - test',
  'afterEach one: suite two - test',
  'afterEach two: suite two - test',

  'after one: <root>',
  'after two: <root>',
]);
                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-runner-option-validation.js                                          0000664 0000000 0000000 00000001731 14746647661 0023614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const test = require('node:test');

[Symbol(), {}, [], () => {}, 1n, true, '1'].forEach((timeout) => {
  assert.throws(() => test({ timeout }), { code: 'ERR_INVALID_ARG_TYPE' });
});
[-1, -Infinity, NaN, 2 ** 33, Number.MAX_SAFE_INTEGER].forEach((timeout) => {
  assert.throws(() => test({ timeout }), { code: 'ERR_OUT_OF_RANGE' });
});
[null, undefined, Infinity, 0, 1, 1.1].forEach((timeout) => {
  // Valid values should not throw.
  test({ timeout });
});

[Symbol(), {}, [], () => {}, 1n, '1'].forEach((concurrency) => {
  assert.throws(() => test({ concurrency }), { code: 'ERR_INVALID_ARG_TYPE' });
});
[-1, 0, 1.1, -Infinity, NaN, 2 ** 33, Number.MAX_SAFE_INTEGER].forEach((concurrency) => {
  assert.throws(() => test({ concurrency }), { code: 'ERR_OUT_OF_RANGE' });
});
[null, undefined, 1, 2 ** 31, true, false].forEach((concurrency) => {
  // Valid values should not throw.
  test({ concurrency });
});
                                       node-23.7.0/test/parallel/test-runner-output.mjs                                                    0000664 0000000 0000000 00000025213 14746647661 0021672 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import * as snapshot from '../common/assertSnapshot.js';
import { describe, it } from 'node:test';
import { hostname } from 'node:os';
import { chdir, cwd } from 'node:process';
import { fileURLToPath } from 'node:url';

const skipForceColors =
  process.config.variables.icu_gyp_path !== 'tools/icu/icu-generic.gyp' ||
  process.config.variables.node_shared_openssl;

const canColorize = process.stderr?.isTTY && (
  typeof process.stderr?.getColorDepth === 'function' ?
    process.stderr?.getColorDepth() > 2 : true);
const skipCoverageColors = !canColorize;

function replaceTestDuration(str) {
  return str
    .replaceAll(/duration_ms: [0-9.]+/g, 'duration_ms: *')
    .replaceAll(/duration_ms [0-9.]+/g, 'duration_ms *');
}

const root = fileURLToPath(new URL('../..', import.meta.url)).slice(0, -1);

const color = '(\\[\\d+m)';
const stackTraceBasePath = new RegExp(`${color}\\(${root.replaceAll(/[\\^$*+?.()|[\]{}]/g, '\\$&')}/?${color}(.*)${color}\\)`, 'g');

function replaceSpecDuration(str) {
  return str
    .replaceAll(/[0-9.]+ms/g, '*ms')
    .replaceAll(/duration_ms [0-9.]+/g, 'duration_ms *')
    .replace(stackTraceBasePath, '$3');
}

function replaceJunitDuration(str) {
  return str
    .replaceAll(/time="[0-9.]+"/g, 'time="*"')
    .replaceAll(/duration_ms [0-9.]+/g, 'duration_ms *')
    .replaceAll(hostname(), 'HOSTNAME')
    .replace(stackTraceBasePath, '$3');
}

function removeWindowsPathEscaping(str) {
  return common.isWindows ? str.replaceAll(/\\\\/g, '\\') : str;
}

function replaceTestLocationLine(str) {
  return str.replaceAll(/(js:)(\d+)(:\d+)/g, '$1(LINE)$3');
}

// The Node test coverage returns results for all files called by the test. This
// will make the output file change if files like test/common/index.js change.
// This transform picks only the first line and then the lines from the test
// file.
function pickTestFileFromLcov(str) {
  const lines = str.split(/\n/);
  const firstLineOfTestFile = lines.findIndex(
    (line) => line.startsWith('SF:') && line.trim().endsWith('output.js')
  );
  const lastLineOfTestFile = lines.findIndex(
    (line, index) => index > firstLineOfTestFile && line.trim() === 'end_of_record'
  );
  return (
    lines[0] + '\n' + lines.slice(firstLineOfTestFile, lastLineOfTestFile + 1).join('\n') + '\n'
  );
}

const defaultTransform = snapshot.transform(
  snapshot.replaceWindowsLineEndings,
  snapshot.replaceStackTrace,
  removeWindowsPathEscaping,
  snapshot.replaceFullPaths,
  snapshot.replaceWindowsPaths,
  replaceTestDuration,
  replaceTestLocationLine,
);
const specTransform = snapshot.transform(
  replaceSpecDuration,
  snapshot.replaceWindowsLineEndings,
  snapshot.replaceStackTrace,
  snapshot.replaceWindowsPaths,
);
const junitTransform = snapshot.transform(
  replaceJunitDuration,
  snapshot.replaceWindowsLineEndings,
  snapshot.replaceStackTrace,
  snapshot.replaceWindowsPaths,
);
const lcovTransform = snapshot.transform(
  snapshot.replaceWindowsLineEndings,
  snapshot.replaceStackTrace,
  snapshot.replaceFullPaths,
  snapshot.replaceWindowsPaths,
  pickTestFileFromLcov
);


const tests = [
  { name: 'test-runner/output/abort.js', flags: ['--test-reporter=tap'] },
  {
    name: 'test-runner/output/abort-runs-after-hook.js',
    flags: ['--test-reporter=tap'],
  },
  { name: 'test-runner/output/abort_suite.js', flags: ['--test-reporter=tap'] },
  { name: 'test-runner/output/abort_hooks.js', flags: ['--test-reporter=tap'] },
  { name: 'test-runner/output/describe_it.js', flags: ['--test-reporter=tap'] },
  {
    name: 'test-runner/output/describe_nested.js',
    flags: ['--test-reporter=tap'],
  },
  { name: 'test-runner/output/eval_dot.js', transform: specTransform },
  { name: 'test-runner/output/eval_spec.js', transform: specTransform },
  { name: 'test-runner/output/eval_tap.js' },
  {
    name: 'test-runner/output/filtered-suite-delayed-build.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/filtered-suite-order.mjs',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/filtered-suite-throws.js',
    flags: ['--test-reporter=tap'],
  },
  { name: 'test-runner/output/hooks.js', flags: ['--test-reporter=tap'] },
  { name: 'test-runner/output/hooks_spec_reporter.js', transform: specTransform },
  { name: 'test-runner/output/skip-each-hooks.js', transform: specTransform },
  { name: 'test-runner/output/suite-skip-hooks.js', transform: specTransform },
  {
    name: 'test-runner/output/timeout_in_before_each_should_not_affect_further_tests.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/hooks-with-no-global-test.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/global-hooks-with-no-tests.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/before-and-after-each-too-many-listeners.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/before-and-after-each-with-timeout-too-many-listeners.js',
    flags: ['--test-reporter=tap'],
  },
  { name: 'test-runner/output/force_exit.js', transform: specTransform },
  {
    name: 'test-runner/output/global_after_should_fail_the_test.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/no_refs.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/no_tests.js',
    flags: ['--test-reporter=tap'],
  },
  { name: 'test-runner/output/only_tests.js', flags: ['--test-reporter=tap'] },
  { name: 'test-runner/output/dot_reporter.js', transform: specTransform },
  { name: 'test-runner/output/junit_reporter.js', transform: junitTransform },
  { name: 'test-runner/output/spec_reporter_successful.js', transform: specTransform },
  { name: 'test-runner/output/spec_reporter.js', transform: specTransform },
  { name: 'test-runner/output/spec_reporter_cli.js', transform: specTransform },
  {
    name: 'test-runner/output/source_mapped_locations.mjs',
    flags: ['--test-reporter=tap'],
  },
  process.features.inspector ?
    {
      name: 'test-runner/output/lcov_reporter.js',
      transform: lcovTransform
    } :
    false,
  { name: 'test-runner/output/output.js', flags: ['--test-reporter=tap'] },
  { name: 'test-runner/output/output_cli.js' },
  {
    name: 'test-runner/output/name_and_skip_patterns.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/name_pattern.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/name_pattern_with_only.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/skip_pattern.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/unfinished-suite-async-error.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/unresolved_promise.js',
    flags: ['--test-reporter=tap'],
  },
  { name: 'test-runner/output/default_output.js', transform: specTransform, tty: true },
  {
    name: 'test-runner/output/arbitrary-output.js',
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/non-tty-forced-color-output.js',
    transform: specTransform,
  },
  canColorize ? {
    name: 'test-runner/output/assertion-color-tty.mjs',
    flags: ['--test', '--stack-trace-limit=0'],
    transform: specTransform,
    tty: true,
  } : false,
  {
    name: 'test-runner/output/async-test-scheduling.mjs',
    flags: ['--test-reporter=tap'],
  },
  !skipForceColors ? {
    name: 'test-runner/output/arbitrary-output-colored.js',
    transform: snapshot.transform(specTransform, replaceTestDuration), tty: true
  } : false,
  { name: 'test-runner/output/dot_output_custom_columns.js', transform: specTransform, tty: true },
  {
    name: 'test-runner/output/tap_escape.js',
    transform: snapshot.transform(
      snapshot.replaceWindowsLineEndings,
      replaceTestDuration,
    ),
    flags: ['--test-reporter=tap'],
  },
  {
    name: 'test-runner/output/test-runner-plan.js',
    flags: ['--test-reporter=tap'],
  },
  process.features.inspector ? {
    name: 'test-runner/output/coverage_failure.js',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  {
    name: 'test-runner/output/test-diagnostic-warning-without-test-only-flag.js',
    flags: ['--test', '--test-reporter=tap'],
  },
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-40.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-80.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector && !skipCoverageColors ? {
    name: 'test-runner/output/coverage-width-80-color.mjs',
    flags: ['--test-coverage-exclude=!test/**'],
    transform: specTransform,
    tty: true
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-100.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-150.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-infinity.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-80-uncovered-lines.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-100-uncovered-lines.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector && !skipCoverageColors ? {
    name: 'test-runner/output/coverage-width-80-uncovered-lines-color.mjs',
    flags: ['--test-coverage-exclude=!test/**'],
    transform: specTransform,
    tty: true
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-150-uncovered-lines.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
  process.features.inspector ? {
    name: 'test-runner/output/coverage-width-infinity-uncovered-lines.mjs',
    flags: ['--test-reporter=tap', '--test-coverage-exclude=!test/**'],
  } : false,
]
.filter(Boolean)
.map(({ flags, name, tty, transform }) => ({
  name,
  fn: common.mustCall(async () => {
    await snapshot.spawnAndAssert(fixtures.path(name), transform ?? defaultTransform, { tty, flags });
  }),
}));

if (cwd() !== root) {
  chdir(root);
}
describe('test runner output', { concurrency: true }, () => {
  for (const { name, fn } of tests) {
    it(name, fn);
  }
});
                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-runner-reporters.js                                                  0000664 0000000 0000000 00000023130 14746647661 0022176 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const { describe, it } = require('node:test');
const { spawnSync } = require('node:child_process');
const assert = require('node:assert');
const fs = require('node:fs');

const testFile = fixtures.path('test-runner/reporters.js');
tmpdir.refresh();

let tmpFiles = 0;
describe('node:test reporters', { concurrency: true }, () => {
  it('should default to outputing TAP to stdout', async () => {
    const child = spawnSync(process.execPath, ['--test', testFile]);
    assert.strictEqual(child.stderr.toString(), '');
    assert.match(child.stdout.toString(), /✖ failing tests:/);
    assert.match(child.stdout.toString(), /✔ ok/);
    assert.match(child.stdout.toString(), /✖ failing/);
    assert.match(child.stdout.toString(), /✔ top level/);
  });

  it('should default destination to stdout when passing a single reporter', async () => {
    const child = spawnSync(process.execPath, ['--test', '--test-reporter', 'dot', testFile]);
    assert.strictEqual(child.stderr.toString(), '');
    assert.match(child.stdout.toString(), /\.XX\.\n/);
    assert.match(child.stdout.toString(), /Failed tests:/);
    assert.match(child.stdout.toString(), /✖ failing/);
    assert.match(child.stdout.toString(), /✖ nested/);
  });

  it('should throw when passing reporters without a destination', async () => {
    const child = spawnSync(process.execPath, ['--test', '--test-reporter', 'dot', '--test-reporter', 'tap', testFile]);
    assert.match(child.stderr.toString(), /The argument '--test-reporter' must match the number of specified '--test-reporter-destination'\. Received \[ 'dot', 'tap' \]/);
    assert.strictEqual(child.stdout.toString(), '');
  });

  it('should throw when passing a destination without a reporter', async () => {
    const child = spawnSync(process.execPath, ['--test', '--test-reporter-destination', 'tap', testFile]);
    assert.match(child.stderr.toString(), /The argument '--test-reporter' must match the number of specified '--test-reporter-destination'\. Received \[\]/);
    assert.strictEqual(child.stdout.toString(), '');
  });

  it('should support stdout as a destination', async () => {
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', 'dot', '--test-reporter-destination', 'stdout', testFile]);
    assert.strictEqual(child.stderr.toString(), '');
    assert.match(child.stdout.toString(), /\.XX\.\n/);
    assert.match(child.stdout.toString(), /Failed tests:/);
    assert.match(child.stdout.toString(), /✖ failing/);
    assert.match(child.stdout.toString(), /✖ nested/);
  });

  it('should support stderr as a destination', async () => {
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', 'dot', '--test-reporter-destination', 'stderr', testFile]);
    assert.match(child.stderr.toString(), /\.XX\.\n/);
    assert.match(child.stderr.toString(), /Failed tests:/);
    assert.match(child.stderr.toString(), /✖ failing/);
    assert.match(child.stderr.toString(), /✖ nested/);
    assert.strictEqual(child.stdout.toString(), '');
  });

  it('should support a file as a destination', async () => {
    const file = tmpdir.resolve(`${tmpFiles++}.out`);
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', 'dot', '--test-reporter-destination', file, testFile]);
    assert.strictEqual(child.stderr.toString(), '');
    assert.strictEqual(child.stdout.toString(), '');
    const fileContents = fs.readFileSync(file, 'utf8');
    assert.match(fileContents, /\.XX\.\n/);
    assert.match(fileContents, /Failed tests:/);
    assert.match(fileContents, /✖ failing/);
    assert.match(fileContents, /✖ nested/);
  });

  it('should disallow using v8-serializer as reporter', async () => {
    const child = spawnSync(process.execPath, ['--test', '--test-reporter', 'v8-serializer', testFile]);
    assert.strictEqual(child.stdout.toString(), '');
    assert(child.status > 0);
    assert.match(child.stderr.toString(), /ERR_MODULE_NOT_FOUND/);
  });

  it('should support multiple reporters', async () => {
    const file = tmpdir.resolve(`${tmpFiles++}.out`);
    const file2 = tmpdir.resolve(`${tmpFiles++}.out`);
    const child = spawnSync(process.execPath,
                            ['--test',
                             '--test-reporter', 'dot', '--test-reporter-destination', file,
                             '--test-reporter', 'spec', '--test-reporter-destination', file2,
                             '--test-reporter', 'tap', '--test-reporter-destination', 'stdout',
                             testFile]);
    assert.match(child.stdout.toString(), /TAP version 13/);
    assert.match(child.stdout.toString(), /# duration_ms/);
    const fileContents = fs.readFileSync(file, 'utf8');
    assert.match(fileContents, /\.XX\.\n/);
    assert.match(fileContents, /Failed tests:/);
    assert.match(fileContents, /✖ failing/);
    assert.match(fileContents, /✖ nested/);
    const file2Contents = fs.readFileSync(file2, 'utf8');
    assert.match(file2Contents, /▶ nested/);
    assert.match(file2Contents, /✔ ok/);
    assert.match(file2Contents, /✖ failing/);
  });

  ['js', 'cjs', 'mjs'].forEach((ext) => {
    it(`should support a '${ext}' file as a custom reporter`, async () => {
      const filename = `custom.${ext}`;
      const child = spawnSync(process.execPath,
                              ['--test', '--test-reporter', fixtures.fileURL('test-runner/custom_reporters/', filename),
                               testFile]);
      assert.strictEqual(child.stderr.toString(), '');
      const stdout = child.stdout.toString();
      assert.match(stdout, /{"test:enqueue":5,"test:dequeue":5,"test:complete":5,"test:start":4,"test:pass":2,"test:fail":2,"test:plan":2,"test:summary":2,"test:diagnostic":\d+}$/);
      assert.strictEqual(stdout.slice(0, filename.length + 2), `${filename} {`);
    });
  });

  it('should support a custom reporter from node_modules', async () => {
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', 'reporter-cjs', 'reporters.js'],
                            { cwd: fixtures.path('test-runner') });
    assert.strictEqual(child.stderr.toString(), '');
    assert.match(
      child.stdout.toString(),
      /^package: reporter-cjs{"test:enqueue":5,"test:dequeue":5,"test:complete":5,"test:start":4,"test:pass":2,"test:fail":2,"test:plan":2,"test:summary":2,"test:diagnostic":\d+}$/,
    );
  });

  it('should support a custom ESM reporter from node_modules', async () => {
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', 'reporter-esm', 'reporters.js'],
                            { cwd: fixtures.path('test-runner') });
    assert.strictEqual(child.stderr.toString(), '');
    assert.match(
      child.stdout.toString(),
      /^package: reporter-esm{"test:enqueue":5,"test:dequeue":5,"test:complete":5,"test:start":4,"test:pass":2,"test:fail":2,"test:plan":2,"test:summary":2,"test:diagnostic":\d+}$/,
    );
  });

  it('should throw when reporter setup throws asynchronously', async () => {
    const child = spawnSync(
      process.execPath,
      ['--test', '--test-reporter', fixtures.fileURL('empty.js'), 'reporters.js'],
      { cwd: fixtures.path('test-runner') }
    );
    assert.strictEqual(child.status, 7);
    assert.strictEqual(child.signal, null);
    assert.strictEqual(child.stdout.toString(), '');
    assert.match(child.stderr.toString(), /ERR_INVALID_ARG_TYPE/);
  });

  it('should throw when reporter errors', async () => {
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', fixtures.fileURL('test-runner/custom_reporters/throwing.js'),
                             fixtures.path('test-runner/default-behavior/index.test.js')]);
    assert.strictEqual(child.status, 7);
    assert.strictEqual(child.signal, null);
    assert.strictEqual(child.stdout.toString(), 'Going to throw an error\n');
    assert.match(child.stderr.toString(), /Error: Reporting error\r?\n\s+at customReporter/);
  });

  it('should throw when reporter errors asynchronously', async () => {
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter',
                             fixtures.fileURL('test-runner/custom_reporters/throwing-async.js'),
                             fixtures.path('test-runner/default-behavior/index.test.js')]);
    assert.strictEqual(child.status, 7);
    assert.strictEqual(child.signal, null);
    assert.strictEqual(child.stdout.toString(), 'Going to throw an error\n');
    assert.match(child.stderr.toString(), /Emitted 'error' event on Duplex instance/);
  });

  it('should support stdout as a destination with spec reporter', async () => {
    process.env.FORCE_COLOR = '1';
    const file = tmpdir.resolve(`${tmpFiles++}.txt`);
    const child = spawnSync(process.execPath,
                            ['--test', '--test-reporter', 'spec', '--test-reporter-destination', file, testFile]);
    assert.strictEqual(child.stderr.toString(), '');
    assert.strictEqual(child.stdout.toString(), '');
    const fileConent = fs.readFileSync(file, 'utf8');
    assert.match(fileConent, /▶ nested/);
    assert.match(fileConent, /✔ ok/);
    assert.match(fileConent, /✖ failing/);
    assert.match(fileConent, /ℹ tests 4/);
    assert.match(fileConent, /ℹ pass 2/);
    assert.match(fileConent, /ℹ fail 2/);
    assert.match(fileConent, /ℹ cancelled 0/);
    assert.match(fileConent, /ℹ skipped 0/);
    assert.match(fileConent, /ℹ todo 0/);
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-runner-root-after-with-refed-handles.js                              0000664 0000000 0000000 00000001002 14746647661 0025675 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { before, after, test } = require('node:test');
const { createServer } = require('node:http');

let server;

before(common.mustCall(() => {
  server = createServer();

  return new Promise(common.mustCall((resolve, reject) => {
    server.listen(0, common.mustCall((err) => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    }));
  }));
}));

after(common.mustCall(() => {
  server.close(common.mustCall());
}));

test();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-runner-root-duration.js                                              0000664 0000000 0000000 00000001552 14746647661 0022763 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const { spawnPromisified } = require('../common');
const fixtures = require('../common/fixtures');
const { strictEqual } = require('node:assert');
const { test } = require('node:test');

test('root duration is longer than test duration', async () => {
  const {
    code,
    stderr,
    stdout,
  } = await spawnPromisified(process.execPath, [
    '--test-reporter=tap',
    fixtures.path('test-runner/root-duration.mjs'),
  ]);

  strictEqual(code, 0);
  strictEqual(stderr, '');
  const durations = [...stdout.matchAll(/duration_ms:? ([.\d]+)/g)];
  strictEqual(durations.length, 2);
  const testDuration = Number.parseFloat(durations[0][1]);
  const rootDuration = Number.parseFloat(durations[1][1]);
  strictEqual(Number.isNaN(testDuration), false);
  strictEqual(Number.isNaN(rootDuration), false);
  strictEqual(rootDuration >= testDuration, true);
});
                                                                                                                                                      node-23.7.0/test/parallel/test-runner-run-coverage.mjs                                              0000664 0000000 0000000 00000021114 14746647661 0022723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import { describe, it, run } from 'node:test';
import assert from 'node:assert';
import { sep } from 'node:path';

const files = [fixtures.path('test-runner', 'coverage.js')];
const abortedSignal = AbortSignal.abort();

describe('require(\'node:test\').run coverage settings', { concurrency: true }, async () => {
  await describe('validation', async () => {
    await it('should only allow boolean in options.coverage', async () => {
      [Symbol(), {}, () => {}, 0, 1, 0n, 1n, '', '1', Promise.resolve(true), []]
        .forEach((coverage) => assert.throws(() => run({ coverage }), {
          code: 'ERR_INVALID_ARG_TYPE'
        }));
    });

    await it('should only allow string|string[] in options.coverageExcludeGlobs', async () => {
      [Symbol(), {}, () => {}, 0, 1, 0n, 1n, Promise.resolve([]), true, false]
        .forEach((coverageExcludeGlobs) => {
          assert.throws(() => run({ coverage: true, coverageExcludeGlobs }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
          assert.throws(() => run({ coverage: true, coverageExcludeGlobs: [coverageExcludeGlobs] }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
        });
      run({ files: [], signal: abortedSignal, coverage: true, coverageExcludeGlobs: [''] });
      run({ files: [], signal: abortedSignal, coverage: true, coverageExcludeGlobs: '' });
    });

    await it('should only allow string|string[] in options.coverageIncludeGlobs', async () => {
      [Symbol(), {}, () => {}, 0, 1, 0n, 1n, Promise.resolve([]), true, false]
        .forEach((coverageIncludeGlobs) => {
          assert.throws(() => run({ coverage: true, coverageIncludeGlobs }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
          assert.throws(() => run({ coverage: true, coverageIncludeGlobs: [coverageIncludeGlobs] }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
        });

      run({ files: [], signal: abortedSignal, coverage: true, coverageIncludeGlobs: [''] });
      run({ files: [], signal: abortedSignal, coverage: true, coverageIncludeGlobs: '' });
    });

    await it('should only allow an int within range in options.lineCoverage', async () => {
      [Symbol(), {}, () => {}, [], 0n, 1n, Promise.resolve([]), true, false]
        .forEach((lineCoverage) => {
          assert.throws(() => run({ coverage: true, lineCoverage }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
          assert.throws(() => run({ coverage: true, lineCoverage: [lineCoverage] }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
        });
      assert.throws(() => run({ coverage: true, lineCoverage: -1 }), { code: 'ERR_OUT_OF_RANGE' });
      assert.throws(() => run({ coverage: true, lineCoverage: 101 }), { code: 'ERR_OUT_OF_RANGE' });

      run({ files: [], signal: abortedSignal, coverage: true, lineCoverage: 0 });
    });

    await it('should only allow an int within range in options.branchCoverage', async () => {
      [Symbol(), {}, () => {}, [], 0n, 1n, Promise.resolve([]), true, false]
        .forEach((branchCoverage) => {
          assert.throws(() => run({ coverage: true, branchCoverage }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
          assert.throws(() => run({ coverage: true, branchCoverage: [branchCoverage] }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
        });

      assert.throws(() => run({ coverage: true, branchCoverage: -1 }), { code: 'ERR_OUT_OF_RANGE' });
      assert.throws(() => run({ coverage: true, branchCoverage: 101 }), { code: 'ERR_OUT_OF_RANGE' });

      run({ files: [], signal: abortedSignal, coverage: true, branchCoverage: 0 });
    });

    await it('should only allow an int within range in options.functionCoverage', async () => {
      [Symbol(), {}, () => {}, [], 0n, 1n, Promise.resolve([]), true, false]
        .forEach((functionCoverage) => {
          assert.throws(() => run({ coverage: true, functionCoverage }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
          assert.throws(() => run({ coverage: true, functionCoverage: [functionCoverage] }), {
            code: 'ERR_INVALID_ARG_TYPE'
          });
        });

      assert.throws(() => run({ coverage: true, functionCoverage: -1 }), { code: 'ERR_OUT_OF_RANGE' });
      assert.throws(() => run({ coverage: true, functionCoverage: 101 }), { code: 'ERR_OUT_OF_RANGE' });

      run({ files: [], signal: abortedSignal, coverage: true, functionCoverage: 0 });
    });
  });

  const options = { concurrency: false, skip: !process.features.inspector ? 'inspector disabled' : false };
  await describe('run with coverage', options, async () => {
    await it('should run with coverage', async () => {
      const stream = run({ files, coverage: true });
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall());
      stream.on('test:coverage', common.mustCall());
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    await it('should run with coverage and exclude by glob', async () => {
      const stream = run({ files, coverage: true, coverageExcludeGlobs: ['test/*/test-runner/invalid-tap.js'] });
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(1));
      stream.on('test:coverage', common.mustCall(({ summary: { files } }) => {
        const filesPaths = files.map(({ path }) => path);
        assert.strictEqual(filesPaths.some((path) => path.includes(`test-runner${sep}invalid-tap.js`)), false);
      }));
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    await it('should run with coverage and include by glob', async () => {
      const stream = run({
        files,
        coverage: true,
        coverageIncludeGlobs: ['test/fixtures/test-runner/coverage.js', 'test/*/v8-coverage/throw.js'],
      });
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(1));
      stream.on('test:coverage', common.mustCall(({ summary: { files } }) => {
        const filesPaths = files.map(({ path }) => path);
        assert.strictEqual(filesPaths.some((path) => path.includes(`v8-coverage${sep}throw.js`)), true);
      }));
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    await it('should run while including and excluding globs', async () => {
      const stream = run({
        files: [...files, fixtures.path('test-runner/invalid-tap.js')],
        coverage: true,
        coverageIncludeGlobs: ['test/fixtures/test-runner/*.js'],
        coverageExcludeGlobs: ['test/fixtures/test-runner/*-tap.js']
      });
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(2));
      stream.on('test:coverage', common.mustCall(({ summary: { files } }) => {
        const filesPaths = files.map(({ path }) => path);
        assert.strictEqual(filesPaths.every((path) => !path.includes(`test-runner${sep}invalid-tap.js`)), true);
        assert.strictEqual(filesPaths.some((path) => path.includes(`test-runner${sep}coverage.js`)), true);
      }));
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    await it('should run with coverage and fail when below line threshold', async () => {
      const thresholdErrors = [];
      const originalExitCode = process.exitCode;
      assert.notStrictEqual(originalExitCode, 1);
      const stream = run({ files, coverage: true, lineCoverage: 99, branchCoverage: 99, functionCoverage: 99 });
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(1));
      stream.on('test:diagnostic', ({ message }) => {
        const match = message.match(/Error: \d{2}\.\d{2}% (line|branch|function) coverage does not meet threshold of 99%/);
        if (match) {
          thresholdErrors.push(match[1]);
        }
      });
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
      assert.deepStrictEqual(thresholdErrors.sort(), ['branch', 'function', 'line']);
      assert.strictEqual(process.exitCode, 1);
      process.exitCode = originalExitCode;
    });
  });
});


// exitHandler doesn't run until after the tests / after hooks finish.
process.on('exit', () => {
  assert.strictEqual(process.listeners('uncaughtException').length, 0);
  assert.strictEqual(process.listeners('unhandledRejection').length, 0);
  assert.strictEqual(process.listeners('beforeExit').length, 0);
  assert.strictEqual(process.listeners('SIGINT').length, 0);
  assert.strictEqual(process.listeners('SIGTERM').length, 0);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-runner-run-files-undefined.mjs                                       0000664 0000000 0000000 00000003450 14746647661 0024174 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import tmpdir from '../common/tmpdir.js';
import { describe, it, run, beforeEach } from 'node:test';
import { dot, spec, tap } from 'node:test/reporters';
import { fork } from 'node:child_process';
import assert from 'node:assert';

if (common.hasCrypto) {
  console.log('1..0 # Skipped: no crypto');
  process.exit(0);
}

if (process.env.CHILD === 'true') {
  describe('require(\'node:test\').run with no files', { concurrency: true }, () => {
    beforeEach(() => {
      tmpdir.refresh();
      process.chdir(tmpdir.path);
    });

    it('should neither pass or fail', async () => {
      const stream = run({
        files: undefined
      }).compose(tap);
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustNotCall());

      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    it('can use the spec reporter', async () => {
      const stream = run({
        files: undefined
      }).compose(spec);
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustNotCall());

      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    it('can use the dot reporter', async () => {
      const stream = run({
        files: undefined
      }).compose(dot);
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustNotCall());

      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });
  });
} else if (common.isAIX) {
  console.log('1..0 # Skipped: test runner without specifying files fails on AIX');
} else {
  fork(import.meta.filename, [], {
    env: { CHILD: 'true' }
  }).on('exit', common.mustCall((code) => {
    assert.strictEqual(code, 0);
  }));
}
                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-runner-run-watch.mjs                                                 0000664 0000000 0000000 00000023475 14746647661 0022252 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import { describe, it, beforeEach, run } from 'node:test';
import assert from 'node:assert';
import { spawn } from 'node:child_process';
import { once } from 'node:events';
import { writeFileSync, renameSync, unlinkSync, existsSync } from 'node:fs';
import tmpdir from '../common/tmpdir.js';
import { join } from 'node:path';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

if (common.isAIX)
  common.skip('folder watch capability is limited in AIX.');

// This test updates these files repeatedly,
// Reading them from disk is unreliable due to race conditions.
const fixtureContent = {
  'dependency.js': 'module.exports = {};',
  'dependency.mjs': 'export const a = 1;',
  'test.js': `
const test = require('node:test');
require('./dependency.js');
import('./dependency.mjs');
import('data:text/javascript,');
test('test has ran');`,
};

let fixturePaths;

function refresh() {
  tmpdir.refresh();

  fixturePaths = Object.keys(fixtureContent)
    .reduce((acc, file) => ({ ...acc, [file]: tmpdir.resolve(file) }), {});
  Object.entries(fixtureContent)
    .forEach(([file, content]) => writeFileSync(fixturePaths[file], content));
}

const runner = join(import.meta.dirname, '..', 'fixtures', 'test-runner-watch.mjs');

async function testWatch(
  {
    fileToUpdate,
    file,
    action = 'update',
    cwd = tmpdir.path,
    fileToCreate,
    runnerCwd,
    isolation
  }
) {
  const ran1 = Promise.withResolvers();
  const ran2 = Promise.withResolvers();
  const args = [runner];
  if (file) args.push('--file', file);
  if (runnerCwd) args.push('--cwd', runnerCwd);
  if (isolation) args.push('--isolation', isolation);
  const child = spawn(process.execPath,
                      args,
                      { encoding: 'utf8', stdio: 'pipe', cwd });
  let stdout = '';
  let currentRun = '';
  const runs = [];

  child.stdout.on('data', (data) => {
    stdout += data.toString();
    currentRun += data.toString();
    const testRuns = stdout.match(/duration_ms\s\d+/g);
    if (testRuns?.length >= 1) ran1.resolve();
    if (testRuns?.length >= 2) ran2.resolve();
  });

  const testUpdate = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const content = fixtureContent[fileToUpdate];
    const path = fixturePaths[fileToUpdate];
    const interval = setInterval(() => writeFileSync(path, content), common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    clearInterval(interval);
    child.kill();
    await once(child, 'exit');

    assert.strictEqual(runs.length, 2);

    for (const run of runs) {
      assert.doesNotMatch(run, /run\(\) is being called recursively/);
      assert.match(run, /tests 1/);
      assert.match(run, /pass 1/);
      assert.match(run, /fail 0/);
      assert.match(run, /cancelled 0/);
    }
  };

  const testRename = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const fileToRenamePath = tmpdir.resolve(fileToUpdate);
    const newFileNamePath = tmpdir.resolve(`test-renamed-${fileToUpdate}`);
    const interval = setInterval(() => {
      renameSync(fileToRenamePath, newFileNamePath);
      clearInterval(interval);
    }, common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    assert.strictEqual(runs.length, 2);

    const [firstRun, secondRun] = runs;
    assert.match(firstRun, /tests 1/);
    assert.match(firstRun, /pass 1/);
    assert.match(firstRun, /fail 0/);
    assert.match(firstRun, /cancelled 0/);
    assert.doesNotMatch(firstRun, /run\(\) is being called recursively/);

    if (action === 'rename2') {
      assert.match(secondRun, /MODULE_NOT_FOUND/);
      return;
    }

    assert.match(secondRun, /tests 1/);
    assert.match(secondRun, /pass 1/);
    assert.match(secondRun, /fail 0/);
    assert.match(secondRun, /cancelled 0/);
    assert.doesNotMatch(secondRun, /run\(\) is being called recursively/);
  };

  const testDelete = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const fileToDeletePath = tmpdir.resolve(fileToUpdate);
    const interval = setInterval(() => {
      if (existsSync(fileToDeletePath)) {
        unlinkSync(fileToDeletePath);
      } else {
        ran2.resolve();
        clearInterval(interval);
      }
    }, common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    assert.strictEqual(runs.length, 2);

    for (const run of runs) {
      assert.doesNotMatch(run, /MODULE_NOT_FOUND/);
    }
  };

  const testCreate = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const newFilePath = tmpdir.resolve(fileToCreate);
    const interval = setInterval(
      () => {
        writeFileSync(
          newFilePath,
          'module.exports = {};'
        );
        clearInterval(interval);
      },
      common.platformTimeout(1000)
    );
    await ran2.promise;
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    for (const run of runs) {
      assert.match(run, /tests 1/);
      assert.match(run, /pass 1/);
      assert.match(run, /fail 0/);
      assert.match(run, /cancelled 0/);
    }
  };

  action === 'update' && await testUpdate();
  action === 'rename' && await testRename();
  action === 'rename2' && await testRename();
  action === 'delete' && await testDelete();
  action === 'create' && await testCreate();
}

describe('test runner watch mode', () => {
  beforeEach(refresh);
  it('should run tests repeatedly', async () => {
    await testWatch({ file: 'test.js', fileToUpdate: 'test.js' });
  });

  it('should run tests with dependency repeatedly', async () => {
    await testWatch({ file: 'test.js', fileToUpdate: 'dependency.js' });
  });

  it('should run tests with ESM dependency', async () => {
    await testWatch({ file: 'test.js', fileToUpdate: 'dependency.mjs' });
  });

  it('should support running tests without a file', async () => {
    await testWatch({ fileToUpdate: 'test.js' });
  });

  it('should support a watched test file rename', async () => {
    await testWatch({ fileToUpdate: 'test.js', action: 'rename' });
  });

  it('should not throw when deleting a watched test file', async () => {
    await testWatch({ fileToUpdate: 'test.js', action: 'delete' });
  });

  it('should run tests with dependency repeatedly in a different cwd', async () => {
    await testWatch({
      file: join(tmpdir.path, 'test.js'),
      fileToUpdate: 'dependency.js',
      cwd: import.meta.dirname,
      action: 'rename2'
    });
  });

  it('should handle renames in a different cwd', async () => {
    await testWatch({
      file: join(tmpdir.path, 'test.js'),
      fileToUpdate: 'test.js',
      cwd: import.meta.dirname,
      action: 'rename2'
    });
  });

  it(
    'should run new tests when a new file is created in the watched directory',
    async () => {
      await testWatch({ action: 'create', fileToCreate: 'new-test-file.test.js' });
    });

  describe('test runner watch mode with different cwd', () => {
    it(
      'should execute run using a different cwd for the runner than the process cwd',
      async () => {
        await testWatch(
          {
            fileToUpdate: 'test.js',
            action: 'rename',
            cwd: import.meta.dirname,
            runnerCwd: tmpdir.path
          }
        );
      });

    it(
      'should execute run using a different cwd for the runner than the process cwd with isolation process',
      async () => {
        await testWatch(
          {
            fileToUpdate: 'test.js',
            action: 'rename',
            cwd: import.meta.dirname,
            runnerCwd: tmpdir.path,
            isolation: 'process'
          }
        );
      });

    it('should run with different cwd while in watch mode', async () => {
      const controller = new AbortController();
      const stream = run({
        cwd: tmpdir.path,
        watch: true,
        signal: controller.signal,
      }).on('data', function({ type }) {
        if (type === 'test:watch:drained') {
          stream.removeAllListeners('test:fail');
          stream.removeAllListeners('test:pass');
          controller.abort();
        }
      });

      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(1));
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    it('should run with different cwd while in watch mode and isolation "none"', async () => {
      const controller = new AbortController();
      const stream = run({
        cwd: tmpdir.path,
        watch: true,
        signal: controller.signal,
        isolation: 'none',
      }).on('data', function({ type }) {
        if (type === 'test:watch:drained') {
          stream.removeAllListeners('test:fail');
          stream.removeAllListeners('test:pass');
          controller.abort();
        }
      });

      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(1));
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    it('should run with different cwd while in watch mode and isolation "process"', async () => {
      const controller = new AbortController();
      const stream = run({
        cwd: tmpdir.path,
        watch: true,
        signal: controller.signal,
        isolation: 'process',
      }).on('data', function({ type }) {
        if (type === 'test:watch:drained') {
          stream.removeAllListeners('test:fail');
          stream.removeAllListeners('test:pass');
          controller.abort();
        }
      });

      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall(1));
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });
  });
});
                                                                                                                                                                                                   node-23.7.0/test/parallel/test-runner-run.mjs                                                       0000664 0000000 0000000 00000052656 14746647661 0021151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import { join } from 'node:path';
import { describe, it, run } from 'node:test';
import { dot, spec, tap } from 'node:test/reporters';
import assert from 'node:assert';
import util from 'node:util';

const testFixtures = fixtures.path('test-runner');

describe('require(\'node:test\').run', { concurrency: true }, () => {
  it('should run with no tests', async () => {
    const stream = run({ files: [] });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustNotCall());
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should fail with non existing file', async () => {
    const stream = run({ files: ['a-random-file-that-does-not-exist.js'] });
    stream.on('test:fail', common.mustCall(1));
    stream.on('test:pass', common.mustNotCall());
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should succeed with a file', async () => {
    const stream = run({ files: [join(testFixtures, 'default-behavior/test/random.cjs')] });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustCall(1));
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  const argPrintingFile = join(testFixtures, 'print-arguments.js');
  it('should allow custom arguments via execArgv', async () => {
    const result = await run({ files: [argPrintingFile], execArgv: ['-p', '"Printed"'] }).compose(spec).toArray();
    assert.strictEqual(result[0].toString(), 'Printed\n');
  });

  it('should allow custom arguments via argv', async () => {
    const stream = run({ files: [argPrintingFile], argv: ['--a-custom-argument'] });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustCall());
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should run same file twice', async () => {
    const stream = run({
      files: [
        join(testFixtures, 'default-behavior/test/random.cjs'),
        join(testFixtures, 'default-behavior/test/random.cjs'),
      ]
    });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustCall(2));
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should run a failed test', async () => {
    const stream = run({ files: [testFixtures] });
    stream.on('test:fail', common.mustCall(1));
    stream.on('test:pass', common.mustNotCall());
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should support timeout', async () => {
    const stream = run({ timeout: 50, files: [
      fixtures.path('test-runner', 'never_ending_sync.js'),
      fixtures.path('test-runner', 'never_ending_async.js'),
    ] });
    stream.on('test:fail', common.mustCall(2));
    stream.on('test:pass', common.mustNotCall());
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should be piped with dot', async () => {
    const result = await run({
      files: [join(testFixtures, 'default-behavior/test/random.cjs')]
    }).compose(dot).toArray();

    assert.strictEqual(result.length, 2);
    assert.strictEqual(util.stripVTControlCharacters(result[0]), '.');
    assert.strictEqual(result[1], '\n');
  });

  describe('should be piped with spec reporter', () => {
    it('new spec', async () => {
      const specReporter = new spec();
      const result = await run({
        files: [join(testFixtures, 'default-behavior/test/random.cjs')]
      }).compose(specReporter).toArray();
      const stringResults = result.map((bfr) => bfr.toString());
      assert.match(stringResults[0], /this should pass/);
      assert.match(stringResults[1], /tests 1/);
      assert.match(stringResults[1], /pass 1/);
    });

    it('spec()', async () => {
      const specReporter = spec();
      const result = await run({
        files: [join(testFixtures, 'default-behavior/test/random.cjs')]
      }).compose(specReporter).toArray();
      const stringResults = result.map((bfr) => bfr.toString());
      assert.match(stringResults[0], /this should pass/);
      assert.match(stringResults[1], /tests 1/);
      assert.match(stringResults[1], /pass 1/);
    });

    it('spec', async () => {
      const result = await run({
        files: [join(testFixtures, 'default-behavior/test/random.cjs')]
      }).compose(spec).toArray();
      const stringResults = result.map((bfr) => bfr.toString());
      assert.match(stringResults[0], /this should pass/);
      assert.match(stringResults[1], /tests 1/);
      assert.match(stringResults[1], /pass 1/);
    });
  });

  it('should be piped with tap', async () => {
    const result = await run({
      files: [join(testFixtures, 'default-behavior/test/random.cjs')]
    }).compose(tap).toArray();
    assert.strictEqual(result.length, 13);
    assert.strictEqual(result[0], 'TAP version 13\n');
    assert.strictEqual(result[1], '# Subtest: this should pass\n');
    assert.strictEqual(result[2], 'ok 1 - this should pass\n');
    assert.match(result[3], /duration_ms: \d+\.?\d*/);
    assert.strictEqual(result[4], '1..1\n');
    assert.strictEqual(result[5], '# tests 1\n');
    assert.strictEqual(result[6], '# suites 0\n');
    assert.strictEqual(result[7], '# pass 1\n');
    assert.strictEqual(result[8], '# fail 0\n');
    assert.strictEqual(result[9], '# cancelled 0\n');
    assert.strictEqual(result[10], '# skipped 0\n');
    assert.strictEqual(result[11], '# todo 0\n');
    assert.match(result[12], /# duration_ms \d+\.?\d*/);
  });

  it('should skip tests not matching testNamePatterns - RegExp', async () => {
    const result = await run({
      files: [join(testFixtures, 'default-behavior/test/skip_by_name.cjs')],
      testNamePatterns: [/executed/]
    })
      .compose(tap)
      .toArray();

    assert.strictEqual(result[2], 'ok 1 - this should be executed\n');
    assert.strictEqual(result[4], '1..1\n');
    assert.strictEqual(result[5], '# tests 1\n');
  });

  it('should skip tests not matching testNamePatterns - string', async () => {
    const result = await run({
      files: [join(testFixtures, 'default-behavior/test/skip_by_name.cjs')],
      testNamePatterns: ['executed']
    })
      .compose(tap)
      .toArray();
    assert.strictEqual(result[2], 'ok 1 - this should be executed\n');
    assert.strictEqual(result[4], '1..1\n');
    assert.strictEqual(result[5], '# tests 1\n');
  });

  it('should pass only to children', async () => {
    const result = await run({
      files: [join(testFixtures, 'test_only.js')],
      only: true
    })
      .compose(tap)
      .toArray();

    assert.strictEqual(result[2], 'ok 1 - this should be executed\n');
    assert.strictEqual(result[4], '1..1\n');
    assert.strictEqual(result[5], '# tests 1\n');
  });

  it('should emit "test:watch:drained" event on watch mode', async () => {
    const controller = new AbortController();
    await run({
      files: [join(testFixtures, 'default-behavior/test/random.cjs')],
      watch: true,
      signal: controller.signal,
    }).on('data', function({ type }) {
      if (type === 'test:watch:drained') {
        controller.abort();
      }
    });
  });

  it('should include test type in enqueue, dequeue events', async (t) => {
    const stream = await run({
      files: [join(testFixtures, 'default-behavior/test/suite_and_test.cjs')],
    });
    t.plan(4);

    stream.on('test:enqueue', common.mustCall((data) => {
      if (data.name === 'this is a suite') {
        t.assert.strictEqual(data.type, 'suite');
      }
      if (data.name === 'this is a test') {
        t.assert.strictEqual(data.type, 'test');
      }
    }, 2));
    stream.on('test:dequeue', common.mustCall((data) => {
      if (data.name === 'this is a suite') {
        t.assert.strictEqual(data.type, 'suite');
      }
      if (data.name === 'this is a test') {
        t.assert.strictEqual(data.type, 'test');
      }
    }, 2));

    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  describe('AbortSignal', () => {
    it('should accept a signal', async () => {
      const stream = run({ signal: AbortSignal.timeout(50), files: [
        fixtures.path('test-runner', 'never_ending_sync.js'),
        fixtures.path('test-runner', 'never_ending_async.js'),
      ] });
      stream.on('test:fail', common.mustCall(2));
      stream.on('test:pass', common.mustNotCall());
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });

    it('should stop watch mode when abortSignal aborts', async () => {
      const controller = new AbortController();
      const result = await run({
        files: [join(testFixtures, 'default-behavior/test/random.cjs')],
        watch: true,
        signal: controller.signal,
      })
        .compose(async function* (source) {
          let waitForCancel = 2;
          for await (const chunk of source) {
            if (chunk.type === 'test:watch:drained' ||
                (chunk.type === 'test:diagnostic' && chunk.data.message.startsWith('duration_ms'))) {
              waitForCancel--;
            }
            if (waitForCancel === 0) {
              controller.abort();
            }
            if (chunk.type === 'test:pass') {
              yield chunk.data.name;
            }
          }
        })
        .toArray();
      assert.deepStrictEqual(result, ['this should pass']);
    });

    it('should abort when test succeeded', async () => {
      const stream = run({
        files: [
          fixtures.path(
            'test-runner',
            'aborts',
            'successful-test-still-call-abort.js'
          ),
        ],
      });

      let passedTestCount = 0;
      let failedTestCount = 0;

      let output = '';
      for await (const data of stream) {
        if (data.type === 'test:stdout') {
          output += data.data.message.toString();
        }
        if (data.type === 'test:fail') {
          failedTestCount++;
        }
        if (data.type === 'test:pass') {
          passedTestCount++;
        }
      }

      assert.match(output, /abort called for test 1/);
      assert.match(output, /abort called for test 2/);
      assert.strictEqual(failedTestCount, 0, new Error('no tests should fail'));
      assert.strictEqual(passedTestCount, 2);
    });

    it('should abort when test failed', async () => {
      const stream = run({
        files: [
          fixtures.path(
            'test-runner',
            'aborts',
            'failed-test-still-call-abort.js'
          ),
        ],
      });

      let passedTestCount = 0;
      let failedTestCount = 0;

      let output = '';
      for await (const data of stream) {
        if (data.type === 'test:stdout') {
          output += data.data.message.toString();
        }
        if (data.type === 'test:fail') {
          failedTestCount++;
        }
        if (data.type === 'test:pass') {
          passedTestCount++;
        }
      }

      assert.match(output, /abort called for test 1/);
      assert.match(output, /abort called for test 2/);
      assert.strictEqual(passedTestCount, 0, new Error('no tests should pass'));
      assert.strictEqual(failedTestCount, 2);
    });
  });

  describe('sharding', () => {
    const shardsTestsFixtures = fixtures.path('test-runner', 'shards');
    const shardsTestsFiles = [
      'a.cjs',
      'b.cjs',
      'c.cjs',
      'd.cjs',
      'e.cjs',
      'f.cjs',
      'g.cjs',
      'h.cjs',
      'i.cjs',
      'j.cjs',
    ].map((file) => join(shardsTestsFixtures, file));

    describe('validation', () => {
      it('should require shard.total when having shard option', () => {
        assert.throws(() => run({ files: shardsTestsFiles, shard: {} }), {
          name: 'TypeError',
          code: 'ERR_INVALID_ARG_TYPE',
          message: 'The "options.shard.total" property must be of type number. Received undefined'
        });
      });

      it('should require shard.index when having shards option', () => {
        assert.throws(() => run({
          files: shardsTestsFiles,
          shard: {
            total: 5
          }
        }), {
          name: 'TypeError',
          code: 'ERR_INVALID_ARG_TYPE',
          message: 'The "options.shard.index" property must be of type number. Received undefined'
        });
      });

      it('should require shard.total to be greater than 0 when having shard option', () => {
        assert.throws(() => run({
          files: shardsTestsFiles,
          shard: {
            total: 0,
            index: 1
          }
        }), {
          name: 'RangeError',
          code: 'ERR_OUT_OF_RANGE',
          message:
            'The value of "options.shard.total" is out of range. It must be >= 1 && <= 9007199254740991. Received 0'
        });
      });

      it('should require shard.index to be greater than 0 when having shard option', () => {
        assert.throws(() => run({
          files: shardsTestsFiles,
          shard: {
            total: 6,
            index: 0
          }
        }), {
          name: 'RangeError',
          code: 'ERR_OUT_OF_RANGE',
          message: 'The value of "options.shard.index" is out of range. It must be >= 1 && <= 6. Received 0'
        });
      });

      it('should require shard.index to not be greater than the shards total when having shard option', () => {
        assert.throws(() => run({
          files: shardsTestsFiles,
          shard: {
            total: 6,
            index: 7
          }
        }), {
          name: 'RangeError',
          code: 'ERR_OUT_OF_RANGE',
          message: 'The value of "options.shard.index" is out of range. It must be >= 1 && <= 6. Received 7'
        });
      });

      it('should require watch mode to be disabled when having shard option', () => {
        assert.throws(() => run({
          files: shardsTestsFiles,
          watch: true,
          shard: {
            total: 6,
            index: 1
          }
        }), {
          name: 'TypeError',
          code: 'ERR_INVALID_ARG_VALUE',
          message: 'The property \'options.shard\' shards not supported with watch mode. Received true'
        });
      });
    });

    it('should run only the tests files matching the shard index', async () => {
      const stream = run({
        files: shardsTestsFiles,
        shard: {
          total: 5,
          index: 1
        }
      });

      const executedTestFiles = [];
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', (passedTest) => {
        executedTestFiles.push(passedTest.file);
      });
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream) ;

      assert.deepStrictEqual(executedTestFiles, [
        join(shardsTestsFixtures, 'a.cjs'),
        join(shardsTestsFixtures, 'f.cjs'),
      ]);
    });

    it('different shards should not run the same file', async () => {
      const executedTestFiles = [];

      const testStreams = [];
      const shards = 5;
      for (let i = 1; i <= shards; i++) {
        const stream = run({
          files: shardsTestsFiles,
          shard: {
            total: shards,
            index: i
          }
        });
        stream.on('test:fail', common.mustNotCall());
        stream.on('test:pass', (passedTest) => {
          executedTestFiles.push(passedTest.file);
        });
        testStreams.push(stream);
      }

      await Promise.all(testStreams.map(async (stream) => {
        // eslint-disable-next-line no-unused-vars
        for await (const _ of stream) ;
      }));

      assert.deepStrictEqual(executedTestFiles, [...new Set(executedTestFiles)]);
    });

    it('combination of all shards should be all the tests', async () => {
      const executedTestFiles = [];

      const testStreams = [];
      const shards = 5;
      for (let i = 1; i <= shards; i++) {
        const stream = run({
          files: shardsTestsFiles,
          shard: {
            total: shards,
            index: i
          }
        });
        stream.on('test:fail', common.mustNotCall());
        stream.on('test:pass', (passedTest) => {
          executedTestFiles.push(passedTest.file);
        });
        testStreams.push(stream);
      }

      await Promise.all(testStreams.map(async (stream) => {
        // eslint-disable-next-line no-unused-vars
        for await (const _ of stream) ;
      }));

      assert.deepStrictEqual(executedTestFiles.sort(), [...shardsTestsFiles].sort());
    });
  });

  describe('validation', () => {
    it('should only allow array in options.files', async () => {
      [Symbol(), {}, () => {}, 0, 1, 0n, 1n, '', '1', Promise.resolve([]), true, false]
        .forEach((files) => assert.throws(() => run({ files }), {
          code: 'ERR_INVALID_ARG_TYPE'
        }));
    });

    it('should only allow array in options.globPatterns', async () => {
      [Symbol(), {}, () => {}, 0, 1, 0n, 1n, '', '1', Promise.resolve([]), true, false]
        .forEach((globPatterns) => assert.throws(() => run({ globPatterns }), {
          code: 'ERR_INVALID_ARG_TYPE'
        }));
    });

    it('should not allow files and globPatterns used together', () => {
      assert.throws(() => run({ files: ['a.js'], globPatterns: ['*.js'] }), {
        code: 'ERR_INVALID_ARG_VALUE'
      });
    });

    it('should only allow a string in options.cwd', async () => {
      [Symbol(), {}, [], () => {}, 0, 1, 0n, 1n, true, false]
        .forEach((cwd) => assert.throws(() => run({ cwd }), {
          code: 'ERR_INVALID_ARG_TYPE'
        }));
    });

    it('should only allow object as options', () => {
      [Symbol(), [], () => {}, 0, 1, 0n, 1n, '', '1', true, false]
        .forEach((options) => assert.throws(() => run(options), {
          code: 'ERR_INVALID_ARG_TYPE'
        }));
    });

    it('should pass instance of stream to setup', async () => {
      const stream = run({
        files: [join(testFixtures, 'default-behavior/test/random.cjs')],
        setup: common.mustCall((root) => {
          assert.strictEqual(root.constructor.name, 'TestsStream');
        }),
      });
      stream.on('test:fail', common.mustNotCall());
      stream.on('test:pass', common.mustCall());
      // eslint-disable-next-line no-unused-vars
      for await (const _ of stream);
    });
  });

  it('should avoid running recursively', async () => {
    const stream = run({ files: [join(testFixtures, 'recursive_run.js')] });
    let stderr = '';
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustCall(1));
    stream.on('test:stderr', (c) => { stderr += c.message; });

    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
    assert.match(stderr, /Warning: node:test run\(\) is being called recursively/);
  });

  it('should run with different cwd', async () => {
    const stream = run({
      cwd: fixtures.path('test-runner', 'cwd')
    });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustCall(1));

    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
  });

  it('should handle a non-existent directory being provided as cwd', async () => {
    const diagnostics = [];
    const stream = run({
      cwd: fixtures.path('test-runner', 'cwd', 'non-existing')
    });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustNotCall());
    stream.on('test:stderr', common.mustNotCall());
    stream.on('test:diagnostic', ({ message }) => {
      diagnostics.push(message);
    });

    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
    for (const entry of [
      'tests 0',
      'suites 0',
      'pass 0',
      'fail 0',
      'cancelled 0',
      'skipped 0',
      'todo 0',
    ]
    ) {
      assert.strictEqual(diagnostics.includes(entry), true);
    }
  });

  it('should handle a non-existent file being provided as cwd', async () => {
    const diagnostics = [];
    const stream = run({
      cwd: fixtures.path('test-runner', 'default-behavior', 'test', 'random.cjs')
    });
    stream.on('test:fail', common.mustNotCall());
    stream.on('test:pass', common.mustNotCall());
    stream.on('test:stderr', common.mustNotCall());
    stream.on('test:diagnostic', ({ message }) => {
      diagnostics.push(message);
    });

    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream);
    for (const entry of [
      'tests 0',
      'suites 0',
      'pass 0',
      'fail 0',
      'cancelled 0',
      'skipped 0',
      'todo 0',
    ]
    ) {
      assert.strictEqual(diagnostics.includes(entry), true);
    }
  });
});

describe('forceExit', () => {
  it('throws for non-boolean values', () => {
    [Symbol(), {}, 0, 1, '1', Promise.resolve([])].forEach((forceExit) => {
      assert.throws(() => run({ forceExit }), {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "options\.forceExit" property must be of type boolean\./
      });
    });
  });

  it('throws if enabled with watch mode', () => {
    assert.throws(() => run({ forceExit: true, watch: true }), {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /The property 'options\.forceExit' is not supported with watch mode\./
    });
  });
});


// exitHandler doesn't run until after the tests / after hooks finish.
process.on('exit', () => {
  assert.strictEqual(process.listeners('uncaughtException').length, 0);
  assert.strictEqual(process.listeners('unhandledRejection').length, 0);
  assert.strictEqual(process.listeners('beforeExit').length, 0);
  assert.strictEqual(process.listeners('SIGINT').length, 0);
  assert.strictEqual(process.listeners('SIGTERM').length, 0);
});
                                                                                  node-23.7.0/test/parallel/test-runner-snapshot-file-tests.js                                        0000664 0000000 0000000 00000005022 14746647661 0024065 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const { suite, test } = require('node:test');

tmpdir.refresh();

suite('t.assert.fileSnapshot() validation', () => {
  test('path must be a string', (t) => {
    t.assert.throws(() => {
      t.assert.fileSnapshot({}, 5);
    }, /The "path" argument must be of type string/);
  });

  test('options must be an object', (t) => {
    t.assert.throws(() => {
      t.assert.fileSnapshot({}, '', null);
    }, /The "options" argument must be of type object/);
  });

  test('options.serializers must be an array if present', (t) => {
    t.assert.throws(() => {
      t.assert.fileSnapshot({}, '', { serializers: 5 });
    }, /The "options\.serializers" property must be an instance of Array/);
  });

  test('options.serializers must only contain functions', (t) => {
    t.assert.throws(() => {
      t.assert.fileSnapshot({}, '', { serializers: [() => {}, ''] });
    }, /The "options\.serializers\[1\]" property must be of type function/);
  });
});

suite('t.assert.fileSnapshot() update/read flow', () => {
  const fixture = fixtures.path(
    'test-runner', 'snapshots', 'file-snapshots.js'
  );

  test('fails prior to snapshot generation', async (t) => {
    const child = await common.spawnPromisified(
      process.execPath,
      [fixture],
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 1);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 3/);
    t.assert.match(child.stdout, /pass 0/);
    t.assert.match(child.stdout, /fail 3/);
    t.assert.match(child.stdout, /Missing snapshots can be generated/);
  });

  test('passes when regenerating snapshots', async (t) => {
    const child = await common.spawnPromisified(
      process.execPath,
      ['--test-update-snapshots', fixture],
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 0);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 3/);
    t.assert.match(child.stdout, /pass 3/);
    t.assert.match(child.stdout, /fail 0/);
  });

  test('passes when snapshots exist', async (t) => {
    const child = await common.spawnPromisified(
      process.execPath,
      [fixture],
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 0);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 3/);
    t.assert.match(child.stdout, /pass 3/);
    t.assert.match(child.stdout, /fail 0/);
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-runner-snapshot-tests.js                                             0000664 0000000 0000000 00000032741 14746647661 0023160 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
/* eslint-disable no-template-curly-in-string */
'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const {
  snapshot,
  suite,
  test,
} = require('node:test');
const {
  SnapshotManager,
  defaultResolveSnapshotPath,
  defaultSerializers,
} = require('internal/test_runner/snapshot');
const fs = require('node:fs');

tmpdir.refresh();

suite('SnapshotManager', () => {
  test('uses default snapshot naming scheme', (t) => {
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(__filename);
    t.assert.strictEqual(file.snapshotFile, `${__filename}.snapshot`);
  });

  test('generates snapshot IDs based on provided name', (t) => {
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(__filename);

    t.assert.strictEqual(file.nextId('foo'), 'foo 1');
    t.assert.strictEqual(file.nextId('foo'), 'foo 2');
    t.assert.strictEqual(file.nextId('bar'), 'bar 1');
    t.assert.strictEqual(file.nextId('baz'), 'baz 1');
    t.assert.strictEqual(file.nextId('foo'), 'foo 3');
    t.assert.strictEqual(file.nextId('foo`'), 'foo` 1');
    t.assert.strictEqual(file.nextId('foo\\'), 'foo\\ 1');
    t.assert.strictEqual(file.nextId('foo`${x}`'), 'foo`${x}` 1');
  });

  test('throws if snapshot file does not have exports', (t) => {
    const fixture = fixtures.path(
      'test-runner', 'snapshots', 'malformed-exports.js'
    );
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(fixture);

    t.assert.throws(() => {
      file.readFile();
    }, (err) => {
      t.assert.strictEqual(err.code, 'ERR_INVALID_STATE');
      t.assert.match(err.message, /Cannot read snapshot/);
      t.assert.strictEqual(err.filename, file.snapshotFile);
      t.assert.match(err.cause.message, /Malformed snapshot file/);
      return true;
    });
  });

  test('provides a tip if snapshot file does not exist', (t) => {
    const fixture = fixtures.path(
      'test-runner', 'snapshots', 'this-file-should-not-exist.js'
    );
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(fixture);

    t.assert.throws(() => {
      file.readFile();
    }, /Missing snapshots can be generated by rerunning the command/);
  });

  test('throws if serialization cannot generate a string', (t) => {
    const manager = new SnapshotManager(false);
    const cause = new Error('boom');
    const input = {
      foo: 1,
      toString() {
        throw cause;
      },
    };

    t.assert.throws(() => {
      manager.serialize(input, [(value) => { return value; }]);
    }, (err) => {
      t.assert.strictEqual(err.code, 'ERR_INVALID_STATE');
      t.assert.match(err.message, /The provided serializers did not generate a string/);
      t.assert.strictEqual(err.input, input);
      t.assert.strictEqual(err.cause, cause);
      return true;
    });
  });

  test('serializes values using provided functions', (t) => {
    const manager = new SnapshotManager(false);
    const output = manager.serialize({ foo: 1 }, [
      (value) => { return JSON.stringify(value); },
      (value) => { return value + '424242'; },
    ]);

    t.assert.strictEqual(output, '\n{"foo":1}424242\n');
  });

  test('serialized values get cast to string', (t) => {
    const manager = new SnapshotManager(false);
    const output = manager.serialize(5, []);

    t.assert.strictEqual(output, '\n5\n');
  });

  test('serialized values get escaped', (t) => {
    const manager = new SnapshotManager(false);
    const output = manager.serialize('fo\\o`${x}`', []);

    t.assert.strictEqual(output, '\nfo\\\\o\\`\\${x}\\`\n');
  });

  test('reads individual snapshots from snapshot file', (t) => {
    const fixture = fixtures.path('test-runner', 'snapshots', 'simple.js');
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(fixture);
    file.readFile();
    const snapshot = file.getSnapshot('foo 1');

    t.assert.strictEqual(snapshot, '\n{\n  "bar": 1,\n  "baz": 2\n}\n');
  });

  test('snapshot file is not read in update mode', (t) => {
    const fixture = fixtures.path('test-runner', 'snapshots', 'simple.js');
    const manager = new SnapshotManager(true);
    const file = manager.resolveSnapshotFile(fixture);
    file.readFile();

    t.assert.throws(() => {
      file.getSnapshot('foo 1');
    }, /Snapshot 'foo 1' not found/);
  });

  test('throws if requested snapshot does not exist in file', (t) => {
    const fixture = fixtures.path('test-runner', 'snapshots', 'simple.js');
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(fixture);

    t.assert.throws(() => {
      file.getSnapshot('does not exist 1');
    }, (err) => {
      t.assert.strictEqual(err.code, 'ERR_INVALID_STATE');
      t.assert.match(err.message, /Snapshot 'does not exist 1' not found/);
      t.assert.strictEqual(err.snapshot, 'does not exist 1');
      t.assert.strictEqual(err.filename, file.snapshotFile);
      return true;
    });
  });

  test('snapshot IDs are escaped when stored', (t) => {
    const fixture = fixtures.path('test-runner', 'snapshots', 'simple.js');
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(fixture);

    file.setSnapshot('foo`${x}` 1', 'test');
    t.assert.strictEqual(file.getSnapshot('foo\\`\\${x}\\` 1'), 'test');
  });

  test('throws if snapshot file cannot be resolved', (t) => {
    const manager = new SnapshotManager(false);
    const assertion = manager.createAssert();

    t.assert.throws(() => {
      Reflect.apply(assertion, { filePath: null }, ['foo']);
    }, (err) => {
      t.assert.strictEqual(err.code, 'ERR_INVALID_STATE');
      t.assert.match(err.message, /Invalid snapshot filename/);
      t.assert.strictEqual(err.filename, null);
      return true;
    });
  });

  test('writes the specified snapshot files', (t) => {
    const testFile1 = tmpdir.resolve('test1.js');
    const testFile2 = tmpdir.resolve('test2.js');
    const manager = new SnapshotManager(true);
    const file1 = manager.resolveSnapshotFile(testFile1);
    const file2 = manager.resolveSnapshotFile(testFile2);
    file1.setSnapshot('foo 1', 'foo 1 value');
    file2.setSnapshot('foo 2', 'foo 2 value');
    t.assert.strictEqual(fs.existsSync(file1.snapshotFile), false);
    t.assert.strictEqual(fs.existsSync(file2.snapshotFile), false);
    manager.writeSnapshotFiles();
    t.assert.strictEqual(fs.existsSync(file1.snapshotFile), true);
    t.assert.strictEqual(fs.existsSync(file2.snapshotFile), true);
  });

  test('creates snapshot directory if it does not exist', (t) => {
    const testFile = tmpdir.resolve('foo/bar/baz/test2.js');
    const manager = new SnapshotManager(true);
    const file = manager.resolveSnapshotFile(testFile);
    file.setSnapshot('foo 1', 'foo value');
    t.assert.strictEqual(fs.existsSync(file.snapshotFile), false);
    manager.writeSnapshotFiles();
    t.assert.strictEqual(fs.existsSync(file.snapshotFile), true);
  });

  test('does not write snapshot files in read mode', (t) => {
    const testFile = tmpdir.resolve('test3.js');
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(testFile);
    file.setSnapshot('foo 1', 'foo value');
    t.assert.strictEqual(fs.existsSync(file.snapshotFile), false);
    manager.writeSnapshotFiles();
    t.assert.strictEqual(fs.existsSync(file.snapshotFile), false);
  });

  test('throws if snapshot files cannot be written', (t) => {
    const testFile = tmpdir.resolve('test4.js');
    const error = new Error('boom');
    const manager = new SnapshotManager(true);
    const file = manager.resolveSnapshotFile(testFile);
    file.snapshots['foo 1'] = { toString() { throw error; } };
    t.assert.strictEqual(fs.existsSync(file.snapshotFile), false);
    t.assert.throws(() => {
      manager.writeSnapshotFiles();
    }, (err) => {
      t.assert.strictEqual(err.code, 'ERR_INVALID_STATE');
      t.assert.match(err.message, /Cannot write snapshot file/);
      t.assert.strictEqual(err.filename, file.snapshotFile);
      t.assert.strictEqual(err.cause, error);
      return true;
    });

    t.assert.strictEqual(fs.existsSync(file.snapshotFile), false);
  });
});

suite('t.assert.snapshot() validation', () => {
  test('options must be an object', (t) => {
    t.assert.throws(() => {
      t.assert.snapshot('', null);
    }, /The "options" argument must be of type object/);
  });

  test('options.serializers must be an array if present', (t) => {
    t.assert.throws(() => {
      t.assert.snapshot('', { serializers: 5 });
    }, /The "options\.serializers" property must be an instance of Array/);
  });

  test('options.serializers must only contain functions', (t) => {
    t.assert.throws(() => {
      t.assert.snapshot('', { serializers: [() => {}, ''] });
    }, /The "options\.serializers\[1\]" property must be of type function/);
  });
});

suite('setResolveSnapshotPath()', () => {
  test('throws if input is not a function', (t) => {
    t.assert.throws(() => {
      snapshot.setResolveSnapshotPath('');
    }, { code: 'ERR_INVALID_ARG_TYPE' });
  });

  test('changes default snapshot output path', (t) => {
    t.after(() => {
      snapshot.setResolveSnapshotPath(defaultResolveSnapshotPath);
    });

    snapshot.setResolveSnapshotPath(() => { return 'foobarbaz'; });
    const manager = new SnapshotManager(false);
    const file = manager.resolveSnapshotFile(__filename);
    t.assert.strictEqual(file.snapshotFile, 'foobarbaz');
  });
});

suite('setDefaultSnapshotSerializers()', () => {
  test('throws if input is not a function array', (t) => {
    t.assert.throws(() => {
      snapshot.setDefaultSnapshotSerializers('');
    }, { code: 'ERR_INVALID_ARG_TYPE' });
    t.assert.throws(() => {
      snapshot.setDefaultSnapshotSerializers([5]);
    }, { code: 'ERR_INVALID_ARG_TYPE' });
  });

  test('changes default serializers', (t) => {
    t.after(() => {
      snapshot.setDefaultSnapshotSerializers(defaultSerializers);
    });

    snapshot.setDefaultSnapshotSerializers([() => { return 'foobarbaz'; }]);
    const manager = new SnapshotManager(false);
    const output = manager.serialize({ foo: 1 });
    t.assert.strictEqual(output, '\nfoobarbaz\n');
  });
});

test('t.assert.snapshot()', async (t) => {
  const fixture = fixtures.path(
    'test-runner', 'snapshots', 'unit.js'
  );

  await t.test('fails prior to snapshot generation', async (t) => {
    const child = await common.spawnPromisified(
      process.execPath,
      [fixture],
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 1);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 5/);
    t.assert.match(child.stdout, /pass 0/);
    t.assert.match(child.stdout, /fail 5/);
    t.assert.match(child.stdout, /Missing snapshots/);
  });

  await t.test('passes when regenerating snapshots', async (t) => {
    const child = await common.spawnPromisified(
      process.execPath,
      ['--test-update-snapshots', fixture],
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 0);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 5/);
    t.assert.match(child.stdout, /pass 5/);
    t.assert.match(child.stdout, /fail 0/);
  });

  await t.test('passes when snapshots exist', async (t) => {
    const child = await common.spawnPromisified(
      process.execPath,
      [fixture],
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 0);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 5/);
    t.assert.match(child.stdout, /pass 5/);
    t.assert.match(child.stdout, /fail 0/);
  });
});

test('snapshots from multiple files (isolation=none)', async (t) => {
  tmpdir.refresh();

  const fixture = fixtures.path('test-runner', 'snapshots', 'unit.js');
  const fixture2 = fixtures.path('test-runner', 'snapshots', 'unit-2.js');

  await t.test('fails prior to snapshot generation', async (t) => {
    const args = [
      '--test',
      '--test-isolation=none',
      fixture,
      fixture2,
    ];
    const child = await common.spawnPromisified(
      process.execPath,
      args,
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 1);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 6/);
    t.assert.match(child.stdout, /pass 0/);
    t.assert.match(child.stdout, /fail 6/);
    t.assert.match(child.stdout, /Missing snapshots/);
  });

  await t.test('passes when regenerating snapshots', async (t) => {
    const args = [
      '--test',
      '--test-isolation=none',
      '--test-update-snapshots',
      fixture,
      fixture2,
    ];
    const child = await common.spawnPromisified(
      process.execPath,
      args,
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 0);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 6/);
    t.assert.match(child.stdout, /pass 6/);
    t.assert.match(child.stdout, /fail 0/);
  });

  await t.test('passes when snapshots exist', async (t) => {
    const args = [
      '--test',
      '--test-isolation=none',
      fixture,
      fixture2,
    ];
    const child = await common.spawnPromisified(
      process.execPath,
      args,
      { cwd: tmpdir.path },
    );

    t.assert.strictEqual(child.code, 0);
    t.assert.strictEqual(child.signal, null);
    t.assert.match(child.stdout, /tests 6/);
    t.assert.match(child.stdout, /pass 6/);
    t.assert.match(child.stdout, /fail 0/);
  });
});
                               node-23.7.0/test/parallel/test-runner-source-maps-invalid-json.js                                   0000664 0000000 0000000 00000000451 14746647661 0025003 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --enable-source-maps
'use strict';

require('../common');
const test = require('node:test');

// Verify that test runner can handle invalid source maps.

test('ok', () => {});

// eslint-disable-next-line @stylistic/js/spaced-comment
//# sourceMappingURL=data:application/json;base64,-1
                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-runner-string-to-regexp.js                                           0000664 0000000 0000000 00000001425 14746647661 0023372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
const common = require('../common');
const { deepStrictEqual, throws } = require('node:assert');
const { convertStringToRegExp } = require('internal/test_runner/utils');

deepStrictEqual(convertStringToRegExp('foo', 'x'), /foo/);
deepStrictEqual(convertStringToRegExp('/bar/', 'x'), /bar/);
deepStrictEqual(convertStringToRegExp('/baz/gi', 'x'), /baz/gi);
deepStrictEqual(convertStringToRegExp('/foo/9', 'x'), /\/foo\/9/);

throws(
  () => convertStringToRegExp('/foo/abcdefghijk', 'x'),
  common.expectsError({
    code: 'ERR_INVALID_ARG_VALUE',
    message: "The argument 'x' is an invalid regular expression. " +
             "Invalid flags supplied to RegExp constructor 'abcdefghijk'. " +
             "Received '/foo/abcdefghijk'",
  })
);
                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-runner-subtest-after-hook.js                                         0000664 0000000 0000000 00000000536 14746647661 0023704 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { test } = require('node:test');

// Regression test for https://github.com/nodejs/node/issues/51997
test('after hook should be called with no subtests', (t) => {
  const timer = setTimeout(common.mustNotCall(), 2 ** 30);

  t.after(common.mustCall(() => {
    clearTimeout(timer);
  }));
});
                                                                                                                                                                  node-23.7.0/test/parallel/test-runner-test-filepath.js                                              0000664 0000000 0000000 00000002417 14746647661 0022727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { strictEqual } = require('node:assert');
const { writeFileSync } = require('node:fs');
const { suite, test } = require('node:test');

tmpdir.refresh();

suite('suite', (t) => {
  strictEqual(t.filePath, __filename);

  test('test', (t) => {
    strictEqual(t.filePath, __filename);

    t.test('subtest', (t) => {
      strictEqual(t.filePath, __filename);

      t.test('subsubtest', (t) => {
        strictEqual(t.filePath, __filename);
      });
    });
  });
});

test((t) => {
  strictEqual(t.filePath, __filename);
});

const importedTestFile = tmpdir.resolve('temp.js');
writeFileSync(importedTestFile, `
  'use strict';
  const { strictEqual } = require('node:assert');
  const { suite, test } = require('node:test');

  suite('imported suite', (t) => {
    strictEqual(t.filePath, ${JSON.stringify(__filename)});

    test('imported test', (t) => {
      strictEqual(t.filePath, ${JSON.stringify(__filename)});

      t.test('imported subtest', (t) => {
        strictEqual(t.filePath, ${JSON.stringify(__filename)});

        t.test('imported subsubtest', (t) => {
          strictEqual(t.filePath, ${JSON.stringify(__filename)});
        });
      });
    });
  });
`);
require(importedTestFile);
                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-runner-test-fullname.js                                              0000664 0000000 0000000 00000001044 14746647661 0022731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { strictEqual } = require('node:assert');
const { suite, test } = require('node:test');

suite('suite', (t) => {
  strictEqual(t.fullName, 'suite');

  test('test', (t) => {
    strictEqual(t.fullName, 'suite > test');

    t.test('subtest', (t) => {
      strictEqual(t.fullName, 'suite > test > subtest');

      t.test('subsubtest', (t) => {
        strictEqual(t.fullName, 'suite > test > subtest > subsubtest');
      });
    });
  });
});

test((t) => {
  strictEqual(t.fullName, '<anonymous>');
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-runner-todo-skip-tests.js                                            0000664 0000000 0000000 00000002023 14746647661 0023220 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { strictEqual } = require('node:assert');
const { run, suite, test } = require('node:test');

if (!process.env.NODE_TEST_CONTEXT) {
  const stream = run({ files: [__filename] });

  stream.on('test:fail', common.mustNotCall());
  stream.on('test:pass', common.mustCall((event) => {
    strictEqual(event.skip, true);
    strictEqual(event.todo, undefined);
  }, 4));
} else {
  test('test options only', { skip: true, todo: true }, common.mustNotCall());

  test('test context calls only', common.mustCall((t) => {
    t.todo();
    t.skip();
  }));

  test('todo test with context skip', { todo: true }, common.mustCall((t) => {
    t.skip();
  }));

  // Note - there is no test for the skip option and t.todo() because the skip
  // option prevents the test from running at all. This is verified by other
  // tests.

  // Suites don't have the context methods, so only test the options combination.
  suite('suite options only', { skip: true, todo: true }, common.mustNotCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-runner-typechecking.js                                               0000664 0000000 0000000 00000002460 14746647661 0022631 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');

// Return type of shorthands should be consistent
// with the return type of test

const assert = require('assert');
const { test, describe, it } = require('node:test');
const { isPromise } = require('util/types');

const testOnly = test('only test', { only: true });
const testTodo = test('todo test', { todo: true });
const testSkip = test('skip test', { skip: true });
const testOnlyShorthand = test.only('only test shorthand');
const testTodoShorthand = test.todo('todo test shorthand');
const testSkipShorthand = test.skip('skip test shorthand');

describe('\'node:test\' and its shorthands should return the same', () => {
  it('should return a Promise', () => {
    assert(isPromise(testOnly));
    assert(isPromise(testTodo));
    assert(isPromise(testSkip));
    assert(isPromise(testOnlyShorthand));
    assert(isPromise(testTodoShorthand));
    assert(isPromise(testSkipShorthand));
  });

  it('should resolve undefined', async () => {
    assert.strictEqual(await testOnly, undefined);
    assert.strictEqual(await testTodo, undefined);
    assert.strictEqual(await testSkip, undefined);
    assert.strictEqual(await testOnlyShorthand, undefined);
    assert.strictEqual(await testTodoShorthand, undefined);
    assert.strictEqual(await testSkipShorthand, undefined);
  });
});
                                                                                                                                                                                                                node-23.7.0/test/parallel/test-runner-v8-deserializer.mjs                                           0000664 0000000 0000000 00000007700 14746647661 0023350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings

import '../common/index.mjs';
import { describe, it, beforeEach } from 'node:test';
import assert from 'node:assert';
import { finished } from 'node:stream/promises';
import { DefaultSerializer } from 'node:v8';
import serializer from 'internal/test_runner/reporter/v8-serializer';
import runner from 'internal/test_runner/runner';

async function toArray(chunks) {
  const arr = [];
  for await (const i of chunks) arr.push(i);
  return arr;
}

const chunks = await toArray(serializer([
  { type: 'test:diagnostic', data: { nesting: 0, details: {}, message: 'diagnostic' } },
]));
const defaultSerializer = new DefaultSerializer();
defaultSerializer.writeHeader();
const headerLength = defaultSerializer.releaseBuffer().length;

describe('v8 deserializer', () => {
  let fileTest;
  let reported;
  beforeEach(() => {
    reported = [];
    fileTest = new runner.FileTest({
      name: 'filetest',
      harness: { config: {} },
    });
    fileTest.reporter.on('data', (data) => reported.push(data));
    assert(fileTest.isClearToSend());
  });

  async function collectReported(chunks) {
    chunks.forEach((chunk) => fileTest.parseMessage(chunk));
    fileTest.drain();
    fileTest.reporter.end();
    await finished(fileTest.reporter);
    return reported;
  }

  it('should do nothing when no chunks', async () => {
    const reported = await collectReported([]);
    assert.deepStrictEqual(reported, []);
  });

  it('should deserialize a chunk with no serialization', async () => {
    const reported = await collectReported([Buffer.from('unknown')]);
    assert.deepStrictEqual(reported, [
      { data: { __proto__: null, file: 'filetest', message: 'unknown' }, type: 'test:stdout' },
    ]);
  });

  it('should deserialize a serialized chunk', async () => {
    const reported = await collectReported(chunks);
    assert.deepStrictEqual(reported, [
      { data: { nesting: 0, details: {}, message: 'diagnostic' }, type: 'test:diagnostic' },
    ]);
  });

  it('should deserialize a serialized chunk after non-serialized chunk', async () => {
    const reported = await collectReported([Buffer.concat([Buffer.from('unknown'), ...chunks])]);
    assert.deepStrictEqual(reported, [
      { data: { __proto__: null, file: 'filetest', message: 'unknown' }, type: 'test:stdout' },
      { data: { nesting: 0, details: {}, message: 'diagnostic' }, type: 'test:diagnostic' },
    ]);
  });

  it('should deserialize a serialized chunk before non-serialized output', async () => {
    const reported = await collectReported([Buffer.concat([ ...chunks, Buffer.from('unknown')])]);
    assert.deepStrictEqual(reported, [
      { data: { nesting: 0, details: {}, message: 'diagnostic' }, type: 'test:diagnostic' },
      { data: { __proto__: null, file: 'filetest', message: 'unknown' }, type: 'test:stdout' },
    ]);
  });

  const headerPosition = headerLength * 2 + 4;
  for (let i = 0; i < headerPosition + 5; i++) {
    const message = `should deserialize a serialized message split into two chunks {...${i},${i + 1}...}`;
    it(message, async () => {
      const data = chunks[0];
      const reported = await collectReported([data.subarray(0, i), data.subarray(i)]);
      assert.deepStrictEqual(reported, [
        { data: { nesting: 0, details: {}, message: 'diagnostic' }, type: 'test:diagnostic' },
      ]);
    });

    it(`${message} wrapped by non-serialized data`, async () => {
      const data = chunks[0];
      const reported = await collectReported([
        Buffer.concat([Buffer.from('unknown'), data.subarray(0, i)]),
        Buffer.concat([data.subarray(i), Buffer.from('unknown')]),
      ]);
      assert.deepStrictEqual(reported, [
        { data: { __proto__: null, file: 'filetest', message: 'unknown' }, type: 'test:stdout' },
        { data: { nesting: 0, details: {}, message: 'diagnostic' }, type: 'test:diagnostic' },
        { data: { __proto__: null, file: 'filetest', message: 'unknown' }, type: 'test:stdout' },
      ]);
    }
    );
  }

});
                                                                node-23.7.0/test/parallel/test-runner-wait-for.js                                                   0000664 0000000 0000000 00000005611 14746647661 0021705 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { suite, test } = require('node:test');

suite('input validation', () => {
  test('throws if condition is not a function', (t) => {
    t.assert.throws(() => {
      t.waitFor(5);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "condition" argument must be of type function/,
    });
  });

  test('throws if options is not an object', (t) => {
    t.assert.throws(() => {
      t.waitFor(() => {}, null);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options" argument must be of type object/,
    });
  });

  test('throws if options.interval is not a number', (t) => {
    t.assert.throws(() => {
      t.waitFor(() => {}, { interval: 'foo' });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options\.interval" property must be of type number/,
    });
  });

  test('throws if options.timeout is not a number', (t) => {
    t.assert.throws(() => {
      t.waitFor(() => {}, { timeout: 'foo' });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options\.timeout" property must be of type number/,
    });
  });
});

test('returns the result of the condition function', async (t) => {
  const result = await t.waitFor(() => {
    return 42;
  });

  t.assert.strictEqual(result, 42);
});

test('returns the result of an async condition function', async (t) => {
  const result = await t.waitFor(async () => {
    return 84;
  });

  t.assert.strictEqual(result, 84);
});

test('errors if the condition times out', async (t) => {
  await t.assert.rejects(async () => {
    await t.waitFor(() => {
      return new Promise(() => {});
    }, {
      interval: 60_000,
      timeout: 1,
    });
  }, {
    message: /waitFor\(\) timed out/,
  });
});

test('polls until the condition returns successfully', async (t) => {
  let count = 0;
  const result = await t.waitFor(() => {
    ++count;
    if (count < 4) {
      throw new Error('resource is not ready yet');
    }

    return 'success';
  }, {
    interval: 1,
    timeout: 60_000,
  });

  t.assert.strictEqual(result, 'success');
  t.assert.strictEqual(count, 4);
});

test('sets last failure as error cause on timeouts', async (t) => {
  const error = new Error('boom');
  await t.assert.rejects(async () => {
    await t.waitFor(() => {
      return new Promise((_, reject) => {
        reject(error);
      });
    });
  }, (err) => {
    t.assert.match(err.message, /timed out/);
    t.assert.strictEqual(err.cause, error);
    return true;
  });
});

test('limits polling if condition takes longer than interval', async (t) => {
  let count = 0;

  function condition() {
    count++;
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve('success');
      }, 200);
    });
  }

  const result = await t.waitFor(condition, {
    interval: 1,
    timeout: 60_000,
  });

  t.assert.strictEqual(result, 'success');
  t.assert.strictEqual(count, 1);
});
                                                                                                                       node-23.7.0/test/parallel/test-runner-watch-mode-complex.mjs                                        0000664 0000000 0000000 00000006446 14746647661 0024036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { spawn } from 'node:child_process';
import { writeFile, unlink } from 'node:fs/promises';
import { setTimeout } from 'node:timers/promises';
import tmpdir from '../common/tmpdir.js';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

if (common.isAIX)
  common.skip('folder watch capability is limited in AIX.');

tmpdir.refresh();

// This test updates these files repeatedly,
// Reading them from disk is unreliable due to race conditions.
const fixtureContent = {
  'dependency.js': 'module.exports = {};',
  'dependency.mjs': 'export const a = 1;',
  // Test 1
  'test.js': `
const test = require('node:test');
require('./dependency.js');
import('./dependency.mjs');
import('data:text/javascript,');
test('first test has ran');`,
  // Test 2
  'test-2.mjs': `
import test from 'node:test';
import './dependency.js';
import { a } from './dependency.mjs';
import 'data:text/javascript,';
test('second test has ran');`,
  // Test file to be deleted
  'test-to-delete.mjs': `
import test from 'node:test';
import './dependency.js';
import { a } from './dependency.mjs';
import 'data:text/javascript,';
test('test to delete has ran');`,
};

const fixturePaths = Object.fromEntries(Object.keys(fixtureContent)
  .map((file) => [file, tmpdir.resolve(file)]));

async function setupFixtures() {
  return Promise.all(Object.entries(fixtureContent)
    .map(([file, content]) => writeFile(fixturePaths[file], content, { flush: true })));
}

await setupFixtures();

describe('test runner watch mode with more complex setup', () => {
  it('should run tests when a dependency changed after a watched test file being deleted', async () => {
    const ran1 = Promise.withResolvers();
    const ran2 = Promise.withResolvers();
    const child = spawn(process.execPath,
                        ['--watch', '--test'],
                        { encoding: 'utf8', stdio: 'pipe', cwd: tmpdir.path });
    let stdout = '';
    let currentRun = '';
    const runs = [];

    child.stdout.on('data', (data) => {
      stdout += data.toString();
      currentRun += data.toString();
      const testRuns = stdout.match(/duration_ms\s\d+/g);

      if (testRuns?.length >= 2) {
        ran2.resolve();
        return;
      }
      if (testRuns?.length >= 1) ran1.resolve();
    });

    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const fileToDeletePathLocal = tmpdir.resolve('test-to-delete.mjs');
    await unlink(fileToDeletePathLocal);
    await setTimeout(common.platformTimeout(1000));

    const content = fixtureContent['dependency.mjs'];
    const path = fixturePaths['dependency.mjs'];
    await writeFile(path, content, { flush: true });
    await setTimeout(common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    currentRun = '';
    child.kill();

    assert.strictEqual(runs.length, 2);

    const [firstRun, secondRun] = runs;

    assert.match(firstRun, /tests 3/);
    assert.match(firstRun, /pass 3/);
    assert.match(firstRun, /fail 0/);
    assert.match(firstRun, /cancelled 0/);

    assert.match(secondRun, /tests 2/);
    assert.match(secondRun, /pass 2/);
    assert.match(secondRun, /fail 0/);
    assert.match(secondRun, /cancelled 0/);
  });
});
                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-runner-watch-mode.mjs                                                0000664 0000000 0000000 00000013664 14746647661 0022371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import { describe, it, beforeEach } from 'node:test';
import { once } from 'node:events';
import assert from 'node:assert';
import { spawn } from 'node:child_process';
import { writeFileSync, renameSync, unlinkSync } from 'node:fs';
import { setTimeout } from 'node:timers/promises';
import tmpdir from '../common/tmpdir.js';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

if (common.isAIX)
  common.skip('folder watch capability is limited in AIX.');

let fixturePaths;

// This test updates these files repeatedly,
// Reading them from disk is unreliable due to race conditions.
const fixtureContent = {
  'dependency.js': 'module.exports = {};',
  'dependency.mjs': 'export const a = 1;',
  'test.js': `
const test = require('node:test');
require('./dependency.js');
import('./dependency.mjs');
import('data:text/javascript,');
test('test has ran');`,
};

function refresh() {
  tmpdir.refresh();
  fixturePaths = Object.keys(fixtureContent)
    .reduce((acc, file) => ({ ...acc, [file]: tmpdir.resolve(file) }), {});
  Object.entries(fixtureContent)
    .forEach(([file, content]) => writeFileSync(fixturePaths[file], content));
}

async function testWatch({
  fileToUpdate,
  file,
  action = 'update',
  fileToCreate,
  isolation,
}) {
  const ran1 = Promise.withResolvers();
  const ran2 = Promise.withResolvers();
  const child = spawn(process.execPath,
                      ['--watch', '--test', '--test-reporter=spec',
                       isolation ? `--test-isolation=${isolation}` : '',
                       file ? fixturePaths[file] : undefined].filter(Boolean),
                      { encoding: 'utf8', stdio: 'pipe', cwd: tmpdir.path });
  let stdout = '';
  let currentRun = '';
  const runs = [];

  child.stdout.on('data', (data) => {
    stdout += data.toString();
    currentRun += data.toString();
    const testRuns = stdout.match(/duration_ms\s\d+/g);
    if (testRuns?.length >= 1) ran1.resolve();
    if (testRuns?.length >= 2) ran2.resolve();
  });

  const testUpdate = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const content = fixtureContent[fileToUpdate];
    const path = fixturePaths[fileToUpdate];
    writeFileSync(path, content);
    await setTimeout(common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    assert.strictEqual(runs.length, 2);

    for (const run of runs) {
      assert.match(run, /tests 1/);
      assert.match(run, /pass 1/);
      assert.match(run, /fail 0/);
      assert.match(run, /cancelled 0/);
    }
  };

  const testRename = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const fileToRenamePath = tmpdir.resolve(fileToUpdate);
    const newFileNamePath = tmpdir.resolve(`test-renamed-${fileToUpdate}`);
    renameSync(fileToRenamePath, newFileNamePath);
    await setTimeout(common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    assert.strictEqual(runs.length, 2);

    for (const run of runs) {
      assert.match(run, /tests 1/);
      assert.match(run, /pass 1/);
      assert.match(run, /fail 0/);
      assert.match(run, /cancelled 0/);
    }
  };

  const testDelete = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const fileToDeletePath = tmpdir.resolve(fileToUpdate);
    unlinkSync(fileToDeletePath);
    await setTimeout(common.platformTimeout(2000));
    ran2.resolve();
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    assert.strictEqual(runs.length, 2);

    for (const run of runs) {
      assert.doesNotMatch(run, /MODULE_NOT_FOUND/);
    }
  };

  const testCreate = async () => {
    await ran1.promise;
    runs.push(currentRun);
    currentRun = '';
    const newFilePath = tmpdir.resolve(fileToCreate);
    writeFileSync(newFilePath, 'module.exports = {};');
    await setTimeout(common.platformTimeout(1000));
    await ran2.promise;
    runs.push(currentRun);
    child.kill();
    await once(child, 'exit');

    for (const run of runs) {
      assert.match(run, /tests 1/);
      assert.match(run, /pass 1/);
      assert.match(run, /fail 0/);
      assert.match(run, /cancelled 0/);
    }
  };

  action === 'update' && await testUpdate();
  action === 'rename' && await testRename();
  action === 'delete' && await testDelete();
  action === 'create' && await testCreate();
}

describe('test runner watch mode', () => {
  beforeEach(refresh);
  for (const isolation of ['none', 'process']) {
    describe(`isolation: ${isolation}`, () => {
      it('should run tests repeatedly', async () => {
        await testWatch({ file: 'test.js', fileToUpdate: 'test.js', isolation });
      });

      it('should run tests with dependency repeatedly', async () => {
        await testWatch({ file: 'test.js', fileToUpdate: 'dependency.js', isolation });
      });

      it('should run tests with ESM dependency', async () => {
        await testWatch({ file: 'test.js', fileToUpdate: 'dependency.mjs', isolation });
      });

      it('should support running tests without a file', async () => {
        await testWatch({ fileToUpdate: 'test.js', isolation });
      });

      it('should support a watched test file rename', async () => {
        await testWatch({ fileToUpdate: 'test.js', action: 'rename', isolation });
      });

      it('should not throw when delete a watched test file', async () => {
        await testWatch({ fileToUpdate: 'test.js', action: 'delete', isolation });
      });

      it('should run new tests when a new file is created in the watched directory', {
        todo: isolation === 'none' ?
          'This test is failing when isolation is set to none and must be fixed' :
          undefined,
      }, async () => {
        await testWatch({ action: 'create', fileToCreate: 'new-test-file.test.js', isolation });
      });
    });
  }
});
                                                                            node-23.7.0/test/parallel/test-safe-get-env.js                                                      0000664 0000000 0000000 00000001151 14746647661 0021122 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals

require('../common');
const assert = require('assert');
const { internalBinding } = require('internal/test/binding');
const { safeGetenv } = internalBinding('credentials');

// FIXME(joyeecheung): this test is not entirely useful. To properly
// test this we could create a mismatch between the effective/real
// group/user id of a Node.js process and see if the environment variables
// are no longer available - but that might be tricky to set up reliably.

for (const oneEnv in process.env) {
  assert.strictEqual(
    safeGetenv(oneEnv),
    process.env[oneEnv]
  );
}
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-security-revert-unknown.js                                           0000664 0000000 0000000 00000000701 14746647661 0023512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const os = require('os');

const { signal, status, output } =
  spawnSync(process.execPath, ['--security-revert=not-a-cve']);
assert.strictEqual(signal, null);
assert.strictEqual(status, 12);
assert.strictEqual(
  output[2].toString(),
  `${process.execPath}: Error: ` +
  `Attempt to revert an unknown CVE [not-a-cve]${os.EOL}`);
                                                               node-23.7.0/test/parallel/test-set-http-max-http-headers.js                                         0000664 0000000 0000000 00000004561 14746647661 0023572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { spawn } = require('child_process');
const path = require('path');
const { suite, test } = require('node:test');
const testName = path.join(__dirname, 'test-http-max-http-headers.js');

test(function(_, cb) {
  console.log('running subtest expecting failure');

  // Validate that the test fails if the max header size is too small.
  const args = ['--expose-internals',
                '--max-http-header-size=1024',
                testName];
  const cp = spawn(process.execPath, args, { stdio: 'inherit' });

  cp.on('close', common.mustCall((code, signal) => {
    assert.strictEqual(code, 1);
    assert.strictEqual(signal, null);
    cb();
  }));
});

test(function(_, cb) {
  console.log('running subtest expecting success');

  const env = Object.assign({}, process.env, {
    NODE_DEBUG: 'http'
  });

  // Validate that the test now passes if the same limit is large enough.
  const args = ['--expose-internals',
                '--max-http-header-size=1024',
                testName,
                '1024'];
  const cp = spawn(process.execPath, args, {
    env,
    stdio: 'inherit'
  });

  cp.on('close', common.mustCall((code, signal) => {
    assert.strictEqual(code, 0);
    assert.strictEqual(signal, null);
    cb();
  }));
});

const skip = process.config.variables.node_without_node_options;
suite('same checks using NODE_OPTIONS if it is supported', { skip }, () => {
  const env = Object.assign({}, process.env, {
    NODE_OPTIONS: '--max-http-header-size=1024'
  });

  test(function(_, cb) {
    console.log('running subtest expecting failure');

    // Validate that the test fails if the max header size is too small.
    const args = ['--expose-internals', testName];
    const cp = spawn(process.execPath, args, { env, stdio: 'inherit' });

    cp.on('close', common.mustCall((code, signal) => {
      assert.strictEqual(code, 1);
      assert.strictEqual(signal, null);
      cb();
    }));
  });

  test(function(_, cb) {
    // Validate that the test now passes if the same limit is large enough.
    const args = ['--expose-internals', testName, '1024'];
    const cp = spawn(process.execPath, args, { env, stdio: 'inherit' });

    cp.on('close', common.mustCall((code, signal) => {
      assert.strictEqual(code, 0);
      assert.strictEqual(signal, null);
      cb();
    }));
  });
});
                                                                                                                                               node-23.7.0/test/parallel/test-set-incoming-message-header.js                                       0000664 0000000 0000000 00000001325 14746647661 0024110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const { IncomingMessage } = require('http');
const assert = require('assert');

// Headers setter function set a header correctly
{
  const im = new IncomingMessage();
  im.headers = { key: 'value' };
  assert.deepStrictEqual(im.headers, { key: 'value' });
}

// Trailers setter function set a header correctly
{
  const im = new IncomingMessage();
  im.trailers = { key: 'value' };
  assert.deepStrictEqual(im.trailers, { key: 'value' });
}

// _addHeaderLines function set a header correctly
{
  const im = new IncomingMessage();
  im.headers = { key1: 'value1' };
  im._addHeaderLines(['key2', 'value2'], 2);
  assert.deepStrictEqual(im.headers, { key1: 'value1', key2: 'value2' });
}
                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-set-process-debug-port.js                                            0000664 0000000 0000000 00000002570 14746647661 0023164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

common.skipIfInspectorDisabled();
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('This test only works on a main thread');
}

const assert = require('assert');
const kMinPort = 1024;
const kMaxPort = 65535;

function check(value, expected) {
  process.debugPort = value;
  assert.strictEqual(process.debugPort, expected);
}

// Expected usage with numbers.
check(0, 0);
check(kMinPort, kMinPort);
check(kMinPort + 1, kMinPort + 1);
check(kMaxPort - 1, kMaxPort - 1);
check(kMaxPort, kMaxPort);

// Numeric strings coerce.
check('0', 0);
check(`${kMinPort}`, kMinPort);
check(`${kMinPort + 1}`, kMinPort + 1);
check(`${kMaxPort - 1}`, kMaxPort - 1);
check(`${kMaxPort}`, kMaxPort);

// Most other values are coerced to 0.
check('', 0);
check(false, 0);
check(NaN, 0);
check(Infinity, 0);
check(-Infinity, 0);
check(function() {}, 0);
check({}, 0);
check([], 0);

// Symbols do not coerce.
assert.throws(() => {
  process.debugPort = Symbol();
}, /^TypeError: Cannot convert a Symbol value to a number$/);

// Verify port bounds checking.
[
  true,
  -1,
  1,
  kMinPort - 1,
  kMaxPort + 1,
  '-1',
  '1',
  `${kMinPort - 1}`,
  `${kMaxPort + 1}`,
].forEach((value) => {
  assert.throws(() => {
    process.debugPort = value;
  }, /^RangeError: process\.debugPort must be 0 or in range 1024 to 65535$/);
});
                                                                                                                                        node-23.7.0/test/parallel/test-setproctitle.js                                                      0000664 0000000 0000000 00000003340 14746647661 0021364 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Original test written by Jakub Lekstan <kuebzky@gmail.com>
const common = require('../common');
const { isMainThread } = require('worker_threads');

// FIXME add sunos support
if (common.isSunOS || common.isIBMi) {
  common.skip(`Unsupported platform [${process.platform}]`);
}

if (!isMainThread) {
  common.skip('Setting the process title from Workers is not supported');
}

const assert = require('assert');
const { exec, execSync } = require('child_process');
const path = require('path');

// The title shouldn't be too long; libuv's uv_set_process_title() out of
// security considerations no longer overwrites envp, only argv, so the
// maximum title length is possibly quite short.
let title = String(process.pid);

assert.notStrictEqual(process.title, title);
process.title = title;
assert.strictEqual(process.title, title);

// Test setting the title but do not try to run `ps` on Windows.
if (common.isWindows) {
  common.skip('Windows does not have "ps" utility');
}

try {
  execSync('command -v ps');
} catch (err) {
  if (err.status === 1) {
    common.skip('The "ps" utility is not available');
  }
  throw err;
}

// To pass this test on alpine, since Busybox `ps` does not
// support `-p` switch, use `ps -o` and `grep` instead.
const cmd = common.isLinux ?
  `ps -o pid,args | grep '${process.pid} ${title}' | grep -v grep` :
  `ps -p ${process.pid} -o args=`;

exec(cmd, common.mustSucceed((stdout, stderr) => {
  assert.strictEqual(stderr, '');

  // Freebsd always add ' (procname)' to the process title
  if (common.isFreeBSD || common.isOpenBSD)
    title += ` (${path.basename(process.execPath)})`;

  // Omitting trailing whitespace and \n
  assert.strictEqual(stdout.replace(/\s+$/, '').endsWith(title), true);
}));
                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-shadow-realm-allowed-builtin-modules.js                              0000664 0000000 0000000 00000001447 14746647661 0025773 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm
'use strict';
const common = require('../common');
const assert = require('assert');

async function main() {
  // Verifies that builtin modules can not be imported in the ShadowRealm.
  const realm = new ShadowRealm();
  // The error object created inside the ShadowRealm with the error code
  // property is not copied on the realm boundary. Only the error message
  // is copied. Simply check the error message here.
  await assert.rejects(realm.importValue('fs', 'readFileSync'), {
    message: /Cannot find package 'fs'/,
  });
  // As above, we can only validate the error message, not the error code.
  await assert.rejects(realm.importValue('node:fs', 'readFileSync'), {
    message: /No such built-in module: node:fs/,
  });
}

main().then(common.mustCall());
                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-shadow-realm-custom-loaders.js                                       0000664 0000000 0000000 00000001417 14746647661 0024170 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');

const commonArgs = [
  '--experimental-shadow-realm',
  '--no-warnings',
];

async function main() {
  // Verifies that custom loaders are not enabled in the ShadowRealm.
  const child = await common.spawnPromisified(process.execPath, [
    ...commonArgs,
    '--experimental-loader',
    fixtures.fileURL('es-module-loaders', 'loader-resolve-shortcircuit.mjs'),
    '--experimental-loader',
    fixtures.fileURL('es-module-loaders', 'loader-load-foo-or-42.mjs'),
    fixtures.path('es-module-shadow-realm', 'custom-loaders.js'),
  ]);

  assert.strictEqual(child.stderr, '');
  assert.strictEqual(child.code, 0);
}

main().then(common.mustCall());
                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-shadow-realm-gc-module.js                                            0000664 0000000 0000000 00000001031 14746647661 0023073 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm --max-old-space-size=20
'use strict';

/**
 * Verifying modules imported by ShadowRealm instances can be correctly
 * garbage collected.
 */

const common = require('../common');
const fixtures = require('../common/fixtures');
const { runAndBreathe } = require('../common/gc');

const mod = fixtures.fileURL('es-module-shadow-realm', 'state-counter.mjs');

runAndBreathe(async () => {
  const realm = new ShadowRealm();
  await realm.importValue(mod, 'getCounter');
}, 100).then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-shadow-realm-gc.js                                                   0000664 0000000 0000000 00000001213 14746647661 0021612 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm --max-old-space-size=20
'use strict';

/**
 * Verifying ShadowRealm instances can be correctly garbage collected.
 */

const common = require('../common');
const { runAndBreathe } = require('../common/gc');
const assert = require('assert');
const { isMainThread, Worker } = require('worker_threads');

runAndBreathe(() => {
  const realm = new ShadowRealm();
  realm.evaluate('new TextEncoder(); 1;');
}, 100).then(common.mustCall());

// Test it in worker too.
if (isMainThread) {
  const worker = new Worker(__filename);
  worker.on('exit', common.mustCall((code) => {
    assert.strictEqual(code, 0);
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-shadow-realm-globals.js                                              0000664 0000000 0000000 00000001206 14746647661 0022646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm
'use strict';

require('../common');
const { intrinsics, webIdlExposedWildcard } = require('../common/globals');
const assert = require('assert');

// Validates APIs exposed on the ShadowRealm globalThis.
const shadowRealm = new ShadowRealm();
const itemsStr = shadowRealm.evaluate(`
(() => {
  return Object.getOwnPropertyNames(globalThis).join(',');
})();
`);
const items = itemsStr.split(',');
const leaks = [];
for (const item of items) {
  if (intrinsics.has(item)) {
    continue;
  }
  if (webIdlExposedWildcard.has(item)) {
    continue;
  }
  leaks.push(item);
}

assert.deepStrictEqual(leaks, []);
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-shadow-realm-import-value-resolve.js                                 0000664 0000000 0000000 00000002040 14746647661 0025321 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm
'use strict';
const common = require('../common');
const assert = require('assert');
const path = require('path');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('This test only works on a main thread');
}

async function main() {
  const realm = new ShadowRealm();

  const dirname = __dirname;
  // Set process cwd to the parent directory of __dirname.
  const cwd = path.dirname(dirname);
  process.chdir(cwd);
  // Hardcode the relative path to ensure the string is still a valid relative
  // URL string.
  const relativePath = './fixtures/es-module-shadow-realm/re-export-state-counter.mjs';

  // Make sure that the module can not be resolved relative to __filename.
  assert.throws(() => require.resolve(relativePath), { code: 'MODULE_NOT_FOUND' });

  // Resolve relative to the current working directory.
  const getCounter = await realm.importValue(relativePath, 'getCounter');
  assert.strictEqual(typeof getCounter, 'function');
}

main().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-shadow-realm-module.js                                               0000664 0000000 0000000 00000002260 14746647661 0022511 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm
'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');

async function main() {
  const realm = new ShadowRealm();
  const mod = fixtures.fileURL('es-module-shadow-realm', 'state-counter.mjs');
  const getCounter = await realm.importValue(mod, 'getCounter');
  assert.strictEqual(getCounter(), 0);
  const getCounter1 = await realm.importValue(mod, 'getCounter');
  // Returned value is a newly wrapped function.
  assert.notStrictEqual(getCounter, getCounter1);
  // Verify that the module state is shared between two `importValue` calls.
  assert.strictEqual(getCounter1(), 1);
  assert.strictEqual(getCounter(), 2);

  const { getCounter: getCounterThisRealm } = await import(mod);
  assert.notStrictEqual(getCounterThisRealm, getCounter);
  // Verify that the module state is not shared between two realms.
  assert.strictEqual(getCounterThisRealm(), 0);
  assert.strictEqual(getCounter(), 3);

  // Verify that shadow realm rejects to import a non-existing module.
  await assert.rejects(realm.importValue('non-exists', 'exports'), TypeError);
}

main().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-shadow-realm-preload-module.js                                       0000664 0000000 0000000 00000001117 14746647661 0024135 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const { spawnSyncAndExitWithoutError } = require('../common/child_process');

const commonArgs = [
  '--experimental-shadow-realm',
];

async function main() {
  // Verifies that --require preload modules are not enabled in the ShadowRealm.
  spawnSyncAndExitWithoutError(process.execPath, [
    ...commonArgs,
    '--require',
    fixtures.path('es-module-shadow-realm', 'preload.js'),
    fixtures.path('es-module-shadow-realm', 'preload-main.js'),
  ]);
}

main().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-shadow-realm-prepare-stack-trace.js                                  0000664 0000000 0000000 00000002341 14746647661 0025061 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm
'use strict';

require('../common');
const assert = require('assert');

let principalRealmPrepareStackTraceCalled = false;
Error.prepareStackTrace = (error, trace) => {
  principalRealmPrepareStackTraceCalled = true;
  return `${String(error)}\n    at ${trace.join('\n    at ')}`;
};

{
  // Validates inner Error.prepareStackTrace can not leak into the outer realm.
  const shadowRealm = new ShadowRealm();

  const stack = shadowRealm.evaluate(`
Error.prepareStackTrace = (error, trace) => {
  globalThis.leaked = 'inner';
  return 'from shadow realm';
};

try {
  throw new Error('boom');
} catch (e) {
  e.stack;
}
`);
  assert.ok(!principalRealmPrepareStackTraceCalled);
  assert.strictEqual(stack, 'from shadow realm');
  assert.strictEqual('leaked' in globalThis, false);
}

{
  // Validates stacks can be generated in the ShadowRealm.
  const shadowRealm = new ShadowRealm();

  const stack = shadowRealm.evaluate(`
function myFunc() {
  throw new Error('boom');
}

try {
  myFunc();
} catch (e) {
  e.stack;
}
`);
  assert.ok(!principalRealmPrepareStackTraceCalled);
  const lines = stack.split('\n');
  assert.strictEqual(lines[0], 'Error: boom');
  assert.match(lines[1], /^ {4}at myFunc \(.*\)/);
}
                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-shadow-realm.js                                                      0000664 0000000 0000000 00000000622 14746647661 0021226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-shadow-realm
'use strict';

require('../common');
const assert = require('assert');

// Validates we can construct ShadowRealm successfully.
const shadowRealm = new ShadowRealm();

const getter = shadowRealm.evaluate('globalThis.realmValue = "inner"; () => globalThis.realmValue;');
assert.strictEqual(getter(), 'inner');
assert.strictEqual('realmValue' in globalThis, false);
                                                                                                              node-23.7.0/test/parallel/test-sigint-infinite-loop.js                                              0000664 0000000 0000000 00000001666 14746647661 0022723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// This test is to assert that we can SIGINT a script which loops forever.
// Ref(http):
// groups.google.com/group/nodejs-dev/browse_thread/thread/e20f2f8df0296d3f
const common = require('../common');
const assert = require('assert');
const spawn = require('child_process').spawn;

console.log('start');

const c = spawn(process.execPath, ['-e', 'while(true) { console.log("hi"); }']);

let sentKill = false;

c.stdout.on('data', function(s) {
  // Prevent race condition:
  // Wait for the first bit of output from the child process
  // so that we're sure that it's in the V8 event loop and not
  // just in the startup phase of execution.
  if (!sentKill) {
    c.kill('SIGINT');
    console.log('SIGINT infinite-loop.js');
    sentKill = true;
  }
});

c.on('exit', common.mustCall(function(code) {
  assert.ok(code !== 0);
  console.log('killed infinite-loop.js');
}));

process.on('exit', function() {
  assert.ok(sentKill);
});
                                                                          node-23.7.0/test/parallel/test-signal-args.js                                                       0000664 0000000 0000000 00000001322 14746647661 0021050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

if (common.isWindows) {
  common.skip('Sending signals with process.kill is not supported on Windows');
}

const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('No signal handling available in Workers');
}

process.once('SIGINT', common.mustCall((signal) => {
  assert.strictEqual(signal, 'SIGINT');
}));

process.kill(process.pid, 'SIGINT');

process.once('SIGTERM', common.mustCall((signal) => {
  assert.strictEqual(signal, 'SIGTERM');
}));

process.kill(process.pid, 'SIGTERM');

// Prevent Node.js from exiting due to empty event loop before signal handlers
// are fired
setImmediate(() => {});
                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-signal-handler-remove-on-exit.js                                     0000664 0000000 0000000 00000000376 14746647661 0024415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');

// Regression test for https://github.com/nodejs/node/issues/30581
// This script should not crash.

function dummy() {}
process.on('SIGINT', dummy);
process.on('exit', () => process.removeListener('SIGINT', dummy));
                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-signal-handler.js                                                    0000664 0000000 0000000 00000004041 14746647661 0021532 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

const common = require('../common');

if (common.isWindows) {
  common.skip('SIGUSR1 and SIGHUP signals are not supported');
}

const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Signal handling in Workers is not supported');
}

console.log(`process.pid: ${process.pid}`);

process.on('SIGUSR1', common.mustCall());

process.on('SIGUSR1', common.mustCall(function() {
  setTimeout(function() {
    console.log('End.');
    process.exit(0);
  }, 5);
}));

let i = 0;
setInterval(function() {
  console.log(`running process...${++i}`);

  if (i === 5) {
    process.kill(process.pid, 'SIGUSR1');
  }
}, 1);

// Test on condition where a watcher for SIGNAL
// has been previously registered, and `process.listeners(SIGNAL).length === 1`
process.on('SIGHUP', common.mustNotCall());
process.removeAllListeners('SIGHUP');
process.on('SIGHUP', common.mustCall());
process.kill(process.pid, 'SIGHUP');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-signal-safety.js                                                     0000664 0000000 0000000 00000000660 14746647661 0021413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
require('../common');
const assert = require('assert');
const { internalBinding } = require('internal/test/binding');
const { Signal } = internalBinding('signal_wrap');

// Test Signal `this` safety
// https://github.com/joyent/node/issues/6690
assert.throws(function() {
  const s = new Signal();
  const nots = { start: s.start };
  nots.start(9);
}, /^TypeError: Illegal invocation$/);
                                                                                node-23.7.0/test/parallel/test-signal-unregister.js                                                 0000664 0000000 0000000 00000000731 14746647661 0022306 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const spawn = require('child_process').spawn;
const fixtures = require('../common/fixtures');

const child = spawn(process.argv[0], [fixtures.path('should_exit.js')]);
child.stdout.once('data', function() {
  child.kill('SIGINT');
});
child.on('exit', common.mustCall(function(exitCode, signalCode) {
  assert.strictEqual(exitCode, null);
  assert.strictEqual(signalCode, 'SIGINT');
}));
                                       node-23.7.0/test/parallel/test-single-executable-blob-config-errors.js                              0000664 0000000 0000000 00000013146 14746647661 0025741 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This tests invalid options for --experimental-sea-config.

'use strict';

require('../common');
const tmpdir = require('../common/tmpdir');
const { writeFileSync, mkdirSync } = require('fs');
const { spawnSync } = require('child_process');
const assert = require('assert');

{
  tmpdir.refresh();
  const config = 'non-existent-relative.json';
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert.match(
    stderr,
    /Cannot read single executable configuration from non-existent-relative\.json/
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('non-existent-absolute.json');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `Cannot read single executable configuration from ${config}`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('invalid.json');
  writeFileSync(config, '\n{\n"main"', 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert.match(stderr, /SyntaxError: Expected ':' after property name/);
  assert(
    stderr.includes(
      `Cannot parse JSON from ${config}`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('empty.json');
  writeFileSync(config, '{}', 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `"main" field of ${config} is not a non-empty string`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('no-main.json');
  writeFileSync(config, '{"output": "test.blob"}', 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `"main" field of ${config} is not a non-empty string`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('no-output.json');
  writeFileSync(config, '{"main": "bundle.js"}', 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `"output" field of ${config} is not a non-empty string`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('invalid-disableExperimentalSEAWarning.json');
  writeFileSync(config, `
{
  "main": "bundle.js",
  "output": "sea-prep.blob",
  "disableExperimentalSEAWarning": "💥"
}
  `, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `"disableExperimentalSEAWarning" field of ${config} is not a Boolean`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('nonexistent-main-relative.json');
  writeFileSync(config, '{"main": "bundle.js", "output": "sea.blob"}', 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert.match(stderr, /Cannot read main script bundle\.js/);
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('nonexistent-main-absolute.json');
  const main = tmpdir.resolve('bundle.js');
  const configJson = JSON.stringify({
    main,
    output: 'sea.blob'
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `Cannot read main script ${main}`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('output-is-dir-absolute.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output-dir');
  mkdirSync(output);
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main,
    output,
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert(
    stderr.includes(
      `Cannot write output to ${output}`
    )
  );
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('output-is-dir-relative.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output-dir');
  mkdirSync(output);
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main,
    output: 'output-dir'
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  const stderr = child.stderr.toString();
  assert.strictEqual(child.status, 1);
  assert.match(stderr, /Cannot write output to output-dir/);
}
                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-single-executable-blob-config.js                                     0000664 0000000 0000000 00000006173 14746647661 0024431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This tests valid options for --experimental-sea-config.
'use strict';

require('../common');
const tmpdir = require('../common/tmpdir');
const { writeFileSync, existsSync } = require('fs');
const { spawnSync } = require('child_process');
const assert = require('assert');

{
  tmpdir.refresh();
  const config = tmpdir.resolve('absolute.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output.blob');
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main,
    output,
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });
  assert.strictEqual(child.status, 0);
  assert(existsSync(output));
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('relative.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output.blob');
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main: 'bundle.js',
    output: 'output.blob'
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  assert.strictEqual(child.status, 0);
  assert(existsSync(output));
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('no-disableExperimentalSEAWarning.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output.blob');
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main: 'bundle.js',
    output: 'output.blob',
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  assert.strictEqual(child.status, 0);
  assert(existsSync(output));
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('true-disableExperimentalSEAWarning.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output.blob');
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main: 'bundle.js',
    output: 'output.blob',
    disableExperimentalSEAWarning: true,
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  assert.strictEqual(child.status, 0);
  assert(existsSync(output));
}

{
  tmpdir.refresh();
  const config = tmpdir.resolve('false-disableExperimentalSEAWarning.json');
  const main = tmpdir.resolve('bundle.js');
  const output = tmpdir.resolve('output.blob');
  writeFileSync(main, 'console.log("hello")', 'utf-8');
  const configJson = JSON.stringify({
    main: 'bundle.js',
    output: 'output.blob',
    disableExperimentalSEAWarning: false,
  });
  writeFileSync(config, configJson, 'utf8');
  const child = spawnSync(
    process.execPath,
    ['--experimental-sea-config', config], {
      cwd: tmpdir.path,
    });

  assert.strictEqual(child.status, 0);
  assert(existsSync(output));
}
                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-snapshot-api.js                                                      0000664 0000000 0000000 00000002706 14746647661 0021256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests snapshot JS API using the example in the docs.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { spawnSyncAndAssert, spawnSyncAndExitWithoutError } = require('../common/child_process');
const fs = require('fs');

const v8 = require('v8');

// By default it should be false. We'll test that it's true in snapshot
// building mode in the fixture.
assert(!v8.startupSnapshot.isBuildingSnapshot());

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const entry = fixtures.path('snapshot', 'v8-startup-snapshot-api.js');
{
  for (const book of [
    'book1.en_US.txt',
    'book1.es_ES.txt',
    'book2.zh_CN.txt',
  ]) {
    const content = `This is ${book}`;
    fs.writeFileSync(tmpdir.resolve(book), content, 'utf8');
  }
  fs.copyFileSync(entry, tmpdir.resolve('entry.js'));
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    'entry.js',
  ], {
    cwd: tmpdir.path
  });
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    'book1',
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      BOOK_LANG: 'en_US',
    }
  }, {
    stderr: 'Reading book1.en_US.txt',
    stdout: 'This is book1.en_US.txt',
    trim: true
  });
}
                                                          node-23.7.0/test/parallel/test-snapshot-argv1.js                                                    0000664 0000000 0000000 00000002422 14746647661 0021520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests snapshot JS API using the example in the docs.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const code = `
require('v8').startupSnapshot.setDeserializeMainFunction(() => {
  console.log(JSON.stringify(process.argv));
});
`;
{
  fs.writeFileSync(tmpdir.resolve('entry.js'), code, 'utf8');
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    'entry.js',
  ], {
    cwd: tmpdir.path
  });
  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    'argv1',
    'argv2',
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
    }
  });

  const stdout = JSON.parse(child.stdout.toString().trim());
  assert.deepStrictEqual(stdout, [
    process.execPath,
    'argv1',
    'argv2',
  ]);
  assert.strictEqual(child.status, 0);
}
                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-snapshot-basic.js                                                    0000664 0000000 0000000 00000003773 14746647661 0021573 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that user land snapshots works when the instance restored from
// the snapshot is launched with --help, --check

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const {
  spawnSyncAndAssert,
  spawnSyncAndExit,
  spawnSyncAndExitWithoutError,
} = require('../common/child_process');
const fs = require('fs');

tmpdir.refresh();

let snapshotScript = 'node:embedded_snapshot_main';
if (!process.config.variables.node_use_node_snapshot) {
  // Check that Node.js built without an embedded snapshot
  // exits with 9 when node:embedded_snapshot_main is specified
  // as snapshot entry point.
  spawnSyncAndExit(process.execPath, [
    '--build-snapshot',
    snapshotScript,
  ], {
    cwd: tmpdir.path
  }, {
    status: 9,
    signal: null,
    stderr: /Node\.js was built without embedded snapshot/
  });

  snapshotScript = fixtures.path('empty.js');
}

// By default, the snapshot blob path is cwd/snapshot.blob.
{
  // Create the snapshot.
  spawnSyncAndExitWithoutError(process.execPath, [
    '--build-snapshot',
    snapshotScript,
  ], {
    cwd: tmpdir.path
  });
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

tmpdir.refresh();
const blobPath = tmpdir.resolve('my-snapshot.blob');
{
  // Create the snapshot.
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    snapshotScript,
  ], {
    cwd: tmpdir.path
  });
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());
}

{
  // Check --help.
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--help',
  ], {
    cwd: tmpdir.path
  }, {
    stdout: /--help/
  });
}

{
  // Check -c.
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '-c',
    fixtures.path('snapshot', 'marked.js'),
  ], {
    cwd: tmpdir.path
  }, {
    stderr: '',
    stdout: '',
    trim: true
  });
}
     node-23.7.0/test/parallel/test-snapshot-child-process-sync.js                                       0000664 0000000 0000000 00000002640 14746647661 0024213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that process.cwd() is accurate when
// restoring state from a snapshot

const { isInsideDirWithUnusualChars } = require('../common');
const { spawnSyncAndAssert } = require('../common/child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const assert = require('assert');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('snapshot', 'child-process-sync.js');
const expected = [
  'From child process spawnSync',
  ...(isInsideDirWithUnusualChars ? [] : ['From child process execSync']),
  'From child process execFileSync',
];

{
  // Create the snapshot.
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path,
    env: { ...process.env, DIRNAME_CONTAINS_SHELL_UNSAFE_CHARS: isInsideDirWithUnusualChars ? 'TRUE' : '' },
  }, {
    trim: true,
    stdout(output) {
      assert.deepStrictEqual(output.split('\n'), expected);
      return true;
    }
  });
}

{
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    file,
  ], {
    cwd: tmpdir.path,
    env: { ...process.env, DIRNAME_CONTAINS_SHELL_UNSAFE_CHARS: isInsideDirWithUnusualChars ? 'TRUE' : '' },
  }, {
    trim: true,
    stdout(output) {
      assert.deepStrictEqual(output.split('\n'), expected);
      return true;
    }
  });
}
                                                                                                node-23.7.0/test/parallel/test-snapshot-cjs-main.js                                                 0000664 0000000 0000000 00000002413 14746647661 0022201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that user land snapshots works when the instance restored from
// the snapshot is launched as a CJS module.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('snapshot', 'mutate-fs.js');
const checkFile = fixtures.path('snapshot', 'check-mutate-fs.js');

{
  // Create the snapshot.
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path
  });
  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());
}

{
  // Run the check file as a CJS module
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    checkFile,
  ], {
    cwd: tmpdir.path
  });

  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
}
                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-snapshot-config.js                                                   0000664 0000000 0000000 00000006135 14746647661 0021752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests --build-snapshot-config.

require('../common');
const assert = require('assert');
const {
  spawnSyncAndAssert,
  spawnSyncAndExit,
  spawnSyncAndExitWithoutError,
} = require('../common/child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

const blobPath = tmpdir.resolve('snapshot.blob');
const builderScript = fixtures.path('snapshot', 'mutate-fs.js');
const checkFile = fixtures.path('snapshot', 'check-mutate-fs.js');
const configPath = tmpdir.resolve('snapshot.json');
tmpdir.refresh();
{
  // Relative path.
  spawnSyncAndExit(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot-config',
    'snapshot.json',
  ], {
    cwd: tmpdir.path
  }, {
    signal: null,
    status: 1,
    trim: true,
    stderr: /Cannot read snapshot configuration from snapshot\.json/
  });

  // Absolute path.
  spawnSyncAndExit(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot-config',
    configPath,
  ], {
    cwd: tmpdir.path
  }, {
    signal: null,
    status: 1,
    trim: true,
    stderr: /Cannot read snapshot configuration from .+snapshot\.json/
  });
}

function writeConfig(config) {
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');
}

{
  tmpdir.refresh();
  // Config without "builder" field should be rejected.
  writeConfig({});
  spawnSyncAndExit(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot-config',
    configPath,
  ], {
    cwd: tmpdir.path
  }, {
    signal: null,
    status: 1,
    trim: true,
    stderr: /"builder" field of .+snapshot\.json is not a non-empty string/
  });
}

let sizeWithCache;
{
  tmpdir.refresh();
  // Create a working snapshot.
  writeConfig({ builder: builderScript });
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot-config',
    configPath,
  ], {
    cwd: tmpdir.path
  });
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());
  sizeWithCache = stats.size;

  // Check the snapshot.
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    checkFile,
  ], {
    cwd: tmpdir.path
  });
}

let sizeWithoutCache;
{
  tmpdir.refresh();
  // Create a working snapshot.
  writeConfig({ builder: builderScript, withoutCodeCache: true });
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot-config',
    configPath,
  ], {
    env: {
      ...process.env,
      NODE_DEBUG_NATIVE: 'CODE_CACHE'
    },
    cwd: tmpdir.path
  });
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());
  sizeWithoutCache = stats.size;
  assert(sizeWithoutCache < sizeWithCache,
         `sizeWithoutCache = ${sizeWithoutCache} >= sizeWithCache ${sizeWithCache}`);
  // Check the snapshot.
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    checkFile,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      NODE_DEBUG_NATIVE: 'CODE_CACHE'
    },
  }, {
    stderr: /snapshot contains 0 code cache/
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-snapshot-console.js                                                  0000664 0000000 0000000 00000002615 14746647661 0022146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests the console works in the deserialized snapshot.

const common = require('../common');
common.skipIfInspectorDisabled();

const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const entry = fixtures.path('snapshot', 'console.js');

{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    entry,
  ], {
    cwd: tmpdir.path
  });
  const stdout = child.stdout.toString();
  if (child.status !== 0) {
    console.log(stdout);
    console.log(child.stderr.toString());
    assert.strictEqual(child.status, 0);
  }
  assert.deepStrictEqual(Object.keys(console), JSON.parse(stdout));
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
    }
  });

  const stdout = child.stdout.toString();
  if (child.status !== 0) {
    console.log(stdout);
    console.log(child.stderr.toString());
    assert.strictEqual(child.status, 0);
  }
  assert.deepStrictEqual(Object.keys(console), JSON.parse(stdout));
  assert.strictEqual(child.status, 0);
}
                                                                                                                   node-23.7.0/test/parallel/test-snapshot-coverage.js                                                 0000664 0000000 0000000 00000003301 14746647661 0022270 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that the snapshot works with built-in coverage collection.

const common = require('../common');
common.skipIfInspectorDisabled();

const { spawnSyncAndExitWithoutError } = require('../common/child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');
const assert = require('assert');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('empty.js');

function filterCoverageFiles(name) {
  return name.startsWith('coverage') && name.endsWith('.json');
}
{
  // Create the snapshot.
  const { child } = spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      NODE_V8_COVERAGE: tmpdir.path,
      NODE_DEBUG_NATIVE: 'inspector_profiler',
    }
  });
  const files = fs.readdirSync(tmpdir.path);
  console.log('Files in tmpdir.path', files);  // Log for debugging the test.
  const coverage = files.filter(filterCoverageFiles);
  console.log(child.stderr.toString());
  assert.strictEqual(coverage.length, 1);
}

{
  const { child } = spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    file,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      NODE_V8_COVERAGE: tmpdir.path,
      NODE_DEBUG_NATIVE: 'inspector_profiler',
    },
  });
  const files = fs.readdirSync(tmpdir.path);
  console.log('Files in tmpdir.path', files);  // Log for debugging the test.
  const coverage = files.filter(filterCoverageFiles);
  console.log(child.stderr.toString());
  assert.strictEqual(coverage.length, 2);
}
                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-snapshot-cwd.js                                                      0000664 0000000 0000000 00000001617 14746647661 0021262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that process.cwd() is accurate when
// restoring state from a snapshot

require('../common');
const { spawnSyncAndAssert } = require('../common/child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('snapshot', 'cwd.js');

const subdir = tmpdir.resolve('foo');
fs.mkdirSync(subdir);

{
  // Create the snapshot.
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path,
    encoding: 'utf8'
  }, {
    status: 0,
  });
}

{
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    file,
  ], {
    cwd: subdir,
    encoding: 'utf8'
  }, {
    status: 0,
    trim: true,
    stdout: subdir,
  });
}
                                                                                                                 node-23.7.0/test/parallel/test-snapshot-dns-lookup-localhost-promise.js                             0000664 0000000 0000000 00000001754 14746647661 0026244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests support for the dns module in snapshot.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { buildSnapshot, runWithSnapshot } = require('../common/snapshot');

const entry = fixtures.path('snapshot', 'dns-lookup.js');
const env = {
  NODE_TEST_HOST: 'localhost',
  NODE_TEST_PROMISE: 'true',
};

tmpdir.refresh();
function checkOutput(stderr, stdout) {
  // We allow failures as it's not always possible to resolve localhost.
  // Functional tests are done in test/internet instead.
  if (!stderr.startsWith('error:')) {
    assert.match(stdout, /address: "\d+\.\d+\.\d+\.\d+"/);
    assert.match(stdout, /family: 4/);
    assert.strictEqual(stdout.trim().split('\n').length, 2);
  }
}
{
  const { stderr, stdout } = buildSnapshot(entry, env);
  checkOutput(stderr, stdout);
}

{
  const { stderr, stdout } = runWithSnapshot(entry, env);
  checkOutput(stderr, stdout);
}
                    node-23.7.0/test/parallel/test-snapshot-dns-lookup-localhost.js                                     0000664 0000000 0000000 00000001755 14746647661 0024571 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests support for the dns module in snapshot.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { buildSnapshot, runWithSnapshot } = require('../common/snapshot');

const entry = fixtures.path('snapshot', 'dns-lookup.js');
const env = {
  NODE_TEST_HOST: 'localhost',
  NODE_TEST_PROMISE: 'false',
};

tmpdir.refresh();
function checkOutput(stderr, stdout) {
  // We allow failures as it's not always possible to resolve localhost.
  // Functional tests are done in test/internet instead.
  if (!stderr.startsWith('error:')) {
    assert.match(stdout, /address: "\d+\.\d+\.\d+\.\d+"/);
    assert.match(stdout, /family: 4/);
    assert.strictEqual(stdout.trim().split('\n').length, 2);
  }
}
{
  const { stderr, stdout } = buildSnapshot(entry, env);
  checkOutput(stderr, stdout);
}

{
  const { stderr, stdout } = runWithSnapshot(entry, env);
  checkOutput(stderr, stdout);
}
                   node-23.7.0/test/parallel/test-snapshot-dns-resolve-localhost-promise.js                            0000664 0000000 0000000 00000001670 14746647661 0026407 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests support for the dns module in snapshot.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { buildSnapshot, runWithSnapshot } = require('../common/snapshot');

const entry = fixtures.path('snapshot', 'dns-resolve.js');
const env = {
  NODE_TEST_HOST: 'localhost',
  NODE_TEST_PROMISE: 'true',
};

tmpdir.refresh();
function checkOutput(stderr, stdout) {
  // We allow failures as it's not always possible to resolve localhost.
  // Functional tests are done in test/internet instead.
  if (!stderr.startsWith('error:')) {
    assert(stdout.includes('addresses: ['));
    assert.strictEqual(stdout.trim().split('\n').length, 1);
  }
}
{
  const { stderr, stdout } = buildSnapshot(entry, env);
  checkOutput(stderr, stdout);
}

{
  const { stderr, stdout } = runWithSnapshot(entry, env);
  checkOutput(stderr, stdout);
}
                                                                        node-23.7.0/test/parallel/test-snapshot-dns-resolve-localhost.js                                    0000664 0000000 0000000 00000001671 14746647661 0024734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests support for the dns module in snapshot.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { buildSnapshot, runWithSnapshot } = require('../common/snapshot');

const entry = fixtures.path('snapshot', 'dns-resolve.js');
const env = {
  NODE_TEST_HOST: 'localhost',
  NODE_TEST_PROMISE: 'false',
};

tmpdir.refresh();
function checkOutput(stderr, stdout) {
  // We allow failures as it's not always possible to resolve localhost.
  // Functional tests are done in test/internet instead.
  if (!stderr.startsWith('error:')) {
    assert(stdout.includes('addresses: ['));
    assert.strictEqual(stdout.trim().split('\n').length, 1);
  }
}
{
  const { stderr, stdout } = buildSnapshot(entry, env);
  checkOutput(stderr, stdout);
}

{
  const { stderr, stdout } = runWithSnapshot(entry, env);
  checkOutput(stderr, stdout);
}
                                                                       node-23.7.0/test/parallel/test-snapshot-error.js                                                    0000664 0000000 0000000 00000003615 14746647661 0021636 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that the errors in the snapshot script can be handled
// properly.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const entry = fixtures.path('snapshot', 'error.js');

// --build-snapshot should be run with an entry point.
{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
  ], {
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  console.log(child.status);
  console.log(stderr);
  console.log(child.stdout.toString());
  assert.strictEqual(child.status, 9);
  assert.match(stderr,
               /--build-snapshot must be used with an entry point script/);
  assert(!fs.existsSync(tmpdir.resolve('snapshot.blob')));
}

// Loading a non-existent snapshot should fail.
{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    entry,
  ], {
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  console.log(child.status);
  console.log(stderr);
  console.log(child.stdout.toString());
  assert.strictEqual(child.status, 14);
  assert.match(stderr, /Cannot open/);
  assert(!fs.existsSync(tmpdir.resolve('snapshot.blob')));
}


// Running an script that throws an error should result in an exit code of 1.
{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    entry,
  ], {
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  console.log(child.status);
  console.log(stderr);
  console.log(child.stdout.toString());
  assert.strictEqual(child.status, 1);
  assert.match(stderr, /error\.js:1/);
  assert(!fs.existsSync(tmpdir.resolve('snapshot.blob')));
}
                                                                                                                   node-23.7.0/test/parallel/test-snapshot-eval.js                                                     0000664 0000000 0000000 00000003250 14746647661 0021427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that user land snapshots works when the instance restored from
// the snapshot is launched with -p and -e

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('snapshot', 'mutate-fs.js');

{
  // Create the snapshot.
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path
  });
  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());
}

{
  // Check -p works.
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '-p',
    'require("fs").foo',
  ], {
    cwd: tmpdir.path
  });

  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  assert(/I am from the snapshot/.test(child.stdout.toString()));
}

{
  // Check -e works.
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '-e',
    'console.log(require("fs").foo)',
  ], {
    cwd: tmpdir.path
  });

  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  assert(/I am from the snapshot/.test(child.stdout.toString()));
}
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-snapshot-gzip.js                                                     0000664 0000000 0000000 00000003161 14746647661 0021452 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that a program that decompresses a gzip file and saves the
// content can be snapshotted and deserialized properly.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('snapshot', 'decompress-gzip-sync.js');

{
  // By default, the snapshot blob path is snapshot.blob at cwd
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    env: {
      ...process.env,
      NODE_TEST_FIXTURE: fixtures.path('person.jpg.gz'),
      NODE_TEST_MODE: 'snapshot'
    },
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  const stdout = child.stdout.toString();
  console.log(stderr);
  console.log(stdout);
  assert.strictEqual(child.status, 0);

  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
  assert(stdout.includes('NODE_TEST_MODE: snapshot'));
}

{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    file,
  ], {
    env: {
      ...process.env,
      NODE_TEST_FIXTURE: fixtures.path('person.jpg.gz'),
      NODE_TEST_MODE: 'verify'
    },
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  const stdout = child.stdout.toString();
  console.log(stderr);
  console.log(stdout);
  assert.strictEqual(child.status, 0);
  assert(stdout.includes('NODE_TEST_MODE: verify'));
}
                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-snapshot-incompatible.js                                             0000664 0000000 0000000 00000003505 14746647661 0023151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that Node.js refuses to load snapshots built with incompatible
// V8 configurations.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const entry = fixtures.path('empty.js');

// The flag used can be any flag that makes a difference in
// v8::ScriptCompiler::CachedDataVersionTag(). --harmony
// is chosen here because it's stable enough and makes a difference.
{
  // Build a snapshot with --harmony.
  const child = spawnSync(process.execPath, [
    '--harmony',
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    entry,
  ], {
    cwd: tmpdir.path
  });
  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  // Now load the snapshot without --harmony, which should fail.
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
    }
  });

  const stderr = child.stderr.toString().trim();
  assert.match(stderr, /Failed to load the startup snapshot/);
  assert.strictEqual(child.status, 14);
}

{
  // Load it again with --harmony and it should work.
  const child = spawnSync(process.execPath, [
    '--harmony',
    '--snapshot-blob',
    blobPath,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
    }
  });

  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
}
                                                                                                                                                                                           node-23.7.0/test/parallel/test-snapshot-namespaced-builtin.js                                       0000664 0000000 0000000 00000001774 14746647661 0024255 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests snapshot JS API using the example in the docs.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
{
  // The list of modules supported in the snapshot is unstable, so just check
  // a few that are known to work.
  const code = `
    require("node:v8");
    require("node:fs");
    require("node:fs/promises");
  `;
  fs.writeFileSync(
    tmpdir.resolve('entry.js'),
    code,
    'utf8'
  );
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    'entry.js',
  ], {
    cwd: tmpdir.path
  });
  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}
    node-23.7.0/test/parallel/test-snapshot-net.js                                                      0000664 0000000 0000000 00000003403 14746647661 0021266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that a local TCP server can be snapshotted and the
// diagnostics channels work across serialization.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const entry = fixtures.path('snapshot', 'server.js');
{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    entry,
  ], {
    cwd: tmpdir.path
  });
  if (child.status !== 0) {
    console.log(child.stderr.toString());
    console.log(child.stdout.toString());
    assert.strictEqual(child.status, 0);
  }
  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
    }
  });

  const stdout = child.stdout.toString().trim();
  console.log(`[stdout]:\n${stdout}\n`);
  const stderr = child.stderr.toString().trim();
  console.log(`[stderr]:\n${stderr}\n`);
  assert.strictEqual(child.status, 0);

  const lines = stdout.split('\n');
  assert.strictEqual(lines.length, 4);

  // The log should look like this:
  // server port ${port}
  // From client diagnostics channel
  // From server diagnostics channel: ${port}
  // recv.length: 256
  assert.match(lines[0], /server port (\d+)/);
  const port = lines[0].match(/server port (\d+)/)[1];
  assert.match(lines[1], /From client diagnostics channel/);
  assert.match(lines[2], new RegExp(`From server diagnostics channel: ${port}`));
  assert.match(lines[3], /recv\.length: 256/);
}
                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-snapshot-reproducible.js                                             0000664 0000000 0000000 00000003450 14746647661 0023161 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const { spawnSyncAndAssert } = require('../common/child_process');
const tmpdir = require('../common/tmpdir');
const fs = require('fs');
const assert = require('assert');

// When the test fails this helper can be modified to write outputs
// differently and aid debugging.
function log(line) {
  console.log(line);
}

function generateSnapshot() {
  tmpdir.refresh();

  spawnSyncAndAssert(
    process.execPath,
    [
      '--random_seed=42',
      '--predictable',
      '--build-snapshot',
      'node:generate_default_snapshot',
    ],
    {
      env: { ...process.env, NODE_DEBUG_NATIVE: 'SNAPSHOT_SERDES' },
      cwd: tmpdir.path
    },
    {
      stderr(output) {
        const lines = output.split('\n');
        for (const line of lines) {
          if (line.startsWith('0x')) {
            log(line);
          }
        }
      },
    }
  );
  const blobPath = tmpdir.resolve('snapshot.blob');
  return fs.readFileSync(blobPath);
}

const buf1 = generateSnapshot();
const buf2 = generateSnapshot();

const diff = [];
let offset = 0;
const step = 16;
do {
  const length = Math.min(buf1.length - offset, step);
  const slice1 = buf1.slice(offset, offset + length).toString('hex');
  const slice2 = buf2.slice(offset, offset + length).toString('hex');
  if (slice1 !== slice2) {
    diff.push({ offset: '0x' + (offset).toString(16), slice1, slice2 });
  }
  offset += length;
} while (offset < buf1.length);

assert.strictEqual(offset, buf1.length);
if (offset < buf2.length) {
  const length = Math.min(buf2.length - offset, step);
  const slice2 = buf2.slice(offset, offset + length).toString('hex');
  diff.push({ offset, slice1: '', slice2 });
  offset += length;
} while (offset < buf2.length);

assert.deepStrictEqual(diff, []);
assert.strictEqual(buf1.length, buf2.length);
                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-snapshot-stack-trace-limit-mutation.js                               0000664 0000000 0000000 00000002515 14746647661 0025656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests mutation to Error.stackTraceLimit in both the snapshot builder script
// and the snapshot main script work.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { spawnSyncAndAssert, spawnSyncAndExitWithoutError } = require('../common/child_process');

const blobPath = tmpdir.resolve('snapshot.blob');

function test(additionalArguments = [], additionalEnv = {}) {
  tmpdir.refresh();
  // Check the mutation works without --stack-trace-limit.
  spawnSyncAndAssert(process.execPath, [
    ...additionalArguments,
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    fixtures.path('snapshot', 'mutate-error-stack-trace-limit.js'),
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      ...additionalEnv,
    }
  }, {
    stderr(output) {
      assert.match(output, /Error\.stackTraceLimit has been modified by the snapshot builder script/);
      assert.match(output, /It will be preserved after snapshot deserialization/);
    }
  });
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
  ], {
    cwd: tmpdir.path
  });
}

test();
test([], { TEST_IN_SERIALIZER: 1 });
test(['--stack-trace-limit=50']);
test(['--stack-trace-limit=50'], { TEST_IN_SERIALIZER: 1 });
                                                                                                                                                                                   node-23.7.0/test/parallel/test-snapshot-stack-trace-limit.js                                        0000664 0000000 0000000 00000002336 14746647661 0024021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests Error.stackTraceLimit is fixed up for snapshot-building contexts,
// and can be restored after deserialization.

require('../common');
const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { spawnSyncAndAssert } = require('../common/child_process');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
{
  spawnSyncAndAssert(process.execPath, [
    '--stack-trace-limit=50',
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    fixtures.path('snapshot', 'error-stack.js'),
  ], {
    cwd: tmpdir.path
  }, {
    stdout(output) {
      assert.match(output, /During snapshot building, Error\.stackTraceLimit = 50/);
      const matches = [...output.matchAll(/at recurse/g)];
      assert.strictEqual(matches.length, 30);
    }
  });
}

{
  spawnSyncAndAssert(process.execPath, [
    '--stack-trace-limit=20',
    '--snapshot-blob',
    blobPath,
  ], {
    cwd: tmpdir.path
  }, {
    stdout(output) {
      assert.match(output, /After snapshot deserialization, Error\.stackTraceLimit = 20/);
      const matches = [...output.matchAll(/at recurse/g)];
      assert.strictEqual(matches.length, 20);
    }
  });
}
                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-snapshot-typescript.js                                               0000664 0000000 0000000 00000003273 14746647661 0022713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests the TypeScript compiler in the snapshot.

require('../common');

const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');

// Concat test/fixtures/snapshot/typescript.js with
// test/fixtures/snapshot/typescript.js into
// tmpdir/snapshot.js.
const file = tmpdir.resolve('snapshot.js');
fs.copyFileSync(fixtures.path('snapshot', 'typescript.js'), file);
fs.appendFileSync(file,
                  fs.readFileSync(fixtures.path('snapshot', 'typescript-main.js')));

{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  const stdout = child.stdout.toString();
  console.log(stderr);
  console.log(stdout);
  assert.strictEqual(child.status, 0);

  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  const outPath = tmpdir.resolve('ts-example.js');
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    fixtures.path('snapshot', 'ts-example.ts'),
    outPath,
  ], {
    cwd: tmpdir.path,
  });
  const stderr = child.stderr.toString();
  const snapshotOutput = child.stdout.toString();
  console.log(stderr);
  console.log(snapshotOutput);

  assert.strictEqual(child.status, 0);
  const result = fs.readFileSync(outPath, 'utf8');
  const expected = fs.readFileSync(
    fixtures.path('snapshot', 'ts-example.js'), 'utf8');
  assert.strictEqual(result, expected);
}
                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-snapshot-umd.js                                                      0000664 0000000 0000000 00000003634 14746647661 0021273 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests the behavior of loading a UMD module with --build-snapshot

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const file = fixtures.path('snapshot', 'marked.js');

{
  // By default, the snapshot blob path is snapshot.blob at cwd
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    file,
  ], {
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  const stdout = child.stdout.toString();
  console.log(stderr);
  console.log(stdout);
  assert.strictEqual(child.status, 0);

  const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
  assert(stats.isFile());
}

{
  let child = spawnSync(process.execPath, [
    '--snapshot-blob',
    tmpdir.resolve('snapshot.blob'),
    fixtures.path('snapshot', 'check-marked.js'),
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      NODE_TEST_USE_SNAPSHOT: 'true'
    }
  });
  let stderr = child.stderr.toString();
  const snapshotOutput = child.stdout.toString();
  console.log(stderr);
  console.log(snapshotOutput);

  assert.strictEqual(child.status, 0);
  assert(stderr.includes('NODE_TEST_USE_SNAPSHOT true'));

  child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    fixtures.path('snapshot', 'check-marked.js'),
  ], {
    cwd: tmpdir.path,
    env: {
      ...process.env,
      NODE_TEST_USE_SNAPSHOT: 'false'
    }
  });
  stderr = child.stderr.toString();
  const verifyOutput = child.stdout.toString();
  console.log(stderr);
  console.log(verifyOutput);

  assert.strictEqual(child.status, 0);
  assert(stderr.includes('NODE_TEST_USE_SNAPSHOT false'));

  assert(snapshotOutput.includes(verifyOutput));
}
                                                                                                    node-23.7.0/test/parallel/test-snapshot-warning.js                                                  0000664 0000000 0000000 00000007317 14746647661 0022155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that the warning handler is cleaned up properly
// during snapshot serialization and installed again during
// deserialization.

require('../common');

const assert = require('assert');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const { spawnSyncAndAssert, spawnSyncAndExitWithoutError } = require('../common/child_process');
const fs = require('fs');

const warningScript = fixtures.path('snapshot', 'warning.js');
const blobPath = tmpdir.resolve('snapshot.blob');
const empty = fixtures.path('empty.js');

tmpdir.refresh();
{
  console.log('\n# Check snapshot scripts that do not emit warnings.');
  spawnSyncAndExitWithoutError(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    empty,
  ], {
    cwd: tmpdir.path
  });
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());

  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    warningScript,
  ], {
    cwd: tmpdir.path
  }, {
    stderr(output) {
      const match = output.match(/Warning: test warning/g);
      assert.strictEqual(match.length, 1);
      return true;
    }
  });
}

tmpdir.refresh();
{
  console.log('\n# Check snapshot scripts that emit ' +
              'warnings and --trace-warnings hint.');
  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    warningScript,
  ], {
    cwd: tmpdir.path
  }, {
    stderr(output) {
      let match = output.match(/Warning: test warning/g);
      assert.strictEqual(match.length, 1);
      match = output.match(/Use `node --trace-warnings/g);
      assert.strictEqual(match.length, 1);
      return true;
    }
  });
  const stats = fs.statSync(blobPath);
  assert(stats.isFile());

  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    warningScript,
  ], {
    cwd: tmpdir.path
  }, {
    stderr(output) {
      // Warnings should not be handled more than once.
      let match = output.match(/Warning: test warning/g);
      assert.strictEqual(match.length, 1);
      match = output.match(/Use `node --trace-warnings/g);
      assert.strictEqual(match.length, 1);
      return true;
    }
  });
}

tmpdir.refresh();
{
  console.log('\n# Check --redirect-warnings');
  const warningFile1 = tmpdir.resolve('warnings.txt');
  const warningFile2 = tmpdir.resolve('warnings2.txt');

  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--redirect-warnings',
    warningFile1,
    '--build-snapshot',
    warningScript,
  ], {
    cwd: tmpdir.path
  }, {
    stderr(output) {
      assert.doesNotMatch(output, /Warning: test warning/);
    }
  });

  const stats = fs.statSync(blobPath);
  assert(stats.isFile());

  const warnings1 = fs.readFileSync(warningFile1, 'utf8');
  console.log(warningFile1, ':', warnings1);
  let match = warnings1.match(/Warning: test warning/g);
  assert.strictEqual(match.length, 1);
  match = warnings1.match(/Use `node --trace-warnings/g);
  assert.strictEqual(match.length, 1);
  fs.rmSync(warningFile1, {
    maxRetries: 3, recursive: false, force: true
  });

  spawnSyncAndAssert(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--redirect-warnings',
    warningFile2,
    warningScript,
  ], {
    cwd: tmpdir.path
  }, {
    stderr(output) {
      assert.doesNotMatch(output, /Warning: test warning/);
      return true;
    }
  });
  assert(!fs.existsSync(warningFile1));

  const warnings2 = fs.readFileSync(warningFile2, 'utf8');
  console.log(warningFile2, ':', warnings1);
  match = warnings2.match(/Warning: test warning/g);
  assert.strictEqual(match.length, 1);
  match = warnings2.match(/Use `node --trace-warnings/g);
  assert.strictEqual(match.length, 1);
}
                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-snapshot-weak-reference.js                                           0000664 0000000 0000000 00000002742 14746647661 0023370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that weak references work across serialization.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');

function runTest(entry) {
  console.log('running test with', entry);
  {
    const child = spawnSync(process.execPath, [
      '--expose-internals',
      '--expose-gc',
      '--snapshot-blob',
      blobPath,
      '--build-snapshot',
      entry,
    ], {
      cwd: tmpdir.path
    });
    if (child.status !== 0) {
      console.log(child.stderr.toString());
      console.log(child.stdout.toString());
      assert.strictEqual(child.status, 0);
    }
    const stats = fs.statSync(tmpdir.resolve('snapshot.blob'));
    assert(stats.isFile());
  }

  {
    const child = spawnSync(process.execPath, [
      '--expose-internals',
      '--expose-gc',
      '--snapshot-blob',
      blobPath,
    ], {
      cwd: tmpdir.path,
      env: {
        ...process.env,
      }
    });

    const stdout = child.stdout.toString().trim();
    const stderr = child.stderr.toString().trim();
    console.log(`[stdout]:\n${stdout}\n`);
    console.log(`[stderr]:\n${stderr}\n`);
    assert.strictEqual(child.status, 0);
  }
}

runTest(fixtures.path('snapshot', 'weak-reference.js'));
runTest(fixtures.path('snapshot', 'weak-reference-gc.js'));
                              node-23.7.0/test/parallel/test-snapshot-worker.js                                                   0000664 0000000 0000000 00000001532 14746647661 0022012 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests snapshot JS API using the example in the docs.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const tmpdir = require('../common/tmpdir');
const fixtures = require('../common/fixtures');
const fs = require('fs');

tmpdir.refresh();
const blobPath = tmpdir.resolve('snapshot.blob');
const entry = fixtures.path('snapshot', 'worker.js');
{
  const child = spawnSync(process.execPath, [
    '--snapshot-blob',
    blobPath,
    '--build-snapshot',
    entry,
  ], {
    cwd: tmpdir.path
  });
  const stderr = child.stderr.toString();
  assert.match(
    stderr,
    /Error: Creating workers is not supported in startup snapshot/);
  assert.match(
    stderr,
    /ERR_NOT_SUPPORTED_IN_SNAPSHOT/);
  assert.strictEqual(child.status, 1);
  assert(!fs.existsSync(blobPath));
}
                                                                                                                                                                      node-23.7.0/test/parallel/test-socket-address.js                                                    0000664 0000000 0000000 00000000737 14746647661 0021565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const net = require('net');

// This tests checks that if server._handle.getsockname
// returns an error number, an error is thrown.

const server = net.createServer({});
server.listen(0, common.mustCall(function() {
  server._handle.getsockname = function(out) {
    return -1;
  };
  assert.throws(() => this.address(),
                /^Error: address [\w|\s-\d]+$/);
  server.close();
}));
                                 node-23.7.0/test/parallel/test-socket-options-invalid.js                                            0000664 0000000 0000000 00000001151 14746647661 0023246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const net = require('net');

{
  const invalidKeys = [
    'objectMode',
    'readableObjectMode',
    'writableObjectMode',
  ];
  invalidKeys.forEach((invalidKey) => {
    const option = {
      [invalidKey]: true
    };
    const message = `The property 'options.${invalidKey}' is not supported. Received true`;

    assert.throws(() => {
      const socket = new net.Socket(option);
      socket.connect({ port: 8080 });
    }, {
      code: 'ERR_INVALID_ARG_VALUE',
      name: 'TypeError',
      message: new RegExp(message)
    });
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-socket-write-after-fin-error.js                                      0000664 0000000 0000000 00000003203 14746647661 0024261 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

// This is similar to simple/test-socket-write-after-fin, except that
// we don't set allowHalfOpen.  Then we write after the client has sent
// a FIN, and this is an error.  However, the standard "write after end"
// message is too vague, and doesn't actually tell you what happens.

const net = require('net');
let serverData = '';
let gotServerEnd = false;
let clientData = '';
let gotClientEnd = false;
let gotServerError = false;

const server = net.createServer(function(sock) {
  sock.setEncoding('utf8');
  sock.on('error', function() {});

  sock.on('data', function(c) {
    serverData += c;
  });
  sock.on('end', function() {
    gotServerEnd = true;
    setImmediate(() => {
      sock.write(serverData, function(er) {
        console.error(`${er.code}: ${er.message}`);
        gotServerError = er;
      });
      sock.end();
    });
  });
  server.close();
});
server.listen(0, function() {
  const sock = net.connect(this.address().port);
  sock.setEncoding('utf8');
  sock.on('data', function(c) {
    clientData += c;
  });

  sock.on('end', function() {
    gotClientEnd = true;
  });

  process.on('exit', function() {
    assert.strictEqual(clientData, '');
    assert.strictEqual(serverData, 'hello1hello2hello3\nTHUNDERMUSCLE!');
    assert(gotClientEnd);
    assert(gotServerEnd);
    assert(gotServerError);
    assert.strictEqual(gotServerError.code, 'EPIPE');
    assert.notStrictEqual(gotServerError.message, 'write after end');
    console.log('ok');
  });

  sock.write('hello1');
  sock.write('hello2');
  sock.write('hello3\n');
  sock.end('THUNDERMUSCLE!');
});
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-socket-write-after-fin.js                                            0000664 0000000 0000000 00000001657 14746647661 0023145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const net = require('net');
const expected = 'hello1hello2hello3\nbye';

const server = net.createServer({
  allowHalfOpen: true
}, common.mustCall(function(sock) {
  let serverData = '';

  sock.setEncoding('utf8');
  sock.on('data', function(c) {
    serverData += c;
  });
  sock.on('end', common.mustCall(function() {
    assert.strictEqual(serverData, expected);
    sock.end(serverData);
    server.close();
  }));
}));
server.listen(0, common.mustCall(function() {
  const sock = net.connect(this.address().port);
  let clientData = '';

  sock.setEncoding('utf8');
  sock.on('data', function(c) {
    clientData += c;
  });

  sock.on('end', common.mustCall(function() {
    assert.strictEqual(clientData, expected);
  }));

  sock.write('hello1');
  sock.write('hello2');
  sock.write('hello3\n');
  assert.strictEqual(sock.end('bye'), sock);

}));
                                                                                 node-23.7.0/test/parallel/test-socket-writes-before-passed-to-tls-socket.js                         0000664 0000000 0000000 00000002443 14746647661 0026674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
if (!common.hasCrypto) common.skip('missing crypto');
const tls = require('tls');
const net = require('net');

const HEAD = Buffer.alloc(1024 * 1024, 0);

const server = net.createServer((serverSock) => {
  let recvLen = 0;
  const recv = [];
  serverSock.on('data', common.mustCallAtLeast((chunk) => {
    recv.push(chunk);
    recvLen += chunk.length;

    // Check that HEAD is followed by a client hello
    if (recvLen > HEAD.length) {
      const clientHelloFstByte = Buffer.concat(recv).subarray(HEAD.length, HEAD.length + 1);
      assert.strictEqual(clientHelloFstByte.toString('hex'), '16');
      process.exit(0);
    }
  }, 1));
})
  .listen(client);

function client() {
  const socket = net.createConnection({
    host: '127.0.0.1',
    port: server.address().port,
  });
  socket.write(HEAD.subarray(0, HEAD.length / 2), common.mustSucceed());

  // This write will be queued by streams.Writable, the super class of net.Socket,
  // which will dequeue this write when it gets notified about the finish of the first write.
  // We had a bug that it wouldn't get notified. This test verifies the bug is fixed.
  socket.write(HEAD.subarray(HEAD.length / 2), common.mustSucceed());

  tls.connect({
    socket,
  });
}
                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-socketaddress.js                                                     0000664 0000000 0000000 00000011456 14746647661 0021510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const {
  ok,
  strictEqual,
  throws,
} = require('assert');
const {
  SocketAddress,
} = require('net');

const {
  InternalSocketAddress,
} = require('internal/socketaddress');
const { internalBinding } = require('internal/test/binding');
const {
  SocketAddress: _SocketAddress,
  AF_INET,
} = internalBinding('block_list');

const { describe, it } = require('node:test');

describe('net.SocketAddress...', () => {

  it('is cloneable', () => {
    const sa = new SocketAddress();
    strictEqual(sa.address, '127.0.0.1');
    strictEqual(sa.port, 0);
    strictEqual(sa.family, 'ipv4');
    strictEqual(sa.flowlabel, 0);

    const mc = new MessageChannel();
    mc.port1.onmessage = common.mustCall(({ data }) => {
      ok(SocketAddress.isSocketAddress(data));

      strictEqual(data.address, '127.0.0.1');
      strictEqual(data.port, 0);
      strictEqual(data.family, 'ipv4');
      strictEqual(data.flowlabel, 0);

      mc.port1.close();
    });
    mc.port2.postMessage(sa);
  });

  it('has reasonable defaults', () => {
    const sa = new SocketAddress({});
    strictEqual(sa.address, '127.0.0.1');
    strictEqual(sa.port, 0);
    strictEqual(sa.family, 'ipv4');
    strictEqual(sa.flowlabel, 0);
  });

  it('interprets simple ipv4 correctly', () => {
    const sa = new SocketAddress({
      address: '123.123.123.123',
    });
    strictEqual(sa.address, '123.123.123.123');
    strictEqual(sa.port, 0);
    strictEqual(sa.family, 'ipv4');
    strictEqual(sa.flowlabel, 0);
  });

  it('sets the port correctly', () => {
    const sa = new SocketAddress({
      address: '123.123.123.123',
      port: 80
    });
    strictEqual(sa.address, '123.123.123.123');
    strictEqual(sa.port, 80);
    strictEqual(sa.family, 'ipv4');
    strictEqual(sa.flowlabel, 0);
  });

  it('interprets simple ipv6 correctly', () => {
    const sa = new SocketAddress({
      family: 'ipv6'
    });
    strictEqual(sa.address, '::');
    strictEqual(sa.port, 0);
    strictEqual(sa.family, 'ipv6');
    strictEqual(sa.flowlabel, 0);
  });

  it('uses the flowlabel correctly', () => {
    const sa = new SocketAddress({
      family: 'ipv6',
      flowlabel: 1,
    });
    strictEqual(sa.address, '::');
    strictEqual(sa.port, 0);
    strictEqual(sa.family, 'ipv6');
    strictEqual(sa.flowlabel, 1);
  });

  it('validates input correctly', () => {
    [1, false, 'hello'].forEach((i) => {
      throws(() => new SocketAddress(i), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    });

    [1, false, {}, [], 'test'].forEach((family) => {
      throws(() => new SocketAddress({ family }), {
        code: 'ERR_INVALID_ARG_VALUE'
      });
    });

    [1, false, {}, []].forEach((address) => {
      throws(() => new SocketAddress({ address }), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    });

    [-1, false, {}, []].forEach((port) => {
      throws(() => new SocketAddress({ port }), {
        code: 'ERR_SOCKET_BAD_PORT'
      });
    });

    throws(() => new SocketAddress({ flowlabel: -1 }), {
      code: 'ERR_OUT_OF_RANGE'
    });
  });

  it('InternalSocketAddress correctly inherits from SocketAddress', () => {
    // Test that the internal helper class InternalSocketAddress correctly
    // inherits from SocketAddress and that it does not throw when its properties
    // are accessed.

    const address = '127.0.0.1';
    const port = 8080;
    const flowlabel = 0;
    const handle = new _SocketAddress(address, port, AF_INET, flowlabel);
    const addr = new InternalSocketAddress(handle);
    ok(addr instanceof SocketAddress);
    strictEqual(addr.address, address);
    strictEqual(addr.port, port);
    strictEqual(addr.family, 'ipv4');
    strictEqual(addr.flowlabel, flowlabel);
  });

  it('SocketAddress.parse() works as expected', () => {
    const good = [
      { input: '1.2.3.4', address: '1.2.3.4', port: 0, family: 'ipv4' },
      { input: '192.168.257:1', address: '192.168.1.1', port: 1, family: 'ipv4' },
      { input: '256', address: '0.0.1.0', port: 0, family: 'ipv4' },
      { input: '999999999:12', address: '59.154.201.255', port: 12, family: 'ipv4' },
      { input: '0xffffffff', address: '255.255.255.255', port: 0, family: 'ipv4' },
      { input: '0x.0x.0', address: '0.0.0.0', port: 0, family: 'ipv4' },
      { input: '[1:0::]', address: '1::', port: 0, family: 'ipv6' },
      { input: '[1::8]:123', address: '1::8', port: 123, family: 'ipv6' },
    ];

    good.forEach((i) => {
      const addr = SocketAddress.parse(i.input);
      strictEqual(addr.address, i.address);
      strictEqual(addr.port, i.port);
      strictEqual(addr.family, i.family);
    });

    const bad = [
      'not an ip',
      'abc.123',
      '259.1.1.1',
      '12:12:12',
    ];

    bad.forEach((i) => {
      strictEqual(SocketAddress.parse(i), undefined);
    });
  });

});
                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-source-map-api.js                                                    0000664 0000000 0000000 00000016651 14746647661 0021476 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --enable-source-maps
'use strict';

const common = require('../common');
const assert = require('assert');
const { findSourceMap, SourceMap } = require('module');
const { readFileSync } = require('fs');

// It should throw with invalid args.
{
  [1, true, 'foo'].forEach((invalidArg) =>
    assert.throws(
      () => new SourceMap(invalidArg),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The "payload" argument must be of type object.' +
               common.invalidArgTypeHelper(invalidArg)
      }
    )
  );
}

// `findSourceMap()` should return undefined when no source map is found.
{
  const files = [
    __filename,
    '',
    'invalid-file',
  ];
  for (const file of files) {
    const sourceMap = findSourceMap(file);
    assert.strictEqual(sourceMap, undefined);
  }
}

// findSourceMap() can lookup source-maps based on URIs, in the
// non-exceptional case.
{
  require('../fixtures/source-map/disk-relative-path.js');
  const sourceMap = findSourceMap(
    require.resolve('../fixtures/source-map/disk-relative-path.js')
  );
  const {
    originalLine,
    originalColumn,
    originalSource
  } = sourceMap.findEntry(0, 29);
  assert.strictEqual(originalLine, 2);
  assert.strictEqual(originalColumn, 4);
  assert(originalSource.endsWith('disk.js'));
  const {
    fileName,
    lineNumber,
    columnNumber,
  } = sourceMap.findOrigin(1, 30);
  assert.strictEqual(fileName, originalSource);
  assert.strictEqual(lineNumber, 3);
  assert.strictEqual(columnNumber, 6);
  assert(Array.isArray(sourceMap.lineLengths));
  assert(!sourceMap.lineLengths.some((len) => (typeof len !== 'number')));
}

// findSourceMap() can be used in Error.prepareStackTrace() to lookup
// source-map attached to error.
{
  let callSite;
  let sourceMap;
  Error.prepareStackTrace = (error, trace) => {
    const throwingRequireCallSite = trace[0];
    if (throwingRequireCallSite.getFileName().endsWith('typescript-throw.js')) {
      sourceMap = findSourceMap(throwingRequireCallSite.getFileName());
      callSite = throwingRequireCallSite;
    }
  };
  try {
    // Require a file that throws an exception, and has a source map.
    require('../fixtures/source-map/typescript-throw.js');
  } catch (err) {
    // eslint-disable-next-line no-unused-expressions
    err.stack; // Force prepareStackTrace() to be called.
  }
  assert(callSite);
  assert(sourceMap);
  const {
    generatedLine,
    generatedColumn,
    originalLine,
    originalColumn,
    originalSource
  } = sourceMap.findEntry(
    callSite.getLineNumber() - 1,
    callSite.getColumnNumber() - 1
  );

  assert.strictEqual(generatedLine, 19);
  assert.strictEqual(generatedColumn, 14);

  assert.strictEqual(originalLine, 17);
  assert.strictEqual(originalColumn, 10);
  assert(originalSource.endsWith('typescript-throw.ts'));

  const {
    fileName,
    lineNumber,
    columnNumber,
  } = sourceMap.findOrigin(
    callSite.getLineNumber(),
    callSite.getColumnNumber()
  );
  assert.strictEqual(fileName, originalSource);
  assert.strictEqual(lineNumber, 18);
  assert.strictEqual(columnNumber, 11);
}

// SourceMap can be instantiated with Source Map V3 object as payload.
{
  const payload = JSON.parse(readFileSync(
    require.resolve('../fixtures/source-map/disk.map'), 'utf8'
  ));
  const lineLengths = readFileSync(
    require.resolve('../fixtures/source-map/disk.map'), 'utf8'
  ).replace(/\n$/, '').split('\n').map((l) => l.length);
  const sourceMap = new SourceMap(payload, { lineLengths });
  const {
    originalLine,
    originalColumn,
    originalSource
  } = sourceMap.findEntry(0, 29);
  assert.strictEqual(originalLine, 2);
  assert.strictEqual(originalColumn, 4);
  assert(originalSource.endsWith('disk.js'));
  const sourceMapLineLengths = sourceMap.lineLengths;
  for (let i = 0; i < sourceMapLineLengths.length; i++) {
    assert.strictEqual(sourceMapLineLengths[i], lineLengths[i]);
  }
  assert.strictEqual(sourceMapLineLengths.length, lineLengths.length);
  // The stored payload should be a clone:
  assert.strictEqual(payload.mappings, sourceMap.payload.mappings);
  assert.notStrictEqual(payload, sourceMap.payload);
  assert.strictEqual(payload.sources[0], sourceMap.payload.sources[0]);
  assert.notStrictEqual(payload.sources, sourceMap.payload.sources);
}

// findEntry() and findOrigin() must return empty object instead of
// error when receiving a malformed mappings.
{
  const payload = JSON.parse(readFileSync(
    require.resolve('../fixtures/source-map/disk.map'), 'utf8'
  ));
  payload.mappings = ';;;;;;;;;';

  const sourceMap = new SourceMap(payload);
  const result = sourceMap.findEntry(0, 5);
  assert.strictEqual(typeof result, 'object');
  assert.strictEqual(Object.keys(result).length, 0);
  const origin = sourceMap.findOrigin(0, 5);
  assert.strictEqual(typeof origin, 'object');
  assert.strictEqual(Object.keys(origin).length, 0);
}

// SourceMap can be instantiated with Index Source Map V3 object as payload.
{
  const payload = JSON.parse(readFileSync(
    require.resolve('../fixtures/source-map/disk-index.map'), 'utf8'
  ));
  const sourceMap = new SourceMap(payload);
  const {
    originalLine,
    originalColumn,
    originalSource
  } = sourceMap.findEntry(0, 29);
  assert.strictEqual(originalLine, 2);
  assert.strictEqual(originalColumn, 4);
  assert(originalSource.endsWith('section.js'));
  // The stored payload should be a clone:
  assert.strictEqual(payload.mappings, sourceMap.payload.mappings);
  assert.notStrictEqual(payload, sourceMap.payload);
  assert.strictEqual(payload.sources[0], sourceMap.payload.sources[0]);
  assert.notStrictEqual(payload.sources, sourceMap.payload.sources);
}

// Test various known decodings to ensure decodeVLQ works correctly.
{
  function makeMinimalMap(column) {
    return {
      sources: ['test.js'],
      // Mapping from the 0th line, 0th column of the output file to the 0th
      // source file, 0th line, ${column}th column.
      mappings: `AAA${column}`,
    };
  }
  const knownDecodings = {
    'A': 0,
    'B': -2147483648,
    'C': 1,
    'D': -1,
    'E': 2,
    'F': -2,

    // 2^31 - 1, maximum values
    '+/////D': 2147483647,
    '8/////D': 2147483646,
    '6/////D': 2147483645,
    '4/////D': 2147483644,
    '2/////D': 2147483643,
    '0/////D': 2147483642,

    // -2^31 + 1, minimum values
    '//////D': -2147483647,
    '9/////D': -2147483646,
    '7/////D': -2147483645,
    '5/////D': -2147483644,
    '3/////D': -2147483643,
    '1/////D': -2147483642,
  };

  for (const column in knownDecodings) {
    const sourceMap = new SourceMap(makeMinimalMap(column));
    const { originalColumn } = sourceMap.findEntry(0, 0);
    assert.strictEqual(originalColumn, knownDecodings[column]);
  }
}

// Test that generated columns are sorted when a negative offset is
// observed, see: https://github.com/mozilla/source-map/pull/92
{
  function makeMinimalMap(generatedColumns, originalColumns) {
    return {
      sources: ['test.js'],
      // Mapping from the 0th line, ${g}th column of the output file to the 0th
      // source file, 0th line, ${column}th column.
      mappings: generatedColumns.map((g, i) => `${g}AA${originalColumns[i]}`)
        .join(',')
    };
  }
  // U = 10
  // F = -2
  // A = 0
  // E = 2
  const sourceMap = new SourceMap(makeMinimalMap(
    ['U', 'F', 'F'],
    ['A', 'E', 'E']
  ));
  assert.strictEqual(sourceMap.findEntry(0, 6).originalColumn, 4);
  assert.strictEqual(sourceMap.findEntry(0, 8).originalColumn, 2);
  assert.strictEqual(sourceMap.findEntry(0, 10).originalColumn, 0);
}
                                                                                       node-23.7.0/test/parallel/test-source-map-cjs-require-cache.js                                      0000664 0000000 0000000 00000002427 14746647661 0024213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --enable-source-maps --max-old-space-size=10 --expose-gc

/**
 * This test verifies that the source map of a CJS module is cleared after the
 * CJS module is reclaimed by GC.
 */

'use strict';
require('../common');
const { gcUntil } = require('../common/gc');
const assert = require('node:assert');
const { findSourceMap } = require('node:module');

const moduleId = require.resolve('../fixtures/source-map/no-throw.js');
const moduleIdRepeat = require.resolve('../fixtures/source-map/no-throw2.js');

function run(moduleId) {
  require(moduleId);
  delete require.cache[moduleId];
  const idx = module.children.findIndex((child) => child.id === moduleId);
  assert.ok(idx >= 0);
  module.children.splice(idx, 1);

  // Verify that the source map is still available
  assert.notStrictEqual(findSourceMap(moduleId), undefined);
}

// Run the test in a function scope so that every variable can be reclaimed by GC.
run(moduleId);

// Run until the source map is cleared by GC, or fail the test after determined iterations.
gcUntil('SourceMap of deleted CJS module is cleared', () => {
  // Repetitively load a second module with --max-old-space-size=10 to make GC more aggressive.
  run(moduleIdRepeat);
  // Verify that the source map is cleared.
  return findSourceMap(moduleId) == null;
});
                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-source-map-enable.js                                                 0000664 0000000 0000000 00000032127 14746647661 0022147 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

if (!process.features.inspector) return;

const common = require('../common');
const assert = require('assert');
const { dirname } = require('path');
const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');
const { pathToFileURL } = require('url');

const tmpdir = require('../common/tmpdir');
tmpdir.refresh();

let dirc = 0;
function nextdir() {
  return process.env.NODE_V8_COVERAGE ||
    tmpdir.resolve(`source_map_${++dirc}`);
}

// Outputs source maps when event loop is drained, with no async logic.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/basic'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache('basic.js', coverageDirectory);
  assert.strictEqual(sourceMap.url, 'https://ci.nodejs.org/418');
}

// Outputs source maps when process.kill(process.pid, "SIGINT"); exits process.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/sigint'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (!common.isWindows) {
    if (output.signal !== 'SIGINT') {
      console.log(output.stderr.toString());
    }
    assert.strictEqual(output.signal, 'SIGINT');
  }
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache('sigint.js', coverageDirectory);
  assert.strictEqual(sourceMap.url, 'https://ci.nodejs.org/402');
}

// Outputs source maps when source-file calls process.exit(1).
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/exit-1'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache('exit-1.js', coverageDirectory);
  assert.strictEqual(sourceMap.url, 'https://ci.nodejs.org/404');
}

// Outputs source-maps for esm module.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    '--no-warnings',
    require.resolve('../fixtures/source-map/esm-basic.mjs'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache('esm-basic.mjs', coverageDirectory);
  assert.strictEqual(sourceMap.url, 'https://ci.nodejs.org/405');
}

// Loads source-maps with relative path from .map file on disk.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/disk-relative-path'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache(
    'disk-relative-path.js',
    coverageDirectory
  );
  // Source-map should have been loaded from disk and sources should have been
  // rewritten, such that they're absolute paths.
  assert.strictEqual(
    dirname(pathToFileURL(
      require.resolve('../fixtures/source-map/disk-relative-path')).href),
    dirname(sourceMap.data.sources[0])
  );
}

// Loads source-maps from inline data URL.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/inline-base64.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache(
    'inline-base64.js',
    coverageDirectory
  );
  // base64 JSON should have been decoded, and paths to sources should have
  // been rewritten such that they're absolute:
  assert.strictEqual(
    dirname(pathToFileURL(
      require.resolve('../fixtures/source-map/inline-base64')).href),
    dirname(sourceMap.data.sources[0])
  );
}

// base64 encoding error does not crash application.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/inline-base64-type-error.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache(
    'inline-base64-type-error.js',
    coverageDirectory
  );

  assert.strictEqual(sourceMap.data, null);
}

// JSON error does not crash application.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/inline-base64-json-error.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache(
    'inline-base64-json-error.js',
    coverageDirectory
  );

  assert.strictEqual(sourceMap.data, null);
}

// Does not apply source-map to stack trace if --experimental-modules
// is not set.
{
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/uglify-throw.js'),
  ]);
  assert.strictEqual(
    output.stderr.toString().match(/.*uglify-throw-original\.js:5:9/),
    null
  );
  assert.strictEqual(
    output.stderr.toString().match(/.*uglify-throw-original\.js:9:3/),
    null
  );
}

// Applies source-maps generated by uglifyjs to stack trace.
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/uglify-throw.js'),
  ]);
  assert.match(
    output.stderr.toString(),
    /.*uglify-throw-original\.js:5:9/
  );
  assert.match(
    output.stderr.toString(),
    /.*uglify-throw-original\.js:9:3/
  );
  assert.match(output.stderr.toString(), /at Hello/);
}

// Applies source-maps generated by tsc to stack trace.
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/typescript-throw.js'),
  ]);
  assert.ok(output.stderr.toString().match(/.*typescript-throw\.ts:18:11/));
  assert.ok(output.stderr.toString().match(/.*typescript-throw\.ts:24:1/));
}

// Applies source-maps generated by babel to stack trace.
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/babel-throw.js'),
  ]);
  assert.ok(
    output.stderr.toString().match(/.*babel-throw-original\.js:18:31/)
  );
}

// Applies source-maps generated by nyc to stack trace.
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/istanbul-throw.js'),
  ]);
  assert.ok(
    output.stderr.toString().match(/.*istanbul-throw-original\.js:5:9/)
  );
  assert.ok(
    output.stderr.toString().match(/.*istanbul-throw-original\.js:9:3/)
  );
}

// Applies source-maps in esm modules to stack trace.
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/babel-esm.mjs'),
  ]);
  assert.ok(
    output.stderr.toString().match(/.*babel-esm-original\.mjs:9:29/)
  );
}

// Does not persist url parameter if source-map has been parsed.
{
  const coverageDirectory = nextdir();
  spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/inline-base64.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  const sourceMap = getSourceMapFromCache(
    'inline-base64.js',
    coverageDirectory
  );
  assert.strictEqual(sourceMap.url, null);
}

// Persists line lengths for in-memory representation of source file.
{
  const checkoutEOL = fs.readFileSync(__filename).includes('\r\n') ? '\r\n' : '\n';
  const coverageDirectory = nextdir();
  spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/istanbul-throw.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  const sourceMap = getSourceMapFromCache(
    'istanbul-throw.js',
    coverageDirectory
  );
  if (checkoutEOL === '\r\n') {
    assert.deepStrictEqual(sourceMap.lineLengths, [1086, 31, 185, 649, 0]);
  } else {
    assert.deepStrictEqual(sourceMap.lineLengths, [1085, 30, 184, 648, 0]);
  }
}

// trace.length === 0 .
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/emptyStackError.js'),
  ]);

  assert.ok(
    output.stderr.toString().match('emptyStackError')
  );
}

// Does not attempt to apply path resolution logic to absolute URLs
// with schemes.
// Refs: https://github.com/webpack/webpack/issues/9601
// Refs: https://sourcemaps.info/spec.html#h.75yo6yoyk7x5
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/webpack.js'),
  ]);
  // Error in original context of source content:
  assert.match(
    output.stderr.toString(),
    /throw new Error\('oh no!'\)\r?\n.*\^/
  );
  // Rewritten stack trace:
  assert.match(output.stderr.toString(), /webpack:\/\/\/webpack\.js:14:9/);
  assert.match(output.stderr.toString(), /at functionD.*14:9/);
  assert.match(output.stderr.toString(), /at functionC.*10:3/);
}

// Properly converts Windows absolute paths to absolute URLs.
// Refs: https://github.com/nodejs/node/issues/50523
// Refs: https://github.com/TypeStrong/ts-node/issues/1769
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/source-map/ts-node-win32.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const sourceMap = getSourceMapFromCache(
    'ts-node-win32.js',
    coverageDirectory
  );
  // base64 JSON should have been decoded, the D: in the sources field should
  // have been taken as the drive letter on Windows, the scheme on POSIX.
  assert.strictEqual(
    sourceMap.data.sources[0],
    common.isWindows ?
      'file:///D:/workspaces/node/test/fixtures/source-map/ts-node.ts' :
      'd:/workspaces/node/test/fixtures/source-map/ts-node.ts'
  );
}

// Stores and applies source map associated with file that throws while
// being required.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/throw-on-require-entry.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  const sourceMap = getSourceMapFromCache(
    'throw-on-require.js',
    coverageDirectory
  );
  // Rewritten stack trace.
  assert.match(output.stderr.toString(), /throw-on-require\.ts:9:9/);
  // Source map should have been serialized.
  assert.ok(sourceMap);
}

// Does not throw TypeError when primitive value is thrown.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/throw-string.js'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  const sourceMap = getSourceMapFromCache(
    'throw-string.js',
    coverageDirectory
  );
  // Original stack trace.
  assert.match(output.stderr.toString(), /goodbye/);
  // Source map should have been serialized.
  assert.ok(sourceMap);
}

// Does not throw TypeError when exception occurs as result of missing named
// export.
{
  const coverageDirectory = nextdir();
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/esm-export-missing.mjs'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  const sourceMap = getSourceMapFromCache(
    'esm-export-missing.mjs',
    coverageDirectory
  );
  // Module loader error displayed.
  assert.match(output.stderr.toString(),
               /does not provide an export named 'Something'/);
  // Source map should have been serialized.
  assert.ok(sourceMap);
}

// Does not include null for async/await with esm
// Refs: https://github.com/nodejs/node/issues/42417
{
  const output = spawnSync(process.execPath, [
    '--enable-source-maps',
    require.resolve('../fixtures/source-map/throw-async.mjs'),
  ]);
  // Error in original context of source content:
  assert.match(
    output.stderr.toString(),
    /throw new Error\(message\)\r?\n.*\^/
  );
  // Rewritten stack trace:
  assert.match(output.stderr.toString(), /at Throw \([^)]+throw-async\.ts:4:9\)/);
}

function getSourceMapFromCache(fixtureFile, coverageDirectory) {
  const jsonFiles = fs.readdirSync(coverageDirectory);
  for (const jsonFile of jsonFiles) {
    let maybeSourceMapCache;
    try {
      maybeSourceMapCache = require(
        path.join(coverageDirectory, jsonFile)
      )['source-map-cache'] || {};
    } catch (err) {
      console.warn(err);
      maybeSourceMapCache = {};
    }
    const keys = Object.keys(maybeSourceMapCache);
    for (const key of keys) {
      if (key.includes(fixtureFile)) {
        return maybeSourceMapCache[key];
      }
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-spawn-cmd-named-pipe.js                                              0000664 0000000 0000000 00000002557 14746647661 0022562 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
// This test is intended for Windows only
if (!common.isWindows)
  common.skip('this test is Windows-specific.');

const assert = require('assert');

if (!process.argv[2]) {
  // parent
  const net = require('net');
  const spawn = require('child_process').spawn;
  const path = require('path');

  const pipeNamePrefix = `${path.basename(__filename)}.${process.pid}`;
  const stdinPipeName = `\\\\.\\pipe\\${pipeNamePrefix}.stdin`;
  const stdoutPipeName = `\\\\.\\pipe\\${pipeNamePrefix}.stdout`;

  const stdinPipeServer = net.createServer(function(c) {
    c.on('end', common.mustCall());
    c.end('hello');
  });
  stdinPipeServer.listen(stdinPipeName);

  const output = [];

  const stdoutPipeServer = net.createServer(function(c) {
    c.on('data', function(x) {
      output.push(x);
    });
    c.on('end', common.mustCall(function() {
      assert.strictEqual(output.join(''), 'hello');
    }));
  });
  stdoutPipeServer.listen(stdoutPipeName);

  const args =
    [`"${__filename}"`, 'child', '<', stdinPipeName, '>', stdoutPipeName];

  const child = spawn(`"${process.execPath}"`, args, { shell: true });

  child.on('exit', common.mustCall(function(exitCode) {
    stdinPipeServer.close();
    stdoutPipeServer.close();
    assert.strictEqual(exitCode, 0);
  }));
} else {
  // child
  process.stdin.pipe(process.stdout);
}
                                                                                                                                                 node-23.7.0/test/parallel/test-sqlite-custom-functions.js                                           0000664 0000000 0000000 00000026561 14746647661 0023474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('node:assert');
const { DatabaseSync } = require('node:sqlite');
const { suite, test } = require('node:test');

suite('DatabaseSync.prototype.function()', () => {
  suite('input validation', () => {
    const db = new DatabaseSync(':memory:');

    test('throws if name is not a string', () => {
      assert.throws(() => {
        db.function();
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "name" argument must be a string/,
      });
    });

    test('throws if function is not a function', () => {
      assert.throws(() => {
        db.function('foo');
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "function" argument must be a function/,
      });
    });

    test('throws if options is not an object', () => {
      assert.throws(() => {
        db.function('foo', null, () => {});
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "options" argument must be an object/,
      });
    });

    test('throws if options.useBigIntArguments is not a boolean', () => {
      assert.throws(() => {
        db.function('foo', { useBigIntArguments: null }, () => {});
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "options\.useBigIntArguments" argument must be a boolean/,
      });
    });

    test('throws if options.varargs is not a boolean', () => {
      assert.throws(() => {
        db.function('foo', { varargs: null }, () => {});
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "options\.varargs" argument must be a boolean/,
      });
    });

    test('throws if options.deterministic is not a boolean', () => {
      assert.throws(() => {
        db.function('foo', { deterministic: null }, () => {});
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "options\.deterministic" argument must be a boolean/,
      });
    });

    test('throws if options.directOnly is not a boolean', () => {
      assert.throws(() => {
        db.function('foo', { directOnly: null }, () => {});
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "options\.directOnly" argument must be a boolean/,
      });
    });
  });

  suite('useBigIntArguments', () => {
    test('converts arguments to BigInts when true', () => {
      const db = new DatabaseSync(':memory:');
      let value;
      const r = db.function('custom', { useBigIntArguments: true }, (arg) => {
        value = arg;
      });
      assert.strictEqual(r, undefined);
      db.prepare('SELECT custom(5) AS custom').get();
      assert.strictEqual(value, 5n);
    });

    test('uses number primitives when false', () => {
      const db = new DatabaseSync(':memory:');
      let value;
      const r = db.function('custom', { useBigIntArguments: false }, (arg) => {
        value = arg;
      });
      assert.strictEqual(r, undefined);
      db.prepare('SELECT custom(5) AS custom').get();
      assert.strictEqual(value, 5);
    });

    test('defaults to false', () => {
      const db = new DatabaseSync(':memory:');
      let value;
      const r = db.function('custom', (arg) => {
        value = arg;
      });
      assert.strictEqual(r, undefined);
      db.prepare('SELECT custom(5) AS custom').get();
      assert.strictEqual(value, 5);
    });

    test('throws if value cannot fit in a number', () => {
      const db = new DatabaseSync(':memory:');
      const value = Number.MAX_SAFE_INTEGER + 1;
      db.function('custom', (arg) => {});
      assert.throws(() => {
        db.prepare(`SELECT custom(${value}) AS custom`).get();
      }, {
        code: 'ERR_OUT_OF_RANGE',
        message: /Value is too large to be represented as a JavaScript number: 9007199254740992/,
      });
    });
  });

  suite('varargs', () => {
    test('supports variable number of arguments when true', () => {
      const db = new DatabaseSync(':memory:');
      let value;
      const r = db.function('custom', { varargs: true }, (...args) => {
        value = args;
      });
      assert.strictEqual(r, undefined);
      db.prepare('SELECT custom(5, 4, 3, 2, 1) AS custom').get();
      assert.deepStrictEqual(value, [5, 4, 3, 2, 1]);
    });

    test('uses function.length when false', () => {
      const db = new DatabaseSync(':memory:');
      let value;
      const r = db.function('custom', { varargs: false }, (a, b, c) => {
        value = [a, b, c];
      });
      assert.strictEqual(r, undefined);
      db.prepare('SELECT custom(1, 2, 3) AS custom').get();
      assert.deepStrictEqual(value, [1, 2, 3]);
    });

    test('defaults to false', () => {
      const db = new DatabaseSync(':memory:');
      let value;
      const r = db.function('custom', (a, b, c) => {
        value = [a, b, c];
      });
      assert.strictEqual(r, undefined);
      db.prepare('SELECT custom(7, 8, 9) AS custom').get();
      assert.deepStrictEqual(value, [7, 8, 9]);
    });

    test('throws if an incorrect number of arguments is provided', () => {
      const db = new DatabaseSync(':memory:');
      db.function('custom', (a, b, c, d) => {});
      assert.throws(() => {
        db.prepare('SELECT custom(1, 2, 3) AS custom').get();
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /wrong number of arguments to function custom\(\)/,
      });
    });
  });

  suite('deterministic', () => {
    test('creates a deterministic function when true', () => {
      const db = new DatabaseSync(':memory:');
      db.function('isDeterministic', { deterministic: true }, () => {
        return 42;
      });
      const r = db.exec(`
        CREATE TABLE t1 (
          a INTEGER PRIMARY KEY,
          b INTEGER GENERATED ALWAYS AS (isDeterministic()) VIRTUAL
        )
      `);
      assert.strictEqual(r, undefined);
    });

    test('creates a non-deterministic function when false', () => {
      const db = new DatabaseSync(':memory:');
      db.function('isNonDeterministic', { deterministic: false }, () => {
        return 42;
      });
      assert.throws(() => {
        db.exec(`
          CREATE TABLE t1 (
            a INTEGER PRIMARY KEY,
            b INTEGER GENERATED ALWAYS AS (isNonDeterministic()) VIRTUAL
          )
        `);
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /non-deterministic functions prohibited in generated columns/,
      });
    });

    test('deterministic defaults to false', () => {
      const db = new DatabaseSync(':memory:');
      db.function('isNonDeterministic', () => {
        return 42;
      });
      assert.throws(() => {
        db.exec(`
          CREATE TABLE t1 (
            a INTEGER PRIMARY KEY,
            b INTEGER GENERATED ALWAYS AS (isNonDeterministic()) VIRTUAL
          )
        `);
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /non-deterministic functions prohibited in generated columns/,
      });
    });
  });

  suite('directOnly', () => {
    test('sets SQLite direct only flag when true', () => {
      const db = new DatabaseSync(':memory:');
      db.function('fn', { deterministic: true, directOnly: true }, () => {
        return 42;
      });
      assert.throws(() => {
        db.exec(`
          CREATE TABLE t1 (
            a INTEGER PRIMARY KEY,
            b INTEGER GENERATED ALWAYS AS (fn()) VIRTUAL
          )
        `);
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /unsafe use of fn\(\)/
      });
    });

    test('does not set SQLite direct only flag when false', () => {
      const db = new DatabaseSync(':memory:');
      db.function('fn', { deterministic: true, directOnly: false }, () => {
        return 42;
      });
      const r = db.exec(`
        CREATE TABLE t1 (
          a INTEGER PRIMARY KEY,
          b INTEGER GENERATED ALWAYS AS (fn()) VIRTUAL
        )
      `);
      assert.strictEqual(r, undefined);
    });

    test('directOnly defaults to false', () => {
      const db = new DatabaseSync(':memory:');
      db.function('fn', { deterministic: true }, () => {
        return 42;
      });
      const r = db.exec(`
        CREATE TABLE t1 (
          a INTEGER PRIMARY KEY,
          b INTEGER GENERATED ALWAYS AS (fn()) VIRTUAL
        )
      `);
      assert.strictEqual(r, undefined);
    });
  });

  suite('return types', () => {
    test('supported return types', () => {
      const db = new DatabaseSync(':memory:');
      db.function('retUndefined', () => {});
      db.function('retNull', () => { return null; });
      db.function('retNumber', () => { return 3; });
      db.function('retString', () => { return 'foo'; });
      db.function('retBigInt', () => { return 5n; });
      db.function('retUint8Array', () => { return new Uint8Array([1, 2, 3]); });
      const stmt = db.prepare(`SELECT
        retUndefined() AS retUndefined,
        retNull() AS retNull,
        retNumber() AS retNumber,
        retString() AS retString,
        retBigInt() AS retBigInt,
        retUint8Array() AS retUint8Array
      `);
      assert.deepStrictEqual(stmt.get(), {
        __proto__: null,
        retUndefined: null,
        retNull: null,
        retNumber: 3,
        retString: 'foo',
        retBigInt: 5,
        retUint8Array: new Uint8Array([1, 2, 3]),
      });
    });

    test('throws if returned BigInt is too large for SQLite', () => {
      const db = new DatabaseSync(':memory:');
      db.function('retBigInt', () => {
        return BigInt(Number.MAX_SAFE_INTEGER + 1);
      });
      const stmt = db.prepare('SELECT retBigInt() AS retBigInt');
      assert.throws(() => {
        stmt.get();
      }, {
        code: 'ERR_OUT_OF_RANGE',
      });
    });

    test('does not support Promise return values', () => {
      const db = new DatabaseSync(':memory:');
      db.function('retPromise', async () => {});
      const stmt = db.prepare('SELECT retPromise() AS retPromise');
      assert.throws(() => {
        stmt.get();
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /Asynchronous user-defined functions are not supported/,
      });
    });

    test('throws on unsupported return types', () => {
      const db = new DatabaseSync(':memory:');
      db.function('retFunction', () => {
        return () => {};
      });
      const stmt = db.prepare('SELECT retFunction() AS retFunction');
      assert.throws(() => {
        stmt.get();
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /Returned JavaScript value cannot be converted to a SQLite value/,
      });
    });
  });

  test('supported argument types', () => {
    const db = new DatabaseSync(':memory:');
    db.function('arguments', (i, f, s, n, b) => {
      assert.strictEqual(i, 5);
      assert.strictEqual(f, 3.14);
      assert.strictEqual(s, 'foo');
      assert.strictEqual(n, null);
      assert.deepStrictEqual(b, new Uint8Array([254]));
      return 42;
    });
    const stmt = db.prepare(
      'SELECT arguments(5, 3.14, \'foo\', null, x\'fe\') as result'
    );
    assert.deepStrictEqual(stmt.get(), { __proto__: null, result: 42 });
  });

  test('propagates thrown errors', () => {
    const db = new DatabaseSync(':memory:');
    const err = new Error('boom');
    db.function('throws', () => {
      throw err;
    });
    const stmt = db.prepare('SELECT throws()');
    assert.throws(() => {
      stmt.get();
    }, err);
  });

  test('throws if database is not open', () => {
    const db = new DatabaseSync(':memory:', { open: false });
    assert.throws(() => {
      db.function('foo', () => {});
    }, {
      code: 'ERR_INVALID_STATE',
      message: /database is not open/,
    });
  });
});
                                                                                                                                               node-23.7.0/test/parallel/test-sqlite-data-types.js                                                 0000664 0000000 0000000 00000010777 14746647661 0022231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { join } = require('node:path');
const { DatabaseSync } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

suite('data binding and mapping', () => {
  test('supported data types', (t) => {
    const u8a = new TextEncoder().encode('a☃b☃c');
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(`
      CREATE TABLE types(
        key INTEGER PRIMARY KEY,
        int INTEGER,
        double REAL,
        text TEXT,
        buf BLOB
      ) STRICT;
    `);
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO types (key, int, double, text, buf) ' +
      'VALUES (?, ?, ?, ?, ?)');
    t.assert.deepStrictEqual(
      stmt.run(1, 42, 3.14159, 'foo', u8a),
      { changes: 1, lastInsertRowid: 1 },
    );
    t.assert.deepStrictEqual(
      stmt.run(2, null, null, null, null),
      { changes: 1, lastInsertRowid: 2 }
    );
    t.assert.deepStrictEqual(
      stmt.run(3, Number(8), Number(2.718), String('bar'), Buffer.from('x☃y☃')),
      { changes: 1, lastInsertRowid: 3 },
    );
    t.assert.deepStrictEqual(
      stmt.run(4, 99n, 0xf, '', new Uint8Array()),
      { changes: 1, lastInsertRowid: 4 },
    );

    const query = db.prepare('SELECT * FROM types WHERE key = ?');
    t.assert.deepStrictEqual(query.get(1), {
      __proto__: null,
      key: 1,
      int: 42,
      double: 3.14159,
      text: 'foo',
      buf: u8a,
    });
    t.assert.deepStrictEqual(query.get(2), {
      __proto__: null,
      key: 2,
      int: null,
      double: null,
      text: null,
      buf: null,
    });
    t.assert.deepStrictEqual(query.get(3), {
      __proto__: null,
      key: 3,
      int: 8,
      double: 2.718,
      text: 'bar',
      buf: new TextEncoder().encode('x☃y☃'),
    });
    t.assert.deepStrictEqual(query.get(4), {
      __proto__: null,
      key: 4,
      int: 99,
      double: 0xf,
      text: '',
      buf: new Uint8Array(),
    });
  });

  test('unsupported data types', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);

    [
      undefined,
      () => {},
      Symbol(),
      /foo/,
      Promise.resolve(),
      new Map(),
      new Set(),
    ].forEach((val) => {
      t.assert.throws(() => {
        db.prepare('INSERT INTO types (key, val) VALUES (?, ?)').run(1, val);
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /Provided value cannot be bound to SQLite parameter 2/,
      });
    });

    t.assert.throws(() => {
      const stmt = db.prepare('INSERT INTO types (key, val) VALUES ($k, $v)');
      stmt.run({ $k: 1, $v: () => {} });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /Provided value cannot be bound to SQLite parameter 2/,
    });
  });

  test('throws when binding a BigInt that is too large', (t) => {
    const max = 9223372036854775807n; // Largest 64-bit signed integer value.
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO types (key, val) VALUES (?, ?)');
    t.assert.deepStrictEqual(
      stmt.run(1, max),
      { changes: 1, lastInsertRowid: 1 },
    );
    t.assert.throws(() => {
      stmt.run(1, max + 1n);
    }, {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /BigInt value is too large to bind/,
    });
  });

  test('statements are unbound on each call', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES (?, ?)');
    t.assert.deepStrictEqual(
      stmt.run(1, 5),
      { changes: 1, lastInsertRowid: 1 },
    );
    t.assert.deepStrictEqual(
      stmt.run(),
      { changes: 1, lastInsertRowid: 2 },
    );
    t.assert.deepStrictEqual(
      db.prepare('SELECT * FROM data ORDER BY key').all(),
      [{ __proto__: null, key: 1, val: 5 }, { __proto__: null, key: 2, val: null }],
    );
  });
});
 node-23.7.0/test/parallel/test-sqlite-database-sync.js                                              0000664 0000000 0000000 00000017463 14746647661 0022673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { existsSync } = require('node:fs');
const { join } = require('node:path');
const { DatabaseSync, StatementSync } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

suite('DatabaseSync() constructor', () => {
  test('throws if called without new', (t) => {
    t.assert.throws(() => {
      DatabaseSync();
    }, {
      code: 'ERR_CONSTRUCT_CALL_REQUIRED',
      message: /Cannot call constructor without `new`/,
    });
  });

  test('throws if database path is not a string', (t) => {
    t.assert.throws(() => {
      new DatabaseSync();
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "path" argument must be a string/,
    });
  });

  test('throws if options is provided but is not an object', (t) => {
    t.assert.throws(() => {
      new DatabaseSync('foo', null);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options" argument must be an object/,
    });
  });

  test('throws if options.open is provided but is not a boolean', (t) => {
    t.assert.throws(() => {
      new DatabaseSync('foo', { open: 5 });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options\.open" argument must be a boolean/,
    });
  });

  test('throws if options.readOnly is provided but is not a boolean', (t) => {
    t.assert.throws(() => {
      new DatabaseSync('foo', { readOnly: 5 });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options\.readOnly" argument must be a boolean/,
    });
  });

  test('is not read-only by default', (t) => {
    const dbPath = nextDb();
    const db = new DatabaseSync(dbPath);
    db.exec('CREATE TABLE foo (id INTEGER PRIMARY KEY)');
  });

  test('is read-only if readOnly is set', (t) => {
    const dbPath = nextDb();
    {
      const db = new DatabaseSync(dbPath);
      db.exec('CREATE TABLE foo (id INTEGER PRIMARY KEY)');
      db.close();
    }
    {
      const db = new DatabaseSync(dbPath, { readOnly: true });
      t.assert.throws(() => {
        db.exec('CREATE TABLE bar (id INTEGER PRIMARY KEY)');
      }, {
        code: 'ERR_SQLITE_ERROR',
        message: /attempt to write a readonly database/,
      });
    }
  });

  test('throws if options.enableForeignKeyConstraints is provided but is not a boolean', (t) => {
    t.assert.throws(() => {
      new DatabaseSync('foo', { enableForeignKeyConstraints: 5 });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options\.enableForeignKeyConstraints" argument must be a boolean/,
    });
  });

  test('enables foreign key constraints by default', (t) => {
    const dbPath = nextDb();
    const db = new DatabaseSync(dbPath);
    db.exec(`
      CREATE TABLE foo (id INTEGER PRIMARY KEY);
      CREATE TABLE bar (foo_id INTEGER REFERENCES foo(id));
    `);
    t.after(() => { db.close(); });
    t.assert.throws(() => {
      db.exec('INSERT INTO bar (foo_id) VALUES (1)');
    }, {
      code: 'ERR_SQLITE_ERROR',
      message: 'FOREIGN KEY constraint failed',
    });
  });

  test('allows disabling foreign key constraints', (t) => {
    const dbPath = nextDb();
    const db = new DatabaseSync(dbPath, { enableForeignKeyConstraints: false });
    db.exec(`
      CREATE TABLE foo (id INTEGER PRIMARY KEY);
      CREATE TABLE bar (foo_id INTEGER REFERENCES foo(id));
    `);
    t.after(() => { db.close(); });
    db.exec('INSERT INTO bar (foo_id) VALUES (1)');
  });

  test('throws if options.enableDoubleQuotedStringLiterals is provided but is not a boolean', (t) => {
    t.assert.throws(() => {
      new DatabaseSync('foo', { enableDoubleQuotedStringLiterals: 5 });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "options\.enableDoubleQuotedStringLiterals" argument must be a boolean/,
    });
  });

  test('disables double-quoted string literals by default', (t) => {
    const dbPath = nextDb();
    const db = new DatabaseSync(dbPath);
    t.after(() => { db.close(); });
    t.assert.throws(() => {
      db.exec('SELECT "foo";');
    }, {
      code: 'ERR_SQLITE_ERROR',
      message: /no such column: "foo"/,
    });
  });

  test('allows enabling double-quoted string literals', (t) => {
    const dbPath = nextDb();
    const db = new DatabaseSync(dbPath, { enableDoubleQuotedStringLiterals: true });
    t.after(() => { db.close(); });
    db.exec('SELECT "foo";');
  });
});

suite('DatabaseSync.prototype.open()', () => {
  test('opens a database connection', (t) => {
    const dbPath = nextDb();
    const db = new DatabaseSync(dbPath, { open: false });
    t.after(() => { db.close(); });

    t.assert.strictEqual(existsSync(dbPath), false);
    t.assert.strictEqual(db.open(), undefined);
    t.assert.strictEqual(existsSync(dbPath), true);
  });

  test('throws if database is already open', (t) => {
    const db = new DatabaseSync(nextDb(), { open: false });
    t.after(() => { db.close(); });

    db.open();
    t.assert.throws(() => {
      db.open();
    }, {
      code: 'ERR_INVALID_STATE',
      message: /database is already open/,
    });
  });
});

suite('DatabaseSync.prototype.close()', () => {
  test('closes an open database connection', (t) => {
    const db = new DatabaseSync(nextDb());

    t.assert.strictEqual(db.close(), undefined);
  });

  test('throws if database is not open', (t) => {
    const db = new DatabaseSync(nextDb(), { open: false });

    t.assert.throws(() => {
      db.close();
    }, {
      code: 'ERR_INVALID_STATE',
      message: /database is not open/,
    });
  });
});

suite('DatabaseSync.prototype.prepare()', () => {
  test('returns a prepared statement', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const stmt = db.prepare('CREATE TABLE webstorage(key TEXT)');
    t.assert.ok(stmt instanceof StatementSync);
  });

  test('throws if database is not open', (t) => {
    const db = new DatabaseSync(nextDb(), { open: false });

    t.assert.throws(() => {
      db.prepare();
    }, {
      code: 'ERR_INVALID_STATE',
      message: /database is not open/,
    });
  });

  test('throws if sql is not a string', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });

    t.assert.throws(() => {
      db.prepare();
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "sql" argument must be a string/,
    });
  });
});

suite('DatabaseSync.prototype.exec()', () => {
  test('executes SQL', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const result = db.exec(`
      CREATE TABLE data(
        key INTEGER PRIMARY KEY,
        val INTEGER
      ) STRICT;
      INSERT INTO data (key, val) VALUES (1, 2);
      INSERT INTO data (key, val) VALUES (8, 9);
    `);
    t.assert.strictEqual(result, undefined);
    const stmt = db.prepare('SELECT * FROM data ORDER BY key');
    t.assert.deepStrictEqual(stmt.all(), [
      { __proto__: null, key: 1, val: 2 },
      { __proto__: null, key: 8, val: 9 },
    ]);
  });

  test('reports errors from SQLite', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });

    t.assert.throws(() => {
      db.exec('CREATE TABLEEEE');
    }, {
      code: 'ERR_SQLITE_ERROR',
      message: /syntax error/,
    });
  });

  test('throws if database is not open', (t) => {
    const db = new DatabaseSync(nextDb(), { open: false });

    t.assert.throws(() => {
      db.exec();
    }, {
      code: 'ERR_INVALID_STATE',
      message: /database is not open/,
    });
  });

  test('throws if sql is not a string', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });

    t.assert.throws(() => {
      db.exec();
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "sql" argument must be a string/,
    });
  });
});
                                                                                                                                                                                                             node-23.7.0/test/parallel/test-sqlite-named-parameters.js                                           0000664 0000000 0000000 00000005003 14746647661 0023365 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { join } = require('node:path');
const { DatabaseSync } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

suite('named parameters', () => {
  test('throws on unknown named parameters', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);

    t.assert.throws(() => {
      const stmt = db.prepare('INSERT INTO types (key, val) VALUES ($k, $v)');
      stmt.run({ $k: 1, $unknown: 1 });
    }, {
      code: 'ERR_INVALID_STATE',
      message: /Unknown named parameter '\$unknown'/,
    });
  });

  test('bare named parameters are supported', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES ($k, $v)');
    stmt.run({ k: 1, v: 9 });
    t.assert.deepStrictEqual(
      db.prepare('SELECT * FROM data').get(),
      { __proto__: null, key: 1, val: 9 },
    );
  });

  test('duplicate bare named parameters are supported', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES ($k, $k)');
    stmt.run({ k: 1 });
    t.assert.deepStrictEqual(
      db.prepare('SELECT * FROM data').get(),
      { __proto__: null, key: 1, val: 1 },
    );
  });

  test('bare named parameters throw on ambiguous names', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO types (key, val) VALUES ($k, @k)');
    t.assert.throws(() => {
      stmt.run({ k: 1 });
    }, {
      code: 'ERR_INVALID_STATE',
      message: 'Cannot create bare named parameter \'k\' because of ' +
               'conflicting names \'$k\' and \'@k\'.',
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-sqlite-session.js                                                    0000664 0000000 0000000 00000042713 14746647661 0021634 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-sqlite
'use strict';
require('../common');
const {
  DatabaseSync,
  constants,
} = require('node:sqlite');
const { test, suite } = require('node:test');

/**
 * Convenience wrapper around assert.deepStrictEqual that sets a null
 * prototype to the expected object.
 */
function deepStrictEqual(t) {
  return (actual, expected, message) => {
    if (Array.isArray(expected)) {
      expected = expected.map((obj) => ({ ...obj, __proto__: null }));
    } else if (typeof expected === 'object') {
      expected = { ...expected, __proto__: null };
    }
    t.assert.deepStrictEqual(actual, expected, message);
  };
}

test('creating and applying a changeset', (t) => {
  const createDataTableSql = `
      CREATE TABLE data(
        key INTEGER PRIMARY KEY,
        value TEXT
      ) STRICT`;

  const createDatabase = () => {
    const database = new DatabaseSync(':memory:');
    database.exec(createDataTableSql);
    return database;
  };

  const databaseFrom = createDatabase();
  const session = databaseFrom.createSession();

  const select = 'SELECT * FROM data ORDER BY key';

  const insert = databaseFrom.prepare('INSERT INTO data (key, value) VALUES (?, ?)');
  insert.run(1, 'hello');
  insert.run(2, 'world');

  const databaseTo = createDatabase();

  t.assert.strictEqual(databaseTo.applyChangeset(session.changeset()), true);
  deepStrictEqual(t)(
    databaseFrom.prepare(select).all(),
    databaseTo.prepare(select).all()
  );
});

test('database.createSession() - closed database results in exception', (t) => {
  const database = new DatabaseSync(':memory:');
  database.close();
  t.assert.throws(() => {
    database.createSession();
  }, {
    name: 'Error',
    message: 'database is not open',
  });
});

test('session.changeset() - closed database results in exception', (t) => {
  const database = new DatabaseSync(':memory:');
  const session = database.createSession();
  database.close();
  t.assert.throws(() => {
    session.changeset();
  }, {
    name: 'Error',
    message: 'database is not open',
  });
});

test('database.applyChangeset() - closed database results in exception', (t) => {
  const database = new DatabaseSync(':memory:');
  const session = database.createSession();
  const changeset = session.changeset();
  database.close();
  t.assert.throws(() => {
    database.applyChangeset(changeset);
  }, {
    name: 'Error',
    message: 'database is not open',
  });
});

test('database.createSession() - use table option to track specific table', (t) => {
  const database1 = new DatabaseSync(':memory:');
  const database2 = new DatabaseSync(':memory:');

  const createData1TableSql = `CREATE TABLE data1 (
      key INTEGER PRIMARY KEY,
      value TEXT
    ) STRICT
    `;
  const createData2TableSql = `CREATE TABLE data2 (
      key INTEGER PRIMARY KEY,
      value TEXT
    ) STRICT
    `;
  database1.exec(createData1TableSql);
  database1.exec(createData2TableSql);
  database2.exec(createData1TableSql);
  database2.exec(createData2TableSql);

  const session = database1.createSession({
    table: 'data1'
  });
  const insert1 = database1.prepare('INSERT INTO data1 (key, value) VALUES (?, ?)');
  insert1.run(1, 'hello');
  insert1.run(2, 'world');
  const insert2 = database1.prepare('INSERT INTO data2 (key, value) VALUES (?, ?)');
  insert2.run(1, 'hello');
  insert2.run(2, 'world');
  const select1 = 'SELECT * FROM data1 ORDER BY key';
  const select2 = 'SELECT * FROM data2 ORDER BY key';
  t.assert.strictEqual(database2.applyChangeset(session.changeset()), true);
  deepStrictEqual(t)(
    database1.prepare(select1).all(),
    database2.prepare(select1).all());  // data1 table should be equal
  deepStrictEqual(t)(database2.prepare(select2).all(), []);  // data2 should be empty in database2
  t.assert.strictEqual(database1.prepare(select2).all().length, 2);  // data1 should have values in database1
});

suite('conflict resolution', () => {
  const createDataTableSql = `CREATE TABLE data (
      key INTEGER PRIMARY KEY,
      value TEXT UNIQUE
    ) STRICT`;

  const prepareConflict = () => {
    const database1 = new DatabaseSync(':memory:');
    const database2 = new DatabaseSync(':memory:');

    database1.exec(createDataTableSql);
    database2.exec(createDataTableSql);

    const insertSql = 'INSERT INTO data (key, value) VALUES (?, ?)';
    const session = database1.createSession();
    database1.prepare(insertSql).run(1, 'hello');
    database1.prepare(insertSql).run(2, 'foo');
    database2.prepare(insertSql).run(1, 'world');
    return {
      database2,
      changeset: session.changeset()
    };
  };

  const prepareDataConflict = () => {
    const database1 = new DatabaseSync(':memory:');
    const database2 = new DatabaseSync(':memory:');

    database1.exec(createDataTableSql);
    database2.exec(createDataTableSql);

    const insertSql = 'INSERT INTO data (key, value) VALUES (?, ?)';
    database1.prepare(insertSql).run(1, 'hello');
    database2.prepare(insertSql).run(1, 'othervalue');
    const session = database1.createSession();
    database1.prepare('UPDATE data SET value = ? WHERE key = ?').run('foo', 1);
    return {
      database2,
      changeset: session.changeset()
    };
  };

  const prepareNotFoundConflict = () => {
    const database1 = new DatabaseSync(':memory:');
    const database2 = new DatabaseSync(':memory:');

    database1.exec(createDataTableSql);
    database2.exec(createDataTableSql);

    const insertSql = 'INSERT INTO data (key, value) VALUES (?, ?)';
    database1.prepare(insertSql).run(1, 'hello');
    const session = database1.createSession();
    database1.prepare('DELETE FROM data WHERE key = 1').run();
    return {
      database2,
      changeset: session.changeset()
    };
  };

  const prepareFkConflict = () => {
    const database1 = new DatabaseSync(':memory:');
    const database2 = new DatabaseSync(':memory:');

    database1.exec(createDataTableSql);
    database2.exec(createDataTableSql);
    const fkTableSql = `CREATE TABLE other (
      key INTEGER PRIMARY KEY,
      ref REFERENCES data(key)
    )`;
    database1.exec(fkTableSql);
    database2.exec(fkTableSql);

    const insertDataSql = 'INSERT INTO data (key, value) VALUES (?, ?)';
    const insertOtherSql = 'INSERT INTO other (key, ref) VALUES (?, ?)';
    database1.prepare(insertDataSql).run(1, 'hello');
    database2.prepare(insertDataSql).run(1, 'hello');
    database1.prepare(insertOtherSql).run(1, 1);
    database2.prepare(insertOtherSql).run(1, 1);

    database1.exec('DELETE FROM other WHERE key = 1');  // So we don't get a fk violation in database1
    const session = database1.createSession();
    database1.prepare('DELETE FROM data WHERE key = 1').run(); // Changeset with fk violation
    database2.exec('PRAGMA foreign_keys = ON');  // Needs to be supported, otherwise will fail here

    return {
      database2,
      changeset: session.changeset()
    };
  };

  const prepareConstraintConflict = () => {
    const database1 = new DatabaseSync(':memory:');
    const database2 = new DatabaseSync(':memory:');

    database1.exec(createDataTableSql);
    database2.exec(createDataTableSql);

    const insertSql = 'INSERT INTO data (key, value) VALUES (?, ?)';
    const session = database1.createSession();
    database1.prepare(insertSql).run(1, 'hello');
    database2.prepare(insertSql).run(2, 'hello');  // database2 already constains hello

    return {
      database2,
      changeset: session.changeset()
    };
  };

  test('database.applyChangeset() - SQLITE_CHANGESET_CONFLICT conflict with default behavior (abort)', (t) => {
    const { database2, changeset } = prepareConflict();
    // When changeset is aborted due to a conflict, applyChangeset should return false
    t.assert.strictEqual(database2.applyChangeset(changeset), false);
    deepStrictEqual(t)(
      database2.prepare('SELECT value from data').all(),
      [{ value: 'world' }]);  // unchanged
  });

  test('database.applyChangeset() - SQLITE_CHANGESET_CONFLICT conflict handled with SQLITE_CHANGESET_ABORT', (t) => {
    const { database2, changeset } = prepareConflict();
    let conflictType = null;
    const result = database2.applyChangeset(changeset, {
      onConflict: (conflictType_) => {
        conflictType = conflictType_;
        return constants.SQLITE_CHANGESET_ABORT;
      }
    });
    // When changeset is aborted due to a conflict, applyChangeset should return false
    t.assert.strictEqual(result, false);
    t.assert.strictEqual(conflictType, constants.SQLITE_CHANGESET_CONFLICT);
    deepStrictEqual(t)(
      database2.prepare('SELECT value from data').all(),
      [{ value: 'world' }]);  // unchanged
  });

  test('database.applyChangeset() - SQLITE_CHANGESET_DATA conflict handled with SQLITE_CHANGESET_REPLACE', (t) => {
    const { database2, changeset } = prepareDataConflict();
    let conflictType = null;
    const result = database2.applyChangeset(changeset, {
      onConflict: (conflictType_) => {
        conflictType = conflictType_;
        return constants.SQLITE_CHANGESET_REPLACE;
      }
    });
    // Not aborted due to conflict, so should return true
    t.assert.strictEqual(result, true);
    t.assert.strictEqual(conflictType, constants.SQLITE_CHANGESET_DATA);
    deepStrictEqual(t)(
      database2.prepare('SELECT value from data ORDER BY key').all(),
      [{ value: 'foo' }]);  // replaced
  });

  test('database.applyChangeset() - SQLITE_CHANGESET_NOTFOUND conflict with SQLITE_CHANGESET_OMIT', (t) => {
    const { database2, changeset } = prepareNotFoundConflict();
    let conflictType = null;
    const result = database2.applyChangeset(changeset, {
      onConflict: (conflictType_) => {
        conflictType = conflictType_;
        return constants.SQLITE_CHANGESET_OMIT;
      }
    });
    // Not aborted due to conflict, so should return true
    t.assert.strictEqual(result, true);
    t.assert.strictEqual(conflictType, constants.SQLITE_CHANGESET_NOTFOUND);
    deepStrictEqual(t)(database2.prepare('SELECT value from data').all(), []);
  });

  test('database.applyChangeset() - SQLITE_CHANGESET_FOREIGN_KEY conflict', (t) => {
    const { database2, changeset } = prepareFkConflict();
    let conflictType = null;
    const result = database2.applyChangeset(changeset, {
      onConflict: (conflictType_) => {
        conflictType = conflictType_;
        return constants.SQLITE_CHANGESET_OMIT;
      }
    });
    // Not aborted due to conflict, so should return true
    t.assert.strictEqual(result, true);
    t.assert.strictEqual(conflictType, constants.SQLITE_CHANGESET_FOREIGN_KEY);
    deepStrictEqual(t)(database2.prepare('SELECT value from data').all(), []);
  });

  test('database.applyChangeset() - SQLITE_CHANGESET_CONSTRAINT conflict', (t) => {
    const { database2, changeset } = prepareConstraintConflict();
    let conflictType = null;
    const result = database2.applyChangeset(changeset, {
      onConflict: (conflictType_) => {
        conflictType = conflictType_;
        return constants.SQLITE_CHANGESET_OMIT;
      }
    });
    // Not aborted due to conflict, so should return true
    t.assert.strictEqual(result, true);
    t.assert.strictEqual(conflictType, constants.SQLITE_CHANGESET_CONSTRAINT);
    deepStrictEqual(t)(database2.prepare('SELECT key, value from data').all(), [{ key: 2, value: 'hello' }]);
  });

  test('conflict resolution handler returns invalid value', (t) => {
    const invalidHandlers = [
      () => -1,
      () => ({}),
      () => null,
      async () => constants.SQLITE_CHANGESET_ABORT,
    ];

    for (const invalidHandler of invalidHandlers) {
      const { database2, changeset } = prepareConflict();
      t.assert.throws(() => {
        database2.applyChangeset(changeset, {
          onConflict: invalidHandler
        });
      }, {
        name: 'Error',
        message: 'bad parameter or other API misuse',
        errcode: 21,
        code: 'ERR_SQLITE_ERROR'
      }, `Did not throw expected exception when using invalid onConflict handler: ${invalidHandler}`);
    }
  });

  test('conflict resolution handler throws', (t) => {
    const { database2, changeset } = prepareConflict();
    t.assert.throws(() => {
      database2.applyChangeset(changeset, {
        onConflict: () => {
          throw new Error('some error');
        }
      });
    }, {
      name: 'Error',
      message: 'some error'
    });
  });
});

test('database.createSession() - filter changes', (t) => {
  const database1 = new DatabaseSync(':memory:');
  const database2 = new DatabaseSync(':memory:');
  const createTableSql = 'CREATE TABLE data1(key INTEGER PRIMARY KEY); CREATE TABLE data2(key INTEGER PRIMARY KEY);';
  database1.exec(createTableSql);
  database2.exec(createTableSql);

  const session = database1.createSession();

  database1.exec('INSERT INTO data1 (key) VALUES (1), (2), (3)');
  database1.exec('INSERT INTO data2 (key) VALUES (1), (2), (3), (4), (5)');

  database2.applyChangeset(session.changeset(), {
    filter: (tableName) => tableName === 'data2'
  });

  const data1Rows = database2.prepare('SELECT * FROM data1').all();
  const data2Rows = database2.prepare('SELECT * FROM data2').all();

  // Expect no rows since all changes were filtered out
  t.assert.strictEqual(data1Rows.length, 0);
  // Expect 5 rows since these changes were not filtered out
  t.assert.strictEqual(data2Rows.length, 5);
});

test('database.createSession() - specify other database', (t) => {
  const database = new DatabaseSync(':memory:');
  const session = database.createSession();
  const sessionMain = database.createSession({
    db: 'main'
  });
  const sessionTest = database.createSession({
    db: 'test'
  });
  database.exec('CREATE TABLE data (key INTEGER PRIMARY KEY)');
  database.exec('INSERT INTO data (key) VALUES (1)');
  t.assert.notStrictEqual(session.changeset().length, 0);
  t.assert.notStrictEqual(sessionMain.changeset().length, 0);
  // Since this session is attached to a different database, its changeset should be empty
  t.assert.strictEqual(sessionTest.changeset().length, 0);
});

test('database.createSession() - wrong arguments', (t) => {
  const database = new DatabaseSync(':memory:');
  t.assert.throws(() => {
    database.createSession(null);
  }, {
    name: 'TypeError',
    message: 'The "options" argument must be an object.'
  });

  t.assert.throws(() => {
    database.createSession({
      table: 123
    });
  }, {
    name: 'TypeError',
    message: 'The "options.table" argument must be a string.'
  });

  t.assert.throws(() => {
    database.createSession({
      db: 123
    });
  }, {
    name: 'TypeError',
    message: 'The "options.db" argument must be a string.'
  });
});

test('database.applyChangeset() - wrong arguments', (t) => {
  const database = new DatabaseSync(':memory:');
  const session = database.createSession();
  t.assert.throws(() => {
    database.applyChangeset(null);
  }, {
    name: 'TypeError',
    message: 'The "changeset" argument must be a Uint8Array.'
  });

  t.assert.throws(() => {
    database.applyChangeset(session.changeset(), null);
  }, {
    name: 'TypeError',
    message: 'The "options" argument must be an object.'
  });

  t.assert.throws(() => {
    database.applyChangeset(session.changeset(), {
      filter: null
    }, null);
  }, {
    name: 'TypeError',
    message: 'The "options.filter" argument must be a function.'
  });

  t.assert.throws(() => {
    database.applyChangeset(session.changeset(), {
      onConflict: null
    }, null);
  }, {
    name: 'TypeError',
    message: 'The "options.onConflict" argument must be a function.'
  });
});

test('session.patchset()', (t) => {
  const database = new DatabaseSync(':memory:');
  database.exec('CREATE TABLE data(key INTEGER PRIMARY KEY, value TEXT)');

  database.exec("INSERT INTO data VALUES ('1', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.')");

  const session = database.createSession();
  database.exec("UPDATE data SET value = 'hi' WHERE key = 1");

  const patchset = session.patchset();
  const changeset = session.changeset();

  t.assert.ok(patchset instanceof Uint8Array);
  t.assert.ok(changeset instanceof Uint8Array);

  t.assert.deepStrictEqual(patchset, session.patchset());
  t.assert.deepStrictEqual(changeset, session.changeset());

  t.assert.ok(
    patchset.length < changeset.length,
    'expected patchset to be smaller than changeset');
});

test('session.close() - using session after close throws exception', (t) => {
  const database = new DatabaseSync(':memory:');
  database.exec('CREATE TABLE data(key INTEGER PRIMARY KEY, value TEXT)');

  database.exec("INSERT INTO data VALUES ('1', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.')");

  const session = database.createSession();
  database.exec("UPDATE data SET value = 'hi' WHERE key = 1");
  session.close();

  database.exec("UPDATE data SET value = 'world' WHERE key = 1");
  t.assert.throws(() => {
    session.changeset();
  }, {
    name: 'Error',
    message: 'session is not open'
  });
});

test('session.close() - after closing database throws exception', (t) => {
  const database = new DatabaseSync(':memory:');
  database.exec('CREATE TABLE data(key INTEGER PRIMARY KEY, value TEXT)');

  database.exec("INSERT INTO data VALUES ('1', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.')");

  const session = database.createSession();
  database.close();

  t.assert.throws(() => {
    session.close();
  }, {
    name: 'Error',
    message: 'database is not open'
  });
});

test('session.close() - closing twice', (t) => {
  const database = new DatabaseSync(':memory:');
  const session = database.createSession();
  session.close();

  t.assert.throws(() => {
    session.close();
  }, {
    name: 'Error',
    message: 'session is not open'
  });
});
                                                     node-23.7.0/test/parallel/test-sqlite-statement-sync.js                                             0000664 0000000 0000000 00000026076 14746647661 0023133 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { join } = require('node:path');
const { DatabaseSync, StatementSync } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

suite('StatementSync() constructor', () => {
  test('StatementSync cannot be constructed directly', (t) => {
    t.assert.throws(() => {
      new StatementSync();
    }, {
      code: 'ERR_ILLEGAL_CONSTRUCTOR',
      message: /Illegal constructor/,
    });
  });
});

suite('StatementSync.prototype.get()', () => {
  test('executes a query and returns undefined on no results', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    let stmt = db.prepare('CREATE TABLE storage(key TEXT, val TEXT)');
    t.assert.strictEqual(stmt.get(), undefined);
    stmt = db.prepare('SELECT * FROM storage');
    t.assert.strictEqual(stmt.get(), undefined);
  });

  test('executes a query and returns the first result', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    let stmt = db.prepare('CREATE TABLE storage(key TEXT, val TEXT)');
    t.assert.strictEqual(stmt.get(), undefined);
    stmt = db.prepare('INSERT INTO storage (key, val) VALUES (?, ?)');
    t.assert.strictEqual(stmt.get('key1', 'val1'), undefined);
    t.assert.strictEqual(stmt.get('key2', 'val2'), undefined);
    stmt = db.prepare('SELECT * FROM storage ORDER BY key');
    t.assert.deepStrictEqual(stmt.get(), { __proto__: null, key: 'key1', val: 'val1' });
  });

  test('executes a query that returns special columns', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const stmt = db.prepare('SELECT 1 as __proto__, 2 as constructor, 3 as toString');
    // eslint-disable-next-line no-dupe-keys
    t.assert.deepStrictEqual(stmt.get(), { __proto__: null, ['__proto__']: 1, constructor: 2, toString: 3 });
  });
});

suite('StatementSync.prototype.all()', () => {
  test('executes a query and returns an empty array on no results', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const stmt = db.prepare('CREATE TABLE storage(key TEXT, val TEXT)');
    t.assert.deepStrictEqual(stmt.all(), []);
  });

  test('executes a query and returns all results', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    let stmt = db.prepare('CREATE TABLE storage(key TEXT, val TEXT)');
    t.assert.deepStrictEqual(stmt.run(), { changes: 0, lastInsertRowid: 0 });
    stmt = db.prepare('INSERT INTO storage (key, val) VALUES (?, ?)');
    t.assert.deepStrictEqual(
      stmt.run('key1', 'val1'),
      { changes: 1, lastInsertRowid: 1 },
    );
    t.assert.deepStrictEqual(
      stmt.run('key2', 'val2'),
      { changes: 1, lastInsertRowid: 2 },
    );
    stmt = db.prepare('SELECT * FROM storage ORDER BY key');
    t.assert.deepStrictEqual(stmt.all(), [
      { __proto__: null, key: 'key1', val: 'val1' },
      { __proto__: null, key: 'key2', val: 'val2' },
    ]);
  });
});

suite('StatementSync.prototype.iterate()', () => {
  test('executes a query and returns an empty iterator on no results', (t) => {
    const db = new DatabaseSync(nextDb());
    const stmt = db.prepare('CREATE TABLE storage(key TEXT, val TEXT)');
    t.assert.deepStrictEqual(stmt.iterate().toArray(), []);
  });

  test('executes a query and returns all results', (t) => {
    const db = new DatabaseSync(nextDb());
    let stmt = db.prepare('CREATE TABLE storage(key TEXT, val TEXT)');
    t.assert.deepStrictEqual(stmt.run(), { changes: 0, lastInsertRowid: 0 });
    stmt = db.prepare('INSERT INTO storage (key, val) VALUES (?, ?)');
    t.assert.deepStrictEqual(
      stmt.run('key1', 'val1'),
      { changes: 1, lastInsertRowid: 1 },
    );
    t.assert.deepStrictEqual(
      stmt.run('key2', 'val2'),
      { changes: 1, lastInsertRowid: 2 },
    );

    const items = [
      { __proto__: null, key: 'key1', val: 'val1' },
      { __proto__: null, key: 'key2', val: 'val2' },
    ];

    stmt = db.prepare('SELECT * FROM storage ORDER BY key');
    t.assert.deepStrictEqual(stmt.iterate().toArray(), items);

    const itemsLoop = items.slice();
    for (const item of stmt.iterate()) {
      t.assert.deepStrictEqual(item, itemsLoop.shift());
    }
  });
});

suite('StatementSync.prototype.run()', () => {
  test('executes a query and returns change metadata', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(`
      CREATE TABLE storage(key TEXT, val TEXT);
      INSERT INTO storage (key, val) VALUES ('foo', 'bar');
    `);
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('SELECT * FROM storage');
    t.assert.deepStrictEqual(stmt.run(), { changes: 1, lastInsertRowid: 1 });
  });

  test('SQLite throws when trying to bind too many parameters', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES (?, ?)');
    t.assert.throws(() => {
      stmt.run(1, 2, 3);
    }, {
      code: 'ERR_SQLITE_ERROR',
      message: 'column index out of range',
      errcode: 25,
      errstr: 'column index out of range',
    });
  });

  test('SQLite defaults to NULL for unbound parameters', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER NOT NULL) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES (?, ?)');
    t.assert.throws(() => {
      stmt.run(1);
    }, {
      code: 'ERR_SQLITE_ERROR',
      message: 'NOT NULL constraint failed: data.val',
      errcode: 1299,
      errstr: 'constraint failed',
    });
  });
});

suite('StatementSync.prototype.sourceSQL', () => {
  test('equals input SQL', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const sql = 'INSERT INTO types (key, val) VALUES ($k, $v)';
    const stmt = db.prepare(sql);
    t.assert.strictEqual(stmt.sourceSQL, sql);
  });
});

suite('StatementSync.prototype.expandedSQL', () => {
  test('equals expanded SQL', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const sql = 'INSERT INTO types (key, val) VALUES ($k, ?)';
    const expanded = 'INSERT INTO types (key, val) VALUES (\'33\', \'42\')';
    const stmt = db.prepare(sql);
    t.assert.deepStrictEqual(
      stmt.run({ $k: '33' }, '42'),
      { changes: 1, lastInsertRowid: 33 },
    );
    t.assert.strictEqual(stmt.expandedSQL, expanded);
  });
});

suite('StatementSync.prototype.setReadBigInts()', () => {
  test('BigInts support can be toggled', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(`
      CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;
      INSERT INTO data (key, val) VALUES (1, 42);
    `);
    t.assert.strictEqual(setup, undefined);

    const query = db.prepare('SELECT val FROM data');
    t.assert.deepStrictEqual(query.get(), { __proto__: null, val: 42 });
    t.assert.strictEqual(query.setReadBigInts(true), undefined);
    t.assert.deepStrictEqual(query.get(), { __proto__: null, val: 42n });
    t.assert.strictEqual(query.setReadBigInts(false), undefined);
    t.assert.deepStrictEqual(query.get(), { __proto__: null, val: 42 });

    const insert = db.prepare('INSERT INTO data (key) VALUES (?)');
    t.assert.deepStrictEqual(
      insert.run(10),
      { changes: 1, lastInsertRowid: 10 },
    );
    t.assert.strictEqual(insert.setReadBigInts(true), undefined);
    t.assert.deepStrictEqual(
      insert.run(20),
      { changes: 1n, lastInsertRowid: 20n },
    );
    t.assert.strictEqual(insert.setReadBigInts(false), undefined);
    t.assert.deepStrictEqual(
      insert.run(30),
      { changes: 1, lastInsertRowid: 30 },
    );
  });

  test('throws when input is not a boolean', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE types(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO types (key, val) VALUES ($k, $v)');
    t.assert.throws(() => {
      stmt.setReadBigInts();
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "readBigInts" argument must be a boolean/,
    });
  });

  test('BigInt is required for reading large integers', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const bad = db.prepare(`SELECT ${Number.MAX_SAFE_INTEGER} + 1`);
    t.assert.throws(() => {
      bad.get();
    }, {
      code: 'ERR_OUT_OF_RANGE',
      message: /^The value of column 0 is too large.*: 9007199254740992$/,
    });
    const good = db.prepare(`SELECT ${Number.MAX_SAFE_INTEGER} + 1`);
    good.setReadBigInts(true);
    t.assert.deepStrictEqual(good.get(), {
      __proto__: null,
      [`${Number.MAX_SAFE_INTEGER} + 1`]: 2n ** 53n,
    });
  });
});

suite('StatementSync.prototype.setAllowBareNamedParameters()', () => {
  test('bare named parameter support can be toggled', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES ($k, $v)');
    t.assert.deepStrictEqual(
      stmt.run({ k: 1, v: 2 }),
      { changes: 1, lastInsertRowid: 1 },
    );
    t.assert.strictEqual(stmt.setAllowBareNamedParameters(false), undefined);
    t.assert.throws(() => {
      stmt.run({ k: 2, v: 4 });
    }, {
      code: 'ERR_INVALID_STATE',
      message: /Unknown named parameter 'k'/,
    });
    t.assert.strictEqual(stmt.setAllowBareNamedParameters(true), undefined);
    t.assert.deepStrictEqual(
      stmt.run({ k: 3, v: 6 }),
      { changes: 1, lastInsertRowid: 3 },
    );
  });

  test('throws when input is not a boolean', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(
      'CREATE TABLE data(key INTEGER PRIMARY KEY, val INTEGER) STRICT;'
    );
    t.assert.strictEqual(setup, undefined);
    const stmt = db.prepare('INSERT INTO data (key, val) VALUES ($k, $v)');
    t.assert.throws(() => {
      stmt.setAllowBareNamedParameters();
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "allowBareNamedParameters" argument must be a boolean/,
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-sqlite-transactions.js                                               0000664 0000000 0000000 00000003522 14746647661 0022654 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { join } = require('node:path');
const { DatabaseSync } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

suite('manual transactions', () => {
  test('a transaction is committed', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(`
      CREATE TABLE data(
        key INTEGER PRIMARY KEY
      ) STRICT;
    `);
    t.assert.strictEqual(setup, undefined);
    t.assert.deepStrictEqual(
      db.prepare('BEGIN').run(),
      { changes: 0, lastInsertRowid: 0 },
    );
    t.assert.deepStrictEqual(
      db.prepare('INSERT INTO data (key) VALUES (100)').run(),
      { changes: 1, lastInsertRowid: 100 },
    );
    t.assert.deepStrictEqual(
      db.prepare('COMMIT').run(),
      { changes: 1, lastInsertRowid: 100 },
    );
    t.assert.deepStrictEqual(
      db.prepare('SELECT * FROM data').all(),
      [{ __proto__: null, key: 100 }],
    );
  });

  test('a transaction is rolled back', (t) => {
    const db = new DatabaseSync(nextDb());
    t.after(() => { db.close(); });
    const setup = db.exec(`
      CREATE TABLE data(
        key INTEGER PRIMARY KEY
      ) STRICT;
    `);
    t.assert.strictEqual(setup, undefined);
    t.assert.deepStrictEqual(
      db.prepare('BEGIN').run(),
      { changes: 0, lastInsertRowid: 0 },
    );
    t.assert.deepStrictEqual(
      db.prepare('INSERT INTO data (key) VALUES (100)').run(),
      { changes: 1, lastInsertRowid: 100 },
    );
    t.assert.deepStrictEqual(
      db.prepare('ROLLBACK').run(),
      { changes: 1, lastInsertRowid: 100 },
    );
    t.assert.deepStrictEqual(db.prepare('SELECT * FROM data').all(), []);
  });
});
                                                                                                                                                                              node-23.7.0/test/parallel/test-sqlite-typed-array-and-data-view.js                                  0000664 0000000 0000000 00000003623 14746647661 0025026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const { join } = require('node:path');
const { DatabaseSync } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

const arrayBuffer = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]).buffer;
const TypedArrays = [
  ['Int8Array', Int8Array],
  ['Uint8Array', Uint8Array],
  ['Uint8ClampedArray', Uint8ClampedArray],
  ['Int16Array', Int16Array],
  ['Uint16Array', Uint16Array],
  ['Int32Array', Int32Array],
  ['Uint32Array', Uint32Array],
  ['Float32Array', Float32Array],
  ['Float64Array', Float64Array],
  ['BigInt64Array', BigInt64Array],
  ['BigUint64Array', BigUint64Array],
  ['DataView', DataView],
];

suite('StatementSync with TypedArray/DataView', () => {
  for (const [displayName, TypedArray] of TypedArrays) {
    test(displayName, (t) => {
      const db = new DatabaseSync(nextDb());
      t.after(() => { db.close(); });
      db.exec('CREATE TABLE test (data BLOB)');
      // insert
      {
        const stmt = db.prepare('INSERT INTO test VALUES (?)');
        stmt.run(new TypedArray(arrayBuffer));
      }
      // select all
      {
        const stmt = db.prepare('SELECT * FROM test');
        const row = stmt.get();
        t.assert.ok(row.data instanceof Uint8Array);
        t.assert.strictEqual(row.data.length, 8);
        t.assert.deepStrictEqual(row.data, new Uint8Array(arrayBuffer));
      }
      // query
      {
        const stmt = db.prepare('SELECT * FROM test WHERE data = ?');
        const rows = stmt.all(new TypedArray(arrayBuffer));
        t.assert.strictEqual(rows.length, 1);
        t.assert.ok(rows[0].data instanceof Uint8Array);
        t.assert.strictEqual(rows[0].data.length, 8);
        t.assert.deepStrictEqual(rows[0].data, new Uint8Array(arrayBuffer));
      }
    });
  }
});
                                                                                                             node-23.7.0/test/parallel/test-sqlite.js                                                            0000664 0000000 0000000 00000006266 14746647661 0020156 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const { spawnPromisified } = require('../common');
const tmpdir = require('../common/tmpdir');
const { join } = require('node:path');
const { DatabaseSync, constants } = require('node:sqlite');
const { suite, test } = require('node:test');
let cnt = 0;

tmpdir.refresh();

function nextDb() {
  return join(tmpdir.path, `database-${cnt++}.db`);
}

suite('accessing the node:sqlite module', () => {
  test('cannot be accessed without the node: scheme', (t) => {
    t.assert.throws(() => {
      require('sqlite');
    }, {
      code: 'MODULE_NOT_FOUND',
      message: /Cannot find module 'sqlite'/,
    });
  });

  test('can be disabled with --no-experimental-sqlite flag', async (t) => {
    const {
      stdout,
      stderr,
      code,
      signal,
    } = await spawnPromisified(process.execPath, [
      '--no-experimental-sqlite',
      '-e',
      'require("node:sqlite")',
    ]);

    t.assert.strictEqual(stdout, '');
    t.assert.match(stderr, /No such built-in module: node:sqlite/);
    t.assert.notStrictEqual(code, 0);
    t.assert.strictEqual(signal, null);
  });
});

test('ERR_SQLITE_ERROR is thrown for errors originating from SQLite', (t) => {
  const db = new DatabaseSync(nextDb());
  t.after(() => { db.close(); });
  const setup = db.exec(`
    CREATE TABLE test(
      key INTEGER PRIMARY KEY
    ) STRICT;
  `);
  t.assert.strictEqual(setup, undefined);
  const stmt = db.prepare('INSERT INTO test (key) VALUES (?)');
  t.assert.deepStrictEqual(stmt.run(1), { changes: 1, lastInsertRowid: 1 });
  t.assert.throws(() => {
    stmt.run(1);
  }, {
    code: 'ERR_SQLITE_ERROR',
    message: 'UNIQUE constraint failed: test.key',
    errcode: 1555,
    errstr: 'constraint failed',
  });
});

test('in-memory databases are supported', (t) => {
  const db1 = new DatabaseSync(':memory:');
  const db2 = new DatabaseSync(':memory:');
  const setup1 = db1.exec(`
    CREATE TABLE data(key INTEGER PRIMARY KEY);
    INSERT INTO data (key) VALUES (1);
  `);
  const setup2 = db2.exec(`
    CREATE TABLE data(key INTEGER PRIMARY KEY);
    INSERT INTO data (key) VALUES (1);
  `);
  t.assert.strictEqual(setup1, undefined);
  t.assert.strictEqual(setup2, undefined);
  t.assert.deepStrictEqual(
    db1.prepare('SELECT * FROM data').all(),
    [{ __proto__: null, key: 1 }]
  );
  t.assert.deepStrictEqual(
    db2.prepare('SELECT * FROM data').all(),
    [{ __proto__: null, key: 1 }]
  );
});

test('sqlite constants are defined', (t) => {
  t.assert.strictEqual(constants.SQLITE_CHANGESET_OMIT, 0);
  t.assert.strictEqual(constants.SQLITE_CHANGESET_REPLACE, 1);
  t.assert.strictEqual(constants.SQLITE_CHANGESET_ABORT, 2);
});

test('PRAGMAs are supported', (t) => {
  const db = new DatabaseSync(nextDb());
  t.after(() => { db.close(); });
  t.assert.deepStrictEqual(
    db.prepare('PRAGMA journal_mode = WAL').get(),
    { __proto__: null, journal_mode: 'wal' },
  );
  t.assert.deepStrictEqual(
    db.prepare('PRAGMA journal_mode').get(),
    { __proto__: null, journal_mode: 'wal' },
  );
});

test('math functions are enabled', (t) => {
  const db = new DatabaseSync(':memory:');
  t.assert.deepStrictEqual(
    db.prepare('SELECT PI() AS pi').get(),
    { __proto__: null, pi: 3.141592653589793 },
  );
});
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-stack-size-limit.js                                                  0000664 0000000 0000000 00000001603 14746647661 0022034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const assert = require('assert');
const { spawnSync } = require('child_process');

// The default --stack-size is 984, which is below Windows' default stack size
// limit of 1 MiB. However, even a slight increase would cause node to exceed
// the 1 MiB limit and thus to crash with the exit code STATUS_STACK_OVERFLOW.
// Newer versions of Node.js allow the stack size to grow to up to 8 MiB, which
// better aligns with default limits on other platforms and which is commonly
// used for browsers on Windows.
// See https://github.com/nodejs/node/issues/43630.

const { status, signal, stderr } = spawnSync(process.execPath, [
  '--stack-size=2000',
  '-e',
  '(function explode() { return explode(); })()',
], {
  encoding: 'utf8'
});

assert.strictEqual(status, 1);
assert.strictEqual(signal, null);
assert.match(stderr, /Maximum call stack size exceeded/);
                                                                                                                             node-23.7.0/test/parallel/test-startup-empty-regexp-statics.js                                      0000664 0000000 0000000 00000006427 14746647661 0024452 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (common.isInsideDirWithUnusualChars) {
  common.skip('expected failure');
}

const assert = require('node:assert');
const { spawnSync, spawn } = require('node:child_process');

assert.strictEqual(RegExp.$_, '');
assert.strictEqual(RegExp.$0, undefined);
assert.strictEqual(RegExp.$1, '');
assert.strictEqual(RegExp.$2, '');
assert.strictEqual(RegExp.$3, '');
assert.strictEqual(RegExp.$4, '');
assert.strictEqual(RegExp.$5, '');
assert.strictEqual(RegExp.$6, '');
assert.strictEqual(RegExp.$7, '');
assert.strictEqual(RegExp.$8, '');
assert.strictEqual(RegExp.$9, '');
assert.strictEqual(RegExp.input, '');
assert.strictEqual(RegExp.lastMatch, '');
assert.strictEqual(RegExp.lastParen, '');
assert.strictEqual(RegExp.leftContext, '');
assert.strictEqual(RegExp.rightContext, '');
assert.strictEqual(RegExp['$&'], '');
assert.strictEqual(RegExp['$`'], '');
assert.strictEqual(RegExp['$+'], '');
assert.strictEqual(RegExp["$'"], '');

const allRegExpStatics =
    'RegExp.$_ + RegExp["$&"] + RegExp["$`"] + RegExp["$+"] + RegExp["$\'"] + ' +
    'RegExp.input + RegExp.lastMatch + RegExp.lastParen + ' +
    'RegExp.leftContext + RegExp.rightContext + ' +
    Array.from({ length: 10 }, (_, i) => `RegExp.$${i}`).join(' + ');

{
  const child = spawnSync(process.execPath,
                          [ '-p', allRegExpStatics ],
                          { stdio: ['inherit', 'pipe', 'inherit'] });
  assert.match(child.stdout.toString(), /^undefined\r?\n$/);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
}

{
  const child = spawnSync(process.execPath,
                          [ '--expose-internals', '-p', `const {
                            SideEffectFreeRegExpPrototypeExec,
                            SideEffectFreeRegExpPrototypeSymbolReplace,
                            SideEffectFreeRegExpPrototypeSymbolSplit,
                          } = require("internal/util");
                          SideEffectFreeRegExpPrototypeExec(/foo/, "foo");
                          SideEffectFreeRegExpPrototypeSymbolReplace(/o/, "foo", "a");
                          SideEffectFreeRegExpPrototypeSymbolSplit(/o/, "foo");
                          ${allRegExpStatics}` ],
                          { stdio: ['inherit', 'pipe', 'inherit'] });
  assert.match(child.stdout.toString(), /^undefined\r?\n$/);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
}

{
  const child = spawnSync(process.execPath,
                          [ '-e', `console.log(${allRegExpStatics})`, '--input-type=module' ],
                          { stdio: ['inherit', 'pipe', 'inherit'] });
  assert.match(child.stdout.toString(), /^undefined\r?\n$/);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
}

if (!common.isInsideDirWithUnusualChars) {
  const child = spawn(process.execPath, [], { stdio: ['pipe', 'pipe', 'inherit'], encoding: 'utf8' });

  let stdout = '';
  child.stdout.on('data', (chunk) => {
    stdout += chunk;
  });

  child.on('exit', common.mustCall((status, signal) => {
    assert.match(stdout, /^undefined\r?\n$/);
    assert.strictEqual(status, 0);
    assert.strictEqual(signal, null);
  }));
  child.on('error', common.mustNotCall());

  child.stdin.end(`console.log(${allRegExpStatics});\n`);
}
                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-startup-empty-regexp-statics.mjs                                     0000664 0000000 0000000 00000002066 14746647661 0024622 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // We must load the CJS version here because the ESM wrapper call `hasIPv6`
// which compiles a RegEx.
// eslint-disable-next-line node-core/require-common-first
import common from '../common/index.js';
import assert from 'node:assert';

if (!common.isInsideDirWithUnusualChars) {
  assert.strictEqual(RegExp.$_, '');
  assert.strictEqual(RegExp.$0, undefined);
  assert.strictEqual(RegExp.$1, '');
  assert.strictEqual(RegExp.$2, '');
  assert.strictEqual(RegExp.$3, '');
  assert.strictEqual(RegExp.$4, '');
  assert.strictEqual(RegExp.$5, '');
  assert.strictEqual(RegExp.$6, '');
  assert.strictEqual(RegExp.$7, '');
  assert.strictEqual(RegExp.$8, '');
  assert.strictEqual(RegExp.$9, '');
  assert.strictEqual(RegExp.input, '');
  assert.strictEqual(RegExp.lastMatch, '');
  assert.strictEqual(RegExp.lastParen, '');
  assert.strictEqual(RegExp.leftContext, '');
  assert.strictEqual(RegExp.rightContext, '');
  assert.strictEqual(RegExp['$&'], '');
  assert.strictEqual(RegExp['$`'], '');
  assert.strictEqual(RegExp['$+'], '');
  assert.strictEqual(RegExp["$'"], '');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-startup-large-pages.js                                               0000664 0000000 0000000 00000002032 14746647661 0022527 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Make sure that Node.js runs correctly with the --use-largepages option.

require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');

{
  const child = spawnSync(process.execPath,
                          [ '--use-largepages=on', '-p', '42' ],
                          { stdio: ['inherit', 'pipe', 'inherit'] });
  const stdout = child.stdout.toString().match(/\S+/g);
  assert.strictEqual(child.status, 0);
  assert.strictEqual(child.signal, null);
  assert.strictEqual(stdout.length, 1);
  assert.strictEqual(stdout[0], '42');
}

{
  const child = spawnSync(process.execPath,
                          [ '--use-largepages=xyzzy', '-p', '42' ]);
  assert.strictEqual(child.status, 9);
  assert.strictEqual(child.signal, null);
  assert.match(child.stderr.toString().trim(),
               /invalid value for --use-largepages$/);
}

// TODO(gabrielschulhof): Make assertions about the stderr, which may or may not
// contain a message indicating that mapping to large pages has failed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stdin-child-proc.js                                                  0000664 0000000 0000000 00000000772 14746647661 0022014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// This tests that pausing and resuming stdin does not hang and timeout
// when done in a child process.  See test/parallel/test-stdin-pause-resume.js
const common = require('../common');
const assert = require('assert');
const child_process = require('child_process');
const path = require('path');
const cp = child_process.spawn(
  process.execPath,
  [path.resolve(__dirname, 'test-stdin-pause-resume.js')]
);

cp.on('exit', common.mustCall((code) => {
  assert.strictEqual(code, 0);
}));
      node-23.7.0/test/parallel/test-stdin-from-file-spawn.js                                             0000664 0000000 0000000 00000003170 14746647661 0022771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const process = require('process');

let defaultShell;
if (process.platform === 'linux' || process.platform === 'darwin') {
  defaultShell = '/bin/sh';
} else if (process.platform === 'win32') {
  defaultShell = 'cmd.exe';
} else {
  common.skip('This is test exists only on Linux/Win32/macOS');
}

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const tmpdir = require('../common/tmpdir');

const tmpDir = tmpdir.path;
tmpdir.refresh();
const tmpCmdFile = path.join(tmpDir, 'test-stdin-from-file-spawn-cmd');
const tmpJsFile = path.join(tmpDir, 'test-stdin-from-file-spawn.js');
fs.writeFileSync(tmpCmdFile, 'echo hello');
fs.writeFileSync(tmpJsFile, `
'use strict';
const { spawn } = require('child_process');
// Reference the object to invoke the getter
process.stdin;
setTimeout(() => {
  let ok = false;
  const child = spawn(process.env.SHELL || '${defaultShell}',
    [], { stdio: ['inherit', 'pipe'] });
  child.stdout.on('data', () => {
    ok = true;
  });
  child.on('close', () => {
    process.exit(ok ? 0 : -1);
  });
}, 100);
`);

// The execPath might contain chars that should be escaped in a shell context.
// On non-Windows, we can pass the path via the env; `"` is not a valid char on
// Windows, so we can simply pass the path.
execSync(
  `"${common.isWindows ? process.execPath : '$NODE'}" "${
    common.isWindows ? tmpJsFile : '$FILE'}" < "${common.isWindows ? tmpCmdFile : '$CMD_FILE'}"`,
  common.isWindows ? undefined : {
    env: { ...process.env, NODE: process.execPath, FILE: tmpJsFile, CMD_FILE: tmpCmdFile },
  },
);
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stdin-from-file.js                                                   0000664 0000000 0000000 00000001347 14746647661 0021647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const childProcess = require('child_process');
const fs = require('fs');

const stdoutScript = fixtures.path('echo-close-check.js');
const tmpFile = tmpdir.resolve('stdin.txt');
const string = fixtures.utf8TestText;

tmpdir.refresh();

fs.writeFileSync(tmpFile, string);

childProcess.exec(...common.escapePOSIXShell`"${process.argv0}" "${stdoutScript}" < "${tmpFile}"`, common.mustCall(function(err, stdout, stderr) {
  fs.unlinkSync(tmpFile);

  assert.ifError(err);
  assert.strictEqual(stdout, `hello world\r\n${string}`);
  assert.strictEqual(stderr, '');
}));
                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stdin-hang.js                                                        0000664 0000000 0000000 00000002656 14746647661 0020710 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');

// This test *only* verifies that invoking the stdin getter does not
// cause node to hang indefinitely.
// If it does, then the test-runner will nuke it.

// invoke the getter.
process.stdin; // eslint-disable-line no-unused-expressions

console.error('Should exit normally now.');
                                                                                  node-23.7.0/test/parallel/test-stdin-pause-resume-sync.js                                           0000664 0000000 0000000 00000002670 14746647661 0023354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
console.error('before opening stdin');
process.stdin.resume();
console.error('stdin opened');
console.error('pausing stdin');
process.stdin.pause();
console.error('opening again');
process.stdin.resume();
console.error('pausing again');
process.stdin.pause();
console.error('should exit now');
                                                                        node-23.7.0/test/parallel/test-stdin-pause-resume.js                                                0000664 0000000 0000000 00000003077 14746647661 0022404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
console.error('before opening stdin');
process.stdin.resume();
console.error('stdin opened');
setTimeout(function() {
  console.error('pausing stdin');
  process.stdin.pause();
  setTimeout(function() {
    console.error('opening again');
    process.stdin.resume();
    setTimeout(function() {
      console.error('pausing again');
      process.stdin.pause();
      console.error('should exit now');
    }, 1);
  }, 1);
}, 1);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stdin-pipe-large.js                                                  0000664 0000000 0000000 00000001150 14746647661 0022004 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// See https://github.com/nodejs/node/issues/5927

const common = require('../common');
const assert = require('assert');
const spawn = require('child_process').spawn;

if (process.argv[2] === 'child') {
  process.stdin.pipe(process.stdout);
  return;
}

const child = spawn(process.execPath, [__filename, 'child'], { stdio: 'pipe' });

const expectedBytes = 1024 * 1024;
let readBytes = 0;

child.stdin.end(Buffer.alloc(expectedBytes));

child.stdout.on('data', (chunk) => readBytes += chunk.length);
child.stdout.on('end', common.mustCall(() => {
  assert.strictEqual(readBytes, expectedBytes);
}));
                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stdin-pipe-resume.js                                                 0000664 0000000 0000000 00000001371 14746647661 0022217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// This tests that piping stdin will cause it to resume() as well.
require('../common');
const assert = require('assert');

if (process.argv[2] === 'child') {
  process.stdin.pipe(process.stdout);
} else {
  const spawn = require('child_process').spawn;
  const buffers = [];
  const child = spawn(process.execPath, [__filename, 'child']);
  child.stdout.on('data', function(c) {
    buffers.push(c);
  });
  child.stdout.on('close', function() {
    const b = Buffer.concat(buffers).toString();
    assert.strictEqual(b, 'Hello, world\n');
    console.log('ok');
  });
  child.stdin.write('Hel');
  child.stdin.write('lo,');
  child.stdin.write(' wo');
  setTimeout(function() {
    child.stdin.write('rld\n');
    child.stdin.end();
  }, 10);
}
                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stdin-resume-pause.js                                                0000664 0000000 0000000 00000002301 14746647661 0022371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
process.stdin.resume();
process.stdin.pause();
                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stdin-script-child-option.js                                         0000664 0000000 0000000 00000000775 14746647661 0023666 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const expected = '--option-to-be-seen-on-child';

const { spawn } = require('child_process');
const child = spawn(process.execPath, ['-', expected], { stdio: 'pipe' });

child.stdin.end('console.log(process.argv[2])');

let actual = '';
child.stdout.setEncoding('utf8');
child.stdout.on('data', (chunk) => actual += chunk);
child.stdout.on('end', common.mustCall(() => {
  assert.strictEqual(actual.trim(), expected);
}));
   node-23.7.0/test/parallel/test-stdin-script-child.js                                                0000664 0000000 0000000 00000001434 14746647661 0022351 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { spawn } = require('child_process');
for (const args of [[], ['-']]) {
  const child = spawn(process.execPath, args, {
    env: { ...process.env,
           NODE_DEBUG: process.argv[2] }
  });
  const wanted = `${child.pid}\n`;
  let found = '';

  child.stdout.setEncoding('utf8');
  child.stdout.on('data', function(c) {
    found += c;
  });

  child.stderr.setEncoding('utf8');
  child.stderr.on('data', function(c) {
    console.error(`> ${c.trim().split('\n').join('\n> ')}`);
  });

  child.on('close', common.mustCall(function(c) {
    assert.strictEqual(c, 0);
    assert.strictEqual(found, wanted);
  }));

  setTimeout(function() {
    child.stdin.end('console.log(process.pid)');
  }, 1);
}
                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-stdio-closed.js                                                      0000664 0000000 0000000 00000002200 14746647661 0021226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const spawn = require('child_process').spawn;
const fs = require('fs');
const fixtures = require('../common/fixtures');

if (common.isWindows) {
  if (process.argv[2] === 'child') {
    /* eslint-disable no-unused-expressions */
    process.stdin;
    process.stdout;
    process.stderr;
    return;
    /* eslint-enable no-unused-expressions */
  }
  const python = process.env.PYTHON || 'python';
  const script = fixtures.path('spawn_closed_stdio.py');
  const proc = spawn(python, [script, process.execPath, __filename, 'child']);
  proc.on('exit', common.mustCall(function(exitCode) {
    assert.strictEqual(exitCode, 0);
  }));
  return;
}

if (process.argv[2] === 'child') {
  [0, 1, 2].forEach((i) => fs.fstatSync(i));
  return;
}

// Run the script in a shell but close stdout and stderr.
const [cmd, opts] = common.escapePOSIXShell`"${process.execPath}" "${__filename}" child 1>&- 2>&-`;
const proc = spawn('/bin/sh', ['-c', cmd], { ...opts, stdio: 'inherit' });

proc.on('exit', common.mustCall(function(exitCode) {
  assert.strictEqual(exitCode, 0);
}));
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stdio-pipe-access.js                                                 0000664 0000000 0000000 00000002211 14746647661 0022153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip("Workers don't have process-like stdio");
}

// Test if Node handles accessing process.stdin if it is a redirected
// pipe without deadlocking
const { spawn, spawnSync } = require('child_process');

const numTries = 5;
const who = process.argv.length <= 2 ? 'runner' : process.argv[2];

switch (who) {
  case 'runner':
    for (let num = 0; num < numTries; ++num) {
      spawnSync(process.argv0,
                [process.argv[1], 'parent'],
                { 'stdio': 'inherit' });
    }
    break;
  case 'parent': {
    const middle = spawn(process.argv0,
                         [process.argv[1], 'middle'],
                         { 'stdio': 'pipe' });
    middle.stdout.on('data', () => {});
    break;
  }
  case 'middle':
    spawn(process.argv0,
          [process.argv[1], 'bottom'],
          { 'stdio': [ process.stdin,
                       process.stdout,
                       process.stderr ] });
    break;
  case 'bottom':
    process.stdin; // eslint-disable-line no-unused-expressions
    break;
}
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stdio-pipe-redirect.js                                               0000664 0000000 0000000 00000002237 14746647661 0022523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip("Workers don't have process-like stdio");
}

// Test if Node handles redirecting one child process stdout to another
// process stdin without crashing.
const spawn = require('child_process').spawn;

const writeSize = 100;
const totalDots = 10000;

const who = process.argv.length <= 2 ? 'parent' : process.argv[2];

switch (who) {
  case 'parent': {
    const consumer = spawn(process.argv0, [process.argv[1], 'consumer'], {
      stdio: ['pipe', 'ignore', 'inherit'],
    });
    const producer = spawn(process.argv0, [process.argv[1], 'producer'], {
      stdio: ['pipe', consumer.stdin, 'inherit'],
    });
    process.stdin.on('data', () => {});
    producer.on('exit', process.exit);
    break;
  }
  case 'producer': {
    const buffer = Buffer.alloc(writeSize, '.');
    let written = 0;
    const write = () => {
      if (written < totalDots) {
        written += writeSize;
        process.stdout.write(buffer, write);
      }
    };
    write();
    break;
  }
  case 'consumer':
    process.stdin.on('data', () => {});
    break;
}
                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stdio-pipe-stderr.js                                                 0000664 0000000 0000000 00000002201 14746647661 0022214 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const fs = require('fs');
const { spawnSync } = require('child_process');

// Test that invoking node with require, and piping stderr to file,
// does not result in exception,
// see: https://github.com/nodejs/node/issues/11257

tmpdir.refresh();
const fakeModulePath = tmpdir.resolve('batman.js');
const stderrOutputPath = tmpdir.resolve('stderr-output.txt');
// We need to redirect stderr to a file to produce #11257
const stream = fs.createWriteStream(stderrOutputPath);

// The error described in #11257 only happens when we require a
// non-built-in module.
fs.writeFileSync(fakeModulePath, '', 'utf8');

stream.on('open', () => {
  spawnSync(process.execPath, {
    input: `require(${JSON.stringify(fakeModulePath)})`,
    stdio: ['pipe', 'pipe', stream]
  });
  const stderr = fs.readFileSync(stderrOutputPath, 'utf8').trim();
  assert.strictEqual(
    stderr,
    '',
    `piping stderr to file should not result in exception: ${stderr}`
  );
  stream.end();
  fs.unlinkSync(stderrOutputPath);
  fs.unlinkSync(fakeModulePath);
});
                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stdio-undestroy.js                                                   0000664 0000000 0000000 00000001700 14746647661 0022015 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const spawn = require('child_process').spawn;

if (process.argv[2] === 'child') {
  process.stdout.destroy();
  process.stderr.destroy();
  console.log('stdout');
  process.stdout.write('rocks\n');
  console.error('stderr');
  setTimeout(function() {
    process.stderr.write('rocks too\n');
  }, 10);
  return;
}

const proc = spawn(process.execPath, [__filename, 'child'], { stdio: 'pipe' });

let stdout = '';
proc.stdout.setEncoding('utf8');
proc.stdout.on('data', common.mustCallAtLeast(function(chunk) {
  stdout += chunk;
}, 1));

let stderr = '';
proc.stderr.setEncoding('utf8');
proc.stderr.on('data', common.mustCallAtLeast(function(chunk) {
  stderr += chunk;
}, 1));

proc.on('exit', common.mustCall(function(exitCode) {
  assert.strictEqual(exitCode, 0);
  assert.strictEqual(stdout, 'stdout\nrocks\n');
  assert.strictEqual(stderr, 'stderr\nrocks too\n');
}));
                                                                node-23.7.0/test/parallel/test-stdout-cannot-be-closed-child-process-pipe.js                        0000664 0000000 0000000 00000001260 14746647661 0026767 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

if (process.argv[2] === 'child')
  process.stdout.end('foo');
else
  parent();

function parent() {
  const spawn = require('child_process').spawn;
  const child = spawn(process.execPath, [__filename, 'child']);
  let out = '';
  let err = '';

  child.stdout.setEncoding('utf8');
  child.stderr.setEncoding('utf8');

  child.stdout.on('data', function(c) {
    out += c;
  });
  child.stderr.on('data', function(c) {
    err += c;
  });

  child.on('close', function(code, signal) {
    assert.strictEqual(code, 0);
    assert.strictEqual(err, '');
    assert.strictEqual(out, 'foo');
    console.log('ok');
  });
}
                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stdout-close-catch.js                                                0000664 0000000 0000000 00000001460 14746647661 0022351 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const child_process = require('child_process');
const fixtures = require('../common/fixtures');
const { getSystemErrorName } = require('util');

const testScript = fixtures.path('catch-stdout-error.js');

const child = child_process.exec(
  ...common.escapePOSIXShell`"${process.execPath}" "${testScript}" | "${process.execPath}" -pe "process.stdin.on('data' , () => process.exit(1))"`
);
let output = '';

child.stderr.on('data', function(c) {
  output += c;
});


child.on('close', common.mustCall(function(code) {
  output = JSON.parse(output);

  assert.strictEqual(output.code, 'EPIPE');
  assert.strictEqual(getSystemErrorName(output.errno), 'EPIPE');
  assert.strictEqual(output.syscall, 'write');
  console.log('ok');
}));
                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stdout-close-unref.js                                                0000664 0000000 0000000 00000003402 14746647661 0022404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const spawn = require('child_process').spawn;

if (process.argv[2] === 'child') {
  process.stdin.resume();
  process.stdin._handle.close();
  process.stdin._handle.unref();  // Should not segfault.
  process.stdin.on('error', common.mustCall());
  return;
}

// Use spawn so that we can be sure that stdin has a _handle property.
// Refs: https://github.com/nodejs/node/pull/5916
const proc = spawn(process.execPath, [__filename, 'child'], { stdio: 'pipe' });

proc.stderr.pipe(process.stderr);
proc.on('exit', common.mustCall(function(exitCode) {
  if (exitCode !== 0)
    process.exitCode = exitCode;
}));
                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stdout-pipeline-destroy.js                                           0000664 0000000 0000000 00000001102 14746647661 0023451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Transform, Readable, pipeline } = require('stream');
const assert = require('assert');

const reader = new Readable({
  read(size) { this.push('foo'); }
});

let count = 0;

const err = new Error('this-error-gets-hidden');

const transform = new Transform({
  transform(chunk, enc, cb) {
    if (count++ >= 5)
      this.emit('error', err);
    else
      cb(null, count.toString() + '\n');
  }
});

pipeline(
  reader,
  transform,
  process.stdout,
  common.mustCall((e) => {
    assert.strictEqual(e, err);
  })
);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stdout-stderr-reading.js                                             0000664 0000000 0000000 00000003307 14746647661 0023100 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

// Verify that stdout is never read from.
const net = require('net');
const read = net.Socket.prototype.read;

net.Socket.prototype.read = function() {
  if (this.fd === 1)
    throw new Error('reading from stdout!');
  if (this.fd === 2)
    throw new Error('reading from stderr!');
  return read.apply(this, arguments);
};

if (process.argv[2] === 'child')
  child();
else
  parent();

function parent() {
  const spawn = require('child_process').spawn;
  const node = process.execPath;

  const c1 = spawn(node, [__filename, 'child']);
  let c1out = '';
  c1.stdout.setEncoding('utf8');
  c1.stdout.on('data', function(chunk) {
    c1out += chunk;
  });
  c1.stderr.setEncoding('utf8');
  c1.stderr.on('data', function(chunk) {
    console.error(`c1err: ${chunk.split('\n').join('\nc1err: ')}`);
  });
  c1.on('close', common.mustCall(function(code, signal) {
    assert(!code);
    assert(!signal);
    assert.strictEqual(c1out, 'ok\n');
    console.log('ok');
  }));

  const c2 = spawn(node, ['-e', 'console.log("ok")']);
  let c2out = '';
  c2.stdout.setEncoding('utf8');
  c2.stdout.on('data', function(chunk) {
    c2out += chunk;
  });
  c1.stderr.setEncoding('utf8');
  c1.stderr.on('data', function(chunk) {
    console.error(`c1err: ${chunk.split('\n').join('\nc1err: ')}`);
  });
  c2.on('close', common.mustCall(function(code, signal) {
    assert(!code);
    assert(!signal);
    assert.strictEqual(c2out, 'ok\n');
    console.log('ok');
  }));
}

function child() {
  // Should not be reading *ever* in here.
  net.Socket.prototype.read = function() {
    throw new Error('no reading allowed in child');
  };
  console.log('ok');
}
                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stdout-stderr-write.js                                               0000664 0000000 0000000 00000000343 14746647661 0022616 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

// https://github.com/nodejs/node/pull/39246
assert.strictEqual(process.stderr.write('asd'), true);
assert.strictEqual(process.stdout.write('asd'), true);
                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stdout-to-file.js                                                    0000664 0000000 0000000 00000002273 14746647661 0021526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const childProcess = require('child_process');
const fs = require('fs');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');

const scriptString = fixtures.path('print-chars.js');
const scriptBuffer = fixtures.path('print-chars-from-buffer.js');
const tmpFile = tmpdir.resolve('stdout.txt');

tmpdir.refresh();

function test(size, useBuffer, cb) {
  try {
    fs.unlinkSync(tmpFile);
  } catch {
    // Continue regardless of error.
  }

  console.log(`${size} chars to ${tmpFile}...`);

  childProcess.exec(...common.escapePOSIXShell`"${
    process.execPath}" "${useBuffer ? scriptBuffer : scriptString}" ${size} > "${tmpFile
  }"`, common.mustSucceed(() => {
    console.log('done!');

    const stat = fs.statSync(tmpFile);

    console.log(`${tmpFile} has ${stat.size} bytes`);

    assert.strictEqual(size, stat.size);
    fs.unlinkSync(tmpFile);

    cb();
  }));
}

test(1024 * 1024, false, common.mustCall(function() {
  console.log('Done printing with string');
  test(1024 * 1024, true, common.mustCall(function() {
    console.log('Done printing with buffer');
  }));
}));
                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-strace-openat-openssl.js                                             0000664 0000000 0000000 00000003257 14746647661 0023100 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { spawn, spawnSync } = require('node:child_process');
const { createInterface } = require('node:readline');
const assert = require('node:assert');

if (!common.hasCrypto)
  common.skip('missing crypto');
if (!common.isLinux)
  common.skip('linux only');
if (common.isASan)
  common.skip('strace does not work well with address sanitizer builds');
if (spawnSync('strace').error !== undefined) {
  common.skip('missing strace');
}

{
  const allowedOpenCalls = new Set([
    '/etc/ssl/openssl.cnf',
  ]);
  const strace = spawn('strace', [
    '-f', '-ff',
    '-e', 'trace=open,openat',
    '-s', '512',
    '-D', process.execPath, '-e', 'require("crypto")',
  ]);

  // stderr is the default for strace
  const rl = createInterface({ input: strace.stderr });
  rl.on('line', (line) => {
    if (!line.startsWith('open')) {
      return;
    }

    const file = line.match(/"(.*?)"/)[1];
    // skip .so reading attempt
    if (file.match(/.+\.so(\.?)/) !== null) {
      return;
    }
    // skip /proc/*
    if (file.match(/\/proc\/.+/) !== null) {
      return;
    }

    assert(allowedOpenCalls.delete(file), `${file} is not in the list of allowed openat calls`);
  });
  const debugOutput = [];
  strace.stderr.setEncoding('utf8');
  strace.stderr.on('data', (chunk) => {
    debugOutput.push(chunk.toString());
  });
  strace.on('error', common.mustNotCall());
  strace.on('exit', common.mustCall((code) => {
    assert.strictEqual(code, 0, debugOutput);
    const missingKeys = Array.from(allowedOpenCalls.keys());
    if (missingKeys.length) {
      assert.fail(`The following openat call are missing: ${missingKeys.join(',')}`);
    }
  }));
}
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stream-add-abort-signal.js                                           0000664 0000000 0000000 00000001145 14746647661 0023245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

require('../common');
const assert = require('assert');
const { addAbortSignal, Readable } = require('stream');
const {
  addAbortSignalNoValidate,
} = require('internal/streams/add-abort-signal');

{
  assert.throws(() => {
    addAbortSignal('INVALID_SIGNAL');
  }, /ERR_INVALID_ARG_TYPE/);

  const ac = new AbortController();
  assert.throws(() => {
    addAbortSignal(ac.signal, 'INVALID_STREAM');
  }, /ERR_INVALID_ARG_TYPE/);
}

{
  const r = new Readable({
    read: () => {},
  });
  assert.deepStrictEqual(r, addAbortSignalNoValidate('INVALID_SIGNAL', r));
}
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-aliases-legacy.js                                             0000664 0000000 0000000 00000000763 14746647661 0023025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const assert = require('assert');
const stream = require('stream');

// Verify that all individual aliases are left in place.

assert.strictEqual(stream.Readable, require('_stream_readable'));
assert.strictEqual(stream.Writable, require('_stream_writable'));
assert.strictEqual(stream.Duplex, require('_stream_duplex'));
assert.strictEqual(stream.Transform, require('_stream_transform'));
assert.strictEqual(stream.PassThrough, require('_stream_passthrough'));
             node-23.7.0/test/parallel/test-stream-auto-destroy.js                                               0000664 0000000 0000000 00000003503 14746647661 0022574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');
const assert = require('assert');

{
  const r = new stream.Readable({
    autoDestroy: true,
    read() {
      this.push('hello');
      this.push('world');
      this.push(null);
    },
    destroy: common.mustCall((err, cb) => cb())
  });

  let ended = false;

  r.resume();

  r.on('end', common.mustCall(() => {
    ended = true;
  }));

  r.on('close', common.mustCall(() => {
    assert(ended);
  }));
}

{
  const w = new stream.Writable({
    autoDestroy: true,
    write(data, enc, cb) {
      cb(null);
    },
    destroy: common.mustCall((err, cb) => cb())
  });

  let finished = false;

  w.write('hello');
  w.write('world');
  w.end();

  w.on('finish', common.mustCall(() => {
    finished = true;
  }));

  w.on('close', common.mustCall(() => {
    assert(finished);
  }));
}

{
  const t = new stream.Transform({
    autoDestroy: true,
    transform(data, enc, cb) {
      cb(null, data);
    },
    destroy: common.mustCall((err, cb) => cb())
  });

  let ended = false;
  let finished = false;

  t.write('hello');
  t.write('world');
  t.end();

  t.resume();

  t.on('end', common.mustCall(() => {
    ended = true;
  }));

  t.on('finish', common.mustCall(() => {
    finished = true;
  }));

  t.on('close', common.mustCall(() => {
    assert(ended);
    assert(finished);
  }));
}

{
  const r = new stream.Readable({
    read() {
      r2.emit('error', new Error('fail'));
    }
  });
  const r2 = new stream.Readable({
    autoDestroy: true,
    destroy: common.mustCall((err, cb) => cb())
  });

  r.pipe(r2);
}

{
  const r = new stream.Readable({
    read() {
      w.emit('error', new Error('fail'));
    }
  });
  const w = new stream.Writable({
    autoDestroy: true,
    destroy: common.mustCall((err, cb) => cb())
  });

  r.pipe(w);
}
                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-await-drain-writers-in-synchronously-recursion-write.js       0000664 0000000 0000000 00000001000 14746647661 0032520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { PassThrough } = require('stream');

const encode = new PassThrough({
  highWaterMark: 1
});

const decode = new PassThrough({
  highWaterMark: 1
});

const send = common.mustCall((buf) => {
  encode.write(buf);
}, 4);

let i = 0;
const onData = common.mustCall(() => {
  if (++i === 2) {
    send(Buffer.from([0x3]));
    send(Buffer.from([0x4]));
  }
}, 4);

encode.pipe(decode).on('data', onData);

send(Buffer.from([0x1]));
send(Buffer.from([0x2]));
node-23.7.0/test/parallel/test-stream-backpressure.js                                               0000664 0000000 0000000 00000001571 14746647661 0022631 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const stream = require('stream');

let pushes = 0;
const total = 65500 + 40 * 1024;
const rs = new stream.Readable({
  read: common.mustCall(function() {
    if (pushes++ === 10) {
      this.push(null);
      return;
    }

    const length = this._readableState.length;

    // We are at most doing two full runs of _reads
    // before stopping, because Readable is greedy
    // to keep its buffer full
    assert(length <= total);

    this.push(Buffer.alloc(65500));
    for (let i = 0; i < 40; i++) {
      this.push(Buffer.alloc(1024));
    }

    // We will be over highWaterMark at this point
    // but a new call to _read is scheduled anyway.
  }, 11)
});

const ws = stream.Writable({
  write: common.mustCall(function(data, enc, cb) {
    setImmediate(cb);
  }, 41 * 10)
});

rs.pipe(ws);
                                                                                                                                       node-23.7.0/test/parallel/test-stream-base-prototype-accessors-enumerability.js                     0000664 0000000 0000000 00000001352 14746647661 0027744 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

require('../common');

// This tests that the prototype accessors added by StreamBase::AddMethods
// are not enumerable. They could be enumerated when inspecting the prototype
// with util.inspect or the inspector protocol.

const assert = require('assert');

// Or anything that calls StreamBase::AddMethods when setting up its prototype
const { internalBinding } = require('internal/test/binding');
const TTY = internalBinding('tty_wrap').TTY;

{
  const ttyIsEnumerable = Object.prototype.propertyIsEnumerable.bind(TTY);
  assert.strictEqual(ttyIsEnumerable('bytesRead'), false);
  assert.strictEqual(ttyIsEnumerable('fd'), false);
  assert.strictEqual(ttyIsEnumerable('_externalStream'), false);
}
                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-base-typechecking.js                                          0000664 0000000 0000000 00000000772 14746647661 0023527 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const net = require('net');

const server = net.createServer().listen(0, common.mustCall(() => {
  const client = net.connect(server.address().port, common.mustCall(() => {
    assert.throws(() => {
      client.write('broken', 'buffer');
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'Second argument must be a buffer'
    });
    client.destroy();
    server.close();
  }));
}));
      node-23.7.0/test/parallel/test-stream-big-packet.js                                                 0000664 0000000 0000000 00000004530 14746647661 0022144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const stream = require('stream');

let passed = false;

class TestStream extends stream.Transform {
  _transform(chunk, encoding, done) {
    // Char 'a' only exists in the last write
    passed ||= chunk.toString().includes('a');
    done();
  }
}

const s1 = new stream.Transform({
  transform(chunk, encoding, cb) {
    process.nextTick(cb, null, chunk);
  }
});
const s2 = new stream.PassThrough();
const s3 = new TestStream();
s1.pipe(s3);
// Don't let s2 auto close which may close s3
s2.pipe(s3, { end: false });

// We must write a buffer larger than highWaterMark
const big = Buffer.alloc(s1.writableHighWaterMark + 1, 'x');

// Since big is larger than highWaterMark, it will be buffered internally.
assert(!s1.write(big));
// 'tiny' is small enough to pass through internal buffer.
assert(s2.write('tiny'));

// Write some small data in next IO loop, which will never be written to s3
// Because 'drain' event is not emitted from s1 and s1 is still paused
setImmediate(s1.write.bind(s1), 'later');

// Assert after two IO loops when all operations have been done.
process.on('exit', function() {
  assert(passed, 'Large buffer is not handled properly by Writable Stream');
});
                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-big-push.js                                                   0000664 0000000 0000000 00000004445 14746647661 0021661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');
const stream = require('stream');
const str = 'asdfasdfasdfasdfasdf';

const r = new stream.Readable({
  highWaterMark: 5,
  encoding: 'utf8'
});

let reads = 0;

function _read() {
  if (reads === 0) {
    setTimeout(() => {
      r.push(str);
    }, 1);
    reads++;
  } else if (reads === 1) {
    const ret = r.push(str);
    assert.strictEqual(ret, false);
    reads++;
  } else {
    r.push(null);
  }
}

r._read = common.mustCall(_read, 3);

r.on('end', common.mustCall());

// Push some data in to start.
// We've never gotten any read event at this point.
const ret = r.push(str);
// Should be false.  > hwm
assert(!ret);
let chunk = r.read();
assert.strictEqual(chunk, str);
chunk = r.read();
assert.strictEqual(chunk, null);

r.once('readable', () => {
  // This time, we'll get *all* the remaining data, because
  // it's been added synchronously, as the read WOULD take
  // us below the hwm, and so it triggered a _read() again,
  // which synchronously added more, which we then return.
  chunk = r.read();
  assert.strictEqual(chunk, str + str);

  chunk = r.read();
  assert.strictEqual(chunk, null);
});
                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-catch-rejections.js                                           0000664 0000000 0000000 00000001630 14746647661 0023361 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');
const assert = require('assert');

{
  const r = new stream.Readable({
    captureRejections: true,
    read() {
    }
  });
  r.push('hello');
  r.push('world');

  const err = new Error('kaboom');

  r.on('error', common.mustCall((_err) => {
    assert.strictEqual(err, _err);
    assert.strictEqual(r.destroyed, true);
  }));

  r.on('data', async () => {
    throw err;
  });
}

{
  const w = new stream.Writable({
    captureRejections: true,
    highWaterMark: 1,
    write(chunk, enc, cb) {
      process.nextTick(cb);
    }
  });

  const err = new Error('kaboom');

  w.write('hello', () => {
    w.write('world');
  });

  w.on('error', common.mustCall((_err) => {
    assert.strictEqual(err, _err);
    assert.strictEqual(w.destroyed, true);
  }));

  w.on('drain', common.mustCall(async () => {
    throw err;
  }, 2));
}
                                                                                                        node-23.7.0/test/parallel/test-stream-compose-operator.js                                           0000664 0000000 0000000 00000005560 14746647661 0023440 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable, Transform,
} = require('stream');
const assert = require('assert');

{
  // with async generator
  const stream = Readable.from(['a', 'b', 'c', 'd']).compose(async function *(stream) {
    let str = '';
    for await (const chunk of stream) {
      str += chunk;

      if (str.length === 2) {
        yield str;
        str = '';
      }
    }
  });
  const result = ['ab', 'cd'];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // With Transformer
  const stream = Readable.from(['a', 'b', 'c', 'd']).compose(new Transform({
    objectMode: true,
    transform: common.mustCall((chunk, encoding, callback) => {
      callback(null, chunk);
    }, 4)
  }));
  const result = ['a', 'b', 'c', 'd'];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // Throwing an error during `compose` (before waiting for data)
  const stream = Readable.from([1, 2, 3, 4, 5]).compose(async function *(stream) { // eslint-disable-line require-yield

    throw new Error('boom');
  });

  assert.rejects(async () => {
    for await (const item of stream) {
      assert.fail('should not reach here, got ' + item);
    }
  }, /boom/).then(common.mustCall());
}

{
  // Throwing an error during `compose` (when waiting for data)
  const stream = Readable.from([1, 2, 3, 4, 5]).compose(async function *(stream) {
    for await (const chunk of stream) {
      if (chunk === 3) {
        throw new Error('boom');
      }
      yield chunk;
    }
  });

  assert.rejects(
    stream.toArray(),
    /boom/,
  ).then(common.mustCall());
}

{
  // Throwing an error during `compose` (after finishing all readable data)
  const stream = Readable.from([1, 2, 3, 4, 5]).compose(async function *(stream) { // eslint-disable-line require-yield

    // eslint-disable-next-line no-unused-vars,no-empty
    for await (const chunk of stream) {
    }

    throw new Error('boom');
  });
  assert.rejects(
    stream.toArray(),
    /boom/,
  ).then(common.mustCall());
}

{
  // AbortSignal
  const ac = new AbortController();
  const stream = Readable.from([1, 2, 3, 4, 5])
    .compose(async function *(source) {
      // Should not reach here
      for await (const chunk of source) {
        yield chunk;
      }
    }, { signal: ac.signal });

  ac.abort();

  assert.rejects(async () => {
    for await (const item of stream) {
      assert.fail('should not reach here, got ' + item);
    }
  }, {
    name: 'AbortError',
  }).then(common.mustCall());
}

{
  assert.throws(
    () => Readable.from(['a']).compose(Readable.from(['b'])),
    { code: 'ERR_INVALID_ARG_VALUE' }
  );
}

{
  assert.throws(
    () => Readable.from(['a']).compose(),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}
                                                                                                                                                node-23.7.0/test/parallel/test-stream-compose.js                                                    0000664 0000000 0000000 00000026416 14746647661 0021612 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Duplex,
  Readable,
  Transform,
  Writable,
  finished,
  compose,
  PassThrough
} = require('stream');
const assert = require('assert');

{
  let res = '';
  compose(
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk + chunk);
      })
    }),
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk.toString().toUpperCase());
      })
    })
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASDASD');
  }));
}

{
  let res = '';
  compose(
    async function*(source) {
      for await (const chunk of source) {
        yield chunk + chunk;
      }
    },
    async function*(source) {
      for await (const chunk of source) {
        yield chunk.toString().toUpperCase();
      }
    }
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASDASD');
  }));
}

{
  let res = '';
  compose(
    async function*(source) {
      for await (const chunk of source) {
        yield chunk + chunk;
      }
    }
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'asdasd');
  }));
}

{
  let res = '';
  compose(
    Readable.from(['asd']),
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk.toString().toUpperCase());
      })
    })
  )
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    async function* () {
      yield 'asd';
    }(),
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk.toString().toUpperCase());
      })
    })
  )
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    new Writable({
      write: common.mustCall((chunk, encoding, callback) => {
        res += chunk;
        callback(null);
      })
    })
  )
  .end('asd')
  .on('finish', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    async function(source) {
      for await (const chunk of source) {
        res += chunk;
      }
    }
  )
  .end('asd')
  .on('finish', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res;
  compose(
    new Transform({
      objectMode: true,
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, { chunk });
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    new Transform({
      objectMode: true,
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, { chunk });
      })
    })
  )
  .end(true)
  .on('data', common.mustCall((buf) => {
    res = buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res.chunk.chunk, true);
  }));
}

{
  const _err = new Error('asd');
  compose(
    new Transform({
      objectMode: true,
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(_err);
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    new Transform({
      objectMode: true,
      transform: common.mustNotCall((chunk, encoding, callback) => {
        callback(null, { chunk });
      })
    })
  )
  .end(true)
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err, _err);
  });
}

{
  const _err = new Error('asd');
  compose(
    new Transform({
      objectMode: true,
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk);
      })
    }),
    async function*(source) { // eslint-disable-line require-yield
      let tmp = '';
      for await (const chunk of source) {
        tmp += chunk;
        throw _err;
      }
      return tmp;
    },
    new Transform({
      objectMode: true,
      transform: common.mustNotCall((chunk, encoding, callback) => {
        callback(null, { chunk });
      })
    })
  )
  .end(true)
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err, _err);
  });
}

{
  let buf = '';

  // Convert into readable Duplex.
  const s1 = compose(async function* () {
    yield 'Hello';
    yield 'World';
  }(), async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  }, async function(source) {
    for await (const chunk of source) {
      buf += chunk;
    }
  });

  assert.strictEqual(s1.writable, false);
  assert.strictEqual(s1.readable, false);

  finished(s1.resume(), common.mustCall((err) => {
    assert(!err);
    assert.strictEqual(buf, 'HELLOWORLD');
  }));
}

{
  let buf = '';
  // Convert into transform duplex.
  const s2 = compose(async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  });
  s2.end('helloworld');
  s2.resume();
  s2.on('data', (chunk) => {
    buf += chunk;
  });

  finished(s2.resume(), common.mustCall((err) => {
    assert(!err);
    assert.strictEqual(buf, 'HELLOWORLD');
  }));
}

{
  let buf = '';

  // Convert into readable Duplex.
  const s1 = compose(async function* () {
    yield 'Hello';
    yield 'World';
  }());

  // Convert into transform duplex.
  const s2 = compose(async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  });

  // Convert into writable duplex.
  const s3 = compose(async function(source) {
    for await (const chunk of source) {
      buf += chunk;
    }
  });

  const s4 = compose(s1, s2, s3);

  finished(s4, common.mustCall((err) => {
    assert(!err);
    assert.strictEqual(buf, 'HELLOWORLD');
  }));
}

{
  let buf = '';

  // Convert into readable Duplex.
  const s1 = compose(async function* () {
    yield 'Hello';
    yield 'World';
  }(), async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  }, async function(source) {
    for await (const chunk of source) {
      buf += chunk;
    }
  });

  finished(s1, common.mustCall((err) => {
    assert(!err);
    assert.strictEqual(buf, 'HELLOWORLD');
  }));
}

{
  assert.throws(
    () => compose(),
    { code: 'ERR_MISSING_ARGS' }
  );
}

{
  assert.throws(
    () => compose(new Writable(), new PassThrough()),
    { code: 'ERR_INVALID_ARG_VALUE' }
  );
}

{
  assert.throws(
    () => compose(new PassThrough(), new Readable({ read() {} }), new PassThrough()),
    { code: 'ERR_INVALID_ARG_VALUE' }
  );
}

{
  let buf = '';

  // Convert into readable Duplex.
  const s1 = compose(async function* () {
    yield 'Hello';
    yield 'World';
  }(), async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  }, async function(source) {
    for await (const chunk of source) {
      buf += chunk;
    }
    return buf;
  });

  finished(s1, common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_RETURN_VALUE');
  }));
}

{
  let buf = '';

  // Convert into readable Duplex.
  const s1 = compose('HelloWorld', async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  }, async function(source) {
    for await (const chunk of source) {
      buf += chunk;
    }
  });

  finished(s1, common.mustCall((err) => {
    assert(!err);
    assert.strictEqual(buf, 'HELLOWORLD');
  }));
}

{
  // In the new stream than should use the writeable of the first stream and readable of the last stream
  // #46829
  (async () => {
    const newStream = compose(
      new PassThrough({
        // reading FROM you in object mode or not
        readableObjectMode: false,

        // writing TO you in object mode or not
        writableObjectMode: false,
      }),
      new Transform({
        // reading FROM you in object mode or not
        readableObjectMode: true,

        // writing TO you in object mode or not
        writableObjectMode: false,
        transform: (chunk, encoding, callback) => {
          callback(null, {
            value: chunk.toString()
          });
        }
      })
    );

    assert.strictEqual(newStream.writableObjectMode, false);
    assert.strictEqual(newStream.readableObjectMode, true);

    newStream.write('Steve Rogers');
    newStream.write('On your left');

    newStream.end();

    assert.deepStrictEqual(await newStream.toArray(), [{ value: 'Steve Rogers' }, { value: 'On your left' }]);
  })().then(common.mustCall());
}

{
  // In the new stream than should use the writeable of the first stream and readable of the last stream
  // #46829
  (async () => {
    const newStream = compose(
      new PassThrough({
        // reading FROM you in object mode or not
        readableObjectMode: true,

        // writing TO you in object mode or not
        writableObjectMode: true,
      }),
      new Transform({
        // reading FROM you in object mode or not
        readableObjectMode: false,

        // writing TO you in object mode or not
        writableObjectMode: true,
        transform: (chunk, encoding, callback) => {
          callback(null, chunk.value);
        }
      })
    );

    assert.strictEqual(newStream.writableObjectMode, true);
    assert.strictEqual(newStream.readableObjectMode, false);

    newStream.write({ value: 'Steve Rogers' });
    newStream.write({ value: 'On your left' });

    newStream.end();

    assert.deepStrictEqual(await newStream.toArray(), [Buffer.from('Steve RogersOn your left')]);
  })().then(common.mustCall());
}

{
  class DuplexProcess extends Duplex {
    constructor(options) {
      super({ ...options, objectMode: true });
      this.stuff = [];
    }

    _write(message, _, callback) {
      this.stuff.push(message);
      callback();
    }

    _destroy(err, cb) {
      cb(err);
    }

    _read() {
      if (this.stuff.length) {
        this.push(this.stuff.shift());
      } else if (this.writableEnded) {
        this.push(null);
      } else {
        this._read();
      }
    }
  }

  const pass = new PassThrough({ objectMode: true });
  const duplex = new DuplexProcess();

  const composed = compose(
    pass,
    duplex
  ).on('error', () => {});

  composed.write('hello');
  composed.write('world');
  composed.end();

  composed.destroy(new Error('an unexpected error'));
  assert.strictEqual(duplex.destroyed, true);

}
                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-stream-construct.js                                                  0000664 0000000 0000000 00000013262 14746647661 0022164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Writable, Readable, Duplex } = require('stream');
const assert = require('assert');

{
  // Multiple callback.
  new Writable({
    construct: common.mustCall((callback) => {
      callback();
      callback();
    })
  }).on('error', common.expectsError({
    name: 'Error',
    code: 'ERR_MULTIPLE_CALLBACK'
  }));
}

{
  // Multiple callback.
  new Readable({
    construct: common.mustCall((callback) => {
      callback();
      callback();
    })
  }).on('error', common.expectsError({
    name: 'Error',
    code: 'ERR_MULTIPLE_CALLBACK'
  }));
}

{
  // Synchronous error.

  new Writable({
    construct: common.mustCall((callback) => {
      callback(new Error('test'));
    })
  }).on('error', common.expectsError({
    name: 'Error',
    message: 'test'
  }));
}

{
  // Synchronous error.

  new Readable({
    construct: common.mustCall((callback) => {
      callback(new Error('test'));
    })
  }).on('error', common.expectsError({
    name: 'Error',
    message: 'test'
  }));
}

{
  // Asynchronous error.

  new Writable({
    construct: common.mustCall((callback) => {
      process.nextTick(callback, new Error('test'));
    })
  }).on('error', common.expectsError({
    name: 'Error',
    message: 'test'
  }));
}

{
  // Asynchronous error.

  new Readable({
    construct: common.mustCall((callback) => {
      process.nextTick(callback, new Error('test'));
    })
  }).on('error', common.expectsError({
    name: 'Error',
    message: 'test'
  }));
}

function testDestroy(factory) {
  {
    let constructed = false;
    const s = factory({
      construct: common.mustCall((cb) => {
        constructed = true;
        process.nextTick(cb);
      })
    });
    s.on('close', common.mustCall(() => {
      assert.strictEqual(constructed, true);
    }));
    s.destroy();
  }

  {
    let constructed = false;
    const s = factory({
      construct: common.mustCall((cb) => {
        constructed = true;
        process.nextTick(cb);
      })
    });
    s.on('close', common.mustCall(() => {
      assert.strictEqual(constructed, true);
    }));
    s.destroy(null, () => {
      assert.strictEqual(constructed, true);
    });
  }

  {
    let constructed = false;
    const s = factory({
      construct: common.mustCall((cb) => {
        constructed = true;
        process.nextTick(cb);
      })
    });
    s.on('close', common.mustCall(() => {
      assert.strictEqual(constructed, true);
    }));
    s.destroy();
  }


  {
    let constructed = false;
    const s = factory({
      construct: common.mustCall((cb) => {
        constructed = true;
        process.nextTick(cb);
      })
    });
    s.on('close', common.mustCall(() => {
      assert.strictEqual(constructed, true);
    }));
    s.on('error', common.mustCall((err) => {
      assert.strictEqual(err.message, 'kaboom');
    }));
    s.destroy(new Error('kaboom'), (err) => {
      assert.strictEqual(err.message, 'kaboom');
      assert.strictEqual(constructed, true);
    });
  }

  {
    let constructed = false;
    const s = factory({
      construct: common.mustCall((cb) => {
        constructed = true;
        process.nextTick(cb);
      })
    });
    s.on('error', common.mustCall(() => {
      assert.strictEqual(constructed, true);
    }));
    s.on('close', common.mustCall(() => {
      assert.strictEqual(constructed, true);
    }));
    s.destroy(new Error());
  }
}
testDestroy((opts) => new Readable({
  read: common.mustNotCall(),
  ...opts
}));
testDestroy((opts) => new Writable({
  write: common.mustNotCall(),
  final: common.mustNotCall(),
  ...opts
}));

{
  let constructed = false;
  const r = new Readable({
    autoDestroy: true,
    construct: common.mustCall((cb) => {
      constructed = true;
      process.nextTick(cb);
    }),
    read: common.mustCall(() => {
      assert.strictEqual(constructed, true);
      r.push(null);
    })
  });
  r.on('close', common.mustCall(() => {
    assert.strictEqual(constructed, true);
  }));
  r.on('data', common.mustNotCall());
}

{
  let constructed = false;
  const w = new Writable({
    autoDestroy: true,
    construct: common.mustCall((cb) => {
      constructed = true;
      process.nextTick(cb);
    }),
    write: common.mustCall((chunk, encoding, cb) => {
      assert.strictEqual(constructed, true);
      process.nextTick(cb);
    }),
    final: common.mustCall((cb) => {
      assert.strictEqual(constructed, true);
      process.nextTick(cb);
    })
  });
  w.on('close', common.mustCall(() => {
    assert.strictEqual(constructed, true);
  }));
  w.end('data');
}

{
  let constructed = false;
  const w = new Writable({
    autoDestroy: true,
    construct: common.mustCall((cb) => {
      constructed = true;
      process.nextTick(cb);
    }),
    write: common.mustNotCall(),
    final: common.mustCall((cb) => {
      assert.strictEqual(constructed, true);
      process.nextTick(cb);
    })
  });
  w.on('close', common.mustCall(() => {
    assert.strictEqual(constructed, true);
  }));
  w.end();
}

{
  new Duplex({
    construct: common.mustCall()
  });
}

{
  // https://github.com/nodejs/node/issues/34448

  let constructed = false;
  const d = new Duplex({
    readable: false,
    construct: common.mustCall((callback) => {
      setImmediate(common.mustCall(() => {
        constructed = true;
        callback();
      }));
    }),
    write(chunk, encoding, callback) {
      callback();
    },
    read() {
      this.push(null);
    }
  });
  d.resume();
  d.end('foo');
  d.on('close', common.mustCall(() => {
    assert.strictEqual(constructed, true);
  }));
}

{
  // Construct should not cause stream to read.
  new Readable({
    construct: common.mustCall((callback) => {
      callback();
    }),
    read: common.mustNotCall()
  });
}
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-consumers.js                                                  0000664 0000000 0000000 00000013205 14746647661 0022153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings
'use strict';

const common = require('../common');
const assert = require('assert');

const {
  arrayBuffer,
  blob,
  buffer,
  text,
  json,
} = require('stream/consumers');

const {
  Readable,
  PassThrough
} = require('stream');

const {
  TransformStream,
} = require('stream/web');

const buf = Buffer.from('hellothere');
const kArrayBuffer =
  buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);

{
  const passthrough = new PassThrough();

  blob(passthrough).then(common.mustCall(async (blob) => {
    assert.strictEqual(blob.size, 10);
    assert.deepStrictEqual(await blob.arrayBuffer(), kArrayBuffer);
  }));

  passthrough.write('hello');
  setTimeout(() => passthrough.end('there'), 10);
}

{
  const passthrough = new PassThrough();

  arrayBuffer(passthrough).then(common.mustCall(async (ab) => {
    assert.strictEqual(ab.byteLength, 10);
    assert.deepStrictEqual(ab, kArrayBuffer);
  }));

  passthrough.write('hello');
  setTimeout(() => passthrough.end('there'), 10);
}

{
  const passthrough = new PassThrough();

  buffer(passthrough).then(common.mustCall(async (buf) => {
    assert.strictEqual(buf.byteLength, 10);
    assert.deepStrictEqual(buf.buffer, kArrayBuffer);
  }));

  passthrough.write('hello');
  setTimeout(() => passthrough.end('there'), 10);
}


{
  const passthrough = new PassThrough();

  text(passthrough).then(common.mustCall(async (str) => {
    assert.strictEqual(str.length, 10);
    assert.strictEqual(str, 'hellothere');
  }));

  passthrough.write('hello');
  setTimeout(() => passthrough.end('there'), 10);
}

{
  const readable = new Readable({
    read() {}
  });

  text(readable).then((data) => {
    assert.strictEqual(data, 'foo\ufffd\ufffd\ufffd');
  });

  readable.push(new Uint8Array([0x66, 0x6f, 0x6f, 0xed, 0xa0, 0x80]));
  readable.push(null);
}

{
  const passthrough = new PassThrough();

  json(passthrough).then(common.mustCall(async (str) => {
    assert.strictEqual(str.length, 10);
    assert.strictEqual(str, 'hellothere');
  }));

  passthrough.write('"hello');
  setTimeout(() => passthrough.end('there"'), 10);
}

{
  const { writable, readable } = new TransformStream();

  blob(readable).then(common.mustCall(async (blob) => {
    assert.strictEqual(blob.size, 10);
    assert.deepStrictEqual(await blob.arrayBuffer(), kArrayBuffer);
  }));

  const writer = writable.getWriter();
  writer.write('hello');
  setTimeout(() => {
    writer.write('there');
    writer.close();
  }, 10);

  assert.rejects(blob(readable), { code: 'ERR_INVALID_STATE' }).then(common.mustCall());
}

{
  const { writable, readable } = new TransformStream();

  arrayBuffer(readable).then(common.mustCall(async (ab) => {
    assert.strictEqual(ab.byteLength, 10);
    assert.deepStrictEqual(ab, kArrayBuffer);
  }));

  const writer = writable.getWriter();
  writer.write('hello');
  setTimeout(() => {
    writer.write('there');
    writer.close();
  }, 10);

  assert.rejects(arrayBuffer(readable), { code: 'ERR_INVALID_STATE' }).then(common.mustCall());
}

{
  const { writable, readable } = new TransformStream();

  text(readable).then(common.mustCall(async (str) => {
    assert.strictEqual(str.length, 10);
    assert.strictEqual(str, 'hellothere');
  }));

  const writer = writable.getWriter();
  writer.write('hello');
  setTimeout(() => {
    writer.write('there');
    writer.close();
  }, 10);

  assert.rejects(text(readable), { code: 'ERR_INVALID_STATE' }).then(common.mustCall());
}

{
  const { writable, readable } = new TransformStream();

  json(readable).then(common.mustCall(async (str) => {
    assert.strictEqual(str.length, 10);
    assert.strictEqual(str, 'hellothere');
  }));

  const writer = writable.getWriter();
  writer.write('"hello');
  setTimeout(() => {
    writer.write('there"');
    writer.close();
  }, 10);

  assert.rejects(json(readable), { code: 'ERR_INVALID_STATE' }).then(common.mustCall());
}

{
  const stream = new PassThrough({
    readableObjectMode: true,
    writableObjectMode: true,
  });

  blob(stream).then(common.mustCall((blob) => {
    assert.strictEqual(blob.size, 30);
  }));

  stream.write({});
  stream.end({});
}

{
  const stream = new PassThrough({
    readableObjectMode: true,
    writableObjectMode: true,
  });

  arrayBuffer(stream).then(common.mustCall((ab) => {
    assert.strictEqual(ab.byteLength, 30);
    assert.strictEqual(
      Buffer.from(ab).toString(),
      '[object Object][object Object]');
  }));

  stream.write({});
  stream.end({});
}

{
  const stream = new PassThrough({
    readableObjectMode: true,
    writableObjectMode: true,
  });

  buffer(stream).then(common.mustCall((buf) => {
    assert.strictEqual(buf.byteLength, 30);
    assert.strictEqual(
      buf.toString(),
      '[object Object][object Object]');
  }));

  stream.write({});
  stream.end({});
}

{
  const stream = new PassThrough({
    readableObjectMode: true,
    writableObjectMode: true,
  });

  assert.rejects(text(stream), {
    code: 'ERR_INVALID_ARG_TYPE',
  }).then(common.mustCall());

  stream.write({});
  stream.end({});
}

{
  const stream = new PassThrough({
    readableObjectMode: true,
    writableObjectMode: true,
  });

  assert.rejects(json(stream), {
    code: 'ERR_INVALID_ARG_TYPE',
  }).then(common.mustCall());

  stream.write({});
  stream.end({});
}

{
  const stream = new TransformStream();
  text(stream.readable).then(common.mustCall((str) => {
    // Incomplete utf8 character is flushed as a replacement char
    assert.strictEqual(str.charCodeAt(0), 0xfffd);
  }));
  const writer = stream.writable.getWriter();
  Promise.all([
    writer.write(new Uint8Array([0xe2])),
    writer.write(new Uint8Array([0x82])),
    writer.close(),
  ]).then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-decoder-objectmode.js                                         0000664 0000000 0000000 00000001020 14746647661 0023643 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const stream = require('stream');
const assert = require('assert');

const readable = new stream.Readable({
  read: () => {},
  encoding: 'utf16le',
  objectMode: true
});

readable.push(Buffer.from('abc', 'utf16le'));
readable.push(Buffer.from('def', 'utf16le'));
readable.push(null);

// Without object mode, these would be concatenated into a single chunk.
assert.strictEqual(readable.read(), 'abc');
assert.strictEqual(readable.read(), 'def');
assert.strictEqual(readable.read(), null);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stream-destroy-event-order.js                                        0000664 0000000 0000000 00000000633 14746647661 0024057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

const rs = new Readable({
  read() {}
});

let closed = false;
let errored = false;

rs.on('close', common.mustCall(() => {
  closed = true;
  assert(errored);
}));

rs.on('error', common.mustCall((err) => {
  errored = true;
  assert(!closed);
}));

rs.destroy(new Error('kaboom'));
                                                                                                     node-23.7.0/test/parallel/test-stream-destroy.js                                                    0000664 0000000 0000000 00000005105 14746647661 0021626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Writable,
  Readable,
  destroy
} = require('stream');
const assert = require('assert');
const http = require('http');

{
  const r = new Readable({ read() {} });
  destroy(r);
  assert.strictEqual(r.destroyed, true);
  r.on('error', common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
  r.on('close', common.mustCall());
}

{
  const r = new Readable({ read() {} });
  destroy(r, new Error('asd'));
  assert.strictEqual(r.destroyed, true);
  r.on('error', common.mustCall((err) => {
    assert.strictEqual(err.message, 'asd');
  }));
  r.on('close', common.mustCall());
}

{
  const w = new Writable({ write() {} });
  destroy(w);
  assert.strictEqual(w.destroyed, true);
  w.on('error', common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
  w.on('close', common.mustCall());
}

{
  const w = new Writable({ write() {} });
  destroy(w, new Error('asd'));
  assert.strictEqual(w.destroyed, true);
  w.on('error', common.mustCall((err) => {
    assert.strictEqual(err.message, 'asd');
  }));
  w.on('close', common.mustCall());
}

{
  const server = http.createServer((req, res) => {
    destroy(req);
    req.on('error', common.mustCall((err) => {
      assert.strictEqual(err.name, 'AbortError');
    }));
    req.on('close', common.mustCall(() => {
      res.end('hello');
    }));
  });

  server.listen(0, () => {
    const req = http.request({
      method: 'POST',
      port: server.address().port,
      agent: new http.Agent()
    });

    req.on('response', (res) => {
      const buf = [];
      res.on('data', (data) => buf.push(data));
      res.on('end', common.mustCall(() => {
        assert.deepStrictEqual(
          Buffer.concat(buf),
          Buffer.from('hello')
        );
        server.close();
      }));
    });

    req.end('asd');
  });
}

{
  const server = http.createServer((req, res) => {
    req
      .resume()
      .on('end', () => {
        destroy(req);
      })
      .on('error', common.mustNotCall());

    req.on('close', common.mustCall(() => {
      res.end('hello');
    }));
  });

  server.listen(0, () => {
    const req = http.request({
      method: 'POST',
      port: server.address().port,
      agent: new http.Agent()
    });
    req.on('response', (res) => {
      const buf = [];
      res.on('data', (data) => buf.push(data));
      res.on('end', common.mustCall(() => {
        assert.deepStrictEqual(
          Buffer.concat(buf),
          Buffer.from('hello')
        );
        server.close();
      }));
    });

    req.end('asd');
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-drop-take.js                                                  0000664 0000000 0000000 00000007272 14746647661 0022032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable,
} = require('stream');
const { deepStrictEqual, rejects, throws, strictEqual } = require('assert');

const { from } = Readable;

const fromAsync = (...args) => from(...args).map(async (x) => x);

const naturals = () => from(async function*() {
  let i = 1;
  while (true) {
    yield i++;
  }
}());

{
  // Synchronous streams
  (async () => {
    deepStrictEqual(await from([1, 2, 3]).drop(2).toArray(), [3]);
    deepStrictEqual(await from([1, 2, 3]).take(1).toArray(), [1]);
    deepStrictEqual(await from([]).drop(2).toArray(), []);
    deepStrictEqual(await from([]).take(1).toArray(), []);
    deepStrictEqual(await from([1, 2, 3]).drop(1).take(1).toArray(), [2]);
    deepStrictEqual(await from([1, 2]).drop(0).toArray(), [1, 2]);
    deepStrictEqual(await from([1, 2]).take(0).toArray(), []);
  })().then(common.mustCall());
  // Asynchronous streams
  (async () => {
    deepStrictEqual(await fromAsync([1, 2, 3]).drop(2).toArray(), [3]);
    deepStrictEqual(await fromAsync([1, 2, 3]).take(1).toArray(), [1]);
    deepStrictEqual(await fromAsync([]).drop(2).toArray(), []);
    deepStrictEqual(await fromAsync([]).take(1).toArray(), []);
    deepStrictEqual(await fromAsync([1, 2, 3]).drop(1).take(1).toArray(), [2]);
    deepStrictEqual(await fromAsync([1, 2]).drop(0).toArray(), [1, 2]);
    deepStrictEqual(await fromAsync([1, 2]).take(0).toArray(), []);
  })().then(common.mustCall());
  // Infinite streams
  // Asynchronous streams
  (async () => {
    deepStrictEqual(await naturals().take(1).toArray(), [1]);
    deepStrictEqual(await naturals().drop(1).take(1).toArray(), [2]);
    const next10 = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
    deepStrictEqual(await naturals().drop(10).take(10).toArray(), next10);
    deepStrictEqual(await naturals().take(5).take(1).toArray(), [1]);
  })().then(common.mustCall());
}


// Don't wait for next item in the original stream when already consumed the requested take amount
{
  let reached = false;
  let resolve;
  const promise = new Promise((res) => resolve = res);

  const stream = from((async function *() {
    yield 1;
    await promise;
    reached = true;
    yield 2;
  })());

  stream.take(1)
    .toArray()
    .then(common.mustCall(() => {
      strictEqual(reached, false);
    }))
    .finally(() => resolve());
}

{
  // Coercion
  (async () => {
    // The spec made me do this ^^
    deepStrictEqual(await naturals().take('cat').toArray(), []);
    deepStrictEqual(await naturals().take('2').toArray(), [1, 2]);
    deepStrictEqual(await naturals().take(true).toArray(), [1]);
  })().then(common.mustCall());
}

{
  // Support for AbortSignal
  const ac = new AbortController();
  rejects(
    Readable.from([1, 2, 3]).take(1, { signal: ac.signal }).toArray(), {
      name: 'AbortError',
    }).then(common.mustCall());
  rejects(
    Readable.from([1, 2, 3]).drop(1, { signal: ac.signal }).toArray(), {
      name: 'AbortError',
    }).then(common.mustCall());
  ac.abort();
}

{
  // Support for AbortSignal, already aborted
  const signal = AbortSignal.abort();
  rejects(
    Readable.from([1, 2, 3]).take(1, { signal }).toArray(), {
      name: 'AbortError',
    }).then(common.mustCall());
}

{
  // Error cases
  const invalidArgs = [
    -1,
    -Infinity,
    -40,
  ];

  for (const example of invalidArgs) {
    throws(() => from([]).take(example).toArray(), /ERR_OUT_OF_RANGE/);
  }

  throws(() => Readable.from([1]).drop(1, 1), /ERR_INVALID_ARG_TYPE/);
  throws(() => Readable.from([1]).drop(1, { signal: true }), /ERR_INVALID_ARG_TYPE/);

  throws(() => Readable.from([1]).take(1, 1), /ERR_INVALID_ARG_TYPE/);
  throws(() => Readable.from([1]).take(1, { signal: true }), /ERR_INVALID_ARG_TYPE/);
}
                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-duplex-destroy.js                                             0000664 0000000 0000000 00000014170 14746647661 0023127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Duplex } = require('stream');
const assert = require('assert');

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {}
  });

  duplex.resume();

  duplex.on('end', common.mustNotCall());
  duplex.on('finish', common.mustNotCall());
  duplex.on('close', common.mustCall());

  duplex.destroy();
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {}
  });
  duplex.resume();

  const expected = new Error('kaboom');

  duplex.on('end', common.mustNotCall());
  duplex.on('finish', common.mustNotCall());
  duplex.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  duplex.destroy(expected);
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {}
  });

  duplex._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, expected);
    cb(err);
  });

  const expected = new Error('kaboom');

  duplex.on('finish', common.mustNotCall('no finish event'));
  duplex.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  duplex.destroy(expected);
  assert.strictEqual(duplex.destroyed, true);
}

{
  const expected = new Error('kaboom');
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {},
    destroy: common.mustCall(function(err, cb) {
      assert.strictEqual(err, expected);
      cb();
    })
  });
  duplex.resume();

  duplex.on('end', common.mustNotCall('no end event'));
  duplex.on('finish', common.mustNotCall('no finish event'));

  // Error is swallowed by the custom _destroy
  duplex.on('error', common.mustNotCall('no error event'));
  duplex.on('close', common.mustCall());

  duplex.destroy(expected);
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {}
  });

  duplex._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb();
  });

  duplex.destroy();
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {}
  });
  duplex.resume();

  duplex._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    process.nextTick(() => {
      this.push(null);
      this.end();
      cb();
    });
  });

  const fail = common.mustNotCall('no finish or end event');

  duplex.on('finish', fail);
  duplex.on('end', fail);

  duplex.destroy();

  duplex.removeListener('end', fail);
  duplex.removeListener('finish', fail);
  duplex.on('end', common.mustNotCall());
  duplex.on('finish', common.mustNotCall());
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {}
  });

  const expected = new Error('kaboom');

  duplex._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb(expected);
  });

  duplex.on('finish', common.mustNotCall('no finish event'));
  duplex.on('end', common.mustNotCall('no end event'));
  duplex.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  duplex.destroy();
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {},
    allowHalfOpen: true
  });
  duplex.resume();

  duplex.on('finish', common.mustNotCall());
  duplex.on('end', common.mustNotCall());

  duplex.destroy();
  assert.strictEqual(duplex.destroyed, true);
}

{
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {},
  });

  duplex.destroyed = true;
  assert.strictEqual(duplex.destroyed, true);

  // The internal destroy() mechanism should not be triggered
  duplex.on('finish', common.mustNotCall());
  duplex.on('end', common.mustNotCall());
  duplex.destroy();
}

{
  function MyDuplex() {
    assert.strictEqual(this.destroyed, false);
    this.destroyed = false;
    Duplex.call(this);
  }

  Object.setPrototypeOf(MyDuplex.prototype, Duplex.prototype);
  Object.setPrototypeOf(MyDuplex, Duplex);

  new MyDuplex();
}

{
  const duplex = new Duplex({
    writable: false,
    autoDestroy: true,
    write(chunk, enc, cb) { cb(); },
    read() {},
  });
  duplex.push(null);
  duplex.resume();
  duplex.on('close', common.mustCall());
}

{
  const duplex = new Duplex({
    readable: false,
    autoDestroy: true,
    write(chunk, enc, cb) { cb(); },
    read() {},
  });
  duplex.end();
  duplex.on('close', common.mustCall());
}

{
  const duplex = new Duplex({
    allowHalfOpen: false,
    autoDestroy: true,
    write(chunk, enc, cb) { cb(); },
    read() {},
  });
  duplex.push(null);
  duplex.resume();
  const orgEnd = duplex.end;
  duplex.end = common.mustNotCall();
  duplex.on('end', () => {
    // Ensure end() is called in next tick to allow
    // any pending writes to be invoked first.
    process.nextTick(() => {
      duplex.end = common.mustCall(orgEnd);
    });
  });
  duplex.on('close', common.mustCall());
}

{
  // Check abort signal
  const controller = new AbortController();
  const { signal } = controller;
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {},
    signal,
  });
  let count = 0;
  duplex.on('error', common.mustCall((e) => {
    assert.strictEqual(count++, 0); // Ensure not called twice
    assert.strictEqual(e.name, 'AbortError');
  }));
  duplex.on('close', common.mustCall());
  controller.abort();
}

{
  const duplex = new Duplex({
    read() {},
    write(chunk, enc, cb) { cb(); }
  });

  duplex.cork();
  duplex.write('foo', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_DESTROYED');
  }));
  duplex.destroy();
}

{
  // Check Symbol.asyncDispose
  const duplex = new Duplex({
    write(chunk, enc, cb) { cb(); },
    read() {},
  });
  let count = 0;
  duplex.on('error', common.mustCall((e) => {
    assert.strictEqual(count++, 0); // Ensure not called twice
    assert.strictEqual(e.name, 'AbortError');
  }));
  duplex.on('close', common.mustCall());
  duplex[Symbol.asyncDispose]().then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-duplex-end.js                                                 0000664 0000000 0000000 00000001664 14746647661 0022210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const Duplex = require('stream').Duplex;

{
  const stream = new Duplex({
    read() {}
  });
  assert.strictEqual(stream.allowHalfOpen, true);
  stream.on('finish', common.mustNotCall());
  assert.strictEqual(stream.listenerCount('end'), 0);
  stream.resume();
  stream.push(null);
}

{
  const stream = new Duplex({
    read() {},
    allowHalfOpen: false
  });
  assert.strictEqual(stream.allowHalfOpen, false);
  stream.on('finish', common.mustCall());
  assert.strictEqual(stream.listenerCount('end'), 0);
  stream.resume();
  stream.push(null);
}

{
  const stream = new Duplex({
    read() {},
    allowHalfOpen: false
  });
  assert.strictEqual(stream.allowHalfOpen, false);
  stream._writableState.ended = true;
  stream.on('finish', common.mustNotCall());
  assert.strictEqual(stream.listenerCount('end'), 0);
  stream.resume();
  stream.push(null);
}
                                                                            node-23.7.0/test/parallel/test-stream-duplex-from.js                                                0000664 0000000 0000000 00000022253 14746647661 0022402 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Duplex, Readable, Writable, pipeline, PassThrough } = require('stream');
const { ReadableStream, WritableStream } = require('stream/web');
const { Blob } = require('buffer');

{
  const d = Duplex.from({
    readable: new Readable({
      read() {
        this.push('asd');
        this.push(null);
      }
    })
  });
  assert.strictEqual(d.readable, true);
  assert.strictEqual(d.writable, false);
  d.once('readable', common.mustCall(function() {
    assert.strictEqual(d.read().toString(), 'asd');
  }));
  d.once('end', common.mustCall(function() {
    assert.strictEqual(d.readable, false);
  }));
}

{
  const d = Duplex.from(new Readable({
    read() {
      this.push('asd');
      this.push(null);
    }
  }));
  assert.strictEqual(d.readable, true);
  assert.strictEqual(d.writable, false);
  d.once('readable', common.mustCall(function() {
    assert.strictEqual(d.read().toString(), 'asd');
  }));
  d.once('end', common.mustCall(function() {
    assert.strictEqual(d.readable, false);
  }));
}

{
  let ret = '';
  const d = Duplex.from(new Writable({
    write(chunk, encoding, callback) {
      ret += chunk;
      callback();
    }
  }));
  assert.strictEqual(d.readable, false);
  assert.strictEqual(d.writable, true);
  d.end('asd');
  d.on('finish', common.mustCall(function() {
    assert.strictEqual(d.writable, false);
    assert.strictEqual(ret, 'asd');
  }));
}

{
  let ret = '';
  const d = Duplex.from({
    writable: new Writable({
      write(chunk, encoding, callback) {
        ret += chunk;
        callback();
      }
    })
  });
  assert.strictEqual(d.readable, false);
  assert.strictEqual(d.writable, true);
  d.end('asd');
  d.on('finish', common.mustCall(function() {
    assert.strictEqual(d.writable, false);
    assert.strictEqual(ret, 'asd');
  }));
}

{
  let ret = '';
  const d = Duplex.from({
    readable: new Readable({
      read() {
        this.push('asd');
        this.push(null);
      }
    }),
    writable: new Writable({
      write(chunk, encoding, callback) {
        ret += chunk;
        callback();
      }
    })
  });
  assert.strictEqual(d.readable, true);
  assert.strictEqual(d.writable, true);
  d.once('readable', common.mustCall(function() {
    assert.strictEqual(d.read().toString(), 'asd');
  }));
  d.once('end', common.mustCall(function() {
    assert.strictEqual(d.readable, false);
  }));
  d.end('asd');
  d.once('finish', common.mustCall(function() {
    assert.strictEqual(d.writable, false);
    assert.strictEqual(ret, 'asd');
  }));
}

{
  const d = Duplex.from(Promise.resolve('asd'));
  assert.strictEqual(d.readable, true);
  assert.strictEqual(d.writable, false);
  d.once('readable', common.mustCall(function() {
    assert.strictEqual(d.read().toString(), 'asd');
  }));
  d.once('end', common.mustCall(function() {
    assert.strictEqual(d.readable, false);
  }));
}

{
  // https://github.com/nodejs/node/issues/40497
  pipeline(
    ['abc\ndef\nghi'],
    Duplex.from(async function * (source) {
      let rest = '';
      for await (const chunk of source) {
        const lines = (rest + chunk.toString()).split('\n');
        rest = lines.pop();
        for (const line of lines) {
          yield line;
        }
      }
      yield rest;
    }),
    async function * (source) { // eslint-disable-line require-yield
      let ret = '';
      for await (const x of source) {
        ret += x;
      }
      assert.strictEqual(ret, 'abcdefghi');
    },
    common.mustSucceed(),
  );
}

// Ensure that isDuplexNodeStream was called
{
  const duplex = new Duplex();
  assert.strictEqual(Duplex.from(duplex), duplex);
}

// Ensure that Duplex.from works for blobs
{
  const blob = new Blob(['blob']);
  const expectedByteLength = blob.size;
  const duplex = Duplex.from(blob);
  duplex.on('data', common.mustCall((arrayBuffer) => {
    assert.strictEqual(arrayBuffer.byteLength, expectedByteLength);
  }));
}

// Ensure that given a promise rejection it emits an error
{
  const myErrorMessage = 'myCustomError';
  Duplex.from(Promise.reject(myErrorMessage))
    .on('error', common.mustCall((error) => {
      assert.strictEqual(error, myErrorMessage);
    }));
}

// Ensure that given a promise rejection on an async function it emits an error
{
  const myErrorMessage = 'myCustomError';
  async function asyncFn() {
    return Promise.reject(myErrorMessage);
  }

  Duplex.from(asyncFn)
    .on('error', common.mustCall((error) => {
      assert.strictEqual(error, myErrorMessage);
    }));
}

// Ensure that Duplex.from throws an Invalid return value when function is void
{
  assert.throws(() => Duplex.from(() => {}), {
    code: 'ERR_INVALID_RETURN_VALUE',
  });
}

// Ensure data if a sub object has a readable stream it's duplexified
{
  const msg = Buffer.from('hello');
  const duplex = Duplex.from({
    readable: Readable({
      read() {
        this.push(msg);
        this.push(null);
      }
    })
  }).on('data', common.mustCall((data) => {
    assert.strictEqual(data, msg);
  }));

  assert.strictEqual(duplex.writable, false);
}

// Ensure data if a sub object has a writable stream it's duplexified
{
  const msg = Buffer.from('hello');
  const duplex = Duplex.from({
    writable: Writable({
      write: common.mustCall((data) => {
        assert.strictEqual(data, msg);
      })
    })
  });

  duplex.write(msg);
  assert.strictEqual(duplex.readable, false);
}

// Ensure data if a sub object has a writable and readable stream it's duplexified
{
  const msg = Buffer.from('hello');

  const duplex = Duplex.from({
    readable: Readable({
      read() {
        this.push(msg);
        this.push(null);
      }
    }),
    writable: Writable({
      write: common.mustCall((data) => {
        assert.strictEqual(data, msg);
      })
    })
  });

  duplex.pipe(duplex)
    .on('data', common.mustCall((data) => {
      assert.strictEqual(data, msg);
      assert.strictEqual(duplex.readable, true);
      assert.strictEqual(duplex.writable, true);
    }))
    .on('end', common.mustCall());
}

// Ensure that given readable stream that throws an error it calls destroy
{
  const myErrorMessage = 'error!';
  const duplex = Duplex.from(Readable({
    read() {
      throw new Error(myErrorMessage);
    }
  }));
  duplex.on('error', common.mustCall((msg) => {
    assert.strictEqual(msg.message, myErrorMessage);
  }));
}

// Ensure that given writable stream that throws an error it calls destroy
{
  const myErrorMessage = 'error!';
  const duplex = Duplex.from(Writable({
    write(chunk, enc, cb) {
      cb(myErrorMessage);
    }
  }));

  duplex.on('error', common.mustCall((msg) => {
    assert.strictEqual(msg, myErrorMessage);
  }));

  duplex.write('test');
}

{
  const through = new PassThrough({ objectMode: true });

  let res = '';
  const d = Readable.from(['foo', 'bar'], { objectMode: true })
    .pipe(Duplex.from({
      writable: through,
      readable: through
    }));

  d.on('data', (data) => {
    d.pause();
    setImmediate(() => {
      d.resume();
    });
    res += data;
  }).on('end', common.mustCall(() => {
    assert.strictEqual(res, 'foobar');
  })).on('close', common.mustCall());
}

function makeATestReadableStream(value) {
  return new ReadableStream({
    start(controller) {
      controller.enqueue(value);
      controller.close();
    }
  });
}

function makeATestWritableStream(writeFunc) {
  return new WritableStream({
    write(chunk) {
      writeFunc(chunk);
    }
  });
}

{
  const d = Duplex.from({
    readable: makeATestReadableStream('foo'),
  });
  assert.strictEqual(d.readable, true);
  assert.strictEqual(d.writable, false);

  d.on('data', common.mustCall((data) => {
    assert.strictEqual(data.toString(), 'foo');
  }));

  d.on('end', common.mustCall(() => {
    assert.strictEqual(d.readable, false);
  }));
}

{
  const d = Duplex.from(makeATestReadableStream('foo'));

  assert.strictEqual(d.readable, true);
  assert.strictEqual(d.writable, false);

  d.on('data', common.mustCall((data) => {
    assert.strictEqual(data.toString(), 'foo');
  }));

  d.on('end', common.mustCall(() => {
    assert.strictEqual(d.readable, false);
  }));
}

{
  let ret = '';
  const d = Duplex.from({
    writable: makeATestWritableStream((chunk) => ret += chunk),
  });

  assert.strictEqual(d.readable, false);
  assert.strictEqual(d.writable, true);

  d.end('foo');
  d.on('finish', common.mustCall(() => {
    assert.strictEqual(ret, 'foo');
    assert.strictEqual(d.writable, false);
  }));
}

{
  let ret = '';
  const d = Duplex.from(makeATestWritableStream((chunk) => ret += chunk));

  assert.strictEqual(d.readable, false);
  assert.strictEqual(d.writable, true);

  d.end('foo');
  d.on('finish', common.mustCall(() => {
    assert.strictEqual(ret, 'foo');
    assert.strictEqual(d.writable, false);
  }));
}

{
  let ret = '';
  const d = Duplex.from({
    readable: makeATestReadableStream('foo'),
    writable: makeATestWritableStream((chunk) => ret += chunk),
  });

  d.end('bar');

  d.on('data', common.mustCall((data) => {
    assert.strictEqual(data.toString(), 'foo');
  }));

  d.on('end', common.mustCall(() => {
    assert.strictEqual(d.readable, false);
  }));

  d.on('finish', common.mustCall(() => {
    assert.strictEqual(ret, 'bar');
    assert.strictEqual(d.writable, false);
  }));
}
                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-duplex-props.js                                               0000664 0000000 0000000 00000001367 14746647661 0022605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const { Duplex } = require('stream');

{
  const d = new Duplex({
    objectMode: true,
    highWaterMark: 100
  });

  assert.strictEqual(d.writableObjectMode, true);
  assert.strictEqual(d.writableHighWaterMark, 100);
  assert.strictEqual(d.readableObjectMode, true);
  assert.strictEqual(d.readableHighWaterMark, 100);
}

{
  const d = new Duplex({
    readableObjectMode: false,
    readableHighWaterMark: 10,
    writableObjectMode: true,
    writableHighWaterMark: 100
  });

  assert.strictEqual(d.writableObjectMode, true);
  assert.strictEqual(d.writableHighWaterMark, 100);
  assert.strictEqual(d.readableObjectMode, false);
  assert.strictEqual(d.readableHighWaterMark, 10);
}
                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-duplex-readable-end.js                                        0000664 0000000 0000000 00000001133 14746647661 0023734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// https://github.com/nodejs/node/issues/35926
const common = require('../common');
const assert = require('assert');
const stream = require('stream');

let loops = 5;

const src = new stream.Readable({
  highWaterMark: 16 * 1024,
  read() {
    if (loops--)
      this.push(Buffer.alloc(20000));
  }
});

const dst = new stream.Transform({
  highWaterMark: 16 * 1024,
  transform(chunk, output, fn) {
    this.push(null);
    fn();
  }
});

src.pipe(dst);

dst.on('data', () => { });
dst.on('end', common.mustCall(() => {
  assert.strictEqual(loops, 3);
  assert.ok(src.isPaused());
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-duplex-readable-writable.js                                   0000664 0000000 0000000 00000002127 14746647661 0025003 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Duplex } = require('stream');
const assert = require('assert');

{
  const duplex = new Duplex({
    readable: false
  });
  assert.strictEqual(duplex.readable, false);
  duplex.push('asd');
  duplex.on('error', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_PUSH_AFTER_EOF');
  }));
  duplex.on('data', common.mustNotCall());
  duplex.on('end', common.mustNotCall());
}

{
  const duplex = new Duplex({
    writable: false,
    write: common.mustNotCall()
  });
  assert.strictEqual(duplex.writable, false);
  duplex.write('asd');
  duplex.on('error', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');
  }));
  duplex.on('finish', common.mustNotCall());
}

{
  const duplex = new Duplex({
    readable: false
  });
  assert.strictEqual(duplex.readable, false);
  duplex.on('data', common.mustNotCall());
  duplex.on('end', common.mustNotCall());
  async function run() {
    for await (const chunk of duplex) {
      assert(false, chunk);
    }
  }
  run().then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-duplex-writable-finished.js                                   0000664 0000000 0000000 00000001250 14746647661 0025031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Duplex } = require('stream');
const assert = require('assert');

// basic
{
  // Find it on Duplex.prototype
  assert(Object.hasOwn(Duplex.prototype, 'writableFinished'));
}

// event
{
  const duplex = new Duplex();

  duplex._write = (chunk, encoding, cb) => {
    // The state finished should start in false.
    assert.strictEqual(duplex.writableFinished, false);
    cb();
  };

  duplex.on('finish', common.mustCall(() => {
    assert.strictEqual(duplex.writableFinished, true);
  }));

  duplex.end('testing finished state', common.mustCall(() => {
    assert.strictEqual(duplex.writableFinished, true);
  }));
}
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-duplex.js                                                     0000664 0000000 0000000 00000007073 14746647661 0021444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

const common = require('../common');
const assert = require('assert');
const Duplex = require('stream').Duplex;
const { ReadableStream, WritableStream } = require('stream/web');

const stream = new Duplex({ objectMode: true });

assert(Duplex() instanceof Duplex);
assert(stream._readableState.objectMode);
assert(stream._writableState.objectMode);
assert(stream.allowHalfOpen);
assert.strictEqual(stream.listenerCount('end'), 0);

let written;
let read;

stream._write = (obj, _, cb) => {
  written = obj;
  cb();
};

stream._read = () => {};

stream.on('data', (obj) => {
  read = obj;
});

stream.push({ val: 1 });
stream.end({ val: 2 });

process.on('exit', () => {
  assert.strictEqual(read.val, 1);
  assert.strictEqual(written.val, 2);
});

// Duplex.fromWeb
{
  const dataToRead = Buffer.from('hello');
  const dataToWrite = Buffer.from('world');

  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(dataToRead);
    },
  });

  const writable = new WritableStream({
    write: common.mustCall((chunk) => {
      assert.strictEqual(chunk, dataToWrite);
    })
  });

  const pair = { readable, writable };
  const duplex = Duplex.fromWeb(pair);

  duplex.write(dataToWrite);
  duplex.once('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, dataToRead);
  }));
}

// Duplex.fromWeb - using utf8 and objectMode
{
  const dataToRead = 'hello';
  const dataToWrite = 'world';

  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(dataToRead);
    },
  });

  const writable = new WritableStream({
    write: common.mustCall((chunk) => {
      assert.strictEqual(chunk, dataToWrite);
    })
  });

  const pair = {
    readable,
    writable
  };
  const duplex = Duplex.fromWeb(pair, { encoding: 'utf8', objectMode: true });

  duplex.write(dataToWrite);
  duplex.once('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, dataToRead);
  }));
}
// Duplex.toWeb
{
  const dataToRead = Buffer.from('hello');
  const dataToWrite = Buffer.from('world');

  const duplex = Duplex({
    read() {
      this.push(dataToRead);
      this.push(null);
    },
    write: common.mustCall((chunk) => {
      assert.strictEqual(chunk, dataToWrite);
    })
  });

  const { writable, readable } = Duplex.toWeb(duplex);
  writable.getWriter().write(dataToWrite);

  readable.getReader().read().then(common.mustCall((result) => {
    assert.deepStrictEqual(Buffer.from(result.value), dataToRead);
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-duplexpair.js                                                 0000664 0000000 0000000 00000003624 14746647661 0022316 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Duplex, duplexPair } = require('stream');

{
  const pair = duplexPair();

  assert(pair[0] instanceof Duplex);
  assert(pair[1] instanceof Duplex);
  assert.notStrictEqual(pair[0], pair[1]);
}

{
  // Verify that the iterable for array assignment works
  const [ clientSide, serverSide ] = duplexPair();
  assert(clientSide instanceof Duplex);
  assert(serverSide instanceof Duplex);
  clientSide.on(
    'data',
    common.mustCall((d) => assert.strictEqual(`${d}`, 'foo'))
  );
  clientSide.on('end', common.mustNotCall());
  serverSide.write('foo');
}

{
  const [ clientSide, serverSide ] = duplexPair();
  assert(clientSide instanceof Duplex);
  assert(serverSide instanceof Duplex);
  serverSide.on(
    'data',
    common.mustCall((d) => assert.strictEqual(`${d}`, 'foo'))
  );
  serverSide.on('end', common.mustCall());
  clientSide.end('foo');
}

{
  const [ serverSide, clientSide ] = duplexPair();
  serverSide.cork();
  serverSide.write('abc');
  serverSide.write('12');
  serverSide.end('\n');
  serverSide.uncork();
  let characters = '';
  clientSide.on('readable', function() {
    for (let segment; (segment = this.read()) !== null;)
      characters += segment;
  });
  clientSide.on('end', common.mustCall(function() {
    assert.strictEqual(characters, 'abc12\n');
  }));
}

// Test the case where the the _write never calls [kCallback]
// because a zero-size push doesn't trigger a _read
{
  const [ serverSide, clientSide ] = duplexPair();
  serverSide.write('');
  serverSide.write('12');
  serverSide.write('');
  serverSide.write('');
  serverSide.end('\n');
  let characters = '';
  clientSide.on('readable', function() {
    for (let segment; (segment = this.read()) !== null;)
      characters += segment;
  });
  clientSide.on('end', common.mustCall(function() {
    assert.strictEqual(characters, '12\n');
  }));
}
                                                                                                            node-23.7.0/test/parallel/test-stream-end-of-streams.js                                             0000664 0000000 0000000 00000000700 14746647661 0022755 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

const { Duplex, finished } = require('stream');

assert.throws(
  () => {
    // Passing empty object to mock invalid stream
    // should throw error
    finished({}, () => {});
  },
  { code: 'ERR_INVALID_ARG_TYPE' }
);

const streamObj = new Duplex();
streamObj.end();
// Below code should not throw any errors as the
// streamObj is `Stream`
finished(streamObj, () => {});
                                                                node-23.7.0/test/parallel/test-stream-end-paused.js                                                 0000664 0000000 0000000 00000003352 14746647661 0022164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');

// Make sure we don't miss the end event for paused 0-length streams

const Readable = require('stream').Readable;
const stream = new Readable();
let calledRead = false;
stream._read = function() {
  assert(!calledRead);
  calledRead = true;
  this.push(null);
};

stream.on('data', function() {
  throw new Error('should not ever get data');
});
stream.pause();

setTimeout(common.mustCall(function() {
  stream.on('end', common.mustCall());
  stream.resume();
}), 1);

process.on('exit', function() {
  assert(calledRead);
  console.log('ok');
});
                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-err-multiple-callback-construction.js                         0000664 0000000 0000000 00000001072 14746647661 0027037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');
const assert = require('assert');

class TestWritable extends stream.Writable {
  _write(_chunk, _encoding, callback) {
    callback();
  }

  _final(callback) {
    process.nextTick(callback);
    process.nextTick(callback);
  }
}

const writable = new TestWritable();

writable.on('finish', common.mustCall());
writable.on('error', common.mustCall((error) => {
  assert.strictEqual(error.message, 'Callback called multiple times');
}));

writable.write('some data');
writable.end();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-error-once.js                                                 0000664 0000000 0000000 00000000616 14746647661 0022212 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Writable, Readable } = require('stream');

{
  const writable = new Writable();
  writable.on('error', common.mustCall());
  writable.end();
  writable.write('h');
  writable.write('h');
}

{
  const readable = new Readable();
  readable.on('error', common.mustCall());
  readable.push(null);
  readable.push('h');
  readable.push('h');
}
                                                                                                                  node-23.7.0/test/parallel/test-stream-event-names.js                                                0000664 0000000 0000000 00000001726 14746647661 0022364 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const { Readable, Writable, Duplex } = require('stream');

{
  const stream = new Readable();
  assert.strictEqual(stream.eventNames().length, 0);
}

{
  const stream = new Readable();
  stream.on('foo', () => {});
  stream.on('data', () => {});
  stream.on('error', () => {});
  assert.deepStrictEqual(stream.eventNames(), ['error', 'data', 'foo']);
}

{
  const stream = new Writable();
  assert.strictEqual(stream.eventNames().length, 0);
}

{
  const stream = new Writable();
  stream.on('foo', () => {});
  stream.on('drain', () => {});
  stream.on('prefinish', () => {});
  assert.deepStrictEqual(stream.eventNames(), ['prefinish', 'drain', 'foo']);
}
{
  const stream = new Duplex();
  assert.strictEqual(stream.eventNames().length, 0);
}

{
  const stream = new Duplex();
  stream.on('foo', () => {});
  stream.on('finish', () => {});
  assert.deepStrictEqual(stream.eventNames(), ['finish', 'foo']);
}
                                          node-23.7.0/test/parallel/test-stream-events-prepend.js                                             0000664 0000000 0000000 00000000647 14746647661 0023102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');

class Writable extends stream.Writable {
  constructor() {
    super();
    this.prependListener = undefined;
  }

  _write(chunk, end, cb) {
    cb();
  }
}

class Readable extends stream.Readable {
  _read() {
    this.push(null);
  }
}

const w = new Writable();
w.on('pipe', common.mustCall());

const r = new Readable();
r.pipe(w);
                                                                                         node-23.7.0/test/parallel/test-stream-filter.js                                                     0000664 0000000 0000000 00000010375 14746647661 0021427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable,
} = require('stream');
const assert = require('assert');
const { once } = require('events');
const { setTimeout } = require('timers/promises');

{
  // Filter works on synchronous streams with a synchronous predicate
  const stream = Readable.from([1, 2, 3, 4, 5]).filter((x) => x < 3);
  const result = [1, 2];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // Filter works on synchronous streams with an asynchronous predicate
  const stream = Readable.from([1, 2, 3, 4, 5]).filter(async (x) => {
    await Promise.resolve();
    return x > 3;
  });
  const result = [4, 5];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // Map works on asynchronous streams with a asynchronous mapper
  const stream = Readable.from([1, 2, 3, 4, 5]).map(async (x) => {
    await Promise.resolve();
    return x + x;
  }).filter((x) => x > 5);
  const result = [6, 8, 10];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // Filter works on an infinite stream
  const stream = Readable.from(async function* () {
    while (true) yield 1;
  }()).filter(common.mustCall(async (x) => {
    return x < 3;
  }, 5));
  (async () => {
    let i = 1;
    for await (const item of stream) {
      assert.strictEqual(item, 1);
      if (++i === 5) break;
    }
  })().then(common.mustCall());
}

{
  // Filter works on constructor created streams
  let i = 0;
  const stream = new Readable({
    read() {
      if (i === 10) {
        this.push(null);
        return;
      }
      this.push(Uint8Array.from([i]));
      i++;
    },
    highWaterMark: 0,
  }).filter(common.mustCall(async ([x]) => {
    return x !== 5;
  }, 10));
  (async () => {
    const result = (await stream.toArray()).map((x) => x[0]);
    const expected = [...Array(10).keys()].filter((x) => x !== 5);
    assert.deepStrictEqual(result, expected);
  })().then(common.mustCall());
}

{
  // Throwing an error during `filter` (sync)
  const stream = Readable.from([1, 2, 3, 4, 5]).filter((x) => {
    if (x === 3) {
      throw new Error('boom');
    }
    return true;
  });
  assert.rejects(
    stream.map((x) => x + x).toArray(),
    /boom/,
  ).then(common.mustCall());
}

{
  // Throwing an error during `filter` (async)
  const stream = Readable.from([1, 2, 3, 4, 5]).filter(async (x) => {
    if (x === 3) {
      throw new Error('boom');
    }
    return true;
  });
  assert.rejects(
    stream.filter(() => true).toArray(),
    /boom/,
  ).then(common.mustCall());
}

{
  // Concurrency + AbortSignal
  const ac = new AbortController();
  let calls = 0;
  const stream = Readable.from([1, 2, 3, 4]).filter(async (_, { signal }) => {
    calls++;
    await once(signal, 'abort');
  }, { signal: ac.signal, concurrency: 2 });
  // pump
  assert.rejects(async () => {
    for await (const item of stream) {
      // nope
      console.log(item);
    }
  }, {
    name: 'AbortError',
  }).then(common.mustCall());

  setImmediate(() => {
    ac.abort();
    assert.strictEqual(calls, 2);
  });
}

{
  // Concurrency result order
  const stream = Readable.from([1, 2]).filter(async (item, { signal }) => {
    await setTimeout(10 - item, { signal });
    return true;
  }, { concurrency: 2 });

  (async () => {
    const expected = [1, 2];
    for await (const item of stream) {
      assert.strictEqual(item, expected.shift());
    }
  })().then(common.mustCall());
}

{
  // Error cases
  assert.throws(() => Readable.from([1]).filter(1), /ERR_INVALID_ARG_TYPE/);
  assert.throws(() => Readable.from([1]).filter((x) => x, {
    concurrency: 'Foo'
  }), /ERR_OUT_OF_RANGE/);
  assert.throws(() => Readable.from([1]).filter((x) => x, 1), /ERR_INVALID_ARG_TYPE/);
}
{
  // Test result is a Readable
  const stream = Readable.from([1, 2, 3, 4, 5]).filter((x) => true);
  assert.strictEqual(stream.readable, true);
}
{
  const stream = Readable.from([1, 2, 3, 4, 5]);
  Object.defineProperty(stream, 'map', {
    value: common.mustNotCall(),
  });
  // Check that map isn't getting called.
  stream.filter(() => true);
}
                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-stream-finished.js                                                   0000664 0000000 0000000 00000032633 14746647661 0021734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Writable,
  Readable,
  Transform,
  finished,
  Duplex,
  PassThrough,
  Stream,
} = require('stream');
const assert = require('assert');
const EE = require('events');
const fs = require('fs');
const { promisify } = require('util');
const http = require('http');

{
  const rs = new Readable({
    read() {}
  });

  finished(rs, common.mustSucceed());

  rs.push(null);
  rs.resume();
}

{
  const ws = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  finished(ws, common.mustSucceed());

  ws.end();
}

{
  const tr = new Transform({
    transform(data, enc, cb) {
      cb();
    }
  });

  let finish = false;
  let ended = false;

  tr.on('end', () => {
    ended = true;
  });

  tr.on('finish', () => {
    finish = true;
  });

  finished(tr, common.mustSucceed(() => {
    assert(finish);
    assert(ended);
  }));

  tr.end();
  tr.resume();
}

{
  const rs = fs.createReadStream(__filename);

  rs.resume();
  finished(rs, common.mustCall());
}

{
  const finishedPromise = promisify(finished);

  async function run() {
    const rs = fs.createReadStream(__filename);
    const done = common.mustCall();

    let ended = false;
    rs.resume();
    rs.on('end', () => {
      ended = true;
    });
    await finishedPromise(rs);
    assert(ended);
    done();
  }

  run();
}

{
  // Check pre-cancelled
  const signal = new EventTarget();
  signal.aborted = true;

  const rs = Readable.from((function* () {})());
  finished(rs, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
}

{
  // Check cancelled before the stream ends sync.
  const ac = new AbortController();
  const { signal } = ac;

  const rs = Readable.from((function* () {})());
  finished(rs, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  ac.abort();
}

{
  // Check cancelled before the stream ends async.
  const ac = new AbortController();
  const { signal } = ac;

  const rs = Readable.from((function* () {})());
  setTimeout(() => ac.abort(), 1);
  finished(rs, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
}

{
  // Check cancelled after doesn't throw.
  const ac = new AbortController();
  const { signal } = ac;

  const rs = Readable.from((function* () {
    yield 5;
    setImmediate(() => ac.abort());
  })());
  rs.resume();
  finished(rs, { signal }, common.mustSucceed());
}

{
  // Promisified abort works
  const finishedPromise = promisify(finished);
  async function run() {
    const ac = new AbortController();
    const { signal } = ac;
    const rs = Readable.from((function* () {})());
    setImmediate(() => ac.abort());
    await finishedPromise(rs, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}

{
  // Promisified pre-aborted works
  const finishedPromise = promisify(finished);
  async function run() {
    const signal = new EventTarget();
    signal.aborted = true;
    const rs = Readable.from((function* () {})());
    await finishedPromise(rs, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}


{
  const rs = fs.createReadStream('file-does-not-exist');

  finished(rs, common.expectsError({
    code: 'ENOENT'
  }));
}

{
  const rs = new Readable();

  finished(rs, common.mustSucceed());

  rs.push(null);
  rs.emit('close'); // Should not trigger an error
  rs.resume();
}

{
  const rs = new Readable();

  finished(rs, common.mustCall((err) => {
    assert(err, 'premature close error');
  }));

  rs.emit('close'); // Should trigger error
  rs.push(null);
  rs.resume();
}

// Test faulty input values and options.
{
  const rs = new Readable({
    read() {}
  });

  assert.throws(
    () => finished(rs, 'foo'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /callback/
    }
  );
  assert.throws(
    () => finished(rs, 'foo', () => {}),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /options/
    }
  );
  assert.throws(
    () => finished(rs, {}, 'foo'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /callback/
    }
  );

  finished(rs, null, common.mustCall());

  rs.push(null);
  rs.resume();
}

// Test that calling returned function removes listeners
{
  const ws = new Writable({
    write(data, env, cb) {
      cb();
    }
  });
  const removeListener = finished(ws, common.mustNotCall());
  removeListener();
  ws.end();
}

{
  const rs = new Readable();
  const removeListeners = finished(rs, common.mustNotCall());
  removeListeners();

  rs.emit('close');
  rs.push(null);
  rs.resume();
}

{
  const streamLike = new EE();
  streamLike.readableEnded = true;
  streamLike.readable = true;
  assert.throws(
    () => {
      finished(streamLike, () => {});
    },
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
  streamLike.emit('close');
}

{
  const writable = new Writable({ write() {} });
  writable.writable = false;
  writable.destroy();
  finished(writable, common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
  }));
}

{
  const readable = new Readable();
  readable.readable = false;
  readable.destroy();
  finished(readable, common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
  }));
}

{
  const w = new Writable({
    write(chunk, encoding, callback) {
      setImmediate(callback);
    }
  });
  finished(w, common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
  }));
  w.end('asd');
  w.destroy();
}

function testClosed(factory) {
  {
    // If already destroyed but finished is cancelled in same tick
    // don't invoke the callback,

    const s = factory();
    s.destroy();
    const dispose = finished(s, common.mustNotCall());
    dispose();
  }

  {
    // If already destroyed invoked callback.

    const s = factory();
    s.destroy();
    finished(s, common.mustCall());
  }

  {
    // Don't invoke until destroy has completed.

    let destroyed = false;
    const s = factory({
      destroy(err, cb) {
        setImmediate(() => {
          destroyed = true;
          cb();
        });
      }
    });
    s.destroy();
    finished(s, common.mustCall(() => {
      assert.strictEqual(destroyed, true);
    }));
  }

  {
    // Invoke callback even if close is inhibited.

    const s = factory({
      emitClose: false,
      destroy(err, cb) {
        cb();
        finished(s, common.mustCall());
      }
    });
    s.destroy();
  }

  {
    // Invoke with deep async.

    const s = factory({
      destroy(err, cb) {
        setImmediate(() => {
          cb();
          setImmediate(() => {
            finished(s, common.mustCall());
          });
        });
      }
    });
    s.destroy();
  }
}

testClosed((opts) => new Readable({ ...opts }));
testClosed((opts) => new Writable({ write() {}, ...opts }));

{
  const w = new Writable({
    write(chunk, encoding, cb) {
      cb();
    },
    autoDestroy: false
  });
  w.end('asd');
  process.nextTick(() => {
    finished(w, common.mustCall());
  });
}

{
  const w = new Writable({
    write(chunk, encoding, cb) {
      cb(new Error());
    },
    autoDestroy: false
  });
  w.write('asd');
  w.on('error', common.mustCall(() => {
    finished(w, common.mustCall());
  }));
}

{
  const r = new Readable({
    autoDestroy: false
  });
  r.push(null);
  r.resume();
  r.on('end', common.mustCall(() => {
    finished(r, common.mustCall());
  }));
}

{
  const rs = fs.createReadStream(__filename, { autoClose: false });
  rs.resume();
  rs.on('close', common.mustNotCall());
  rs.on('end', common.mustCall(() => {
    finished(rs, common.mustCall());
  }));
}

{
  const d = new EE();
  d._writableState = {};
  d._writableState.finished = true;
  finished(d, { readable: false, writable: true }, common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
  }));
  d._writableState.errored = true;
  d.emit('close');
}

{
  const r = new Readable();
  finished(r, common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
  }));
  r.push('asd');
  r.push(null);
  r.destroy();
}

{
  const d = new Duplex({
    final(cb) { }, // Never close writable side for test purpose
    read() {
      this.push(null);
    }
  });

  d.on('end', common.mustCall());

  finished(d, { readable: true, writable: false }, common.mustCall());

  d.end();
  d.resume();
}

{
  const d = new Duplex({
    final(cb) { }, // Never close writable side for test purpose
    read() {
      this.push(null);
    }
  });

  d.on('end', common.mustCall());

  d.end();
  finished(d, { readable: true, writable: false }, common.mustCall());

  d.resume();
}

{
  // Test for compat for e.g. fd-slicer which implements
  // non standard destroy behavior which might not emit
  // 'close'.
  const r = new Readable();
  finished(r, common.mustCall());
  r.resume();
  r.push('asd');
  r.destroyed = true;
  r.push(null);
}

{
  // Regression https://github.com/nodejs/node/issues/33130
  const response = new PassThrough();

  class HelloWorld extends Duplex {
    constructor(response) {
      super({
        autoDestroy: false
      });

      this.response = response;
      this.readMore = false;

      response.once('end', () => {
        this.push(null);
      });

      response.on('readable', () => {
        if (this.readMore) {
          this._read();
        }
      });
    }

    _read() {
      const { response } = this;

      this.readMore = true;

      if (response.readableLength) {
        this.readMore = false;
      }

      let data;
      while ((data = response.read()) !== null) {
        this.push(data);
      }
    }
  }

  const instance = new HelloWorld(response);
  instance.setEncoding('utf8');
  instance.end();

  (async () => {
    await EE.once(instance, 'finish');

    setImmediate(() => {
      response.write('chunk 1');
      response.write('chunk 2');
      response.write('chunk 3');
      response.end();
    });

    let res = '';
    for await (const data of instance) {
      res += data;
    }

    assert.strictEqual(res, 'chunk 1chunk 2chunk 3');
  })().then(common.mustCall());
}

{
  const p = new PassThrough();
  p.end();
  finished(p, common.mustNotCall());
}

{
  const p = new PassThrough();
  p.end();
  p.on('finish', common.mustCall(() => {
    finished(p, common.mustNotCall());
  }));
}

{
  const server = http.createServer(common.mustCall((req, res) => {
    res.on('close', common.mustCall(() => {
      finished(res, common.mustCall(() => {
        server.close();
      }));
    }));
    res.end();
  }))
  .listen(0, function() {
    http.request({
      method: 'GET',
      port: this.address().port
    }).end()
      .on('response', common.mustCall());
  });
}

{
  const server = http.createServer(common.mustCall((req, res) => {
    req.on('close', common.mustCall(() => {
      finished(req, common.mustCall(() => {
        server.close();
      }));
    }));
    req.destroy();
  })).listen(0, function() {
    http.request({
      method: 'GET',
      port: this.address().port
    }).end().on('error', common.mustCall());
  });
}

{
  const w = new Writable({
    write(chunk, encoding, callback) {
      process.nextTick(callback);
    }
  });
  w.aborted = false;
  w.end();
  let closed = false;
  w.on('finish', () => {
    assert.strictEqual(closed, false);
    w.emit('aborted');
  });
  w.on('close', common.mustCall(() => {
    closed = true;
  }));

  finished(w, common.mustCall(() => {
    assert.strictEqual(closed, true);
  }));
}

{
  const w = new Writable();
  const _err = new Error();
  w.destroy(_err);
  assert.strictEqual(w.errored, _err);
  finished(w, common.mustCall((err) => {
    assert.strictEqual(_err, err);
    assert.strictEqual(w.closed, true);
    finished(w, common.mustCall((err) => {
      assert.strictEqual(_err, err);
    }));
  }));
}

{
  const w = new Writable();
  w.destroy();
  assert.strictEqual(w.errored, null);
  finished(w, common.mustCall((err) => {
    assert.strictEqual(w.closed, true);
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
    finished(w, common.mustCall((err) => {
      assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
    }));
  }));
}

{
  // Legacy Streams do not inherit from Readable or Writable.
  // We cannot really assume anything about them, so we cannot close them
  // automatically.
  const s = new Stream();
  finished(s, common.mustNotCall());
}

{
  const server = http.createServer(common.mustCall(function(req, res) {
    fs.createReadStream(__filename).pipe(res);
    finished(res, common.mustCall(function(err) {
      assert.strictEqual(err, undefined);
    }));
  })).listen(0, function() {
    http.request(
      { method: 'GET', port: this.address().port },
      common.mustCall(function(res) {
        res.resume();
        finished(res, common.mustCall(() => {
          server.close();
        }));
      })
    ).end();
  });
}

{
  let isCalled = false;
  const stream = new Duplex({
    write(chunk, enc, cb) {
      setImmediate(() => {
        isCalled = true;
        cb();
      });
    }
  });

  stream.end('foo');

  finished(stream, { readable: false }, common.mustCall((err) => {
    assert(!err);
    assert.strictEqual(isCalled, true);
    assert.strictEqual(stream._writableState.pendingcb, 0);
  }));
}

{
  const stream = new Duplex({
    write(chunk, enc, cb) {}
  });

  stream.end('foo');

  // Simulate an old stream implementation that doesn't have pendingcb
  delete stream._writableState.pendingcb;

  finished(stream, { readable: false }, common.mustCall());
}
                                                                                                     node-23.7.0/test/parallel/test-stream-flatMap.js                                                    0000664 0000000 0000000 00000006752 14746647661 0021532 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fixtures = require('../common/fixtures');
const {
  Readable,
} = require('stream');
const assert = require('assert');
const { setTimeout } = require('timers/promises');
const { createReadStream } = require('fs');

function oneTo5() {
  return Readable.from([1, 2, 3, 4, 5]);
}

{
  // flatMap works on synchronous streams with a synchronous mapper
  (async () => {
    assert.deepStrictEqual(
      await oneTo5().flatMap((x) => [x + x]).toArray(),
      [2, 4, 6, 8, 10]
    );
    assert.deepStrictEqual(
      await oneTo5().flatMap(() => []).toArray(),
      []
    );
    assert.deepStrictEqual(
      await oneTo5().flatMap((x) => [x, x]).toArray(),
      [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]
    );
  })().then(common.mustCall());
}


{
  // flatMap works on sync/async streams with an asynchronous mapper
  (async () => {
    assert.deepStrictEqual(
      await oneTo5().flatMap(async (x) => [x, x]).toArray(),
      [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]
    );
    const asyncOneTo5 = oneTo5().map(async (x) => x);
    assert.deepStrictEqual(
      await asyncOneTo5.flatMap(async (x) => [x, x]).toArray(),
      [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]
    );
  })().then(common.mustCall());
}
{
  // flatMap works on a stream where mapping returns a stream
  (async () => {
    const result = await oneTo5().flatMap(async (x) => {
      return Readable.from([x, x]);
    }).toArray();
    assert.deepStrictEqual(result, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]);
  })().then(common.mustCall());
  // flatMap works on an objectMode stream where mappign returns a stream
  (async () => {
    const result = await oneTo5().flatMap(() => {
      return createReadStream(fixtures.path('x.txt'));
    }).toArray();
    // The resultant stream is in object mode so toArray shouldn't flatten
    assert.strictEqual(result.length, 5);
    assert.deepStrictEqual(
      Buffer.concat(result).toString(),
      'xyz\n'.repeat(5)
    );

  })().then(common.mustCall());

}

{
  // Concurrency + AbortSignal
  const ac = new AbortController();
  const stream = oneTo5().flatMap(common.mustNotCall(async (_, { signal }) => {
    await setTimeout(100, { signal });
  }), { signal: ac.signal, concurrency: 2 });
  // pump
  assert.rejects(async () => {
    for await (const item of stream) {
      // nope
      console.log(item);
    }
  }, {
    name: 'AbortError',
  }).then(common.mustCall());

  queueMicrotask(() => {
    ac.abort();
  });
}

{
  // Already aborted AbortSignal
  const stream = oneTo5().flatMap(common.mustNotCall(async (_, { signal }) => {
    await setTimeout(100, { signal });
  }), { signal: AbortSignal.abort() });
  // pump
  assert.rejects(async () => {
    for await (const item of stream) {
      // nope
      console.log(item);
    }
  }, {
    name: 'AbortError',
  }).then(common.mustCall());
}

{
  // Error cases
  assert.throws(() => Readable.from([1]).flatMap(1), /ERR_INVALID_ARG_TYPE/);
  assert.throws(() => Readable.from([1]).flatMap((x) => x, {
    concurrency: 'Foo'
  }), /ERR_OUT_OF_RANGE/);
  assert.throws(() => Readable.from([1]).flatMap((x) => x, 1), /ERR_INVALID_ARG_TYPE/);
  assert.throws(() => Readable.from([1]).flatMap((x) => x, { signal: true }), /ERR_INVALID_ARG_TYPE/);
}
{
  // Test result is a Readable
  const stream = oneTo5().flatMap((x) => x);
  assert.strictEqual(stream.readable, true);
}
{
  const stream = oneTo5();
  Object.defineProperty(stream, 'map', {
    value: common.mustNotCall(),
  });
  // Check that map isn't getting called.
  stream.flatMap(() => true);
}
                      node-23.7.0/test/parallel/test-stream-forEach.js                                                    0000664 0000000 0000000 00000007062 14746647661 0021510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable,
} = require('stream');
const assert = require('assert');
const { once } = require('events');

{
  // forEach works on synchronous streams with a synchronous predicate
  const stream = Readable.from([1, 2, 3]);
  const result = [1, 2, 3];
  (async () => {
    await stream.forEach((value) => assert.strictEqual(value, result.shift()));
  })().then(common.mustCall());
}

{
  // forEach works an asynchronous streams
  const stream = Readable.from([1, 2, 3]).filter(async (x) => {
    await Promise.resolve();
    return true;
  });
  const result = [1, 2, 3];
  (async () => {
    await stream.forEach((value) => assert.strictEqual(value, result.shift()));
  })().then(common.mustCall());
}

{
  // forEach works on asynchronous streams with a asynchronous forEach fn
  const stream = Readable.from([1, 2, 3]).filter(async (x) => {
    await Promise.resolve();
    return true;
  });
  const result = [1, 2, 3];
  (async () => {
    await stream.forEach(async (value) => {
      await Promise.resolve();
      assert.strictEqual(value, result.shift());
    });
  })().then(common.mustCall());
}

{
  // forEach works on an infinite stream
  const ac = new AbortController();
  const { signal } = ac;
  const stream = Readable.from(async function* () {
    while (true) yield 1;
  }(), { signal });
  let i = 0;
  assert.rejects(stream.forEach(common.mustCall((x) => {
    i++;
    if (i === 10) ac.abort();
    assert.strictEqual(x, 1);
  }, 10)), { name: 'AbortError' }).then(common.mustCall());
}

{
  // Emitting an error during `forEach`
  const stream = Readable.from([1, 2, 3, 4, 5]);
  assert.rejects(stream.forEach(async (x) => {
    if (x === 3) {
      stream.emit('error', new Error('boom'));
    }
  }), /boom/).then(common.mustCall());
}

{
  // Throwing an error during `forEach` (sync)
  const stream = Readable.from([1, 2, 3, 4, 5]);
  assert.rejects(stream.forEach((x) => {
    if (x === 3) {
      throw new Error('boom');
    }
  }), /boom/).then(common.mustCall());
}

{
  // Throwing an error during `forEach` (async)
  const stream = Readable.from([1, 2, 3, 4, 5]);
  assert.rejects(stream.forEach(async (x) => {
    if (x === 3) {
      return Promise.reject(new Error('boom'));
    }
  }), /boom/).then(common.mustCall());
}

{
  // Concurrency + AbortSignal
  const ac = new AbortController();
  let calls = 0;
  const forEachPromise =
    Readable.from([1, 2, 3, 4]).forEach(async (_, { signal }) => {
      calls++;
      await once(signal, 'abort');
    }, { signal: ac.signal, concurrency: 2, highWaterMark: 0 });
  // pump
  assert.rejects(async () => {
    await forEachPromise;
  }, {
    name: 'AbortError',
  }).then(common.mustCall());

  setImmediate(() => {
    ac.abort();
    assert.strictEqual(calls, 2);
  });
}

{
  // Error cases
  assert.rejects(async () => {
    await Readable.from([1]).forEach(1);
  }, /ERR_INVALID_ARG_TYPE/).then(common.mustCall());
  assert.rejects(async () => {
    await Readable.from([1]).forEach((x) => x, {
      concurrency: 'Foo'
    });
  }, /ERR_OUT_OF_RANGE/).then(common.mustCall());
  assert.rejects(async () => {
    await Readable.from([1]).forEach((x) => x, 1);
  }, /ERR_INVALID_ARG_TYPE/).then(common.mustCall());
}
{
  // Test result is a Promise
  const stream = Readable.from([1, 2, 3, 4, 5]).forEach((_) => true);
  assert.strictEqual(typeof stream.then, 'function');
}
{
  const stream = Readable.from([1, 2, 3, 4, 5]);
  Object.defineProperty(stream, 'map', {
    value: common.mustNotCall(),
  });
  // Check that map isn't getting called.
  stream.forEach(() => true);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-inheritance.js                                                0000664 0000000 0000000 00000003555 14746647661 0022435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { Readable, Writable, Duplex, Transform } = require('stream');

const readable = new Readable({ read() {} });
const writable = new Writable({ write() {} });
const duplex = new Duplex({ read() {}, write() {} });
const transform = new Transform({ transform() {} });

assert.ok(readable instanceof Readable);
assert.ok(!(writable instanceof Readable));
assert.ok(duplex instanceof Readable);
assert.ok(transform instanceof Readable);

assert.ok(!(readable instanceof Writable));
assert.ok(writable instanceof Writable);
assert.ok(duplex instanceof Writable);
assert.ok(transform instanceof Writable);

assert.ok(!(readable instanceof Duplex));
assert.ok(!(writable instanceof Duplex));
assert.ok(duplex instanceof Duplex);
assert.ok(transform instanceof Duplex);

assert.ok(!(readable instanceof Transform));
assert.ok(!(writable instanceof Transform));
assert.ok(!(duplex instanceof Transform));
assert.ok(transform instanceof Transform);

assert.ok(!(null instanceof Writable));
assert.ok(!(undefined instanceof Writable));

// Simple inheritance check for `Writable` works fine in a subclass constructor.
function CustomWritable() {
  assert.ok(
    this instanceof CustomWritable,
    `${this} does not inherit from CustomWritable`
  );
  assert.ok(
    this instanceof Writable,
    `${this} does not inherit from Writable`
  );
}

Object.setPrototypeOf(CustomWritable, Writable);
Object.setPrototypeOf(CustomWritable.prototype, Writable.prototype);

new CustomWritable();

assert.throws(
  CustomWritable,
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'undefined does not inherit from CustomWritable'
  }
);

class OtherCustomWritable extends Writable {}

assert(!(new OtherCustomWritable() instanceof CustomWritable));
assert(!(new CustomWritable() instanceof OtherCustomWritable));
                                                                                                                                                   node-23.7.0/test/parallel/test-stream-ispaused.js                                                   0000664 0000000 0000000 00000003152 14746647661 0021752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const stream = require('stream');

const readable = new stream.Readable();

// _read is a noop, here.
readable._read = Function();

// Default state of a stream is not "paused"
assert.ok(!readable.isPaused());

// Make the stream start flowing...
readable.on('data', Function());

// still not paused.
assert.ok(!readable.isPaused());

readable.pause();
assert.ok(readable.isPaused());
readable.resume();
assert.ok(!readable.isPaused());
                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-iterator-helpers-test262-tests.mjs                            0000664 0000000 0000000 00000013305 14746647661 0026153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import { mustCall } from '../common/index.mjs';
import { Readable } from 'stream';
import assert from 'assert';

// These tests are manually ported from the draft PR for the test262 test suite
// Authored by Rick Waldron in https://github.com/tc39/test262/pull/2818/files

// test262 license:
// The << Software identified by reference to the Ecma Standard* ("Software)">>
// is protected by copyright and is being made available under the
// "BSD License", included below. This Software may be subject to third party
// rights (rights from parties other than Ecma International), including patent
// rights, and no licenses under such third party rights are granted under this
// license even if the third party concerned is a member of Ecma International.
// SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT
// http://www.ecma-international.org/memento/codeofconduct.htm FOR INFORMATION
// REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA
// INTERNATIONAL STANDARDS*

// Copyright (C) 2012-2013 Ecma International
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 1.   Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
// 2.   Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 3.   Neither the name of the authors nor Ecma International may be used to
//      endorse or promote products derived from this software without specific
//      prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS
// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
// NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// * Ecma International Standards hereafter means Ecma International Standards
// as well as Ecma Technical Reports


// Note all the tests that check AsyncIterator's prototype itself and things
// that happen before stream conversion were not ported.
{
  // drop/length
  assert.strictEqual(Readable.prototype.drop.length, 1);
  const descriptor = Object.getOwnPropertyDescriptor(
    Readable.prototype,
    'drop'
  );
  assert.strictEqual(descriptor.enumerable, false);
  assert.strictEqual(descriptor.configurable, true);
  assert.strictEqual(descriptor.writable, true);
  // drop/limit-equals-total
  const iterator = Readable.from([1, 2]).drop(2);
  const result = await iterator[Symbol.asyncIterator]().next();
  assert.deepStrictEqual(result, { done: true, value: undefined });
  // drop/limit-greater-than-total.js
  const iterator2 = Readable.from([1, 2]).drop(3);
  const result2 = await iterator2[Symbol.asyncIterator]().next();
  assert.deepStrictEqual(result2, { done: true, value: undefined });
  // drop/limit-less-than-total.js
  const iterator3 = Readable.from([1, 2]).drop(1);
  const result3 = await iterator3[Symbol.asyncIterator]().next();
  assert.deepStrictEqual(result3, { done: false, value: 2 });
  // drop/limit-rangeerror
  assert.throws(() => Readable.from([1]).drop(-1), RangeError);
  assert.throws(() => {
    Readable.from([1]).drop({
      valueOf() {
        throw new Error('boom');
      }
    });
  }, /boom/);
  // drop/limit-tointeger
  const two = await Readable.from([1, 2]).drop({ valueOf: () => 1 }).toArray();
  assert.deepStrictEqual(two, [2]);
  // drop/name
  assert.strictEqual(Readable.prototype.drop.name, 'drop');
  // drop/non-constructible
  assert.throws(() => new Readable.prototype.drop(1), TypeError);
  // drop/proto
  const proto = Object.getPrototypeOf(Readable.prototype.drop);
  assert.strictEqual(proto, Function.prototype);
}
{
  // every/abrupt-iterator-close
  const stream = Readable.from([1, 2, 3]);
  const e = new Error();
  await assert.rejects(stream.every(mustCall(() => {
    throw e;
  }, 1)), e);
}
{
  // every/callable-fn
  await assert.rejects(Readable.from([1, 2]).every({}), TypeError);
}
{
  // every/callable
  Readable.prototype.every.call(Readable.from([]), () => {});
  // eslint-disable-next-line array-callback-return
  Readable.from([]).every(() => {});
  assert.throws(() => {
    const r = Readable.from([]);
    new r.every(() => {});
  }, TypeError);
}

{
  // every/false
  const iterator = Readable.from([1, 2, 3]);
  const result = await iterator.every((v) => v === 1);
  assert.strictEqual(result, false);
}
{
  // every/every
  const iterator = Readable.from([1, 2, 3]);
  const result = await iterator.every((v) => true);
  assert.strictEqual(result, true);
}

{
  // every/is-function
  assert.strictEqual(typeof Readable.prototype.every, 'function');
}
{
  // every/length
  assert.strictEqual(Readable.prototype.every.length, 1);
  // every/name
  assert.strictEqual(Readable.prototype.every.name, 'every');
  // every/propdesc
  const descriptor = Object.getOwnPropertyDescriptor(
    Readable.prototype,
    'every'
  );
  assert.strictEqual(descriptor.enumerable, false);
  assert.strictEqual(descriptor.configurable, true);
  assert.strictEqual(descriptor.writable, true);
}
                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-map.js                                                        0000664 0000000 0000000 00000023243 14746647661 0020715 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable,
} = require('stream');
const assert = require('assert');
const { once } = require('events');
const { setTimeout } = require('timers/promises');

function createDependentPromises(n) {
  const promiseAndResolveArray = [];

  for (let i = 0; i < n; i++) {
    let res;
    const promise = new Promise((resolve) => {
      if (i === 0) {
        res = resolve;
        return;
      }
      res = () => promiseAndResolveArray[i - 1][0].then(resolve);
    });

    promiseAndResolveArray.push([promise, res]);
  }

  return promiseAndResolveArray;
}

{
  // Map works on synchronous streams with a synchronous mapper
  const stream = Readable.from([1, 2, 3, 4, 5]).map((x) => x + x);
  (async () => {
    assert.deepStrictEqual(await stream.toArray(), [2, 4, 6, 8, 10]);
  })().then(common.mustCall());
}

{
  // Map works on synchronous streams with an asynchronous mapper
  const stream = Readable.from([1, 2, 3, 4, 5]).map(async (x) => {
    await Promise.resolve();
    return x + x;
  });
  (async () => {
    assert.deepStrictEqual(await stream.toArray(), [2, 4, 6, 8, 10]);
  })().then(common.mustCall());
}

{
  // Map works on asynchronous streams with a asynchronous mapper
  const stream = Readable.from([1, 2, 3, 4, 5]).map(async (x) => {
    return x + x;
  }).map((x) => x + x);
  (async () => {
    assert.deepStrictEqual(await stream.toArray(), [4, 8, 12, 16, 20]);
  })().then(common.mustCall());
}

{
  // Map works on an infinite stream
  const stream = Readable.from(async function* () {
    while (true) yield 1;
  }()).map(common.mustCall(async (x) => {
    return x + x;
  }, 5));
  (async () => {
    let i = 1;
    for await (const item of stream) {
      assert.strictEqual(item, 2);
      if (++i === 5) break;
    }
  })().then(common.mustCall());
}

{
  // Map works on non-objectMode streams
  const stream = new Readable({
    read() {
      this.push(Uint8Array.from([1]));
      this.push(Uint8Array.from([2]));
      this.push(null);
    }
  }).map(async ([x]) => {
    return x + x;
  }).map((x) => x + x);
  const result = [4, 8];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // Does not care about data events
  const source = new Readable({
    read() {
      this.push(Uint8Array.from([1]));
      this.push(Uint8Array.from([2]));
      this.push(null);
    }
  });
  setImmediate(() => stream.emit('data', Uint8Array.from([1])));
  const stream = source.map(async ([x]) => {
    return x + x;
  }).map((x) => x + x);
  const result = [4, 8];
  (async () => {
    for await (const item of stream) {
      assert.strictEqual(item, result.shift());
    }
  })().then(common.mustCall());
}

{
  // Emitting an error during `map`
  const stream = Readable.from([1, 2, 3, 4, 5]).map(async (x) => {
    if (x === 3) {
      stream.emit('error', new Error('boom'));
    }
    return x + x;
  });
  assert.rejects(
    stream.map((x) => x + x).toArray(),
    /boom/,
  ).then(common.mustCall());
}

{
  // Throwing an error during `map` (sync)
  const stream = Readable.from([1, 2, 3, 4, 5]).map((x) => {
    if (x === 3) {
      throw new Error('boom');
    }
    return x + x;
  });
  assert.rejects(
    stream.map((x) => x + x).toArray(),
    /boom/,
  ).then(common.mustCall());
}


{
  // Throwing an error during `map` (async)
  const stream = Readable.from([1, 2, 3, 4, 5]).map(async (x) => {
    if (x === 3) {
      throw new Error('boom');
    }
    return x + x;
  });
  assert.rejects(
    stream.map((x) => x + x).toArray(),
    /boom/,
  ).then(common.mustCall());
}

{
  // Concurrency + AbortSignal
  const ac = new AbortController();
  const range = Readable.from([1, 2, 3, 4, 5]);
  const stream = range.map(common.mustCall(async (_, { signal }) => {
    await once(signal, 'abort');
    throw signal.reason;
  }, 2), { signal: ac.signal, concurrency: 2, highWaterMark: 0 });
  // pump
  assert.rejects(async () => {
    for await (const item of stream) {
      assert.fail('should not reach here, got ' + item);
    }
  }, {
    name: 'AbortError',
  }).then(common.mustCall());

  setImmediate(() => {
    ac.abort();
  });
}

{
  // Concurrency result order
  const stream = Readable.from([1, 2]).map(async (item, { signal }) => {
    await setTimeout(10 - item, { signal });
    return item;
  }, { concurrency: 2 });

  (async () => {
    const expected = [1, 2];
    for await (const item of stream) {
      assert.strictEqual(item, expected.shift());
    }
  })().then(common.mustCall());
}


{
  // highWaterMark with small concurrency
  const finishOrder = [];

  const promises = createDependentPromises(4);

  const raw = Readable.from([2, 0, 1, 3]);
  const stream = raw.map(async (item) => {
    const [promise, resolve] = promises[item];
    resolve();

    await promise;
    finishOrder.push(item);
    return item;
  }, { concurrency: 2 });

  (async () => {
    await stream.toArray();

    assert.deepStrictEqual(finishOrder, [0, 1, 2, 3]);
  })().then(common.mustCall(), common.mustNotCall());
}

{
  // highWaterMark with a lot of items and large concurrency
  const finishOrder = [];

  const promises = createDependentPromises(20);

  const input = [10, 1, 0, 3, 4, 2, 5, 7, 8, 9, 6, 11, 12, 13, 18, 15, 16, 17, 14, 19];
  const raw = Readable.from(input);
  // Should be
  // 10, 1, 0, 3, 4, 2 | next: 0
  // 10, 1, 3, 4, 2, 5 | next: 1
  // 10, 3, 4, 2, 5, 7 | next: 2
  // 10, 3, 4, 5, 7, 8 | next: 3
  // 10, 4, 5, 7, 8, 9 | next: 4
  // 10, 5, 7, 8, 9, 6 | next: 5
  // 10, 7, 8, 9, 6, 11 | next: 6
  // 10, 7, 8, 9, 11, 12 | next: 7
  // 10, 8, 9, 11, 12, 13 | next: 8
  // 10, 9, 11, 12, 13, 18 | next: 9
  // 10, 11, 12, 13, 18, 15 | next: 10
  // 11, 12, 13, 18, 15, 16 | next: 11
  // 12, 13, 18, 15, 16, 17 | next: 12
  // 13, 18, 15, 16, 17, 14 | next: 13
  // 18, 15, 16, 17, 14, 19 | next: 14
  // 18, 15, 16, 17, 19 | next: 15
  // 18, 16, 17, 19 | next: 16
  // 18, 17, 19 | next: 17
  // 18, 19 | next: 18
  // 19 | next: 19
  //

  const stream = raw.map(async (item) => {
    const [promise, resolve] = promises[item];
    resolve();

    await promise;
    finishOrder.push(item);
    return item;
  }, { concurrency: 6 });

  (async () => {
    const outputOrder = await stream.toArray();

    assert.deepStrictEqual(outputOrder, input);
    assert.deepStrictEqual(finishOrder, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
  })().then(common.mustCall(), common.mustNotCall());
}

{
  // Custom highWaterMark with a lot of items and large concurrency
  const finishOrder = [];

  const promises = createDependentPromises(20);

  const input = [11, 1, 0, 3, 4, 2, 5, 7, 8, 9, 6, 10, 12, 13, 18, 15, 16, 17, 14, 19];
  const raw = Readable.from(input);
  // Should be
  // 11, 1, 0, 3, 4     | next: 0, buffer: []
  // 11, 1, 3, 4, 2     | next: 1, buffer: [0]
  // 11, 3, 4, 2, 5     | next: 2, buffer: [0, 1]
  // 11, 3, 4, 5, 7     | next: 3, buffer: [0, 1, 2]
  // 11, 4, 5, 7, 8     | next: 4, buffer: [0, 1, 2, 3]
  // 11, 5, 7, 8, 9     | next: 5, buffer: [0, 1, 2, 3, 4]
  // 11, 7, 8, 9, 6     | next: 6, buffer: [0, 1, 2, 3, 4, 5]
  // 11, 7, 8, 9, 10    | next: 7, buffer: [0, 1, 2, 3, 4, 5, 6] -- buffer full
  // 11, 8, 9, 10, 12   | next: 8, buffer: [0, 1, 2, 3, 4, 5, 6]
  // 11, 9, 10, 12, 13  | next: 9, buffer: [0, 1, 2, 3, 4, 5, 6]
  // 11, 10, 12, 13, 18 | next: 10, buffer: [0, 1, 2, 3, 4, 5, 6]
  // 11, 12, 13, 18, 15 | next: 11, buffer: [0, 1, 2, 3, 4, 5, 6]
  // 12, 13, 18, 15, 16 | next: 12, buffer: [] -- all items flushed as 11 is consumed and all the items wait for it
  // 13, 18, 15, 16, 17 | next: 13, buffer: []
  // 18, 15, 16, 17, 14 | next: 14, buffer: []
  // 18, 15, 16, 17, 19 | next: 15, buffer: [14]
  // 18, 16, 17, 19     | next: 16, buffer: [14, 15]
  // 18, 17, 19         | next: 17, buffer: [14, 15, 16]
  // 18, 19             | next: 18, buffer: [14, 15, 16, 17]
  // 19                 | next: 19, buffer: [] -- all items flushed
  //

  const stream = raw.map(async (item) => {
    const [promise, resolve] = promises[item];
    resolve();

    await promise;
    finishOrder.push(item);
    return item;
  }, { concurrency: 5, highWaterMark: 7 });

  (async () => {
    const outputOrder = await stream.toArray();

    assert.deepStrictEqual(outputOrder, input);
    assert.deepStrictEqual(finishOrder, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
  })().then(common.mustCall(), common.mustNotCall());
}

{
  // Where there is a delay between the first and the next item it should not wait for filled queue
  // before yielding to the user
  const promises = createDependentPromises(3);

  const raw = Readable.from([0, 1, 2]);

  const stream = raw
      .map(async (item) => {
        if (item !== 0) {
          await promises[item][0];
        }

        return item;
      }, { concurrency: 2 })
      .map((item) => {
        // eslint-disable-next-line no-unused-vars
        for (const [_, resolve] of promises) {
          resolve();
        }

        return item;
      });

  (async () => {
    await stream.toArray();
  })().then(common.mustCall(), common.mustNotCall());
}

{
  // Error cases
  assert.throws(() => Readable.from([1]).map(1), /ERR_INVALID_ARG_TYPE/);
  assert.throws(() => Readable.from([1]).map((x) => x, {
    concurrency: 'Foo'
  }), /ERR_OUT_OF_RANGE/);
  assert.throws(() => Readable.from([1]).map((x) => x, {
    concurrency: -1
  }), /ERR_OUT_OF_RANGE/);
  assert.throws(() => Readable.from([1]).map((x) => x, 1), /ERR_INVALID_ARG_TYPE/);
  assert.throws(() => Readable.from([1]).map((x) => x, { signal: true }), /ERR_INVALID_ARG_TYPE/);
}
{
  // Test result is a Readable
  const stream = Readable.from([1, 2, 3, 4, 5]).map((x) => x);
  assert.strictEqual(stream.readable, true);
}
                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-objectmode-undefined.js                                       0000664 0000000 0000000 00000001534 14746647661 0024211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable, Writable, Transform } = require('stream');

{
  const stream = new Readable({
    objectMode: true,
    read: common.mustCall(() => {
      stream.push(undefined);
      stream.push(null);
    })
  });

  stream.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, undefined);
  }));
}

{
  const stream = new Writable({
    objectMode: true,
    write: common.mustCall((chunk) => {
      assert.strictEqual(chunk, undefined);
    })
  });

  stream.write(undefined);
}

{
  const stream = new Transform({
    objectMode: true,
    transform: common.mustCall((chunk) => {
      stream.push(chunk);
    })
  });

  stream.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, undefined);
  }));

  stream.write(undefined);
}
                                                                                                                                                                    node-23.7.0/test/parallel/test-stream-once-readable-pipe.js                                         0000664 0000000 0000000 00000002262 14746647661 0023552 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable, Writable } = require('stream');

// This test ensures that if have 'readable' listener
// on Readable instance it will not disrupt the pipe.

{
  let receivedData = '';
  const w = new Writable({
    write: (chunk, env, callback) => {
      receivedData += chunk;
      callback();
    },
  });

  const data = ['foo', 'bar', 'baz'];
  const r = new Readable({
    read: () => {},
  });

  r.once('readable', common.mustCall());

  r.pipe(w);
  r.push(data[0]);
  r.push(data[1]);
  r.push(data[2]);
  r.push(null);

  w.on('finish', common.mustCall(() => {
    assert.strictEqual(receivedData, data.join(''));
  }));
}

{
  let receivedData = '';
  const w = new Writable({
    write: (chunk, env, callback) => {
      receivedData += chunk;
      callback();
    },
  });

  const data = ['foo', 'bar', 'baz'];
  const r = new Readable({
    read: () => {},
  });

  r.pipe(w);
  r.push(data[0]);
  r.push(data[1]);
  r.push(data[2]);
  r.push(null);
  r.once('readable', common.mustCall());

  w.on('finish', common.mustCall(() => {
    assert.strictEqual(receivedData, data.join(''));
  }));
}
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-passthrough-drain.js                                          0000664 0000000 0000000 00000000411 14746647661 0023572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { PassThrough } = require('stream');

const pt = new PassThrough({ highWaterMark: 0 });
pt.on('drain', common.mustCall());
assert(!pt.write('hello1'));
pt.read();
pt.read();
                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stream-pipe-after-end.js                                             0000664 0000000 0000000 00000004240 14746647661 0022734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable, Writable } = require('stream');

class TestReadable extends Readable {
  constructor(opt) {
    super(opt);
    this._ended = false;
  }

  _read() {
    if (this._ended)
      this.emit('error', new Error('_read called twice'));
    this._ended = true;
    this.push(null);
  }
}

class TestWritable extends Writable {
  constructor(opt) {
    super(opt);
    this._written = [];
  }

  _write(chunk, encoding, cb) {
    this._written.push(chunk);
    cb();
  }
}

// This one should not emit 'end' until we read() from it later.
const ender = new TestReadable();

// What happens when you pipe() a Readable that's already ended?
const piper = new TestReadable();
// pushes EOF null, and length=0, so this will trigger 'end'
piper.read();

setTimeout(common.mustCall(function() {
  ender.on('end', common.mustCall());
  const c = ender.read();
  assert.strictEqual(c, null);

  const w = new TestWritable();
  w.on('finish', common.mustCall());
  piper.pipe(w);
}), 1);
                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stream-pipe-await-drain-manual-resume.js                             0000664 0000000 0000000 00000004442 14746647661 0026044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');
const assert = require('assert');

// A consumer stream with a very low highWaterMark, which starts in a state
// where it buffers the chunk it receives rather than indicating that they
// have been consumed.
const writable = new stream.Writable({
  highWaterMark: 5
});

let isCurrentlyBufferingWrites = true;
const queue = [];

writable._write = (chunk, encoding, cb) => {
  if (isCurrentlyBufferingWrites)
    queue.push({ chunk, cb });
  else
    cb();
};

const readable = new stream.Readable({
  read() {}
});

readable.pipe(writable);

readable.once('pause', common.mustCall(() => {
  assert.strictEqual(
    readable._readableState.awaitDrainWriters,
    writable,
    'Expected awaitDrainWriters to be a Writable but instead got ' +
    `${readable._readableState.awaitDrainWriters}`
  );
  // First pause, resume manually. The next write() to writable will still
  // return false, because chunks are still being buffered, so it will increase
  // the awaitDrain counter again.

  process.nextTick(common.mustCall(() => {
    readable.resume();
  }));

  readable.once('pause', common.mustCall(() => {
    assert.strictEqual(
      readable._readableState.awaitDrainWriters,
      writable,
      '.resume() should not reset the awaitDrainWriters, but instead got ' +
      `${readable._readableState.awaitDrainWriters}`
    );
    // Second pause, handle all chunks from now on. Once all callbacks that
    // are currently queued up are handled, the awaitDrain drain counter should
    // fall back to 0 and all chunks that are pending on the readable side
    // should be flushed.
    isCurrentlyBufferingWrites = false;
    for (const queued of queue)
      queued.cb();
  }));
}));

readable.push(Buffer.alloc(100));  // Fill the writable HWM, first 'pause'.
readable.push(Buffer.alloc(100));  // Second 'pause'.
readable.push(Buffer.alloc(100));  // Should get through to the writable.
readable.push(null);

writable.on('finish', common.mustCall(() => {
  assert.strictEqual(
    readable._readableState.awaitDrainWriters,
    null,
    `awaitDrainWriters should be reset to null
    after all chunks are written but instead got
    ${readable._readableState.awaitDrainWriters}`
  );
  // Everything okay, all chunks were written.
}));
                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-pipe-await-drain-push-while-write.js                          0000664 0000000 0000000 00000002071 14746647661 0026502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');
const assert = require('assert');

const writable = new stream.Writable({
  highWaterMark: 16 * 1024,
  write: common.mustCall(function(chunk, encoding, cb) {
    assert.strictEqual(
      readable._readableState.awaitDrainWriters,
      null,
    );

    if (chunk.length === 32 * 1024) { // first chunk
      readable.push(Buffer.alloc(34 * 1024)); // above hwm
      // We should check if awaitDrain counter is increased in the next
      // tick, because awaitDrain is incremented after this method finished
      process.nextTick(() => {
        assert.strictEqual(readable._readableState.awaitDrainWriters, writable);
      });
    }

    process.nextTick(cb);
  }, 3)
});

// A readable stream which produces two buffers.
const bufs = [Buffer.alloc(32 * 1024), Buffer.alloc(33 * 1024)]; // above hwm
const readable = new stream.Readable({
  highWaterMark: 16 * 1024,
  read: function() {
    while (bufs.length > 0) {
      this.push(bufs.shift());
    }
  }
});

readable.pipe(writable);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stream-pipe-await-drain.js                                           0000664 0000000 0000000 00000003753 14746647661 0023277 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');
const assert = require('assert');

// This is very similar to test-stream-pipe-cleanup-pause.js.

const reader = new stream.Readable();
const writer1 = new stream.Writable();
const writer2 = new stream.Writable();
const writer3 = new stream.Writable();

// 560000 is chosen here because it is larger than the (default) highWaterMark
// and will cause `.write()` to return false
// See: https://github.com/nodejs/node/issues/5820
const buffer = Buffer.allocUnsafe(560000);

reader._read = () => {};

writer1._write = common.mustCall(function(chunk, encoding, cb) {
  this.emit('chunk-received');
  process.nextTick(cb);
}, 1);

writer1.once('chunk-received', () => {
  assert.strictEqual(
    reader._readableState.awaitDrainWriters.size,
    0,
    'awaitDrain initial value should be 0, actual is ' +
    reader._readableState.awaitDrainWriters.size
  );
  setImmediate(() => {
    // This one should *not* get through to writer1 because writer2 is not
    // "done" processing.
    reader.push(buffer);
  });
});

// A "slow" consumer:
writer2._write = common.mustCall((chunk, encoding, cb) => {
  assert.strictEqual(
    reader._readableState.awaitDrainWriters.size,
    1,
    'awaitDrain should be 1 after first push, actual is ' +
    reader._readableState.awaitDrainWriters.size
  );
  // Not calling cb here to "simulate" slow stream.
  // This should be called exactly once, since the first .write() call
  // will return false.
}, 1);

writer3._write = common.mustCall((chunk, encoding, cb) => {
  assert.strictEqual(
    reader._readableState.awaitDrainWriters.size,
    2,
    'awaitDrain should be 2 after second push, actual is ' +
    reader._readableState.awaitDrainWriters.size
  );
  // Not calling cb here to "simulate" slow stream.
  // This should be called exactly once, since the first .write() call
  // will return false.
}, 1);

reader.pipe(writer1);
reader.pipe(writer2);
reader.pipe(writer3);
reader.push(buffer);
                     node-23.7.0/test/parallel/test-stream-pipe-cleanup-pause.js                                         0000664 0000000 0000000 00000001641 14746647661 0023633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');

const reader = new stream.Readable();
const writer1 = new stream.Writable();
const writer2 = new stream.Writable();

// 560000 is chosen here because it is larger than the (default) highWaterMark
// and will cause `.write()` to return false
// See: https://github.com/nodejs/node/issues/2323
const buffer = Buffer.allocUnsafe(560000);

reader._read = () => {};

writer1._write = common.mustCall(function(chunk, encoding, cb) {
  this.emit('chunk-received');
  cb();
}, 1);
writer1.once('chunk-received', function() {
  reader.unpipe(writer1);
  reader.pipe(writer2);
  reader.push(buffer);
  setImmediate(function() {
    reader.push(buffer);
    setImmediate(function() {
      reader.push(buffer);
    });
  });
});

writer2._write = common.mustCall(function(chunk, encoding, cb) {
  cb();
}, 3);

reader.pipe(writer1);
reader.push(buffer);
                                                                                               node-23.7.0/test/parallel/test-stream-pipe-cleanup.js                                               0000664 0000000 0000000 00000007715 14746647661 0022530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// This test asserts that Stream.prototype.pipe does not leave listeners
// hanging on the source or dest.
require('../common');
const stream = require('stream');
const assert = require('assert');

function Writable() {
  this.writable = true;
  this.endCalls = 0;
  stream.Stream.call(this);
}
Object.setPrototypeOf(Writable.prototype, stream.Stream.prototype);
Object.setPrototypeOf(Writable, stream.Stream);
Writable.prototype.end = function() {
  this.endCalls++;
};

Writable.prototype.destroy = function() {
  this.endCalls++;
};

function Readable() {
  this.readable = true;
  stream.Stream.call(this);
}
Object.setPrototypeOf(Readable.prototype, stream.Stream.prototype);
Object.setPrototypeOf(Readable, stream.Stream);

function Duplex() {
  this.readable = true;
  Writable.call(this);
}
Object.setPrototypeOf(Duplex.prototype, Writable.prototype);
Object.setPrototypeOf(Duplex, Writable);

let i = 0;
const limit = 100;

let w = new Writable();

let r;

for (i = 0; i < limit; i++) {
  r = new Readable();
  r.pipe(w);
  r.emit('end');
}
assert.strictEqual(r.listeners('end').length, 0);
assert.strictEqual(w.endCalls, limit);

w.endCalls = 0;

for (i = 0; i < limit; i++) {
  r = new Readable();
  r.pipe(w);
  r.emit('close');
}
assert.strictEqual(r.listeners('close').length, 0);
assert.strictEqual(w.endCalls, limit);

w.endCalls = 0;

r = new Readable();

for (i = 0; i < limit; i++) {
  w = new Writable();
  r.pipe(w);
  w.emit('close');
}
assert.strictEqual(w.listeners('close').length, 0);

r = new Readable();
w = new Writable();
const d = new Duplex();
r.pipe(d); // pipeline A
d.pipe(w); // pipeline B
assert.strictEqual(r.listeners('end').length, 2);   // A.onend, A.cleanup
assert.strictEqual(r.listeners('close').length, 2); // A.onclose, A.cleanup
assert.strictEqual(d.listeners('end').length, 2);   // B.onend, B.cleanup
// A.cleanup, B.onclose, B.cleanup
assert.strictEqual(d.listeners('close').length, 3);
assert.strictEqual(w.listeners('end').length, 0);
assert.strictEqual(w.listeners('close').length, 1); // B.cleanup

r.emit('end');
assert.strictEqual(d.endCalls, 1);
assert.strictEqual(w.endCalls, 0);
assert.strictEqual(r.listeners('end').length, 0);
assert.strictEqual(r.listeners('close').length, 0);
assert.strictEqual(d.listeners('end').length, 2);   // B.onend, B.cleanup
assert.strictEqual(d.listeners('close').length, 2); // B.onclose, B.cleanup
assert.strictEqual(w.listeners('end').length, 0);
assert.strictEqual(w.listeners('close').length, 1); // B.cleanup

d.emit('end');
assert.strictEqual(d.endCalls, 1);
assert.strictEqual(w.endCalls, 1);
assert.strictEqual(r.listeners('end').length, 0);
assert.strictEqual(r.listeners('close').length, 0);
assert.strictEqual(d.listeners('end').length, 0);
assert.strictEqual(d.listeners('close').length, 0);
assert.strictEqual(w.listeners('end').length, 0);
assert.strictEqual(w.listeners('close').length, 0);
                                                   node-23.7.0/test/parallel/test-stream-pipe-deadlock.js                                              0000664 0000000 0000000 00000001262 14746647661 0022636 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable, Writable } = require('stream');

// https://github.com/nodejs/node/issues/48666
(async () => {
  // Prepare src that is internally ended, with buffered data pending
  const src = new Readable({ read() {} });
  src.push(Buffer.alloc(100));
  src.push(null);
  src.pause();

  // Give it time to settle
  await new Promise((resolve) => setImmediate(resolve));

  const dst = new Writable({
    highWaterMark: 1000,
    write(buf, enc, cb) {
      process.nextTick(cb);
    }
  });

  dst.write(Buffer.alloc(1000)); // Fill write buffer
  dst.on('finish', common.mustCall());
  src.pipe(dst);
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-pipe-error-handling.js                                        0000664 0000000 0000000 00000006210 14746647661 0024001 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');
const { Stream, PassThrough } = require('stream');

{
  const source = new Stream();
  const dest = new Stream();

  source.pipe(dest);

  let gotErr = null;
  source.on('error', function(err) {
    gotErr = err;
  });

  const err = new Error('This stream turned into bacon.');
  source.emit('error', err);
  assert.strictEqual(gotErr, err);
}

{
  const source = new Stream();
  const dest = new Stream();

  source.pipe(dest);

  const err = new Error('This stream turned into bacon.');

  let gotErr = null;
  try {
    source.emit('error', err);
  } catch (e) {
    gotErr = e;
  }

  assert.strictEqual(gotErr, err);
}

{
  const R = Stream.Readable;
  const W = Stream.Writable;

  const r = new R({ autoDestroy: false });
  const w = new W({ autoDestroy: false });
  let removed = false;

  r._read = common.mustCall(function() {
    setTimeout(common.mustCall(function() {
      assert(removed);
      assert.throws(function() {
        w.emit('error', new Error('fail'));
      }, /^Error: fail$/);
    }), 1);
  });

  w.on('error', myOnError);
  r.pipe(w);
  w.removeListener('error', myOnError);
  removed = true;

  function myOnError() {
    throw new Error('this should not happen');
  }
}

{
  const R = Stream.Readable;
  const W = Stream.Writable;

  const r = new R();
  const w = new W();
  let removed = false;

  r._read = common.mustCall(function() {
    setTimeout(common.mustCall(function() {
      assert(removed);
      w.emit('error', new Error('fail'));
    }), 1);
  });

  w.on('error', common.mustCall());
  w._write = () => {};

  r.pipe(w);
  // Removing some OTHER random listener should not do anything
  w.removeListener('error', () => {});
  removed = true;
}

{
  const _err = new Error('this should be handled');
  const destination = new PassThrough();
  destination.once('error', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));

  const stream = new Stream();
  stream
    .pipe(destination);

  destination.destroy(_err);
}
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-pipe-error-unhandled.js                                       0000664 0000000 0000000 00000000635 14746647661 0024164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable, Writable } = require('stream');

process.on('uncaughtException', common.mustCall((err) => {
  assert.strictEqual(err.message, 'asd');
}));

const r = new Readable({
  read() {
    this.push('asd');
  }
});
const w = new Writable({
  autoDestroy: true,
  write() {}
});

r.pipe(w);
w.destroy(new Error('asd'));
                                                                                                   node-23.7.0/test/parallel/test-stream-pipe-event.js                                                 0000664 0000000 0000000 00000003364 14746647661 0022216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const stream = require('stream');
const assert = require('assert');

function Writable() {
  this.writable = true;
  stream.Stream.call(this);
}
Object.setPrototypeOf(Writable.prototype, stream.Stream.prototype);
Object.setPrototypeOf(Writable, stream.Stream);

function Readable() {
  this.readable = true;
  stream.Stream.call(this);
}
Object.setPrototypeOf(Readable.prototype, stream.Stream.prototype);
Object.setPrototypeOf(Readable, stream.Stream);

let passed = false;

const w = new Writable();
w.on('pipe', function(src) {
  passed = true;
});

const r = new Readable();
r.pipe(w);

assert.ok(passed);
                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-pipe-flow-after-unpipe.js                                     0000664 0000000 0000000 00000001362 14746647661 0024435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Readable, Writable } = require('stream');

// Tests that calling .unpipe() un-blocks a stream that is paused because
// it is waiting on the writable side to finish a write().

const rs = new Readable({
  highWaterMark: 1,
  // That this gets called at least 20 times is the real test here.
  read: common.mustCallAtLeast(() => rs.push('foo'), 20)
});

const ws = new Writable({
  highWaterMark: 1,
  write: common.mustCall(() => {
    // Ignore the callback, this write() simply never finishes.
    setImmediate(() => rs.unpipe(ws));
  })
});

let chunks = 0;
rs.on('data', common.mustCallAtLeast(() => {
  chunks++;
  if (chunks >= 20)
    rs.pause();  // Finish this test.
}));

rs.pipe(ws);
                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-pipe-flow.js                                                  0000664 0000000 0000000 00000003653 14746647661 0022045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable, Writable, PassThrough } = require('stream');

{
  let ticks = 17;

  const rs = new Readable({
    objectMode: true,
    read: () => {
      if (ticks-- > 0)
        return process.nextTick(() => rs.push({}));
      rs.push({});
      rs.push(null);
    }
  });

  const ws = new Writable({
    highWaterMark: 0,
    objectMode: true,
    write: (data, end, cb) => setImmediate(cb)
  });

  rs.on('end', common.mustCall());
  ws.on('finish', common.mustCall());
  rs.pipe(ws);
}

{
  let missing = 8;

  const rs = new Readable({
    objectMode: true,
    read: () => {
      if (missing--) rs.push({});
      else rs.push(null);
    }
  });

  const pt = rs
    .pipe(new PassThrough({ objectMode: true, highWaterMark: 2 }))
    .pipe(new PassThrough({ objectMode: true, highWaterMark: 2 }));

  pt.on('end', () => {
    wrapper.push(null);
  });

  const wrapper = new Readable({
    objectMode: true,
    read: () => {
      process.nextTick(() => {
        let data = pt.read();
        if (data === null) {
          pt.once('readable', () => {
            data = pt.read();
            if (data !== null) wrapper.push(data);
          });
        } else {
          wrapper.push(data);
        }
      });
    }
  });

  wrapper.resume();
  wrapper.on('end', common.mustCall());
}

{
  // Only register drain if there is backpressure.
  const rs = new Readable({ read() {} });

  const pt = rs
    .pipe(new PassThrough({ objectMode: true, highWaterMark: 2 }));
  assert.strictEqual(pt.listenerCount('drain'), 0);
  pt.on('finish', () => {
    assert.strictEqual(pt.listenerCount('drain'), 0);
  });

  rs.push('asd');
  assert.strictEqual(pt.listenerCount('drain'), 0);

  process.nextTick(() => {
    rs.push('asd');
    assert.strictEqual(pt.listenerCount('drain'), 0);
    rs.push(null);
    assert.strictEqual(pt.listenerCount('drain'), 0);
  });
}
                                                                                     node-23.7.0/test/parallel/test-stream-pipe-manual-resume.js                                         0000664 0000000 0000000 00000001372 14746647661 0023645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');

function test(throwCodeInbetween) {
  // Check that a pipe does not stall if .read() is called unexpectedly
  // (i.e. the stream is not resumed by the pipe).

  const n = 1000;
  let counter = n;
  const rs = stream.Readable({
    objectMode: true,
    read: common.mustCallAtLeast(() => {
      if (--counter >= 0)
        rs.push({ counter });
      else
        rs.push(null);
    }, n)
  });

  const ws = stream.Writable({
    objectMode: true,
    write: common.mustCall((data, enc, cb) => {
      setImmediate(cb);
    }, n)
  });

  setImmediate(() => throwCodeInbetween(rs, ws));

  rs.pipe(ws);
}

test((rs) => rs.read());
test((rs) => rs.resume());
test(() => 0);
                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-pipe-multiple-pipes.js                                        0000664 0000000 0000000 00000002332 14746647661 0024040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');
const assert = require('assert');

const readable = new stream.Readable({
  read: () => {}
});

const writables = [];

for (let i = 0; i < 5; i++) {
  const target = new stream.Writable({
    write: common.mustCall((chunk, encoding, callback) => {
      target.output.push(chunk);
      callback();
    }, 1)
  });
  target.output = [];

  target.on('pipe', common.mustCall());
  readable.pipe(target);


  writables.push(target);
}

const input = Buffer.from([1, 2, 3, 4, 5]);

readable.push(input);

// The pipe() calls will postpone emission of the 'resume' event using nextTick,
// so no data will be available to the writable streams until then.
process.nextTick(common.mustCall(() => {
  for (const target of writables) {
    assert.deepStrictEqual(target.output, [input]);

    target.on('unpipe', common.mustCall());
    readable.unpipe(target);
  }

  readable.push('something else'); // This does not get through.
  readable.push(null);
  readable.resume(); // Make sure the 'end' event gets emitted.
}));

readable.on('end', common.mustCall(() => {
  for (const target of writables) {
    assert.deepStrictEqual(target.output, [input]);
  }
}));
                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-pipe-needDrain.js                                             0000664 0000000 0000000 00000001122 14746647661 0022754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable, Writable } = require('stream');

// Pipe should pause temporarily if writable needs drain.
{
  const w = new Writable({
    write(buf, encoding, callback) {
      process.nextTick(callback);
    },
    highWaterMark: 1
  });

  while (w.write('asd'));

  assert.strictEqual(w.writableNeedDrain, true);

  const r = new Readable({
    read() {
      this.push('asd');
      this.push(null);
    }
  });

  r.on('pause', common.mustCall(2));
  r.on('end', common.mustCall());

  r.pipe(w);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-pipe-same-destination-twice.js                                0000664 0000000 0000000 00000004433 14746647661 0025450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// Regression test for https://github.com/nodejs/node/issues/12718.
// Tests that piping a source stream twice to the same destination stream
// works, and that a subsequent unpipe() call only removes the pipe *once*.
const assert = require('assert');
const { PassThrough, Writable } = require('stream');

{
  const passThrough = new PassThrough();
  const dest = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      assert.strictEqual(`${chunk}`, 'foobar');
      cb();
    })
  });

  passThrough.pipe(dest);
  passThrough.pipe(dest);

  assert.strictEqual(passThrough._events.data.length, 2);
  assert.strictEqual(passThrough._readableState.pipes.length, 2);
  assert.strictEqual(passThrough._readableState.pipes[0], dest);
  assert.strictEqual(passThrough._readableState.pipes[1], dest);

  passThrough.unpipe(dest);

  assert.strictEqual(passThrough._events.data.length, 1);
  assert.strictEqual(passThrough._readableState.pipes.length, 1);
  assert.deepStrictEqual(passThrough._readableState.pipes, [dest]);

  passThrough.write('foobar');
  passThrough.pipe(dest);
}

{
  const passThrough = new PassThrough();
  const dest = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      assert.strictEqual(`${chunk}`, 'foobar');
      cb();
    }, 2)
  });

  passThrough.pipe(dest);
  passThrough.pipe(dest);

  assert.strictEqual(passThrough._events.data.length, 2);
  assert.strictEqual(passThrough._readableState.pipes.length, 2);
  assert.strictEqual(passThrough._readableState.pipes[0], dest);
  assert.strictEqual(passThrough._readableState.pipes[1], dest);

  passThrough.write('foobar');
}

{
  const passThrough = new PassThrough();
  const dest = new Writable({
    write: common.mustNotCall()
  });

  passThrough.pipe(dest);
  passThrough.pipe(dest);

  assert.strictEqual(passThrough._events.data.length, 2);
  assert.strictEqual(passThrough._readableState.pipes.length, 2);
  assert.strictEqual(passThrough._readableState.pipes[0], dest);
  assert.strictEqual(passThrough._readableState.pipes[1], dest);

  passThrough.unpipe(dest);
  passThrough.unpipe(dest);

  assert.strictEqual(passThrough._events.data, undefined);
  assert.strictEqual(passThrough._readableState.pipes.length, 0);

  passThrough.write('foobar');
}
                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-pipe-unpipe-streams.js                                        0000664 0000000 0000000 00000005236 14746647661 0024051 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { Readable, Writable } = require('stream');

const source = Readable({ read: () => {} });
const dest1 = Writable({ write: () => {} });
const dest2 = Writable({ write: () => {} });

source.pipe(dest1);
source.pipe(dest2);

dest1.on('unpipe', common.mustCall());
dest2.on('unpipe', common.mustCall());

assert.strictEqual(source._readableState.pipes[0], dest1);
assert.strictEqual(source._readableState.pipes[1], dest2);
assert.strictEqual(source._readableState.pipes.length, 2);

// Should be able to unpipe them in the reverse order that they were piped.

source.unpipe(dest2);

assert.deepStrictEqual(source._readableState.pipes, [dest1]);
assert.notStrictEqual(source._readableState.pipes, dest2);

dest2.on('unpipe', common.mustNotCall());
source.unpipe(dest2);

source.unpipe(dest1);

assert.strictEqual(source._readableState.pipes.length, 0);

{
  // Test `cleanup()` if we unpipe all streams.
  const source = Readable({ read: () => {} });
  const dest1 = Writable({ write: () => {} });
  const dest2 = Writable({ write: () => {} });

  let destCount = 0;
  const srcCheckEventNames = ['end', 'data'];
  const destCheckEventNames = ['close', 'finish', 'drain', 'error', 'unpipe'];

  const checkSrcCleanup = common.mustCall(() => {
    assert.strictEqual(source._readableState.pipes.length, 0);
    assert.strictEqual(source._readableState.flowing, false);
    for (const eventName of srcCheckEventNames) {
      assert.strictEqual(
        source.listenerCount(eventName), 0,
        `source's '${eventName}' event listeners not removed`
      );
    }
  });

  function checkDestCleanup(dest) {
    const currentDestId = ++destCount;
    source.pipe(dest);

    const unpipeChecker = common.mustCall(() => {
      assert.deepStrictEqual(
        dest.listeners('unpipe'), [unpipeChecker],
        `destination{${currentDestId}} should have a 'unpipe' event ` +
        'listener which is `unpipeChecker`'
      );
      dest.removeListener('unpipe', unpipeChecker);
      for (const eventName of destCheckEventNames) {
        assert.strictEqual(
          dest.listenerCount(eventName), 0,
          `destination{${currentDestId}}'s '${eventName}' event ` +
          'listeners not removed'
        );
      }

      if (--destCount === 0)
        checkSrcCleanup();
    });

    dest.on('unpipe', unpipeChecker);
  }

  checkDestCleanup(dest1);
  checkDestCleanup(dest2);
  source.unpipe();
}

{
  const src = Readable({ read: () => {} });
  const dst = Writable({ write: () => {} });
  src.pipe(dst);
  src.on('resume', common.mustCall(() => {
    src.on('pause', common.mustCall());
    src.unpipe(dst);
  }));
}
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-stream-pipe-without-listenerCount.js                                 0000664 0000000 0000000 00000000635 14746647661 0025432 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const stream = require('stream');

const r = new stream.Stream();
r.listenerCount = undefined;

const w = new stream.Stream();
w.listenerCount = undefined;

w.on('pipe', function() {
  r.emit('error', new Error('Readable Error'));
  w.emit('error', new Error('Writable Error'));
});
r.on('error', common.mustCall());
w.on('error', common.mustCall());
r.pipe(w);
                                                                                                   node-23.7.0/test/parallel/test-stream-pipeline-async-iterator.js                                    0000664 0000000 0000000 00000001167 14746647661 0024710 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable, PassThrough, pipeline } = require('stream');
const assert = require('assert');

const _err = new Error('kaboom');

async function run() {
  const source = new Readable({
    read() {
    }
  });
  source.push('hello');
  source.push('world');

  setImmediate(() => { source.destroy(_err); });

  const iterator = pipeline(
    source,
    new PassThrough(),
    () => {});

  iterator.setEncoding('utf8');

  for await (const k of iterator) {
    assert.strictEqual(k, 'helloworld');
  }
}

run().catch(common.mustCall((err) => assert.strictEqual(err, _err)));
                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-pipeline-duplex.js                                            0000664 0000000 0000000 00000000677 14746647661 0023252 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { pipeline, Duplex, PassThrough } = require('stream');
const assert = require('assert');

const remote = new PassThrough();
const local = new Duplex({
  read() {},
  write(chunk, enc, callback) {
    callback();
  }
});

pipeline(remote, local, remote, common.mustCall((err) => {
  assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
}));

setImmediate(() => {
  remote.end();
});
                                                                 node-23.7.0/test/parallel/test-stream-pipeline-http2.js                                             0000664 0000000 0000000 00000001416 14746647661 0023002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');
const { Readable, pipeline } = require('stream');
const http2 = require('http2');

{
  const server = http2.createServer((req, res) => {
    pipeline(req, res, common.mustCall());
  });

  server.listen(0, () => {
    const url = `http://localhost:${server.address().port}`;
    const client = http2.connect(url);
    const req = client.request({ ':method': 'POST' });

    const rs = new Readable({
      read() {
        rs.push('hello');
      }
    });

    pipeline(rs, req, common.mustCall((err) => {
      server.close();
      client.close();
    }));

    let cnt = 10;
    req.on('data', (data) => {
      cnt--;
      if (cnt === 0) rs.destroy();
    });
  });
}
                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-stream-pipeline-listeners.js                                         0000664 0000000 0000000 00000003451 14746647661 0023752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { pipeline, Duplex, PassThrough, Writable } = require('stream');
const assert = require('assert');

process.on('uncaughtException', common.mustCall((err) => {
  assert.strictEqual(err.message, 'no way');
}, 2));

// Ensure that listeners is removed if last stream is readable
// And other stream's listeners unchanged
const a = new PassThrough();
a.end('foobar');
const b = new Duplex({
  write(chunk, encoding, callback) {
    callback();
  }
});
pipeline(a, b, common.mustCall((error) => {
  if (error) {
    assert.ifError(error);
  }

  assert(a.listenerCount('error') > 0);
  assert.strictEqual(b.listenerCount('error'), 0);
  setTimeout(() => {
    assert.strictEqual(b.listenerCount('error'), 0);
    b.destroy(new Error('no way'));
  }, 100);
}));

// Async generators
const c = new PassThrough();
c.end('foobar');
const d = pipeline(
  c,
  async function* (source) {
    for await (const chunk of source) {
      yield String(chunk).toUpperCase();
    }
  },
  common.mustCall((error) => {
    if (error) {
      assert.ifError(error);
    }

    assert(c.listenerCount('error') > 0);
    assert.strictEqual(d.listenerCount('error'), 0);
    setTimeout(() => {
      assert.strictEqual(b.listenerCount('error'), 0);
      d.destroy(new Error('no way'));
    }, 100);
  })
);

// If last stream is not readable, will not throw and remove listeners
const e = new PassThrough();
e.end('foobar');
const f = new Writable({
  write(chunk, encoding, callback) {
    callback();
  }
});
pipeline(e, f, common.mustCall((error) => {
  if (error) {
    assert.ifError(error);
  }

  assert(e.listenerCount('error') > 0);
  assert(f.listenerCount('error') > 0);
  setTimeout(() => {
    assert(f.listenerCount('error') > 0);
    f.destroy(new Error('no way'));
  }, 100);
}));
                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stream-pipeline-process.js                                           0000664 0000000 0000000 00000001017 14746647661 0023414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const os = require('os');

if (process.argv[2] === 'child') {
  const { pipeline } = require('stream');
  pipeline(
    process.stdin,
    process.stdout,
    common.mustSucceed()
  );
} else {
  const cp = require('child_process');
  cp.exec(...common.escapePOSIXShell`echo hello | "${process.execPath}" "${__filename}" child`, common.mustSucceed((stdout) => {
    assert.strictEqual(stdout.split(os.EOL).shift().trim(), 'hello');
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stream-pipeline-queued-end-in-destroy.js                             0000664 0000000 0000000 00000002126 14746647661 0026067 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable, Duplex, pipeline } = require('stream');

// Test that the callback for pipeline() is called even when the ._destroy()
// method of the stream places an .end() request to itself that does not
// get processed before the destruction of the stream (i.e. the 'close' event).
// Refs: https://github.com/nodejs/node/issues/24456

const readable = new Readable({
  read: common.mustCall()
});

const duplex = new Duplex({
  write(chunk, enc, cb) {
    // Simulate messages queueing up.
  },
  read() {},
  destroy(err, cb) {
    // Call end() from inside the destroy() method, like HTTP/2 streams
    // do at the time of writing.
    this.end();
    cb(err);
  }
});

duplex.on('finished', common.mustNotCall());

pipeline(readable, duplex, common.mustCall((err) => {
  assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
}));

// Write one chunk of data, and destroy the stream later.
// That should trigger the pipeline destruction.
readable.push('foo');
setImmediate(() => {
  readable.destroy();
});
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-stream-pipeline-uncaught.js                                          0000664 0000000 0000000 00000001104 14746647661 0023551 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  pipeline,
  PassThrough
} = require('stream');
const assert = require('assert');

process.on('uncaughtException', common.mustCall((err) => {
  assert.strictEqual(err.message, 'error');
}));

// Ensure that pipeline that ends with Promise
// still propagates error to uncaughtException.
const s = new PassThrough();
s.end('data');
pipeline(s, async function(source) {
  for await (const chunk of source) { } // eslint-disable-line no-unused-vars, no-empty
}, common.mustSucceed(() => {
  throw new Error('error');
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-pipeline-with-empty-string.js                                 0000664 0000000 0000000 00000000421 14746647661 0025347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  pipeline,
  PassThrough
} = require('stream');


async function runTest() {
  await pipeline(
    '',
    new PassThrough({ objectMode: true }),
    common.mustCall(),
  );
}

runTest().then(common.mustCall());
                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-pipeline.js                                                   0000664 0000000 0000000 00000106677 14746647661 0021762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Stream,
  Writable,
  Readable,
  Transform,
  pipeline,
  PassThrough,
  Duplex,
  addAbortSignal,
} = require('stream');
const pipelinep = require('stream/promises').pipeline;
const assert = require('assert');
const http = require('http');
const { promisify } = require('util');
const net = require('net');
const tsp = require('timers/promises');
const tmpdir = require('../common/tmpdir');
const fs = require('fs');

{
  let finished = false;
  const processed = [];
  const expected = [
    Buffer.from('a'),
    Buffer.from('b'),
    Buffer.from('c'),
  ];

  const read = new Readable({
    read() {}
  });

  const write = new Writable({
    write(data, enc, cb) {
      processed.push(data);
      cb();
    }
  });

  write.on('finish', () => {
    finished = true;
  });

  for (let i = 0; i < expected.length; i++) {
    read.push(expected[i]);
  }
  read.push(null);

  pipeline(read, write, common.mustSucceed(() => {
    assert.ok(finished);
    assert.deepStrictEqual(processed, expected);
  }));
}

{
  const read = new Readable({
    read() {}
  });

  assert.throws(() => {
    pipeline(read, () => {});
  }, /ERR_MISSING_ARGS/);
  assert.throws(() => {
    pipeline(() => {});
  }, /ERR_MISSING_ARGS/);
  assert.throws(() => {
    pipeline();
  }, /ERR_INVALID_ARG_TYPE/);
}

tmpdir.refresh();
{
  assert.rejects(async () => {
    const read = fs.createReadStream(__filename);
    const write = fs.createWriteStream(tmpdir.resolve('a'));
    const close = promisify(write.close);
    await close.call(write);
    await pipelinep(read, write);
  }, /ERR_STREAM_UNABLE_TO_PIPE/).then(common.mustCall());
}

{
  const read = new Readable({
    read() {}
  });

  const write = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  read.push('data');
  setImmediate(() => read.destroy());

  pipeline(read, write, common.mustCall((err) => {
    assert.ok(err, 'should have an error');
  }));
}

{
  const read = new Readable({
    read() {}
  });

  const write = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  read.push('data');
  setImmediate(() => read.destroy(new Error('kaboom')));

  const dst = pipeline(read, write, common.mustCall((err) => {
    assert.deepStrictEqual(err, new Error('kaboom'));
  }));

  assert.strictEqual(dst, write);
}

{
  const read = new Readable({
    read() {}
  });

  const transform = new Transform({
    transform(data, enc, cb) {
      cb(new Error('kaboom'));
    }
  });

  const write = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  read.on('close', common.mustCall());
  transform.on('close', common.mustCall());
  write.on('close', common.mustCall());

  [read, transform, write].forEach((stream) => {
    stream.on('error', common.mustCall((err) => {
      assert.deepStrictEqual(err, new Error('kaboom'));
    }));
  });

  const dst = pipeline(read, transform, write, common.mustCall((err) => {
    assert.deepStrictEqual(err, new Error('kaboom'));
  }));

  assert.strictEqual(dst, write);

  read.push('hello');
}

{
  const server = http.createServer((req, res) => {
    const rs = new Readable({
      read() {
        rs.push('hello');
        rs.push(null);
      }
    });

    pipeline(rs, res, () => {});
  });

  server.listen(0, () => {
    const req = http.request({
      port: server.address().port
    });

    req.end();
    req.on('response', (res) => {
      const buf = [];
      res.on('data', (data) => buf.push(data));
      res.on('end', common.mustCall(() => {
        assert.deepStrictEqual(
          Buffer.concat(buf),
          Buffer.from('hello')
        );
        server.close();
      }));
    });
  });
}

{
  const server = http.createServer((req, res) => {
    let sent = false;
    const rs = new Readable({
      read() {
        if (sent) {
          return;
        }
        sent = true;
        rs.push('hello');
      },
      destroy: common.mustCall((err, cb) => {
        // Prevents fd leaks by destroying http pipelines
        cb();
      })
    });

    pipeline(rs, res, () => {});
  });

  server.listen(0, () => {
    const req = http.request({
      port: server.address().port
    });

    req.end();
    req.on('response', (res) => {
      setImmediate(() => {
        res.destroy();
        server.close();
      });
    });
  });
}

{
  const server = http.createServer((req, res) => {
    let sent = 0;
    const rs = new Readable({
      read() {
        if (sent++ > 10) {
          return;
        }
        rs.push('hello');
      },
      destroy: common.mustCall((err, cb) => {
        cb();
      })
    });

    pipeline(rs, res, () => {});
  });

  let cnt = 10;

  const badSink = new Writable({
    write(data, enc, cb) {
      cnt--;
      if (cnt === 0) cb(new Error('kaboom'));
      else cb();
    }
  });

  server.listen(0, () => {
    const req = http.request({
      port: server.address().port
    });

    req.end();
    req.on('response', (res) => {
      pipeline(res, badSink, common.mustCall((err) => {
        assert.deepStrictEqual(err, new Error('kaboom'));
        server.close();
      }));
    });
  });
}

{
  const server = http.createServer((req, res) => {
    pipeline(req, res, common.mustSucceed());
  });

  server.listen(0, () => {
    const req = http.request({
      port: server.address().port
    });

    let sent = 0;
    const rs = new Readable({
      read() {
        if (sent++ > 10) {
          return;
        }
        rs.push('hello');
      }
    });

    pipeline(rs, req, common.mustCall(() => {
      server.close();
    }));

    req.on('response', (res) => {
      let cnt = 10;
      res.on('data', () => {
        cnt--;
        if (cnt === 0) rs.destroy();
      });
    });
  });
}

{
  const makeTransform = () => {
    const tr = new Transform({
      transform(data, enc, cb) {
        cb(null, data);
      }
    });

    tr.on('close', common.mustCall());
    return tr;
  };

  const rs = new Readable({
    read() {
      rs.push('hello');
    }
  });

  let cnt = 10;

  const ws = new Writable({
    write(data, enc, cb) {
      cnt--;
      if (cnt === 0) return cb(new Error('kaboom'));
      cb();
    }
  });

  rs.on('close', common.mustCall());
  ws.on('close', common.mustCall());

  pipeline(
    rs,
    makeTransform(),
    makeTransform(),
    makeTransform(),
    makeTransform(),
    makeTransform(),
    makeTransform(),
    ws,
    common.mustCall((err) => {
      assert.deepStrictEqual(err, new Error('kaboom'));
    })
  );
}

{
  const oldStream = new Stream();

  oldStream.pause = oldStream.resume = () => {};
  oldStream.write = (data) => {
    oldStream.emit('data', data);
    return true;
  };
  oldStream.end = () => {
    oldStream.emit('end');
  };

  const expected = [
    Buffer.from('hello'),
    Buffer.from('world'),
  ];

  const rs = new Readable({
    read() {
      for (let i = 0; i < expected.length; i++) {
        rs.push(expected[i]);
      }
      rs.push(null);
    }
  });

  const ws = new Writable({
    write(data, enc, cb) {
      assert.deepStrictEqual(data, expected.shift());
      cb();
    }
  });

  let finished = false;

  ws.on('finish', () => {
    finished = true;
  });

  pipeline(
    rs,
    oldStream,
    ws,
    common.mustSucceed(() => {
      assert(finished, 'last stream finished');
    })
  );
}

{
  const oldStream = new Stream();

  oldStream.pause = oldStream.resume = () => {};
  oldStream.write = (data) => {
    oldStream.emit('data', data);
    return true;
  };
  oldStream.end = () => {
    oldStream.emit('end');
  };

  const destroyableOldStream = new Stream();

  destroyableOldStream.pause = destroyableOldStream.resume = () => {};
  destroyableOldStream.destroy = common.mustCall(() => {
    destroyableOldStream.emit('close');
  });
  destroyableOldStream.write = (data) => {
    destroyableOldStream.emit('data', data);
    return true;
  };
  destroyableOldStream.end = () => {
    destroyableOldStream.emit('end');
  };

  const rs = new Readable({
    read() {
      rs.destroy(new Error('stop'));
    }
  });

  const ws = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  let finished = false;

  ws.on('finish', () => {
    finished = true;
  });

  pipeline(
    rs,
    oldStream,
    destroyableOldStream,
    ws,
    common.mustCall((err) => {
      assert.deepStrictEqual(err, new Error('stop'));
      assert(!finished, 'should not finish');
    })
  );
}

{
  const pipelinePromise = promisify(pipeline);

  async function run() {
    const read = new Readable({
      read() {}
    });

    const write = new Writable({
      write(data, enc, cb) {
        cb();
      }
    });

    read.push('data');
    read.push(null);

    let finished = false;

    write.on('finish', () => {
      finished = true;
    });

    await pipelinePromise(read, write);

    assert(finished);
  }

  run();
}

{
  // Check aborted signal without values
  const pipelinePromise = promisify(pipeline);
  async function run() {
    const ac = new AbortController();
    const { signal } = ac;
    async function* producer() {
      ac.abort();
      await Promise.resolve();
      yield '8';
    }

    const w = new Writable({
      write(chunk, encoding, callback) {
        callback();
      }
    });
    await pipelinePromise(producer, w, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}

{
  // Check aborted signal after init.
  const pipelinePromise = promisify(pipeline);
  async function run() {
    const ac = new AbortController();
    const { signal } = ac;
    async function* producer() {
      yield '5';
      await Promise.resolve();
      ac.abort();
      await Promise.resolve();
      yield '8';
    }

    const w = new Writable({
      write(chunk, encoding, callback) {
        callback();
      }
    });
    await pipelinePromise(producer, w, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}

{
  // Check pre-aborted signal
  const pipelinePromise = promisify(pipeline);
  async function run() {
    const signal = AbortSignal.abort();
    async function* producer() {
      yield '5';
      await Promise.resolve();
      yield '8';
    }

    const w = new Writable({
      write(chunk, encoding, callback) {
        callback();
      }
    });
    await pipelinePromise(producer, w, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}

{
  const read = new Readable({
    read() {}
  });

  const transform = new Transform({
    transform(data, enc, cb) {
      cb(new Error('kaboom'));
    }
  });

  const write = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  assert.throws(
    () => pipeline(read, transform, write),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}

{
  const server = http.Server(function(req, res) {
    res.write('asd');
  });
  server.listen(0, function() {
    http.get({ port: this.address().port }, (res) => {
      const stream = new PassThrough();

      stream.on('error', common.mustCall());

      pipeline(
        res,
        stream,
        common.mustCall((err) => {
          assert.strictEqual(err.message, 'oh no');
          server.close();
        })
      );

      stream.destroy(new Error('oh no'));
    }).on('error', common.mustNotCall());
  });
}

{
  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    }
  });
  pipeline(function*() {
    yield 'hello';
    yield 'world';
  }(), w, common.mustSucceed(() => {
    assert.strictEqual(res, 'helloworld');
  }));
}

{
  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    }
  });
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }(), w, common.mustSucceed(() => {
    assert.strictEqual(res, 'helloworld');
  }));
}

{
  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    }
  });
  pipeline(function*() {
    yield 'hello';
    yield 'world';
  }, w, common.mustSucceed(() => {
    assert.strictEqual(res, 'helloworld');
  }));
}

{
  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    }
  });
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, w, common.mustSucceed(() => {
    assert.strictEqual(res, 'helloworld');
  }));
}

{
  let res = '';
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, async function*(source) {
    for await (const chunk of source) {
      yield chunk.toUpperCase();
    }
  }, async function(source) {
    for await (const chunk of source) {
      res += chunk;
    }
  }, common.mustSucceed(() => {
    assert.strictEqual(res, 'HELLOWORLD');
  }));
}

{
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, async function*(source) {
    for await (const chunk of source) {
      yield chunk.toUpperCase();
    }
  }, async function(source) {
    let ret = '';
    for await (const chunk of source) {
      ret += chunk;
    }
    return ret;
  }, common.mustSucceed((val) => {
    assert.strictEqual(val, 'HELLOWORLD');
  }));
}

{
  // AsyncIterable destination is returned and finalizes.

  const ret = pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
  }, async function*(source) { // eslint-disable-line require-yield
    for await (const chunk of source) { } // eslint-disable-line no-unused-vars, no-empty
  }, common.mustCall((err) => {
    assert.strictEqual(err, undefined);
  }));
  ret.resume();
  assert.strictEqual(typeof ret.pipe, 'function');
}

{
  // AsyncFunction destination is not returned and error is
  // propagated.

  const ret = pipeline(async function*() { // eslint-disable-line require-yield
    await Promise.resolve();
    throw new Error('kaboom');
  }, async function*(source) { // eslint-disable-line require-yield
    for await (const chunk of source) { } // eslint-disable-line no-unused-vars, no-empty
  }, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
  }));
  ret.resume();
  assert.strictEqual(typeof ret.pipe, 'function');
}

{
  const s = new PassThrough();
  pipeline(async function*() { // eslint-disable-line require-yield
    throw new Error('kaboom');
  }, s, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(s.destroyed, true);
  }));
}

{
  const s = new PassThrough();
  pipeline(async function*() { // eslint-disable-line require-yield
    throw new Error('kaboom');
  }(), s, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(s.destroyed, true);
  }));
}

{
  const s = new PassThrough();
  pipeline(function*() { // eslint-disable-line require-yield
    throw new Error('kaboom');
  }, s, common.mustCall((err, val) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(s.destroyed, true);
  }));
}

{
  const s = new PassThrough();
  pipeline(function*() { // eslint-disable-line require-yield
    throw new Error('kaboom');
  }(), s, common.mustCall((err, val) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(s.destroyed, true);
  }));
}

{
  const s = new PassThrough();
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, s, async function(source) {
    for await (const chunk of source) { // eslint-disable-line no-unused-vars
      throw new Error('kaboom');
    }
  }, common.mustCall((err, val) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(s.destroyed, true);
  }));
}

{
  const s = new PassThrough();
  const ret = pipeline(function() {
    return ['hello', 'world'];
  }, s, async function*(source) { // eslint-disable-line require-yield
    for await (const chunk of source) { // eslint-disable-line no-unused-vars
      throw new Error('kaboom');
    }
  }, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(s.destroyed, true);
  }));
  ret.resume();
  assert.strictEqual(typeof ret.pipe, 'function');
}

{
  // Legacy streams without async iterator.

  const s = new PassThrough();
  s.push('asd');
  s.push(null);
  s[Symbol.asyncIterator] = null;
  let ret = '';
  pipeline(s, async function(source) {
    for await (const chunk of source) {
      ret += chunk;
    }
  }, common.mustCall((err) => {
    assert.strictEqual(err, undefined);
    assert.strictEqual(ret, 'asd');
  }));
}

{
  // v1 streams without read().

  const s = new Stream();
  process.nextTick(() => {
    s.emit('data', 'asd');
    s.emit('end');
  });
  // 'destroyer' can be called multiple times,
  // once from stream wrapper and
  // once from iterator wrapper.
  s.close = common.mustCallAtLeast(1);
  let ret = '';
  pipeline(s, async function(source) {
    for await (const chunk of source) {
      ret += chunk;
    }
  }, common.mustCall((err) => {
    assert.strictEqual(err, undefined);
    assert.strictEqual(ret, 'asd');
  }));
}

{
  // v1 error streams without read().

  const s = new Stream();
  process.nextTick(() => {
    s.emit('error', new Error('kaboom'));
  });
  s.destroy = common.mustCall();
  pipeline(s, async function(source) {
  }, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
  }));
}

{
  const s = new PassThrough();
  assert.throws(() => {
    pipeline(function(source) {
    }, s, () => {});
  }, (err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_RETURN_VALUE');
    assert.strictEqual(s.destroyed, false);
    return true;
  });
}

{
  const s = new PassThrough();
  assert.throws(() => {
    pipeline(s, function(source) {
    }, s, () => {});
  }, (err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_RETURN_VALUE');
    assert.strictEqual(s.destroyed, false);
    return true;
  });
}

{
  const s = new PassThrough();
  assert.throws(() => {
    pipeline(s, function(source) {
    }, () => {});
  }, (err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_RETURN_VALUE');
    assert.strictEqual(s.destroyed, false);
    return true;
  });
}

{
  const s = new PassThrough();
  assert.throws(() => {
    pipeline(s, function*(source) {
    }, () => {});
  }, (err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_RETURN_VALUE');
    assert.strictEqual(s.destroyed, false);
    return true;
  });
}

{
  let res = '';
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, new Transform({
    transform(chunk, encoding, cb) {
      cb(new Error('kaboom'));
    }
  }), async function(source) {
    for await (const chunk of source) {
      res += chunk;
    }
  }, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(res, '');
  }));
}

{
  let res = '';
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, new Transform({
    transform(chunk, encoding, cb) {
      process.nextTick(cb, new Error('kaboom'));
    }
  }), async function(source) {
    for await (const chunk of source) {
      res += chunk;
    }
  }, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(res, '');
  }));
}

{
  let res = '';
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
  }, new Transform({
    decodeStrings: false,
    transform(chunk, encoding, cb) {
      cb(null, chunk.toUpperCase());
    }
  }), async function(source) {
    for await (const chunk of source) {
      res += chunk;
    }
  }, common.mustSucceed(() => {
    assert.strictEqual(res, 'HELLOWORLD');
  }));
}

{
  // Ensure no unhandled rejection from async function.

  pipeline(async function*() {
    yield 'hello';
  }, async function(source) {
    throw new Error('kaboom');
  }, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
  }));
}

{
  const src = new PassThrough({ autoDestroy: false });
  const dst = new PassThrough({ autoDestroy: false });
  pipeline(src, dst, common.mustCall(() => {
    assert.strictEqual(src.destroyed, false);
    assert.strictEqual(dst.destroyed, false);
  }));
  src.end();
}

{
  // Make sure 'close' before 'end' finishes without error
  // if readable has received eof.
  // Ref: https://github.com/nodejs/node/issues/29699
  const r = new Readable();
  const w = new Writable({
    write(chunk, encoding, cb) {
      cb();
    }
  });
  pipeline(r, w, (err) => {
    assert.strictEqual(err, undefined);
  });
  r.push('asd');
  r.push(null);
  r.emit('close');
}

{
  const server = http.createServer((req, res) => {
  });

  server.listen(0, () => {
    const req = http.request({
      port: server.address().port
    });

    const body = new PassThrough();
    pipeline(
      body,
      req,
      common.mustSucceed(() => {
        assert(!req.res);
        assert(!req.aborted);
        req.abort();
        server.close();
      })
    );
    body.end();
  });
}

{
  const src = new PassThrough();
  const dst = new PassThrough();
  pipeline(src, dst, common.mustSucceed(() => {
    assert.strictEqual(dst.destroyed, false);
  }));
  src.end();
}

{
  const src = new PassThrough();
  const dst = new PassThrough();
  dst.readable = false;
  pipeline(src, dst, common.mustSucceed(() => {
    assert.strictEqual(dst.destroyed, true);
  }));
  src.end();
}

{
  let res = '';
  const rs = new Readable({
    read() {
      setImmediate(() => {
        rs.push('hello');
      });
    }
  });
  const ws = new Writable({
    write: common.mustNotCall()
  });
  pipeline(rs, async function*(stream) { // eslint-disable-line require-yield
    for await (const chunk of stream) { // eslint-disable-line no-unused-vars
      throw new Error('kaboom');
    }
  }, async function *(source) { // eslint-disable-line require-yield
    for await (const chunk of source) {
      res += chunk;
    }
  }, ws, common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(res, '');
  }));
}

{
  const server = http.createServer((req, res) => {
    req.socket.on('error', common.mustNotCall());
    pipeline(req, new PassThrough(), (err) => {
      assert.ifError(err);
      res.end();
      server.close();
    });
  });

  server.listen(0, () => {
    const req = http.request({
      method: 'PUT',
      port: server.address().port
    });
    req.end('asd123');
    req.on('response', common.mustCall());
    req.on('error', common.mustNotCall());
  });
}

{
  // Might still want to be able to use the writable side
  // of src. This is in the case where e.g. the Duplex input
  // is not directly connected to its output. Such a case could
  // happen when the Duplex is reading from a socket and then echos
  // the data back on the same socket.
  const src = new PassThrough();
  assert.strictEqual(src.writable, true);
  const dst = new PassThrough();
  pipeline(src, dst, common.mustCall((err) => {
    assert.strictEqual(src.writable, true);
    assert.strictEqual(src.destroyed, false);
  }));
  src.push(null);
}

{
  const src = new PassThrough();
  const dst = pipeline(
    src,
    async function * (source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
    })
  );
  src.push('asd');
  dst.destroy();
}

{
  pipeline(async function * () {
    yield 'asd';
  }, async function * (source) {
    for await (const chunk of source) {
      yield { chunk };
    }
  }, common.mustSucceed());
}

{
  let closed = false;
  const src = new Readable({
    read() {},
    destroy(err, cb) {
      process.nextTick(cb);
    }
  });
  const dst = new Writable({
    write(chunk, encoding, callback) {
      callback();
    }
  });
  src.on('close', () => {
    closed = true;
  });
  src.push(null);
  pipeline(src, dst, common.mustCall((err) => {
    assert.strictEqual(closed, true);
  }));
}

{
  let closed = false;
  const src = new Readable({
    read() {},
    destroy(err, cb) {
      process.nextTick(cb);
    }
  });
  const dst = new Duplex({});
  src.on('close', common.mustCall(() => {
    closed = true;
  }));
  src.push(null);
  pipeline(src, dst, common.mustCall((err) => {
    assert.strictEqual(closed, true);
  }));
}

{
  const server = net.createServer(common.mustCall((socket) => {
    // echo server
    pipeline(socket, socket, common.mustSucceed());
    // 13 force destroys the socket before it has a chance to emit finish
    socket.on('finish', common.mustCall(() => {
      server.close();
    }));
  })).listen(0, common.mustCall(() => {
    const socket = net.connect(server.address().port);
    socket.end();
  }));
}

{
  const d = new Duplex({
    autoDestroy: false,
    write: common.mustCall((data, enc, cb) => {
      d.push(data);
      cb();
    }),
    read: common.mustCall(() => {
      d.push(null);
    }),
    final: common.mustCall((cb) => {
      setTimeout(() => {
        assert.strictEqual(d.destroyed, false);
        cb();
      }, 1000);
    }),
    destroy: common.mustNotCall()
  });

  const sink = new Writable({
    write: common.mustCall((data, enc, cb) => {
      cb();
    })
  });

  pipeline(d, sink, common.mustSucceed());

  d.write('test');
  d.end();
}

{
  const server = net.createServer(common.mustCall((socket) => {
    // echo server
    pipeline(socket, socket, common.mustSucceed());
    socket.on('finish', common.mustCall(() => {
      server.close();
    }));
  })).listen(0, common.mustCall(() => {
    const socket = net.connect(server.address().port);
    socket.end();
  }));
}

{
  const d = new Duplex({
    autoDestroy: false,
    write: common.mustCall((data, enc, cb) => {
      d.push(data);
      cb();
    }),
    read: common.mustCall(() => {
      d.push(null);
    }),
    final: common.mustCall((cb) => {
      setTimeout(() => {
        assert.strictEqual(d.destroyed, false);
        cb();
      }, 1000);
    }),
    // `destroy()` won't be invoked by pipeline since
    // the writable side has not completed when
    // the pipeline has completed.
    destroy: common.mustNotCall()
  });

  const sink = new Writable({
    write: common.mustCall((data, enc, cb) => {
      cb();
    })
  });

  pipeline(d, sink, common.mustSucceed());

  d.write('test');
  d.end();
}

{
  const r = new Readable({
    read() {}
  });
  r.push('hello');
  r.push('world');
  r.push(null);
  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    }
  });
  pipeline([r, w], common.mustSucceed(() => {
    assert.strictEqual(res, 'helloworld');
  }));
}

{
  let flushed = false;
  const makeStream = () =>
    new Transform({
      transform: (chunk, enc, cb) => cb(null, chunk),
      flush: (cb) =>
        setTimeout(() => {
          flushed = true;
          cb(null);
        }, 1),
    });

  const input = new Readable();
  input.push(null);

  pipeline(
    input,
    makeStream(),
    common.mustCall(() => {
      assert.strictEqual(flushed, true);
    }),
  );
}
{
  function createThenable() {
    let counter = 0;
    return {
      get then() {
        if (counter++) {
          throw new Error('Cannot access `then` more than once');
        }
        return Function.prototype;
      },
    };
  }

  pipeline(
    function* () {
      yield 0;
    },
    createThenable,
    () => common.mustNotCall(),
  );
}


{
  const ac = new AbortController();
  const reason = new Error('Reason');
  const r = Readable.from(async function* () {
    for (let i = 0; i < 10; i++) {
      await Promise.resolve();
      yield String(i);
      if (i === 5) {
        ac.abort(reason);
      }
    }
  }());
  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    }
  });
  const cb = common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.strictEqual(err.cause, reason);
    assert.strictEqual(res, '012345');
    assert.strictEqual(w.destroyed, true);
    assert.strictEqual(r.destroyed, true);
    assert.strictEqual(pipelined.destroyed, true);
  });
  const pipelined = addAbortSignal(ac.signal, pipeline([r, w], cb));
}

{
  pipeline([1, 2, 3], PassThrough({ objectMode: true }),
           common.mustSucceed(() => {}));

  let res = '';
  const w = new Writable({
    write(chunk, encoding, callback) {
      res += chunk;
      callback();
    },
  });
  pipeline(['1', '2', '3'], w, common.mustSucceed(() => {
    assert.strictEqual(res, '123');
  }));
}

{
  const content = 'abc';
  pipeline(Buffer.from(content), PassThrough({ objectMode: true }),
           common.mustSucceed(() => {}));

  let res = '';
  pipeline(Buffer.from(content), async function*(previous) {
    for await (const val of previous) {
      res += String.fromCharCode(val);
      yield val;
    }
  }, common.mustSucceed(() => {
    assert.strictEqual(res, content);
  }));
}

{
  const ac = new AbortController();
  const signal = ac.signal;
  pipelinep(
    async function * ({ signal }) { // eslint-disable-line require-yield
      await tsp.setTimeout(1e6, signal);
    },
    async function(source) {

    },
    { signal }
  ).catch(common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
  ac.abort();
}

{
  async function run() {
    let finished = false;
    let text = '';
    const write = new Writable({
      write(data, enc, cb) {
        text += data;
        cb();
      }
    });
    write.on('finish', () => {
      finished = true;
    });

    await pipelinep([Readable.from('Hello World!'), write]);
    assert(finished);
    assert.strictEqual(text, 'Hello World!');
  }

  run();
}

{
  let finished = false;
  let text = '';
  const write = new Writable({
    write(data, enc, cb) {
      text += data;
      cb();
    }
  });
  write.on('finish', () => {
    finished = true;
  });

  pipeline([Readable.from('Hello World!'), write], common.mustSucceed(() => {
    assert(finished);
    assert.strictEqual(text, 'Hello World!');
  }));
}

{
  const pipelinePromise = promisify(pipeline);

  async function run() {
    const read = new Readable({
      read() {}
    });

    const duplex = new PassThrough();

    read.push(null);

    await pipelinePromise(read, duplex);

    assert.strictEqual(duplex.destroyed, false);
  }

  run().then(common.mustCall());
}

{
  const pipelinePromise = promisify(pipeline);

  async function run() {
    const read = new Readable({
      read() {}
    });

    const duplex = new PassThrough();
    const transform = new PassThrough();

    read.push(null);

    await pipelinePromise(read, transform, duplex, { end: false });

    assert.strictEqual(transform.destroyed, true);
    assert.strictEqual(transform.writableEnded, true);

    assert.strictEqual(duplex.destroyed, false);
    assert.strictEqual(duplex.writableEnded, false);
  }

  run().then(common.mustCall());
}

{
  const s = new PassThrough({ objectMode: true });
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
    yield 'world';
  }, s, async function(source) {
    let ret = '';
    let n = 0;
    for await (const chunk of source) {
      if (n++ > 1) {
        break;
      }
      ret += chunk;
    }
    return ret;
  }, common.mustCall((err, val) => {
    assert.strictEqual(err, undefined);
    assert.strictEqual(val, 'helloworld');
    assert.strictEqual(s.destroyed, true);
  }));
}

{
  const s = new PassThrough({ objectMode: true });
  pipeline(async function*() {
    await Promise.resolve();
    yield 'hello';
    yield 'world';
    yield 'world';
  }, s, async function(source) {
    return null;
  }, common.mustCall((err, val) => {
    assert.strictEqual(err, undefined);
    assert.strictEqual(val, null);
  }));
}

{
  // Mimics a legacy stream without the .destroy method
  class LegacyWritable extends Stream {
    write(chunk, encoding, callback) {
      callback();
    }
  }

  const writable = new LegacyWritable();
  writable.on('error', common.mustCall((err) => {
    assert.deepStrictEqual(err, new Error('stop'));
  }));

  pipeline(
    Readable.from({
      [Symbol.asyncIterator]() {
        return {
          next() {
            return Promise.reject(new Error('stop'));
          }
        };
      }
    }),
    writable,
    common.mustCall((err) => {
      assert.deepStrictEqual(err, new Error('stop'));
    })
  );
}

{
  class CustomReadable extends Readable {
    _read() {
      this.push('asd');
      this.push(null);
    }
  }

  class CustomWritable extends Writable {
    constructor() {
      super();
      this.endCount = 0;
      this.str = '';
    }

    _write(chunk, enc, cb) {
      this.str += chunk;
      cb();
    }

    end() {
      this.endCount += 1;
      super.end();
    }
  }

  const readable = new CustomReadable();
  const writable = new CustomWritable();

  pipeline(readable, writable, common.mustSucceed(() => {
    assert.strictEqual(writable.str, 'asd');
    assert.strictEqual(writable.endCount, 1);
  }));
}

{
  const readable = new Readable({
    read() {}
  });
  readable.on('end', common.mustCall(() => {
    pipeline(readable, new PassThrough(), common.mustSucceed());
  }));
  readable.push(null);
  readable.read();
}

{
  const dup = new Duplex({
    read() {},
    write(chunk, enc, cb) {
      cb();
    }
  });
  dup.on('end', common.mustCall(() => {
    pipeline(dup, new PassThrough(), common.mustSucceed());
  }));
  dup.push(null);
  dup.read();
}

{
  let res = '';
  const writable = new Writable({
    write(chunk, enc, cb) {
      res += chunk;
      cb();
    }
  });
  pipelinep(async function*() {
    yield 'hello';
    await Promise.resolve();
    yield 'world';
  }, writable, { end: false }).then(common.mustCall(() => {
    assert.strictEqual(res, 'helloworld');
    assert.strictEqual(writable.closed, false);
  }));
}

{
  const r = new Readable();
  for (let i = 0; i < 4000; i++) {
    r.push('asdfdagljanfgkaljdfn');
  }
  r.push(null);

  let ended = false;
  r.on('end', () => {
    ended = true;
  });

  const w = new Writable({
    write(chunk, enc, cb) {
      cb(null);
    },
    final: common.mustCall((cb) => {
      assert.strictEqual(ended, true);
      cb(null);
    })
  });

  pipeline(r, w, common.mustCall((err) => {
    assert.strictEqual(err, undefined);
  }));
}

{
  // See https://github.com/nodejs/node/issues/51540 for the following 2 tests
  const src = new Readable();
  const dst = new Writable({
    destroy(error, cb) {
      // Takes a while to destroy
      setImmediate(cb);
    },
  });

  pipeline(src, dst, (err) => {
    assert.strictEqual(src.closed, true);
    assert.strictEqual(dst.closed, true);
    assert.strictEqual(err.message, 'problem');
  });
  src.destroy(new Error('problem'));
}

{
  const src = new Readable();
  const dst = new Writable({
    destroy(error, cb) {
      // Takes a while to destroy
      setImmediate(cb);
    },
  });
  const passThroughs = [];
  for (let i = 0; i < 10; i++) {
    passThroughs.push(new PassThrough());
  }

  pipeline(src, ...passThroughs, dst, (err) => {
    assert.strictEqual(src.closed, true);
    assert.strictEqual(dst.closed, true);
    assert.strictEqual(err.message, 'problem');

    for (let i = 0; i < passThroughs.length; i++) {
      assert.strictEqual(passThroughs[i].closed, true);
    }
  });
  src.destroy(new Error('problem'));
}

{
  async function* myAsyncGenerator(ag) {
    for await (const data of ag) {
      yield data;
    }
  }

  const duplexStream = Duplex.from(myAsyncGenerator);

  const r = new Readable({
    read() {
      this.push('data1\n');
      throw new Error('booom');
    },
  });

  const w = new Writable({
    write(chunk, encoding, callback) {
      callback();
    },
  });

  pipeline(r, duplexStream, w, common.mustCall((err) => {
    assert.deepStrictEqual(err, new Error('booom'));
  }));
}
                                                                 node-23.7.0/test/parallel/test-stream-preprocess.js                                                 0000664 0000000 0000000 00000003633 14746647661 0022326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const fs = require('fs');
const rl = require('readline');
const fixtures = require('../common/fixtures');

const BOM = '\uFEFF';

// Get the data using a non-stream way to compare with the streamed data.
const modelData = fixtures.readSync('file-to-read-without-bom.txt', 'utf8');
const modelDataFirstCharacter = modelData[0];

// Detect the number of forthcoming 'line' events for mustCall() 'expected' arg.
const lineCount = modelData.match(/\n/g).length;

// Ensure both without-bom and with-bom test files are textwise equal.
assert.strictEqual(fixtures.readSync('file-to-read-with-bom.txt', 'utf8'),
                   `${BOM}${modelData}`
);

// An unjustified BOM stripping with a non-BOM character unshifted to a stream.
const inputWithoutBOM =
  fs.createReadStream(fixtures.path('file-to-read-without-bom.txt'), 'utf8');

inputWithoutBOM.once('readable', common.mustCall(() => {
  const maybeBOM = inputWithoutBOM.read(1);
  assert.strictEqual(maybeBOM, modelDataFirstCharacter);
  assert.notStrictEqual(maybeBOM, BOM);

  inputWithoutBOM.unshift(maybeBOM);

  let streamedData = '';
  rl.createInterface({
    input: inputWithoutBOM,
  }).on('line', common.mustCall((line) => {
    streamedData += `${line}\n`;
  }, lineCount)).on('close', common.mustCall(() => {
    assert.strictEqual(streamedData, modelData);
  }));
}));

// A justified BOM stripping.
const inputWithBOM =
  fs.createReadStream(fixtures.path('file-to-read-with-bom.txt'), 'utf8');

inputWithBOM.once('readable', common.mustCall(() => {
  const maybeBOM = inputWithBOM.read(1);
  assert.strictEqual(maybeBOM, BOM);

  let streamedData = '';
  rl.createInterface({
    input: inputWithBOM,
  }).on('line', common.mustCall((line) => {
    streamedData += `${line}\n`;
  }, lineCount)).on('close', common.mustCall(() => {
    assert.strictEqual(streamedData, modelData);
  }));
}));
                                                                                                     node-23.7.0/test/parallel/test-stream-promises.js                                                   0000664 0000000 0000000 00000006471 14746647661 0022005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');
const {
  Readable, Writable, promises,
} = stream;
const {
  finished, pipeline,
} = require('stream/promises');
const fs = require('fs');
const assert = require('assert');
const { promisify } = require('util');

assert.strictEqual(promises.pipeline, pipeline);
assert.strictEqual(promises.finished, finished);
assert.strictEqual(pipeline, promisify(stream.pipeline));
assert.strictEqual(finished, promisify(stream.finished));

// pipeline success
{
  let finished = false;
  const processed = [];
  const expected = [Buffer.from('a'), Buffer.from('b'), Buffer.from('c')];

  const read = new Readable({
    read() {
    }
  });

  const write = new Writable({
    write(data, enc, cb) {
      processed.push(data);
      cb();
    }
  });

  write.on('finish', () => {
    finished = true;
  });

  for (let i = 0; i < expected.length; i++) {
    read.push(expected[i]);
  }
  read.push(null);

  pipeline(read, write).then(common.mustCall((value) => {
    assert.ok(finished);
    assert.deepStrictEqual(processed, expected);
  }));
}

// pipeline error
{
  const read = new Readable({
    read() {
    }
  });

  const write = new Writable({
    write(data, enc, cb) {
      cb();
    }
  });

  read.push('data');
  setImmediate(() => read.destroy());

  pipeline(read, write).catch(common.mustCall((err) => {
    assert.ok(err, 'should have an error');
  }));
}

// finished success
{
  async function run() {
    const rs = fs.createReadStream(__filename);

    let ended = false;
    rs.resume();
    rs.on('end', () => {
      ended = true;
    });
    await finished(rs);
    assert(ended);
  }

  run().then(common.mustCall());
}

// finished error
{
  const rs = fs.createReadStream('file-does-not-exist');

  assert.rejects(finished(rs), {
    code: 'ENOENT'
  }).then(common.mustCall());
}

{
  const streamObj = new Readable();
  assert.throws(() => {
    // Passing cleanup option not as boolean
    // should throw error
    finished(streamObj, { cleanup: 2 });
  }, { code: 'ERR_INVALID_ARG_TYPE' });
}

// Below code should not throw any errors as the
// streamObj is `Stream` and cleanup is boolean
{
  const streamObj = new Readable();
  finished(streamObj, { cleanup: true });
}


// Cleanup function should not be called when cleanup is set to false
// listenerCount should be 1 after calling finish
{
  const streamObj = new Writable();
  assert.strictEqual(streamObj.listenerCount('end'), 0);
  finished(streamObj, { cleanup: false }).then(common.mustCall(() => {
    assert.strictEqual(streamObj.listenerCount('end'), 1);
  }));
  streamObj.end();
}

// Cleanup function should be called when cleanup is set to true
// listenerCount should be 0 after calling finish
{
  const streamObj = new Writable();
  assert.strictEqual(streamObj.listenerCount('end'), 0);
  finished(streamObj, { cleanup: true }).then(common.mustCall(() => {
    assert.strictEqual(streamObj.listenerCount('end'), 0);
  }));
  streamObj.end();
}

// Cleanup function should not be called when cleanup has not been set
// listenerCount should be 1 after calling finish
{
  const streamObj = new Writable();
  assert.strictEqual(streamObj.listenerCount('end'), 0);
  finished(streamObj).then(common.mustCall(() => {
    assert.strictEqual(streamObj.listenerCount('end'), 1);
  }));
  streamObj.end();
}
                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stream-push-order.js                                                 0000664 0000000 0000000 00000003244 14746647661 0022227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const Readable = require('stream').Readable;
const assert = require('assert');

const s = new Readable({
  highWaterMark: 20,
  encoding: 'ascii'
});

const list = ['1', '2', '3', '4', '5', '6'];

s._read = function(n) {
  const one = list.shift();
  if (!one) {
    s.push(null);
  } else {
    const two = list.shift();
    s.push(one);
    s.push(two);
  }
};

s.read(0);

// ACTUALLY [1, 3, 5, 6, 4, 2]

process.on('exit', function() {
  assert.strictEqual(s.readableBuffer.join(','), '1,2,3,4,5,6');
  console.log('ok');
});
                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-push-strings.js                                               0000664 0000000 0000000 00000004140 14746647661 0022601 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

const Readable = require('stream').Readable;

class MyStream extends Readable {
  constructor(options) {
    super(options);
    this._chunks = 3;
  }

  _read(n) {
    switch (this._chunks--) {
      case 0:
        return this.push(null);
      case 1:
        return setTimeout(() => {
          this.push('last chunk');
        }, 100);
      case 2:
        return this.push('second to last chunk');
      case 3:
        return process.nextTick(() => {
          this.push('first chunk');
        });
      default:
        throw new Error('?');
    }
  }
}

const ms = new MyStream();
const results = [];
ms.on('readable', function() {
  let chunk;
  while (null !== (chunk = ms.read()))
    results.push(String(chunk));
});

const expect = [ 'first chunksecond to last chunk', 'last chunk' ];
process.on('exit', function() {
  assert.strictEqual(ms._chunks, -1);
  assert.deepStrictEqual(results, expect);
  console.log('ok');
});
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stream-readable-aborted.js                                           0000664 0000000 0000000 00000002642 14746647661 0023315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable, Duplex } = require('stream');

{
  const readable = new Readable({
    read() {
    }
  });
  assert.strictEqual(readable.readableAborted, false);
  readable.destroy();
  assert.strictEqual(readable.readableAborted, true);
}

{
  const readable = new Readable({
    read() {
    }
  });
  assert.strictEqual(readable.readableAborted, false);
  readable.push(null);
  readable.destroy();
  assert.strictEqual(readable.readableAborted, true);
}

{
  const readable = new Readable({
    read() {
    }
  });
  assert.strictEqual(readable.readableAborted, false);
  readable.push('asd');
  readable.destroy();
  assert.strictEqual(readable.readableAborted, true);
}

{
  const readable = new Readable({
    read() {
    }
  });
  assert.strictEqual(readable.readableAborted, false);
  readable.push('asd');
  readable.push(null);
  assert.strictEqual(readable.readableAborted, false);
  readable.on('end', common.mustCall(() => {
    assert.strictEqual(readable.readableAborted, false);
    readable.destroy();
    assert.strictEqual(readable.readableAborted, false);
    queueMicrotask(() => {
      assert.strictEqual(readable.readableAborted, false);
    });
  }));
  readable.resume();
}

{
  const duplex = new Duplex({
    readable: false,
    write() {}
  });
  duplex.destroy();
  assert.strictEqual(duplex.readableAborted, false);
}
                                                                                              node-23.7.0/test/parallel/test-stream-readable-add-chunk-during-data.js                             0000664 0000000 0000000 00000001140 14746647661 0025720 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

// Verify that .push() and .unshift() can be called from 'data' listeners.

for (const method of ['push', 'unshift']) {
  const r = new Readable({ read() {} });
  r.once('data', common.mustCall((chunk) => {
    assert.strictEqual(r.readableLength, 0);
    r[method](chunk);
    assert.strictEqual(r.readableLength, chunk.length);

    r.on('data', common.mustCall((chunk) => {
      assert.strictEqual(chunk.toString(), 'Hello, world');
    }));
  }));

  r.push('Hello, world');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stream-readable-async-iterators.js                                   0000664 0000000 0000000 00000046662 14746647661 0025036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Stream,
  Readable,
  Transform,
  PassThrough,
  pipeline
} = require('stream');
const assert = require('assert');
const http = require('http');
const fs = require('fs');

async function tests() {
  {
    // v1 stream

    const stream = new Stream();
    stream.destroy = common.mustCall();
    process.nextTick(() => {
      stream.emit('data', 'hello');
      stream.emit('data', 'world');
      stream.emit('end');
    });

    let res = '';
    stream[Symbol.asyncIterator] = Readable.prototype[Symbol.asyncIterator];
    for await (const d of stream) {
      res += d;
    }
    assert.strictEqual(res, 'helloworld');
  }

  {
    // v1 stream error

    const stream = new Stream();
    stream.close = common.mustCall();
    process.nextTick(() => {
      stream.emit('data', 0);
      stream.emit('data', 1);
      stream.emit('error', new Error('asd'));
    });

    const iter = Readable.prototype[Symbol.asyncIterator].call(stream);
    await iter.next()
      .then(common.mustNotCall())
      .catch(common.mustCall((err) => {
        assert.strictEqual(err.message, 'asd');
      }));
  }

  {
    // Non standard stream cleanup

    const readable = new Readable({ autoDestroy: false, read() {} });
    readable.push('asd');
    readable.push('asd');
    readable.destroy = null;
    readable.close = common.mustCall(() => {
      readable.emit('close');
    });

    await (async () => {
      for await (const d of readable) {
        return;
      }
    })();
  }

  {
    const readable = new Readable({ objectMode: true, read() {} });
    readable.push(0);
    readable.push(1);
    readable.push(null);

    const iter = readable[Symbol.asyncIterator]();
    assert.strictEqual((await iter.next()).value, 0);
    for await (const d of iter) {
      assert.strictEqual(d, 1);
    }
  }

  {
    console.log('read without for..await');
    const max = 5;
    const readable = new Readable({
      objectMode: true,
      read() {}
    });

    const iter = readable[Symbol.asyncIterator]();
    assert.strictEqual(iter.stream, readable);
    const values = [];
    for (let i = 0; i < max; i++) {
      values.push(iter.next());
    }
    Promise.all(values).then(common.mustCall((values) => {
      values.forEach(common.mustCall(
        (item, i) => assert.strictEqual(item.value, 'hello-' + i), 5));
    }));

    readable.push('hello-0');
    readable.push('hello-1');
    readable.push('hello-2');
    readable.push('hello-3');
    readable.push('hello-4');
    readable.push(null);

    const last = await iter.next();
    assert.strictEqual(last.done, true);
  }

  {
    console.log('read without for..await deferred');
    const readable = new Readable({
      objectMode: true,
      read() {}
    });

    const iter = readable[Symbol.asyncIterator]();
    assert.strictEqual(iter.stream, readable);
    let values = [];
    for (let i = 0; i < 3; i++) {
      values.push(iter.next());
    }

    readable.push('hello-0');
    readable.push('hello-1');
    readable.push('hello-2');

    let k = 0;
    const results1 = await Promise.all(values);
    results1.forEach(common.mustCall(
      (item) => assert.strictEqual(item.value, 'hello-' + k++), 3));

    values = [];
    for (let i = 0; i < 2; i++) {
      values.push(iter.next());
    }

    readable.push('hello-3');
    readable.push('hello-4');
    readable.push(null);

    const results2 = await Promise.all(values);
    results2.forEach(common.mustCall(
      (item) => assert.strictEqual(item.value, 'hello-' + k++), 2));

    const last = await iter.next();
    assert.strictEqual(last.done, true);
  }

  {
    console.log('read without for..await with errors');
    const max = 3;
    const readable = new Readable({
      objectMode: true,
      read() {}
    });

    const iter = readable[Symbol.asyncIterator]();
    assert.strictEqual(iter.stream, readable);
    const values = [];
    const errors = [];
    let i;
    for (i = 0; i < max; i++) {
      values.push(iter.next());
    }
    for (i = 0; i < 2; i++) {
      errors.push(iter.next());
    }

    readable.push('hello-0');
    readable.push('hello-1');
    readable.push('hello-2');

    const resolved = await Promise.all(values);

    resolved.forEach(common.mustCall(
      (item, i) => assert.strictEqual(item.value, 'hello-' + i), max));

    errors.slice(0, 1).forEach((promise) => {
      promise.catch(common.mustCall((err) => {
        assert.strictEqual(err.message, 'kaboom');
      }));
    });

    errors.slice(1).forEach((promise) => {
      promise.then(common.mustCall(({ done, value }) => {
        assert.strictEqual(done, true);
        assert.strictEqual(value, undefined);
      }));
    });

    readable.destroy(new Error('kaboom'));
  }

  {
    console.log('call next() after error');
    const readable = new Readable({
      read() {}
    });
    const iterator = readable[Symbol.asyncIterator]();

    const err = new Error('kaboom');
    readable.destroy(err);
    await assert.rejects(iterator.next.bind(iterator), err);
  }

  {
    console.log('read object mode');
    const max = 42;
    let readed = 0;
    let received = 0;
    const readable = new Readable({
      objectMode: true,
      read() {
        this.push('hello');
        if (++readed === max) {
          this.push(null);
        }
      }
    });

    for await (const k of readable) {
      received++;
      assert.strictEqual(k, 'hello');
    }

    assert.strictEqual(readed, received);
  }

  {
    console.log('destroy sync');
    const readable = new Readable({
      objectMode: true,
      read() {
        this.destroy(new Error('kaboom from read'));
      }
    });

    let err;
    try {
      // eslint-disable-next-line no-unused-vars, no-empty
      for await (const k of readable) { }
    } catch (e) {
      err = e;
    }
    assert.strictEqual(err.message, 'kaboom from read');
  }

  {
    console.log('destroy async');
    const readable = new Readable({
      objectMode: true,
      read() {
        if (!this.pushed) {
          this.push('hello');
          this.pushed = true;

          setImmediate(() => {
            this.destroy(new Error('kaboom'));
          });
        }
      }
    });

    let received = 0;

    let err = null;
    try {
      // eslint-disable-next-line no-unused-vars
      for await (const k of readable) {
        received++;
      }
    } catch (e) {
      err = e;
    }

    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(received, 1);
  }

  {
    console.log('destroyed by throw');
    const readable = new Readable({
      objectMode: true,
      read() {
        this.push('hello');
      }
    });

    let err = null;
    try {
      for await (const k of readable) {
        assert.strictEqual(k, 'hello');
        throw new Error('kaboom');
      }
    } catch (e) {
      err = e;
    }

    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(readable.destroyed, true);
  }

  {
    console.log('destroyed sync after push');
    const readable = new Readable({
      objectMode: true,
      read() {
        this.push('hello');
        this.destroy(new Error('kaboom'));
      }
    });

    let received = 0;

    let err = null;
    try {
      for await (const k of readable) {
        assert.strictEqual(k, 'hello');
        received++;
      }
    } catch (e) {
      err = e;
    }

    assert.strictEqual(err.message, 'kaboom');
    assert.strictEqual(received, 1);
  }

  {
    console.log('destroyed will not deadlock');
    const readable = new Readable();
    readable.destroy();
    process.nextTick(async () => {
      readable.on('close', common.mustNotCall());
      let received = 0;
      let err = null;
      try {
        for await (const k of readable) {
          // Just make linting pass. This should never run.
          assert.strictEqual(k, 'hello');
          received++;
        }
      } catch (_err) {
        err = _err;
      }
      assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
      assert.strictEqual(received, 0);
    });
  }

  {
    console.log('push async');
    const max = 42;
    let readed = 0;
    let received = 0;
    const readable = new Readable({
      objectMode: true,
      read() {
        setImmediate(() => {
          this.push('hello');
          if (++readed === max) {
            this.push(null);
          }
        });
      }
    });

    for await (const k of readable) {
      received++;
      assert.strictEqual(k, 'hello');
    }

    assert.strictEqual(readed, received);
  }

  {
    console.log('push binary async');
    const max = 42;
    let readed = 0;
    const readable = new Readable({
      read() {
        setImmediate(() => {
          this.push('hello');
          if (++readed === max) {
            this.push(null);
          }
        });
      }
    });

    let expected = '';
    readable.setEncoding('utf8');
    readable.pause();
    readable.on('data', (chunk) => {
      expected += chunk;
    });

    let data = '';
    for await (const k of readable) {
      data += k;
    }

    assert.strictEqual(data, expected);
  }

  {
    console.log('.next() on destroyed stream');
    const readable = new Readable({
      read() {
        // no-op
      }
    });

    readable.destroy();

    const it = await readable[Symbol.asyncIterator]();
    const next = it.next();
    next
      .then(common.mustNotCall())
      .catch(common.mustCall((err) => {
        assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
      }));
  }

  {
    console.log('.next() on pipelined stream');
    const readable = new Readable({
      read() {
        // no-op
      }
    });

    const passthrough = new PassThrough();
    const err = new Error('kaboom');
    pipeline(readable, passthrough, common.mustCall((e) => {
      assert.strictEqual(e, err);
    }));
    readable.destroy(err);
    await assert.rejects(
      readable[Symbol.asyncIterator]().next(),
      (e) => {
        assert.strictEqual(e, err);
        return true;
      }
    );
  }

  {
    console.log('iterating on an ended stream completes');
    const r = new Readable({
      objectMode: true,
      read() {
        this.push('asdf');
        this.push('hehe');
        this.push(null);
      }
    });
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const a of r) { }
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const b of r) { }
  }

  {
    console.log('destroy mid-stream errors');
    const r = new Readable({
      objectMode: true,
      read() {
        this.push('asdf');
        this.push('hehe');
      }
    });

    let err = null;
    try {
      // eslint-disable-next-line no-unused-vars
      for await (const a of r) {
        r.destroy(null);
      }
    } catch (_err) {
      err = _err;
    }
    assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
  }

  {
    console.log('readable side of a transform stream pushes null');
    const transform = new Transform({
      objectMode: true,
      transform: (chunk, enc, cb) => { cb(null, chunk); }
    });
    transform.push(0);
    transform.push(1);
    process.nextTick(() => {
      transform.push(null);
    });

    const mustReach = [ common.mustCall(), common.mustCall() ];

    const iter = transform[Symbol.asyncIterator]();
    assert.strictEqual((await iter.next()).value, 0);

    for await (const d of iter) {
      assert.strictEqual(d, 1);
      mustReach[0]();
    }
    mustReach[1]();
  }

  {
    console.log('all next promises must be resolved on end');
    const r = new Readable({
      objectMode: true,
      read() {
      }
    });

    const b = r[Symbol.asyncIterator]();
    const c = b.next();
    const d = b.next();
    r.push(null);
    assert.deepStrictEqual(await c, { done: true, value: undefined });
    assert.deepStrictEqual(await d, { done: true, value: undefined });
  }

  {
    console.log('all next promises must be rejected on destroy');
    const r = new Readable({
      objectMode: true,
      read() {
      }
    });

    const b = r[Symbol.asyncIterator]();
    const c = b.next();
    const d = b.next();
    r.destroy();
    c
      .then(common.mustNotCall())
      .catch(common.mustCall((err) => {
        assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
      }));
    assert.deepStrictEqual(await d, { done: true, value: undefined });
  }

  {
    console.log('all next promises must be resolved on destroy with error');
    const r = new Readable({
      objectMode: true,
      read() {
      }
    });

    const b = r[Symbol.asyncIterator]();
    const c = b.next();
    const d = b.next();
    const err = new Error('kaboom');
    r.destroy(err);

    await Promise.all([(async () => {
      let e;
      try {
        await c;
      } catch (_e) {
        e = _e;
      }
      assert.strictEqual(e, err);
    })(), (async () => {
      let e;
      let x;
      try {
        x = await d;
      } catch (_e) {
        e = _e;
      }
      assert.strictEqual(e, undefined);
      assert.strictEqual(x.done, true);
      assert.strictEqual(x.value, undefined);
    })()]);
  }

  {
    const _err = new Error('asd');
    const r = new Readable({
      read() {
      },
      destroy(err, callback) {
        setTimeout(() => callback(_err), 1);
      }
    });

    r.destroy();
    const it = r[Symbol.asyncIterator]();
    it.next().catch(common.mustCall((err) => {
      assert.strictEqual(err, _err);
    }));
  }

  {
    // Don't destroy if no auto destroy.
    // https://github.com/nodejs/node/issues/35116

    const r = new Readable({
      autoDestroy: false,
      read() {
        this.push('asd');
        this.push(null);
      }
    });

    for await (const chunk of r) { } // eslint-disable-line no-unused-vars, no-empty
    assert.strictEqual(r.destroyed, false);
  }

  {
    // Destroy if no auto destroy and premature break.
    // https://github.com/nodejs/node/pull/35122/files#r485678318

    const r = new Readable({
      autoDestroy: false,
      read() {
        this.push('asd');
      }
    });

    for await (const chunk of r) { // eslint-disable-line no-unused-vars
      break;
    }
    assert.strictEqual(r.destroyed, true);
  }

  {
    // Don't destroy before 'end'.

    const r = new Readable({
      read() {
        this.push('asd');
        this.push(null);
      }
    }).on('end', () => {
      assert.strictEqual(r.destroyed, false);
    });

    for await (const chunk of r) { } // eslint-disable-line no-unused-vars, no-empty
    assert.strictEqual(r.destroyed, true);
  }
}

{
  // AsyncIterator return should end even when destroy
  // does not implement the callback API.

  const r = new Readable({
    objectMode: true,
    read() {
    }
  });

  const originalDestroy = r.destroy;
  r.destroy = (err) => {
    originalDestroy.call(r, err);
  };
  const it = r[Symbol.asyncIterator]();
  const p = it.return();
  r.push(null);
  p.then(common.mustCall());
}


{
  // AsyncIterator return should not error with
  // premature close.

  const r = new Readable({
    objectMode: true,
    read() {
    }
  });

  const originalDestroy = r.destroy;
  r.destroy = (err) => {
    originalDestroy.call(r, err);
  };
  const it = r[Symbol.asyncIterator]();
  const p = it.return();
  r.emit('close');
  p.then(common.mustCall()).catch(common.mustNotCall());
}

{
  // AsyncIterator should not finish correctly if destroyed.

  const r = new Readable({
    objectMode: true,
    read() {
    }
  });

  r.destroy();
  r.on('close', () => {
    const it = r[Symbol.asyncIterator]();
    const next = it.next();
    next
      .then(common.mustNotCall())
      .catch(common.mustCall((err) => {
        assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
      }));
  });
}

{
  // AsyncIterator should throw if prematurely closed
  // before end has been emitted.
  (async function() {
    const readable = fs.createReadStream(__filename);

    try {
      // eslint-disable-next-line no-unused-vars
      for await (const chunk of readable) {
        readable.close();
      }

      assert.fail('should have thrown');
    } catch (err) {
      assert.strictEqual(err.code, 'ERR_STREAM_PREMATURE_CLOSE');
    }

    assert.ok(readable.destroyed);
  })().then(common.mustCall());
}

// AsyncIterator non-destroying iterator
{
  function createReadable() {
    return Readable.from((async function* () {
      await Promise.resolve();
      yield 5;
      await Promise.resolve();
      yield 7;
      await Promise.resolve();
    })());
  }

  // Check explicit destroying on return
  (async function() {
    const readable = createReadable();
    for await (const chunk of readable.iterator({ destroyOnReturn: true })) {
      assert.strictEqual(chunk, 5);
      break;
    }

    assert.ok(readable.destroyed);
  })().then(common.mustCall());

  // Check explicit non-destroy with return true
  (async function() {
    const readable = createReadable();
    const opts = { destroyOnReturn: false };
    for await (const chunk of readable.iterator(opts)) {
      assert.strictEqual(chunk, 5);
      break;
    }

    assert.ok(!readable.destroyed);

    for await (const chunk of readable.iterator(opts)) {
      assert.strictEqual(chunk, 7);
    }

    assert.ok(readable.destroyed);
  })().then(common.mustCall());

  // Check non-object options.
  {
    const readable = createReadable();
    assert.throws(
      () => readable.iterator(42),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The "options" argument must be of type object. Received ' +
                 'type number (42)',
      }
    );
  }

  // Check for dangling listeners
  (async function() {
    const readable = createReadable();
    const opts = { destroyOnReturn: false };
    while (readable.readable) {
      // eslint-disable-next-line no-unused-vars
      for await (const chunk of readable.iterator(opts)) {
        break;
      }
    }

    assert.deepStrictEqual(readable.eventNames(), []);
  })().then(common.mustCall());
}

{
  let _req;
  const server = http.createServer((request, response) => {
    response.statusCode = 404;
    response.write('never ends');
  });

  server.listen(() => {
    _req = http.request(`http://localhost:${server.address().port}`)
      .on('response', common.mustCall(async (res) => {
        setTimeout(() => {
          _req.destroy(new Error('something happened'));
        }, 100);

        res.on('error', common.mustCall());

        let _err;
        try {
          // eslint-disable-next-line no-unused-vars, no-empty
          for await (const chunk of res) { }
        } catch (err) {
          _err = err;
        }

        assert.strictEqual(_err.code, 'ECONNRESET');
        server.close();
      }))
      .on('error', common.mustCall())
      .end();
  });
}

{
  async function getParsedBody(request) {
    let body = '';

    for await (const data of request) {
      body += data;
    }

    try {
      return JSON.parse(body);
    } catch {
      return {};
    }
  }

  const str = JSON.stringify({ asd: true });
  const server = http.createServer(async (request, response) => {
    const body = await getParsedBody(request);
    response.statusCode = 200;
    assert.strictEqual(JSON.stringify(body), str);
    response.end(JSON.stringify(body));
  }).listen(() => {
    http
      .request({
        method: 'POST',
        hostname: 'localhost',
        port: server.address().port,
      })
      .end(str)
      .on('response', async (res) => {
        let body = '';
        for await (const chunk of res) {
          body += chunk;
        }
        assert.strictEqual(body, str);
        server.close();
      });
  });
}

// To avoid missing some tests if a promise does not resolve
tests().then(common.mustCall());
                                                                              node-23.7.0/test/parallel/test-stream-readable-constructor-set-methods.js                           0000664 0000000 0000000 00000000341 14746647661 0026506 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const Readable = require('stream').Readable;

const _read = common.mustCall(function _read(n) {
  this.push(null);
});

const r = new Readable({ read: _read });
r.resume();
                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-readable-data.js                                              0000664 0000000 0000000 00000000561 14746647661 0022604 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const { Readable } = require('stream');

const readable = new Readable({
  read() {}
});

function read() {}

readable.setEncoding('utf8');
readable.on('readable', read);
readable.removeListener('readable', read);

process.nextTick(function() {
  readable.on('data', common.mustCall());
  readable.push('hello');
});
                                                                                                                                               node-23.7.0/test/parallel/test-stream-readable-default-encoding.js                                  0000664 0000000 0000000 00000001270 14746647661 0025101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

{
  assert.throws(() => {
    new Readable({
      read: () => {},
      defaultEncoding: 'my invalid encoding',
    });
  }, {
    code: 'ERR_UNKNOWN_ENCODING',
  });
}

{
  const r = new Readable({
    read() {},
    defaultEncoding: 'hex'
  });

  r.push('ab');

  r.on('data', common.mustCall((chunk) => assert.strictEqual(chunk.toString('hex'), 'ab')), 1);
}

{
  const r = new Readable({
    read() {},
    defaultEncoding: 'hex',
  });

  r.push('xy', 'utf-8');

  r.on('data', common.mustCall((chunk) => assert.strictEqual(chunk.toString('utf-8'), 'xy')), 1);
}
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-readable-destroy.js                                           0000664 0000000 0000000 00000020565 14746647661 0023372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable, addAbortSignal } = require('stream');
const assert = require('assert');

{
  const read = new Readable({
    read() {}
  });
  read.resume();

  read.on('close', common.mustCall());

  read.destroy();
  assert.strictEqual(read.errored, null);
  assert.strictEqual(read.destroyed, true);
}

{
  const read = new Readable({
    read() {}
  });
  read.resume();

  const expected = new Error('kaboom');

  read.on('end', common.mustNotCall('no end event'));
  read.on('close', common.mustCall());
  read.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  read.destroy(expected);
  assert.strictEqual(read.errored, expected);
  assert.strictEqual(read.destroyed, true);
}

{
  const read = new Readable({
    read() {}
  });

  read._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, expected);
    cb(err);
  });

  const expected = new Error('kaboom');

  read.on('end', common.mustNotCall('no end event'));
  read.on('close', common.mustCall());
  read.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  read.destroy(expected);
  assert.strictEqual(read.destroyed, true);
}

{
  const read = new Readable({
    read() {},
    destroy: common.mustCall(function(err, cb) {
      assert.strictEqual(err, expected);
      cb();
    })
  });

  const expected = new Error('kaboom');

  read.on('end', common.mustNotCall('no end event'));

  // Error is swallowed by the custom _destroy
  read.on('error', common.mustNotCall('no error event'));
  read.on('close', common.mustCall());

  read.destroy(expected);
  assert.strictEqual(read.destroyed, true);
}

{
  const read = new Readable({
    read() {}
  });

  read._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb();
  });

  read.destroy();
  assert.strictEqual(read.destroyed, true);
}

{
  const read = new Readable({
    read() {}
  });
  read.resume();

  read._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    process.nextTick(() => {
      this.push(null);
      cb();
    });
  });

  const fail = common.mustNotCall('no end event');

  read.on('end', fail);
  read.on('close', common.mustCall());

  read.destroy();

  read.removeListener('end', fail);
  read.on('end', common.mustNotCall());
  assert.strictEqual(read.destroyed, true);
}

{
  const read = new Readable({
    read() {}
  });

  const expected = new Error('kaboom');

  read._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb(expected);
  });

  let ticked = false;
  read.on('end', common.mustNotCall('no end event'));
  read.on('error', common.mustCall((err) => {
    assert.strictEqual(ticked, true);
    assert.strictEqual(read._readableState.errorEmitted, true);
    assert.strictEqual(read._readableState.errored, expected);
    assert.strictEqual(err, expected);
  }));

  read.destroy();
  assert.strictEqual(read._readableState.errorEmitted, false);
  assert.strictEqual(read._readableState.errored, expected);
  assert.strictEqual(read.destroyed, true);
  ticked = true;
}

{
  const read = new Readable({
    read() {}
  });
  read.resume();

  read.destroyed = true;
  assert.strictEqual(read.destroyed, true);

  // The internal destroy() mechanism should not be triggered
  read.on('end', common.mustNotCall());
  read.destroy();
}

{
  function MyReadable() {
    assert.strictEqual(this.destroyed, false);
    this.destroyed = false;
    Readable.call(this);
  }

  Object.setPrototypeOf(MyReadable.prototype, Readable.prototype);
  Object.setPrototypeOf(MyReadable, Readable);

  new MyReadable();
}

{
  // Destroy and destroy callback
  const read = new Readable({
    read() {}
  });
  read.resume();

  const expected = new Error('kaboom');

  let ticked = false;
  read.on('close', common.mustCall(() => {
    assert.strictEqual(read._readableState.errorEmitted, true);
    assert.strictEqual(ticked, true);
  }));
  read.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  assert.strictEqual(read._readableState.errored, null);
  assert.strictEqual(read._readableState.errorEmitted, false);

  read.destroy(expected, common.mustCall(function(err) {
    assert.strictEqual(read._readableState.errored, expected);
    assert.strictEqual(err, expected);
  }));
  assert.strictEqual(read._readableState.errorEmitted, false);
  assert.strictEqual(read._readableState.errored, expected);
  ticked = true;
}

{
  const readable = new Readable({
    destroy: common.mustCall(function(err, cb) {
      process.nextTick(cb, new Error('kaboom 1'));
    }),
    read() {}
  });

  let ticked = false;
  readable.on('close', common.mustCall(() => {
    assert.strictEqual(ticked, true);
    assert.strictEqual(readable._readableState.errorEmitted, true);
  }));
  readable.on('error', common.mustCall((err) => {
    assert.strictEqual(ticked, true);
    assert.strictEqual(err.message, 'kaboom 1');
    assert.strictEqual(readable._readableState.errorEmitted, true);
  }));

  readable.destroy();
  assert.strictEqual(readable.destroyed, true);
  assert.strictEqual(readable._readableState.errored, null);
  assert.strictEqual(readable._readableState.errorEmitted, false);

  // Test case where `readable.destroy()` is called again with an error before
  // the `_destroy()` callback is called.
  readable.destroy(new Error('kaboom 2'));
  assert.strictEqual(readable._readableState.errorEmitted, false);
  assert.strictEqual(readable._readableState.errored, null);

  ticked = true;
}

{
  const read = new Readable({
    read() {}
  });

  read.destroy();
  read.push('hi');
  read.on('data', common.mustNotCall());
}

{
  const read = new Readable({
    read: common.mustNotCall()
  });
  read.destroy();
  assert.strictEqual(read.destroyed, true);
  read.read();
}

{
  const read = new Readable({
    autoDestroy: false,
    read() {
      this.push(null);
      this.push('asd');
    }
  });

  read.on('error', common.mustCall(() => {
    assert(read._readableState.errored);
  }));
  read.resume();
}

{
  const controller = new AbortController();
  const read = addAbortSignal(controller.signal, new Readable({
    read() {
      this.push('asd');
    },
  }));

  read.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
  }));
  controller.abort();
  read.on('data', common.mustNotCall());
}

{
  const controller = new AbortController();
  const read = new Readable({
    signal: controller.signal,
    read() {
      this.push('asd');
    },
  });

  read.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
  }));
  controller.abort();
  read.on('data', common.mustNotCall());
}

{
  const controller = new AbortController();
  const read = addAbortSignal(controller.signal, new Readable({
    objectMode: true,
    read() {
      return false;
    }
  }));
  read.push('asd');

  read.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
  }));
  assert.rejects((async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const chunk of read) { }
  })(), /AbortError/).then(common.mustCall());
  setTimeout(() => controller.abort(), 0);
}

{
  const read = new Readable({
    read() {
    },
  });

  read.on('data', common.mustNotCall());
  read.on('error', common.mustCall((e) => {
    read.push('asd');
    read.read();
  }));
  read.on('close', common.mustCall((e) => {
    read.push('asd');
    read.read();
  }));
  read.destroy(new Error('asd'));
}

{
  const read = new Readable({
    read() {
    },
  });

  read.on('data', common.mustNotCall());
  read.on('close', common.mustCall((e) => {
    read.push('asd');
    read.read();
  }));
  read.destroy();
}

{
  const read = new Readable({
    read() {
    },
  });

  read.on('data', common.mustNotCall());
  read.on('close', common.mustCall((e) => {
    read.push('asd');
    read.unshift('asd');
  }));
  read.destroy();
}

{
  const read = new Readable({
    read() {
    },
  });

  read.on('data', common.mustNotCall());
  read.destroy();
  read.unshift('asd');
}

{
  const read = new Readable({
    read() {
    },
  });

  read.resume();
  read.on('data', common.mustNotCall());
  read.on('close', common.mustCall((e) => {
    read.push('asd');
  }));
  read.destroy();
}

{
  const read = new Readable({
    read() {
    },
  });

  read.on('data', common.mustNotCall());
  read.destroy();
  read.push('asd');
}
                                                                                                                                           node-23.7.0/test/parallel/test-stream-readable-didRead.js                                           0000664 0000000 0000000 00000004133 14746647661 0023226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { isDisturbed, isErrored, Readable } = require('stream');

function noop() {}

function check(readable, data, fn) {
  assert.strictEqual(readable.readableDidRead, false);
  assert.strictEqual(isDisturbed(readable), false);
  assert.strictEqual(isErrored(readable), false);
  if (data === -1) {
    readable.on('error', common.mustCall(() => {
      assert.strictEqual(isErrored(readable), true);
    }));
    readable.on('data', common.mustNotCall());
    readable.on('end', common.mustNotCall());
  } else {
    readable.on('error', common.mustNotCall());
    if (data === -2) {
      readable.on('end', common.mustNotCall());
    } else {
      readable.on('end', common.mustCall());
    }
    if (data > 0) {
      readable.on('data', common.mustCallAtLeast(data));
    } else {
      readable.on('data', common.mustNotCall());
    }
  }
  readable.on('close', common.mustCall());
  fn();
  setImmediate(() => {
    assert.strictEqual(readable.readableDidRead, data > 0);
    if (data > 0) {
      assert.strictEqual(isDisturbed(readable), true);
    }
  });
}

{
  const readable = new Readable({
    read() {
      this.push(null);
    }
  });
  check(readable, 0, () => {
    readable.read();
  });
}

{
  const readable = new Readable({
    read() {
      this.push(null);
    }
  });
  check(readable, 0, () => {
    readable.resume();
  });
}

{
  const readable = new Readable({
    read() {
      this.push(null);
    }
  });
  check(readable, -2, () => {
    readable.destroy();
  });
}

{
  const readable = new Readable({
    read() {
      this.push(null);
    }
  });

  check(readable, -1, () => {
    readable.destroy(new Error());
  });
}

{
  const readable = new Readable({
    read() {
      this.push('data');
      this.push(null);
    }
  });

  check(readable, 1, () => {
    readable.on('data', noop);
  });
}

{
  const readable = new Readable({
    read() {
      this.push('data');
      this.push(null);
    }
  });

  check(readable, 1, () => {
    readable.on('data', noop);
    readable.off('data', noop);
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-readable-dispose.js                                           0000664 0000000 0000000 00000001063 14746647661 0023337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable } = require('stream');
const assert = require('assert');

{
  const read = new Readable({
    read() {}
  });
  read.resume();

  read.on('end', common.mustNotCall('no end event'));
  read.on('close', common.mustCall());
  read.on('error', common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  read[Symbol.asyncDispose]().then(common.mustCall(() => {
    assert.strictEqual(read.errored.name, 'AbortError');
    assert.strictEqual(read.destroyed, true);
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-readable-emit-readable-short-stream.js                        0000664 0000000 0000000 00000005375 14746647661 0027024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');
const assert = require('assert');

{
  const r = new stream.Readable({
    read: common.mustCall(function() {
      this.push('content');
      this.push(null);
    })
  });

  const t = new stream.Transform({
    transform: common.mustCall(function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    }),
    flush: common.mustCall(function(callback) {
      return callback();
    })
  });

  r.pipe(t);
  t.on('readable', common.mustCall(function() {
    while (true) {
      const chunk = t.read();
      if (!chunk)
        break;

      assert.strictEqual(chunk.toString(), 'content');
    }
  }, 2));
}

{
  const t = new stream.Transform({
    transform: common.mustCall(function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    }),
    flush: common.mustCall(function(callback) {
      return callback();
    })
  });

  t.end('content');

  t.on('readable', common.mustCall(function() {
    while (true) {
      const chunk = t.read();
      if (!chunk)
        break;
      assert.strictEqual(chunk.toString(), 'content');
    }
  }));
}

{
  const t = new stream.Transform({
    transform: common.mustCall(function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    }),
    flush: common.mustCall(function(callback) {
      return callback();
    })
  });

  t.write('content');
  t.end();

  t.on('readable', common.mustCall(function() {
    while (true) {
      const chunk = t.read();
      if (!chunk)
        break;
      assert.strictEqual(chunk.toString(), 'content');
    }
  }));
}

{
  const t = new stream.Readable({
    read() {
    }
  });

  t.on('readable', common.mustCall(function() {
    while (true) {
      const chunk = t.read();
      if (!chunk)
        break;
      assert.strictEqual(chunk.toString(), 'content');
    }
  }));

  t.push('content');
  t.push(null);
}

{
  const t = new stream.Readable({
    read() {
    }
  });

  t.on('readable', common.mustCall(function() {
    while (true) {
      const chunk = t.read();
      if (!chunk)
        break;
      assert.strictEqual(chunk.toString(), 'content');
    }
  }, 2));

  process.nextTick(() => {
    t.push('content');
    t.push(null);
  });
}

{
  const t = new stream.Transform({
    transform: common.mustCall(function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    }),
    flush: common.mustCall(function(callback) {
      return callback();
    })
  });

  t.on('readable', common.mustCall(function() {
    while (true) {
      const chunk = t.read();
      if (!chunk)
        break;
      assert.strictEqual(chunk.toString(), 'content');
    }
  }, 2));

  t.write('content');
  t.end();
}
                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-stream-readable-emittedReadable.js                                   0000664 0000000 0000000 00000004134 14746647661 0024746 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const Readable = require('stream').Readable;

const readable = new Readable({
  read: () => {}
});

// Initialized to false.
assert.strictEqual(readable._readableState.emittedReadable, false);

const expected = [Buffer.from('foobar'), Buffer.from('quo'), null];
readable.on('readable', common.mustCall(() => {
  // emittedReadable should be true when the readable event is emitted
  assert.strictEqual(readable._readableState.emittedReadable, true);
  assert.deepStrictEqual(readable.read(), expected.shift());
  // emittedReadable is reset to false during read()
  assert.strictEqual(readable._readableState.emittedReadable, false);
}, 3));

// When the first readable listener is just attached,
// emittedReadable should be false
assert.strictEqual(readable._readableState.emittedReadable, false);

// These trigger a single 'readable', as things are batched up
process.nextTick(common.mustCall(() => {
  readable.push('foo');
}));
process.nextTick(common.mustCall(() => {
  readable.push('bar');
}));

// These triggers two readable events
setImmediate(common.mustCall(() => {
  readable.push('quo');
  process.nextTick(common.mustCall(() => {
    readable.push(null);
  }));
}));

const noRead = new Readable({
  read: () => {}
});

noRead.on('readable', common.mustCall(() => {
  // emittedReadable should be true when the readable event is emitted
  assert.strictEqual(noRead._readableState.emittedReadable, true);
  noRead.read(0);
  // emittedReadable is not reset during read(0)
  assert.strictEqual(noRead._readableState.emittedReadable, true);
}));

noRead.push('foo');
noRead.push(null);

const flowing = new Readable({
  read: () => {}
});

flowing.on('data', common.mustCall(() => {
  // When in flowing mode, emittedReadable is always false.
  assert.strictEqual(flowing._readableState.emittedReadable, false);
  flowing.read();
  assert.strictEqual(flowing._readableState.emittedReadable, false);
}, 3));

flowing.push('foooo');
flowing.push('bar');
flowing.push('quo');
process.nextTick(common.mustCall(() => {
  flowing.push(null);
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-stream-readable-end-destroyed.js                                     0000664 0000000 0000000 00000000447 14746647661 0024444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable } = require('stream');

{
  // Don't emit 'end' after 'close'.

  const r = new Readable();

  r.on('end', common.mustNotCall());
  r.resume();
  r.destroy();
  r.on('close', common.mustCall(() => {
    r.push(null);
  }));
}
                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-readable-ended.js                                             0000664 0000000 0000000 00000002136 14746647661 0022752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable } = require('stream');
const assert = require('assert');

// basic
{
  // Find it on Readable.prototype
  assert(Object.hasOwn(Readable.prototype, 'readableEnded'));
}

// event
{
  const readable = new Readable();

  readable._read = () => {
    // The state ended should start in false.
    assert.strictEqual(readable.readableEnded, false);
    readable.push('asd');
    assert.strictEqual(readable.readableEnded, false);
    readable.push(null);
    assert.strictEqual(readable.readableEnded, false);
  };

  readable.on('end', common.mustCall(() => {
    assert.strictEqual(readable.readableEnded, true);
  }));

  readable.on('data', common.mustCall(() => {
    assert.strictEqual(readable.readableEnded, false);
  }));
}

// Verifies no `error` triggered on multiple .push(null) invocations
{
  const readable = new Readable();

  readable.on('readable', () => { readable.read(); });
  readable.on('error', common.mustNotCall());
  readable.on('end', common.mustCall());

  readable.push('a');
  readable.push(null);
  readable.push(null);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-stream-readable-error-end.js                                         0000664 0000000 0000000 00000000472 14746647661 0023571 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable } = require('stream');

{
  const r = new Readable({ read() {} });

  r.on('end', common.mustNotCall());
  r.on('data', common.mustCall());
  r.on('error', common.mustCall());
  r.push('asd');
  r.push(null);
  r.destroy(new Error('kaboom'));
}
                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-readable-event.js                                             0000664 0000000 0000000 00000006704 14746647661 0023021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');

const Readable = require('stream').Readable;

{
  // First test, not reading when the readable is added.
  // make sure that on('readable', ...) triggers a readable event.
  const r = new Readable({
    highWaterMark: 3
  });

  r._read = common.mustNotCall();

  // This triggers a 'readable' event, which is lost.
  r.push(Buffer.from('blerg'));

  setTimeout(function() {
    // We're testing what we think we are
    assert(!r._readableState.reading);
    r.on('readable', common.mustCall());
  }, 1);
}

{
  // Second test, make sure that readable is re-emitted if there's
  // already a length, while it IS reading.

  const r = new Readable({
    highWaterMark: 3
  });

  r._read = common.mustCall();

  // This triggers a 'readable' event, which is lost.
  r.push(Buffer.from('bl'));

  setTimeout(function() {
    // Assert we're testing what we think we are
    assert(r._readableState.reading);
    r.on('readable', common.mustCall());
  }, 1);
}

{
  // Third test, not reading when the stream has not passed
  // the highWaterMark but *has* reached EOF.
  const r = new Readable({
    highWaterMark: 30
  });

  r._read = common.mustNotCall();

  // This triggers a 'readable' event, which is lost.
  r.push(Buffer.from('blerg'));
  r.push(null);

  setTimeout(function() {
    // Assert we're testing what we think we are
    assert(!r._readableState.reading);
    r.on('readable', common.mustCall());
  }, 1);
}

{
  // Pushing an empty string in non-objectMode should
  // trigger next `read()`.
  const underlyingData = ['', 'x', 'y', '', 'z'];
  const expected = underlyingData.filter((data) => data);
  const result = [];

  const r = new Readable({
    encoding: 'utf8',
  });
  r._read = function() {
    process.nextTick(() => {
      if (!underlyingData.length) {
        this.push(null);
      } else {
        this.push(underlyingData.shift());
      }
    });
  };

  r.on('readable', () => {
    const data = r.read();
    if (data !== null) result.push(data);
  });

  r.on('end', common.mustCall(() => {
    assert.deepStrictEqual(result, expected);
  }));
}

{
  // #20923
  const r = new Readable();
  r._read = function() {
    // Actually doing thing here
  };
  r.on('data', function() {});

  r.removeAllListeners();

  assert.strictEqual(r.eventNames().length, 0);
}
                                                            node-23.7.0/test/parallel/test-stream-readable-flow-recursion.js                                    0000664 0000000 0000000 00000004725 14746647661 0024657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

// This test verifies that passing a huge number to read(size)
// will push up the highWaterMark, and cause the stream to read
// more data continuously, but without triggering a nextTick
// warning or RangeError.

const Readable = require('stream').Readable;

// Throw an error if we trigger a nextTick warning.
process.throwDeprecation = true;

const stream = new Readable({ highWaterMark: 2 });
let reads = 0;
let total = 5000;
stream._read = function(size) {
  reads++;
  size = Math.min(size, total);
  total -= size;
  if (size === 0)
    stream.push(null);
  else
    stream.push(Buffer.allocUnsafe(size));
};

let depth = 0;

function flow(stream, size, callback) {
  depth += 1;
  const chunk = stream.read(size);

  if (!chunk)
    stream.once('readable', flow.bind(null, stream, size, callback));
  else
    callback(chunk);

  depth -= 1;
  console.log(`flow(${depth}): exit`);
}

flow(stream, 5000, function() {
  console.log(`complete (${depth})`);
});

process.on('exit', function(code) {
  assert.strictEqual(reads, 2);
  // We pushed up the high water mark
  assert.strictEqual(stream.readableHighWaterMark, 8192);
  // Length is 0 right now, because we pulled it all out.
  assert.strictEqual(stream.readableLength, 0);
  assert(!code);
  assert.strictEqual(depth, 0);
  console.log('ok');
});
                                           node-23.7.0/test/parallel/test-stream-readable-from-web-termination.js                              0000664 0000000 0000000 00000000503 14746647661 0025734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { Readable } = require('stream');

{
  const r = Readable.from(['data']);

  const wrapper = Readable.fromWeb(Readable.toWeb(r));

  wrapper.on('data', () => {
    // Destroying wrapper while emitting data should not cause uncaught
    // exceptions
    wrapper.destroy();
  });
}
                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-readable-hwm-0-async.js                                       0000664 0000000 0000000 00000001205 14746647661 0023732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

// This test ensures that Readable stream will continue to call _read
// for streams with highWaterMark === 0 once the stream returns data
// by calling push() asynchronously.

const { Readable } = require('stream');

let count = 5;

const r = new Readable({
  // Called 6 times: First 5 return data, last one signals end of stream.
  read: common.mustCall(() => {
    process.nextTick(common.mustCall(() => {
      if (count--)
        r.push('a');
      else
        r.push(null);
    }));
  }, 6),
  highWaterMark: 0,
});

r.on('end', common.mustCall());
r.on('data', common.mustCall(5));
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-readable-hwm-0-no-flow-data.js                                0000664 0000000 0000000 00000007022 14746647661 0025110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

// Ensure that subscribing the 'data' event will not make the stream flow.
// The 'data' event will require calling read() by hand.
//
// The test is written for the (somewhat rare) highWaterMark: 0 streams to
// specifically catch any regressions that might occur with these streams.

const assert = require('assert');
const { Readable } = require('stream');

const streamData = [ 'a', null ];

// Track the calls so we can assert their order later.
const calls = [];
const r = new Readable({
  read: common.mustCall(() => {
    calls.push('_read:' + streamData[0]);
    process.nextTick(() => {
      calls.push('push:' + streamData[0]);
      r.push(streamData.shift());
    });
  }, streamData.length),
  highWaterMark: 0,

  // Object mode is used here just for testing convenience. It really
  // shouldn't affect the order of events. Just the data and its format.
  objectMode: true,
});

assert.strictEqual(r.readableFlowing, null);
r.on('readable', common.mustCall(() => {
  calls.push('readable');
}, 2));
assert.strictEqual(r.readableFlowing, false);
r.on('data', common.mustCall((data) => {
  calls.push('data:' + data);
}, 1));
r.on('end', common.mustCall(() => {
  calls.push('end');
}));
assert.strictEqual(r.readableFlowing, false);

// The stream emits the events asynchronously but that's not guaranteed to
// happen on the next tick (especially since the _read implementation above
// uses process.nextTick).
//
// We use setImmediate here to give the stream enough time to emit all the
// events it's about to emit.
setImmediate(() => {

  // Only the _read, push, readable calls have happened. No data must be
  // emitted yet.
  assert.deepStrictEqual(calls, ['_read:a', 'push:a', 'readable']);

  // Calling 'r.read()' should trigger the data event.
  assert.strictEqual(r.read(), 'a');
  assert.deepStrictEqual(
    calls,
    ['_read:a', 'push:a', 'readable', 'data:a']);

  // The next 'read()' will return null because hwm: 0 does not buffer any
  // data and the _read implementation above does the push() asynchronously.
  //
  // Note: This 'null' signals "no data available". It isn't the end-of-stream
  // null value as the stream doesn't know yet that it is about to reach the
  // end.
  //
  // Using setImmediate again to give the stream enough time to emit all the
  // events it wants to emit.
  assert.strictEqual(r.read(), null);
  setImmediate(() => {

    // There's a new 'readable' event after the data has been pushed.
    // The 'end' event will be emitted only after a 'read()'.
    //
    // This is somewhat special for the case where the '_read' implementation
    // calls 'push' asynchronously. If 'push' was synchronous, the 'end' event
    // would be emitted here _before_ we call read().
    assert.deepStrictEqual(
      calls,
      ['_read:a', 'push:a', 'readable', 'data:a',
       '_read:null', 'push:null', 'readable']);

    assert.strictEqual(r.read(), null);

    // While it isn't really specified whether the 'end' event should happen
    // synchronously with read() or not, we'll assert the current behavior
    // ('end' event happening on the next tick after read()) so any changes
    // to it are noted and acknowledged in the future.
    assert.deepStrictEqual(
      calls,
      ['_read:a', 'push:a', 'readable', 'data:a',
       '_read:null', 'push:null', 'readable']);
    process.nextTick(() => {
      assert.deepStrictEqual(
        calls,
        ['_read:a', 'push:a', 'readable', 'data:a',
         '_read:null', 'push:null', 'readable', 'end']);
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-readable-hwm-0.js                                             0000664 0000000 0000000 00000001477 14746647661 0022632 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

// This test ensures that Readable stream will call _read() for streams
// with highWaterMark === 0 upon .read(0) instead of just trying to
// emit 'readable' event.

const assert = require('assert');
const { Readable } = require('stream');

const r = new Readable({
  // Must be called only once upon setting 'readable' listener
  read: common.mustCall(),
  highWaterMark: 0,
});

let pushedNull = false;
// This will trigger read(0) but must only be called after push(null)
// because the we haven't pushed any data
r.on('readable', common.mustCall(() => {
  assert.strictEqual(r.read(), null);
  assert.strictEqual(pushedNull, true);
}));
r.on('end', common.mustCall());
process.nextTick(() => {
  assert.strictEqual(r.read(), null);
  pushedNull = true;
  r.push(null);
});
                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stream-readable-infinite-read.js                                     0000664 0000000 0000000 00000001330 14746647661 0024404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

const buf = Buffer.alloc(8192);

const readable = new Readable({
  highWaterMark: 16 * 1024,
  read: common.mustCall(function() {
    this.push(buf);
  }, 31)
});

let i = 0;

readable.on('readable', common.mustCall(function() {
  if (i++ === 10) {
    // We will just terminate now.
    process.removeAllListeners('readable');
    return;
  }

  const data = readable.read();
  // TODO(mcollina): there is something odd in the highWaterMark logic
  // investigate.
  if (i === 1) {
    assert.strictEqual(data.length, 8192 * 2);
  } else {
    assert.strictEqual(data.length, 8192 * 3);
  }
}, 11));
                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-readable-invalid-chunk.js                                     0000664 0000000 0000000 00000001221 14746647661 0024421 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');

function testPushArg(val) {
  const readable = new stream.Readable({
    read: () => {}
  });
  readable.on('error', common.expectsError({
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  }));
  readable.push(val);
}

testPushArg([]);
testPushArg({});
testPushArg(0);

function testUnshiftArg(val) {
  const readable = new stream.Readable({
    read: () => {}
  });
  readable.on('error', common.expectsError({
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  }));
  readable.unshift(val);
}

testUnshiftArg([]);
testUnshiftArg({});
testUnshiftArg(0);
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-readable-needReadable.js                                      0000664 0000000 0000000 00000005354 14746647661 0024233 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const Readable = require('stream').Readable;

const readable = new Readable({
  read: () => {}
});

// Initialized to false.
assert.strictEqual(readable._readableState.needReadable, false);

readable.on('readable', common.mustCall(() => {
  // When the readable event fires, needReadable is reset.
  assert.strictEqual(readable._readableState.needReadable, false);
  readable.read();
}));

// If a readable listener is attached, then a readable event is needed.
assert.strictEqual(readable._readableState.needReadable, true);

readable.push('foo');
readable.push(null);

readable.on('end', common.mustCall(() => {
  // No need to emit readable anymore when the stream ends.
  assert.strictEqual(readable._readableState.needReadable, false);
}));

const asyncReadable = new Readable({
  read: () => {}
});

asyncReadable.on('readable', common.mustCall(() => {
  if (asyncReadable.read() !== null) {
    // After each read(), the buffer is empty.
    // If the stream doesn't end now,
    // then we need to notify the reader on future changes.
    assert.strictEqual(asyncReadable._readableState.needReadable, true);
  }
}, 2));

process.nextTick(common.mustCall(() => {
  asyncReadable.push('foooo');
}));
process.nextTick(common.mustCall(() => {
  asyncReadable.push('bar');
}));
setImmediate(common.mustCall(() => {
  asyncReadable.push(null);
  assert.strictEqual(asyncReadable._readableState.needReadable, false);
}));

const flowing = new Readable({
  read: () => {}
});

// Notice this must be above the on('data') call.
flowing.push('foooo');
flowing.push('bar');
flowing.push('quo');
process.nextTick(common.mustCall(() => {
  flowing.push(null);
}));

// When the buffer already has enough data, and the stream is
// in flowing mode, there is no need for the readable event.
flowing.on('data', common.mustCall(function(data) {
  assert.strictEqual(flowing._readableState.needReadable, false);
}, 3));

const slowProducer = new Readable({
  read: () => {}
});

slowProducer.on('readable', common.mustCall(() => {
  const chunk = slowProducer.read(8);
  const state = slowProducer._readableState;
  if (chunk === null) {
    // The buffer doesn't have enough data, and the stream is not need,
    // we need to notify the reader when data arrives.
    assert.strictEqual(state.needReadable, true);
  } else {
    assert.strictEqual(state.needReadable, false);
  }
}, 4));

process.nextTick(common.mustCall(() => {
  slowProducer.push('foo');
  process.nextTick(common.mustCall(() => {
    slowProducer.push('foo');
    process.nextTick(common.mustCall(() => {
      slowProducer.push('foo');
      process.nextTick(common.mustCall(() => {
        slowProducer.push(null);
      }));
    }));
  }));
}));
                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-stream-readable-next-no-null.js                                      0000664 0000000 0000000 00000000640 14746647661 0024231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const { mustNotCall, expectsError } = require('../common');
const { Readable } = require('stream');

async function* generate() {
  yield null;
}

const stream = Readable.from(generate());

stream.on('error', expectsError({
  code: 'ERR_STREAM_NULL_VALUES',
  name: 'TypeError',
  message: 'May not write null values to stream'
}));

stream.on('data', mustNotCall());

stream.on('end', mustNotCall());
                                                                                                node-23.7.0/test/parallel/test-stream-readable-no-unneeded-readable.js                              0000664 0000000 0000000 00000002177 14746647661 0025636 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Readable, PassThrough } = require('stream');

function test(r) {
  const wrapper = new Readable({
    read: () => {
      let data = r.read();

      if (data) {
        wrapper.push(data);
        return;
      }

      r.once('readable', function() {
        data = r.read();
        if (data) {
          wrapper.push(data);
        }
        // else: the end event should fire
      });
    },
  });

  r.once('end', function() {
    wrapper.push(null);
  });

  wrapper.resume();
  wrapper.once('end', common.mustCall());
}

{
  const source = new Readable({
    read: () => {}
  });
  source.push('foo');
  source.push('bar');
  source.push(null);

  const pt = source.pipe(new PassThrough());
  test(pt);
}

{
  // This is the underlying cause of the above test case.
  const pushChunks = ['foo', 'bar'];
  const r = new Readable({
    read: () => {
      const chunk = pushChunks.shift();
      if (chunk) {
        // synchronous call
        r.push(chunk);
      } else {
        // asynchronous call
        process.nextTick(() => r.push(null));
      }
    },
  });

  test(r);
}
                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stream-readable-object-multi-push-async.js                           0000664 0000000 0000000 00000007170 14746647661 0026364 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

const MAX = 42;
const BATCH = 10;

{
  const readable = new Readable({
    objectMode: true,
    read: common.mustCall(function() {
      console.log('>> READ');
      fetchData((err, data) => {
        if (err) {
          this.destroy(err);
          return;
        }

        if (data.length === 0) {
          console.log('pushing null');
          this.push(null);
          return;
        }

        console.log('pushing');
        data.forEach((d) => this.push(d));
      });
    }, Math.floor(MAX / BATCH) + 2)
  });

  let i = 0;
  function fetchData(cb) {
    if (i > MAX) {
      setTimeout(cb, 10, null, []);
    } else {
      const array = [];
      const max = i + BATCH;
      for (; i < max; i++) {
        array.push(i);
      }
      setTimeout(cb, 10, null, array);
    }
  }

  readable.on('readable', () => {
    let data;
    console.log('readable emitted');
    while ((data = readable.read()) !== null) {
      console.log(data);
    }
  });

  readable.on('end', common.mustCall(() => {
    assert.strictEqual(i, (Math.floor(MAX / BATCH) + 1) * BATCH);
  }));
}

{
  const readable = new Readable({
    objectMode: true,
    read: common.mustCall(function() {
      console.log('>> READ');
      fetchData((err, data) => {
        if (err) {
          this.destroy(err);
          return;
        }

        if (data.length === 0) {
          console.log('pushing null');
          this.push(null);
          return;
        }

        console.log('pushing');
        data.forEach((d) => this.push(d));
      });
    }, Math.floor(MAX / BATCH) + 2)
  });

  let i = 0;
  function fetchData(cb) {
    if (i > MAX) {
      setTimeout(cb, 10, null, []);
    } else {
      const array = [];
      const max = i + BATCH;
      for (; i < max; i++) {
        array.push(i);
      }
      setTimeout(cb, 10, null, array);
    }
  }

  readable.on('data', (data) => {
    console.log('data emitted', data);
  });

  readable.on('end', common.mustCall(() => {
    assert.strictEqual(i, (Math.floor(MAX / BATCH) + 1) * BATCH);
  }));
}

{
  const readable = new Readable({
    objectMode: true,
    read: common.mustCall(function() {
      console.log('>> READ');
      fetchData((err, data) => {
        if (err) {
          this.destroy(err);
          return;
        }

        console.log('pushing');
        data.forEach((d) => this.push(d));

        if (data[BATCH - 1] >= MAX) {
          console.log('pushing null');
          this.push(null);
        }
      });
    }, Math.floor(MAX / BATCH) + 1)
  });

  let i = 0;
  function fetchData(cb) {
    const array = [];
    const max = i + BATCH;
    for (; i < max; i++) {
      array.push(i);
    }
    setTimeout(cb, 10, null, array);
  }

  readable.on('data', (data) => {
    console.log('data emitted', data);
  });

  readable.on('end', common.mustCall(() => {
    assert.strictEqual(i, (Math.floor(MAX / BATCH) + 1) * BATCH);
  }));
}

{
  const readable = new Readable({
    objectMode: true,
    read: common.mustNotCall()
  });

  readable.on('data', common.mustNotCall());

  readable.push(null);

  let nextTickPassed = false;
  process.nextTick(() => {
    nextTickPassed = true;
  });

  readable.on('end', common.mustCall(() => {
    assert.strictEqual(nextTickPassed, true);
  }));
}

{
  const readable = new Readable({
    objectMode: true,
    read: common.mustCall()
  });

  readable.on('data', (data) => {
    console.log('data emitted', data);
  });

  readable.on('end', common.mustCall());

  setImmediate(() => {
    readable.push('aaa');
    readable.push(null);
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-readable-pause-and-resume.js                                  0000664 0000000 0000000 00000002716 14746647661 0025052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

let ticks = 18;
let expectedData = 19;

const rs = new Readable({
  objectMode: true,
  read: () => {
    if (ticks-- > 0)
      return process.nextTick(() => rs.push({}));
    rs.push({});
    rs.push(null);
  }
});

rs.on('end', common.mustCall());
readAndPause();

function readAndPause() {
  // Does a on(data) -> pause -> wait -> resume -> on(data) ... loop.
  // Expects on(data) to never fire if the stream is paused.
  const ondata = common.mustCall((data) => {
    rs.pause();

    expectedData--;
    if (expectedData <= 0)
      return;

    setImmediate(function() {
      rs.removeListener('data', ondata);
      readAndPause();
      rs.resume();
    });
  }, 1); // Only call ondata once

  rs.on('data', ondata);
}

{
  const readable = new Readable({
    read() {}
  });

  function read() {}

  readable.setEncoding('utf8');
  readable.on('readable', read);
  readable.removeListener('readable', read);
  readable.pause();

  process.nextTick(function() {
    assert(readable.isPaused());
  });
}

{
  const { PassThrough } = require('stream');

  const source3 = new PassThrough();
  const target3 = new PassThrough();

  const chunk = Buffer.allocUnsafe(1000);
  while (target3.write(chunk));

  source3.pipe(target3);
  target3.on('drain', common.mustCall(() => {
    assert(!source3.isPaused());
  }));
  target3.on('data', () => {});
}
                                                  node-23.7.0/test/parallel/test-stream-readable-readable-then-resume.js                              0000664 0000000 0000000 00000001257 14746647661 0025667 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable } = require('stream');
const assert = require('assert');

// This test verifies that a stream could be resumed after
// removing the readable event in the same tick

check(new Readable({
  objectMode: true,
  highWaterMark: 1,
  read() {
    if (!this.first) {
      this.push('hello');
      this.first = true;
      return;
    }

    this.push(null);
  }
}));

function check(s) {
  const readableListener = common.mustNotCall();
  s.on('readable', readableListener);
  s.on('end', common.mustCall());
  assert.strictEqual(s.removeListener, s.off);
  s.removeListener('readable', readableListener);
  s.resume();
}
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-stream-readable-readable.js                                          0000664 0000000 0000000 00000001640 14746647661 0023431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { Readable } = require('stream');

{
  const r = new Readable({
    read() {}
  });
  assert.strictEqual(r.readable, true);
  r.destroy();
  assert.strictEqual(r.readable, false);
}

{
  const mustNotCall = common.mustNotCall();
  const r = new Readable({
    read() {}
  });
  assert.strictEqual(r.readable, true);
  r.on('end', mustNotCall);
  r.resume();
  r.push(null);
  assert.strictEqual(r.readable, true);
  r.off('end', mustNotCall);
  r.on('end', common.mustCall(() => {
    assert.strictEqual(r.readable, false);
  }));
}

{
  const r = new Readable({
    read: common.mustCall(() => {
      process.nextTick(() => {
        r.destroy(new Error());
        assert.strictEqual(r.readable, false);
      });
    })
  });
  r.resume();
  r.on('error', common.mustCall(() => {
    assert.strictEqual(r.readable, false);
  }));
}
                                                                                                node-23.7.0/test/parallel/test-stream-readable-reading-readingMore.js                               0000664 0000000 0000000 00000010572 14746647661 0025541 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const Readable = require('stream').Readable;

{
  const readable = new Readable({
    read(size) {}
  });

  const state = readable._readableState;

  // Starting off with false initially.
  assert.strictEqual(state.reading, false);
  assert.strictEqual(state.readingMore, false);

  readable.on('data', common.mustCall((data) => {
    // While in a flowing state with a 'readable' listener
    // we should not be reading more
    if (readable.readableFlowing)
      assert.strictEqual(state.readingMore, true);

    // Reading as long as we've not ended
    assert.strictEqual(state.reading, !state.ended);
  }, 2));

  function onStreamEnd() {
    // End of stream; state.reading is false
    // And so should be readingMore.
    assert.strictEqual(state.readingMore, false);
    assert.strictEqual(state.reading, false);
  }

  const expectedReadingMore = [true, true, false];
  readable.on('readable', common.mustCall(() => {
    // There is only one readingMore scheduled from on('data'),
    // after which everything is governed by the .read() call
    assert.strictEqual(state.readingMore, expectedReadingMore.shift());

    // If the stream has ended, we shouldn't be reading
    assert.strictEqual(state.ended, !state.reading);

    // Consume all the data
    while (readable.read() !== null);

    if (expectedReadingMore.length === 0) // Reached end of stream
      process.nextTick(common.mustCall(onStreamEnd, 1));
  }, 3));

  readable.on('end', common.mustCall(onStreamEnd));
  readable.push('pushed');

  readable.read(6);

  // reading
  assert.strictEqual(state.reading, true);
  assert.strictEqual(state.readingMore, true);

  // add chunk to front
  readable.unshift('unshifted');

  // end
  readable.push(null);
}

{
  const readable = new Readable({
    read(size) {}
  });

  const state = readable._readableState;

  // Starting off with false initially.
  assert.strictEqual(state.reading, false);
  assert.strictEqual(state.readingMore, false);

  readable.on('data', common.mustCall((data) => {
    // While in a flowing state without a 'readable' listener
    // we should be reading more
    if (readable.readableFlowing)
      assert.strictEqual(state.readingMore, true);

    // Reading as long as we've not ended
    assert.strictEqual(state.reading, !state.ended);
  }, 2));

  function onStreamEnd() {
    // End of stream; state.reading is false
    // And so should be readingMore.
    assert.strictEqual(state.readingMore, false);
    assert.strictEqual(state.reading, false);
  }

  readable.on('end', common.mustCall(onStreamEnd));
  readable.push('pushed');

  // Stop emitting 'data' events
  assert.strictEqual(state.flowing, true);
  readable.pause();

  // paused
  assert.strictEqual(state.reading, false);
  assert.strictEqual(state.flowing, false);

  readable.resume();
  assert.strictEqual(state.reading, false);
  assert.strictEqual(state.flowing, true);

  // add chunk to front
  readable.unshift('unshifted');

  // end
  readable.push(null);
}

{
  const readable = new Readable({
    read(size) {}
  });

  const state = readable._readableState;

  // Starting off with false initially.
  assert.strictEqual(state.reading, false);
  assert.strictEqual(state.readingMore, false);

  const onReadable = common.mustNotCall();

  readable.on('readable', onReadable);

  readable.on('data', common.mustCall((data) => {
    // Reading as long as we've not ended
    assert.strictEqual(state.reading, !state.ended);
  }, 2));

  readable.removeListener('readable', onReadable);

  function onStreamEnd() {
    // End of stream; state.reading is false
    // And so should be readingMore.
    assert.strictEqual(state.readingMore, false);
    assert.strictEqual(state.reading, false);
  }

  readable.on('end', common.mustCall(onStreamEnd));
  readable.push('pushed');

  // We are still not flowing, we will be resuming in the next tick
  assert.strictEqual(state.flowing, false);

  // Wait for nextTick, so the readableListener flag resets
  process.nextTick(function() {
    readable.resume();

    // Stop emitting 'data' events
    assert.strictEqual(state.flowing, true);
    readable.pause();

    // paused
    assert.strictEqual(state.flowing, false);

    readable.resume();
    assert.strictEqual(state.flowing, true);

    // add chunk to front
    readable.unshift('unshifted');

    // end
    readable.push(null);
  });
}
                                                                                                                                      node-23.7.0/test/parallel/test-stream-readable-resume-hwm.js                                        0000664 0000000 0000000 00000001245 14746647661 0023764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Readable } = require('stream');

// readable.resume() should not lead to a ._read() call being scheduled
// when we exceed the high water mark already.

const readable = new Readable({
  read: common.mustNotCall(),
  highWaterMark: 100
});

// Fill up the internal buffer so that we definitely exceed the HWM:
for (let i = 0; i < 10; i++)
  readable.push('a'.repeat(200));

// Call resume, and pause after one chunk.
// The .pause() is just so that we don’t empty the buffer fully, which would
// be a valid reason to call ._read().
readable.resume();
readable.once('data', common.mustCall(() => readable.pause()));
                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-readable-resumeScheduled.js                                   0000664 0000000 0000000 00000003404 14746647661 0025013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// Testing Readable Stream resumeScheduled state

const assert = require('assert');
const { Readable, Writable } = require('stream');

{
  // pipe() test case
  const r = new Readable({ read() {} });
  const w = new Writable();

  // resumeScheduled should start = `false`.
  assert.strictEqual(r._readableState.resumeScheduled, false);

  // Calling pipe() should change the state value = true.
  r.pipe(w);
  assert.strictEqual(r._readableState.resumeScheduled, true);

  process.nextTick(common.mustCall(() => {
    assert.strictEqual(r._readableState.resumeScheduled, false);
  }));
}

{
  // 'data' listener test case
  const r = new Readable({ read() {} });

  // resumeScheduled should start = `false`.
  assert.strictEqual(r._readableState.resumeScheduled, false);

  r.push(Buffer.from([1, 2, 3]));

  // Adding 'data' listener should change the state value
  r.on('data', common.mustCall(() => {
    assert.strictEqual(r._readableState.resumeScheduled, false);
  }));
  assert.strictEqual(r._readableState.resumeScheduled, true);

  process.nextTick(common.mustCall(() => {
    assert.strictEqual(r._readableState.resumeScheduled, false);
  }));
}

{
  // resume() test case
  const r = new Readable({ read() {} });

  // resumeScheduled should start = `false`.
  assert.strictEqual(r._readableState.resumeScheduled, false);

  // Calling resume() should change the state value.
  r.resume();
  assert.strictEqual(r._readableState.resumeScheduled, true);

  r.on('resume', common.mustCall(() => {
    // The state value should be `false` again
    assert.strictEqual(r._readableState.resumeScheduled, false);
  }));

  process.nextTick(common.mustCall(() => {
    assert.strictEqual(r._readableState.resumeScheduled, false);
  }));
}
                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-readable-setEncoding-existing-buffers.js                      0000664 0000000 0000000 00000002507 14746647661 0027421 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { Readable } = require('stream');
const assert = require('assert');

{
  // Call .setEncoding() while there are bytes already in the buffer.
  const r = new Readable({ read() {} });

  r.push(Buffer.from('a'));
  r.push(Buffer.from('b'));

  r.setEncoding('utf8');
  const chunks = [];
  r.on('data', (chunk) => chunks.push(chunk));

  process.nextTick(() => {
    assert.deepStrictEqual(chunks, ['ab']);
  });
}

{
  // Call .setEncoding() while the buffer contains a complete,
  // but chunked character.
  const r = new Readable({ read() {} });

  r.push(Buffer.from([0xf0]));
  r.push(Buffer.from([0x9f]));
  r.push(Buffer.from([0x8e]));
  r.push(Buffer.from([0x89]));

  r.setEncoding('utf8');
  const chunks = [];
  r.on('data', (chunk) => chunks.push(chunk));

  process.nextTick(() => {
    assert.deepStrictEqual(chunks, ['🎉']);
  });
}

{
  // Call .setEncoding() while the buffer contains an incomplete character,
  // and finish the character later.
  const r = new Readable({ read() {} });

  r.push(Buffer.from([0xf0]));
  r.push(Buffer.from([0x9f]));

  r.setEncoding('utf8');

  r.push(Buffer.from([0x8e]));
  r.push(Buffer.from([0x89]));

  const chunks = [];
  r.on('data', (chunk) => chunks.push(chunk));

  process.nextTick(() => {
    assert.deepStrictEqual(chunks, ['🎉']);
  });
}
                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-readable-setEncoding-null.js                                  0000664 0000000 0000000 00000000512 14746647661 0025101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const { Readable } = require('stream');


{
  const readable = new Readable({ encoding: 'hex' });
  assert.strictEqual(readable._readableState.encoding, 'hex');

  readable.setEncoding(null);

  assert.strictEqual(readable._readableState.encoding, 'utf8');
}
                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-readable-strategy-option.js                                   0000664 0000000 0000000 00000003735 14746647661 0025051 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Readable } = require('stream');
const assert = require('assert');
const { strictEqual } = require('assert');

{
  // Strategy 2
  const streamData = ['a', 'b', 'c', null];

  // Fulfill a Readable object
  const readable = new Readable({
    read: common.mustCall(() => {
      process.nextTick(() => {
        readable.push(streamData.shift());
      });
    }, streamData.length),
  });

  // Use helper to convert it to a Web ReadableStream using ByteLength strategy
  const readableStream = Readable.toWeb(readable, {
    strategy: new ByteLengthQueuingStrategy({ highWaterMark: 1 }),
  });

  assert(!readableStream.locked);
  readableStream.getReader().read().then(common.mustCall());
}

{
  // Strategy 2
  const streamData = ['a', 'b', 'c', null];

  // Fulfill a Readable object
  const readable = new Readable({
    read: common.mustCall(() => {
      process.nextTick(() => {
        readable.push(streamData.shift());
      });
    }, streamData.length),
  });

  // Use helper to convert it to a Web ReadableStream using Count strategy
  const readableStream = Readable.toWeb(readable, {
    strategy: new CountQueuingStrategy({ highWaterMark: 1 }),
  });

  assert(!readableStream.locked);
  readableStream.getReader().read().then(common.mustCall());
}

{
  const desireSizeExpected = 2;

  const stringStream = new ReadableStream(
    {
      start(controller) {
        // Check if the strategy is being assigned on the init of the ReadableStream
        strictEqual(controller.desiredSize, desireSizeExpected);
        controller.enqueue('a');
        controller.enqueue('b');
        controller.close();
      },
    },
    new CountQueuingStrategy({ highWaterMark: desireSizeExpected })
  );

  const reader = stringStream.getReader();

  reader.read().then(common.mustCall());
  reader.read().then(common.mustCall());
  reader.read().then(({ value, done }) => {
    strictEqual(value, undefined);
    strictEqual(done, true);
  });
}
                                   node-23.7.0/test/parallel/test-stream-readable-to-web-termination.js                                0000664 0000000 0000000 00000000444 14746647661 0025417 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { Readable } = require('stream');

{
  const r = Readable.from([]);
  // Cancelling reader while closing should not cause uncaught exceptions
  r.on('close', () => reader.cancel());

  const reader = Readable.toWeb(r).getReader();
  reader.read();
}
                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-readable-to-web.js                                            0000664 0000000 0000000 00000003616 14746647661 0023074 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
if (!common.hasCrypto) { common.skip('missing crypto'); }

const { Readable } = require('stream');
const process = require('process');
const { randomBytes } = require('crypto');
const assert = require('assert');

// Based on: https://github.com/nodejs/node/issues/46347#issuecomment-1413886707
// edit: make it cross-platform as /dev/urandom is not available on Windows
{
  let currentMemoryUsage = process.memoryUsage().arrayBuffers;

  // We initialize a stream, but not start consuming it
  const randomNodeStream = new Readable({
    read(size) {
      randomBytes(size, (err, buffer) => {
        if (err) {
          // If an error occurs, emit an 'error' event
          this.emit('error', err);
          return;
        }

        // Push the random bytes to the stream
        this.push(buffer);
      });
    }
  });
  // after 2 seconds, it'll get converted to web stream
  let randomWebStream;

  // We check memory usage every second
  // since it's a stream, it shouldn't be higher than the chunk size
  const reportMemoryUsage = () => {
    const { arrayBuffers } = process.memoryUsage();
    currentMemoryUsage = arrayBuffers;

    assert(currentMemoryUsage <= 256 * 1024 * 1024);
  };
  setInterval(reportMemoryUsage, 1000);

  // after 1 second we use Readable.toWeb
  // memory usage should stay pretty much the same since it's still a stream
  setTimeout(() => {
    randomWebStream = Readable.toWeb(randomNodeStream);
  }, 1000);

  // after 2 seconds we start consuming the stream
  // memory usage will grow, but the old chunks should be garbage-collected pretty quickly
  setTimeout(async () => {
    // eslint-disable-next-line no-unused-vars
    for await (const _ of randomWebStream) {
      // Do nothing, just let the stream flow
    }
  }, 2000);

  setTimeout(() => {
    // Test considered passed if we don't crash
    process.exit(0);
  }, 5000);
}
                                                                                                                  node-23.7.0/test/parallel/test-stream-readable-unpipe-resume.js                                     0000664 0000000 0000000 00000000627 14746647661 0024474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');
const fs = require('fs');

const readStream = fs.createReadStream(process.execPath);

const transformStream = new stream.Transform({
  transform: common.mustCall(() => {
    readStream.unpipe();
    readStream.resume();
  })
});

readStream.on('end', common.mustCall());

readStream
  .pipe(transformStream)
  .resume();
                                                                                                         node-23.7.0/test/parallel/test-stream-readable-unshift.js                                           0000664 0000000 0000000 00000007754 14746647661 0023366 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable } = require('stream');

{
  // Check that strings are saved as Buffer
  const readable = new Readable({ read() {} });

  const string = 'abc';

  readable.on('data', common.mustCall((chunk) => {
    assert(Buffer.isBuffer(chunk));
    assert.strictEqual(chunk.toString('utf8'), string);
  }, 1));

  readable.unshift(string);

}

{
  // Check that data goes at the beginning
  const readable = new Readable({ read() {} });
  const unshift = 'front';
  const push = 'back';

  const expected = [unshift, push];
  readable.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk.toString('utf8'), expected.shift());
  }, 2));


  readable.push(push);
  readable.unshift(unshift);
}

{
  // Check that buffer is saved with correct encoding
  const readable = new Readable({ read() {} });

  const encoding = 'base64';
  const string = Buffer.from('abc').toString(encoding);

  readable.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk.toString(encoding), string);
  }, 1));

  readable.unshift(string, encoding);

}

{

  const streamEncoding = 'base64';

  function checkEncoding(readable) {

    // chunk encodings
    const encodings = ['utf8', 'binary', 'hex', 'base64'];
    const expected = [];

    readable.on('data', common.mustCall((chunk) => {
      const { encoding, string } = expected.pop();
      assert.strictEqual(chunk.toString(encoding), string);
    }, encodings.length));

    for (const encoding of encodings) {
      const string = 'abc';

      // If encoding is the same as the state.encoding the string is
      // saved as is
      const expect = encoding !== streamEncoding ?
        Buffer.from(string, encoding).toString(streamEncoding) : string;

      expected.push({ encoding, string: expect });

      readable.unshift(string, encoding);
    }
  }

  const r1 = new Readable({ read() {} });
  r1.setEncoding(streamEncoding);
  checkEncoding(r1);

  const r2 = new Readable({ read() {}, encoding: streamEncoding });
  checkEncoding(r2);

}

{
  // Both .push & .unshift should have the same behaviour
  // When setting an encoding, each chunk should be emitted with that encoding
  const encoding = 'base64';

  function checkEncoding(readable) {
    const string = 'abc';
    readable.on('data', common.mustCall((chunk) => {
      assert.strictEqual(chunk, Buffer.from(string).toString(encoding));
    }, 2));

    readable.push(string);
    readable.unshift(string);
  }

  const r1 = new Readable({ read() {} });
  r1.setEncoding(encoding);
  checkEncoding(r1);

  const r2 = new Readable({ read() {}, encoding });
  checkEncoding(r2);

}

{
  // Check that ObjectMode works
  const readable = new Readable({ objectMode: true, read() {} });

  const chunks = ['a', 1, {}, []];

  readable.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, chunks.pop());
  }, chunks.length));

  for (const chunk of chunks) {
    readable.unshift(chunk);
  }
}

{

  // Should not throw: https://github.com/nodejs/node/issues/27192
  const highWaterMark = 50;
  class ArrayReader extends Readable {
    constructor(opt) {
      super({ highWaterMark });
      // The error happened only when pushing above hwm
      this.buffer = new Array(highWaterMark * 2).fill(0).map(String);
    }
    _read(size) {
      while (this.buffer.length) {
        const chunk = this.buffer.shift();
        if (!this.buffer.length) {
          this.push(chunk);
          this.push(null);
          return true;
        }
        if (!this.push(chunk))
          return;
      }
    }
  }

  function onRead() {
    while (null !== (stream.read())) {
      // Remove the 'readable' listener before unshifting
      stream.removeListener('readable', onRead);
      stream.unshift('a');
      stream.on('data', (chunk) => {
        console.log(chunk.length);
      });
      break;
    }
  }

  const stream = new ArrayReader();
  stream.once('readable', common.mustCall(onRead));
  stream.on('end', common.mustCall());

}
                    node-23.7.0/test/parallel/test-stream-readable-with-unimplemented-_read.js                          0000664 0000000 0000000 00000000522 14746647661 0026557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Readable } = require('stream');

const readable = new Readable();

readable.read();
readable.on('error', common.expectsError({
  code: 'ERR_METHOD_NOT_IMPLEMENTED',
  name: 'Error',
  message: 'The _read() method is not implemented'
}));
readable.on('close', common.mustCall());
                                                                                                                                                                              node-23.7.0/test/parallel/test-stream-readableListening-state.js                                    0000664 0000000 0000000 00000001665 14746647661 0024676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const stream = require('stream');

const r = new stream.Readable({
  read: () => {}
});

// readableListening state should start in `false`.
assert.strictEqual(r._readableState.readableListening, false);

r.on('readable', common.mustCall(() => {
  // Inside the readable event this state should be true.
  assert.strictEqual(r._readableState.readableListening, true);
}));

r.push(Buffer.from('Testing readableListening state'));

const r2 = new stream.Readable({
  read: () => {}
});

// readableListening state should start in `false`.
assert.strictEqual(r2._readableState.readableListening, false);

r2.on('data', common.mustCall((chunk) => {
  // readableListening should be false because we don't have
  // a `readable` listener
  assert.strictEqual(r2._readableState.readableListening, false);
}));

r2.push(Buffer.from('Testing readableListening state'));
                                                                           node-23.7.0/test/parallel/test-stream-reduce.js                                                     0000664 0000000 0000000 00000007657 14746647661 0021422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable,
} = require('stream');
const assert = require('assert');

function sum(p, c) {
  return p + c;
}

{
  // Does the same thing as `(await stream.toArray()).reduce(...)`
  (async () => {
    const tests = [
      [[], sum, 0],
      [[1], sum, 0],
      [[1, 2, 3, 4, 5], sum, 0],
      [[...Array(100).keys()], sum, 0],
      [['a', 'b', 'c'], sum, ''],
      [[1, 2], sum],
      [[1, 2, 3], (x, y) => y],
    ];
    for (const [values, fn, initial] of tests) {
      const streamReduce = await Readable.from(values)
                                         .reduce(fn, initial);
      const arrayReduce = values.reduce(fn, initial);
      assert.deepStrictEqual(streamReduce, arrayReduce);
    }
    // Does the same thing as `(await stream.toArray()).reduce(...)` with an
    // asynchronous reducer
    for (const [values, fn, initial] of tests) {
      const streamReduce = await Readable.from(values)
                                         .map(async (x) => x)
                                         .reduce(fn, initial);
      const arrayReduce = values.reduce(fn, initial);
      assert.deepStrictEqual(streamReduce, arrayReduce);
    }
  })().then(common.mustCall());
}
{
  // Works with an async reducer, with or without initial value
  (async () => {
    const six = await Readable.from([1, 2, 3]).reduce(async (p, c) => p + c, 0);
    assert.strictEqual(six, 6);
  })().then(common.mustCall());
  (async () => {
    const six = await Readable.from([1, 2, 3]).reduce(async (p, c) => p + c);
    assert.strictEqual(six, 6);
  })().then(common.mustCall());
}
{
  // Works lazily
  assert.rejects(Readable.from([1, 2, 3, 4, 5, 6])
    .map(common.mustCall((x) => {
      return x;
    }, 3)) // Two consumed and one buffered by `map` due to default concurrency
    .reduce(async (p, c) => {
      if (p === 1) {
        throw new Error('boom');
      }
      return c;
    }, 0)
  , /boom/).then(common.mustCall());
}

{
  // Support for AbortSignal
  const ac = new AbortController();
  assert.rejects(async () => {
    await Readable.from([1, 2, 3]).reduce(async (p, c) => {
      if (c === 3) {
        await new Promise(() => {}); // Explicitly do not pass signal here
      }
      return Promise.resolve();
    }, 0, { signal: ac.signal });
  }, {
    name: 'AbortError',
  }).then(common.mustCall());
  ac.abort();
}


{
  // Support for AbortSignal - pre aborted
  const stream = Readable.from([1, 2, 3]);
  assert.rejects(async () => {
    await stream.reduce(async (p, c) => {
      if (c === 3) {
        await new Promise(() => {}); // Explicitly do not pass signal here
      }
      return Promise.resolve();
    }, 0, { signal: AbortSignal.abort() });
  }, {
    name: 'AbortError',
  }).then(common.mustCall(() => {
    assert.strictEqual(stream.destroyed, true);
  }));
}

{
  // Support for AbortSignal - deep
  const stream = Readable.from([1, 2, 3]);
  assert.rejects(async () => {
    await stream.reduce(async (p, c, { signal }) => {
      signal.addEventListener('abort', common.mustCall(), { once: true });
      if (c === 3) {
        await new Promise(() => {}); // Explicitly do not pass signal here
      }
      return Promise.resolve();
    }, 0, { signal: AbortSignal.abort() });
  }, {
    name: 'AbortError',
  }).then(common.mustCall(() => {
    assert.strictEqual(stream.destroyed, true);
  }));
}

{
  // Error cases
  assert.rejects(() => Readable.from([]).reduce(1), /TypeError/).then(common.mustCall());
  assert.rejects(() => Readable.from([]).reduce('5'), /TypeError/).then(common.mustCall());
  assert.rejects(() => Readable.from([]).reduce((x, y) => x + y, 0, 1), /ERR_INVALID_ARG_TYPE/).then(common.mustCall());
  assert.rejects(() => Readable.from([]).reduce((x, y) => x + y, 0, { signal: true }), /ERR_INVALID_ARG_TYPE/).then(common.mustCall());
}

{
  // Test result is a Promise
  const result = Readable.from([1, 2, 3, 4, 5]).reduce(sum, 0);
  assert.ok(result instanceof Promise);
}
                                                                                 node-23.7.0/test/parallel/test-stream-set-default-hwm.js                                            0000664 0000000 0000000 00000001555 14746647661 0023150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const assert = require('node:assert');
const {
  setDefaultHighWaterMark,
  getDefaultHighWaterMark,
  Writable,
  Readable,
  Transform
} = require('stream');

assert.notStrictEqual(getDefaultHighWaterMark(false), 32 * 1000);
setDefaultHighWaterMark(false, 32 * 1000);
assert.strictEqual(getDefaultHighWaterMark(false), 32 * 1000);

assert.notStrictEqual(getDefaultHighWaterMark(true), 32);
setDefaultHighWaterMark(true, 32);
assert.strictEqual(getDefaultHighWaterMark(true), 32);

const w = new Writable({
  write() {}
});
assert.strictEqual(w.writableHighWaterMark, 32 * 1000);

const r = new Readable({
  read() {}
});
assert.strictEqual(r.readableHighWaterMark, 32 * 1000);

const t = new Transform({
  transform() {}
});
assert.strictEqual(t.writableHighWaterMark, 32 * 1000);
assert.strictEqual(t.readableHighWaterMark, 32 * 1000);
                                                                                                                                                   node-23.7.0/test/parallel/test-stream-some-find-every.mjs                                           0000664 0000000 0000000 00000014140 14746647661 0023322 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as common from '../common/index.mjs';
import { setTimeout } from 'timers/promises';
import { Readable } from 'stream';
import assert from 'assert';


function oneTo5() {
  return Readable.from([1, 2, 3, 4, 5]);
}

function oneTo5Async() {
  return oneTo5().map(async (x) => {
    await Promise.resolve();
    return x;
  });
}
{
  // Some, find, and every work with a synchronous stream and predicate
  assert.strictEqual(await oneTo5().some((x) => x > 3), true);
  assert.strictEqual(await oneTo5().every((x) => x > 3), false);
  assert.strictEqual(await oneTo5().find((x) => x > 3), 4);
  assert.strictEqual(await oneTo5().some((x) => x > 6), false);
  assert.strictEqual(await oneTo5().every((x) => x < 6), true);
  assert.strictEqual(await oneTo5().find((x) => x > 6), undefined);
  assert.strictEqual(await Readable.from([]).some(() => true), false);
  assert.strictEqual(await Readable.from([]).every(() => true), true);
  assert.strictEqual(await Readable.from([]).find(() => true), undefined);
}

{
  // Some, find, and every work with an asynchronous stream and synchronous predicate
  assert.strictEqual(await oneTo5Async().some((x) => x > 3), true);
  assert.strictEqual(await oneTo5Async().every((x) => x > 3), false);
  assert.strictEqual(await oneTo5Async().find((x) => x > 3), 4);
  assert.strictEqual(await oneTo5Async().some((x) => x > 6), false);
  assert.strictEqual(await oneTo5Async().every((x) => x < 6), true);
  assert.strictEqual(await oneTo5Async().find((x) => x > 6), undefined);
}

{
  // Some, find, and every work on synchronous streams with an asynchronous predicate
  assert.strictEqual(await oneTo5().some(async (x) => x > 3), true);
  assert.strictEqual(await oneTo5().every(async (x) => x > 3), false);
  assert.strictEqual(await oneTo5().find(async (x) => x > 3), 4);
  assert.strictEqual(await oneTo5().some(async (x) => x > 6), false);
  assert.strictEqual(await oneTo5().every(async (x) => x < 6), true);
  assert.strictEqual(await oneTo5().find(async (x) => x > 6), undefined);
}

{
  // Some, find, and every work on asynchronous streams with an asynchronous predicate
  assert.strictEqual(await oneTo5Async().some(async (x) => x > 3), true);
  assert.strictEqual(await oneTo5Async().every(async (x) => x > 3), false);
  assert.strictEqual(await oneTo5Async().find(async (x) => x > 3), 4);
  assert.strictEqual(await oneTo5Async().some(async (x) => x > 6), false);
  assert.strictEqual(await oneTo5Async().every(async (x) => x < 6), true);
  assert.strictEqual(await oneTo5Async().find(async (x) => x > 6), undefined);
}

{
  async function checkDestroyed(stream) {
    await setTimeout();
    assert.strictEqual(stream.destroyed, true);
  }

  {
    // Some, find, and every short circuit
    const someStream = oneTo5();
    await someStream.some(common.mustCall((x) => x > 2, 3));
    await checkDestroyed(someStream);

    const everyStream = oneTo5();
    await everyStream.every(common.mustCall((x) => x < 3, 3));
    await checkDestroyed(everyStream);

    const findStream = oneTo5();
    await findStream.find(common.mustCall((x) => x > 1, 2));
    await checkDestroyed(findStream);

    // When short circuit isn't possible the whole stream is iterated
    await oneTo5().some(common.mustCall(() => false, 5));
    await oneTo5().every(common.mustCall(() => true, 5));
    await oneTo5().find(common.mustCall(() => false, 5));
  }

  {
    // Some, find, and every short circuit async stream/predicate
    const someStream = oneTo5Async();
    await someStream.some(common.mustCall(async (x) => x > 2, 3));
    await checkDestroyed(someStream);

    const everyStream = oneTo5Async();
    await everyStream.every(common.mustCall(async (x) => x < 3, 3));
    await checkDestroyed(everyStream);

    const findStream = oneTo5Async();
    await findStream.find(common.mustCall(async (x) => x > 1, 2));
    await checkDestroyed(findStream);

    // When short circuit isn't possible the whole stream is iterated
    await oneTo5Async().some(common.mustCall(async () => false, 5));
    await oneTo5Async().every(common.mustCall(async () => true, 5));
    await oneTo5Async().find(common.mustCall(async () => false, 5));
  }
}

{
  // Concurrency doesn't affect which value is found.
  const found = await Readable.from([1, 2]).find(async (val) => {
    if (val === 1) {
      await setTimeout(100);
    }
    return true;
  }, { concurrency: 2 });
  assert.strictEqual(found, 1);
}

{
  // Support for AbortSignal
  for (const op of ['some', 'every', 'find']) {
    {
      const ac = new AbortController();
      assert.rejects(Readable.from([1, 2, 3])[op](
        () => new Promise(() => { }),
        { signal: ac.signal }
      ), {
        name: 'AbortError',
      }, `${op} should abort correctly with sync abort`).then(common.mustCall());
      ac.abort();
    }
    {
      // Support for pre-aborted AbortSignal
      assert.rejects(Readable.from([1, 2, 3])[op](
        () => new Promise(() => { }),
        { signal: AbortSignal.abort() }
      ), {
        name: 'AbortError',
      }, `${op} should abort with pre-aborted abort controller`).then(common.mustCall());
    }
  }
}
{
  // Error cases
  for (const op of ['some', 'every', 'find']) {
    assert.rejects(async () => {
      await Readable.from([1])[op](1);
    }, /ERR_INVALID_ARG_TYPE/, `${op} should throw for invalid function`).then(common.mustCall());
    assert.rejects(async () => {
      await Readable.from([1])[op]((x) => x, {
        concurrency: 'Foo'
      });
    }, /ERR_OUT_OF_RANGE/, `${op} should throw for invalid concurrency`).then(common.mustCall());
    assert.rejects(async () => {
      await Readable.from([1])[op]((x) => x, 1);
    }, /ERR_INVALID_ARG_TYPE/, `${op} should throw for invalid concurrency`).then(common.mustCall());
    assert.rejects(async () => {
      await Readable.from([1])[op]((x) => x, {
        signal: true
      });
    }, /ERR_INVALID_ARG_TYPE/, `${op} should throw for invalid signal`).then(common.mustCall());
  }
}
{
  for (const op of ['some', 'every', 'find']) {
    const stream = oneTo5();
    Object.defineProperty(stream, 'map', {
      value: common.mustNotCall(),
    });
    // Check that map isn't getting called.
    stream[op](() => {});
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-stream-toArray.js                                                    0000664 0000000 0000000 00000004435 14746647661 0021563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Readable,
} = require('stream');
const assert = require('assert');

{
  // Works on a synchronous stream
  (async () => {
    const tests = [
      [],
      [1],
      [1, 2, 3],
      Array(100).fill().map((_, i) => i),
    ];
    for (const test of tests) {
      const stream = Readable.from(test);
      const result = await stream.toArray();
      assert.deepStrictEqual(result, test);
    }
  })().then(common.mustCall());
}

{
  // Works on a non-object-mode stream
  (async () => {
    const firstBuffer = Buffer.from([1, 2, 3]);
    const secondBuffer = Buffer.from([4, 5, 6]);
    const stream = Readable.from(
      [firstBuffer, secondBuffer],
      { objectMode: false });
    const result = await stream.toArray();
    assert.strictEqual(Array.isArray(result), true);
    assert.deepStrictEqual(result, [firstBuffer, secondBuffer]);
  })().then(common.mustCall());
}

{
  // Works on an asynchronous stream
  (async () => {
    const tests = [
      [],
      [1],
      [1, 2, 3],
      Array(100).fill().map((_, i) => i),
    ];
    for (const test of tests) {
      const stream = Readable.from(test).map((x) => Promise.resolve(x));
      const result = await stream.toArray();
      assert.deepStrictEqual(result, test);
    }
  })().then(common.mustCall());
}

{
  // Support for AbortSignal
  const ac = new AbortController();
  let stream;
  assert.rejects(async () => {
    stream = Readable.from([1, 2, 3]).map(async (x) => {
      if (x === 3) {
        await new Promise(() => {}); // Explicitly do not pass signal here
      }
      return Promise.resolve(x);
    });
    await stream.toArray({ signal: ac.signal });
  }, {
    name: 'AbortError',
  }).then(common.mustCall(() => {
    // Only stops toArray, does not destroy the stream
    assert(stream.destroyed, false);
  }));
  ac.abort();
}
{
  // Test result is a Promise
  const result = Readable.from([1, 2, 3, 4, 5]).toArray();
  assert.strictEqual(result instanceof Promise, true);
}
{
  // Error cases
  assert.rejects(async () => {
    await Readable.from([1]).toArray(1);
  }, /ERR_INVALID_ARG_TYPE/).then(common.mustCall());

  assert.rejects(async () => {
    await Readable.from([1]).toArray({
      signal: true
    });
  }, /ERR_INVALID_ARG_TYPE/).then(common.mustCall());
}
                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-stream-toWeb-allows-server-response.js                               0000664 0000000 0000000 00000001210 14746647661 0025645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Writable } = require('stream');

const assert = require('assert');
const http = require('http');

// Check if Writable.toWeb works on the response object after creating a server.
const server = http.createServer(
  common.mustCall((req, res) => {
    const webStreamResponse = Writable.toWeb(res);
    assert.strictEqual(webStreamResponse instanceof WritableStream, true);
    res.end();
  })
);

server.listen(
  0,
  common.mustCall(() => {
    http.get(
      {
        port: server.address().port,
      },
      common.mustCall(() => {
        server.close();
      })
    );
  })
);
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-transform-callback-twice.js                                   0000664 0000000 0000000 00000000516 14746647661 0025014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Transform } = require('stream');
const stream = new Transform({
  transform(chunk, enc, cb) { cb(); cb(); }
});

stream.on('error', common.expectsError({
  name: 'Error',
  message: 'Callback called multiple times',
  code: 'ERR_MULTIPLE_CALLBACK'
}));

stream.write('foo');
                                                                                                                                                                                  node-23.7.0/test/parallel/test-stream-transform-constructor-set-methods.js                          0000664 0000000 0000000 00000001433 14746647661 0026765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const assert = require('assert');
const { Transform } = require('stream');

const t = new Transform();

assert.throws(
  () => {
    t.end(Buffer.from('blerg'));
  },
  {
    name: 'Error',
    code: 'ERR_METHOD_NOT_IMPLEMENTED',
    message: 'The _transform() method is not implemented'
  }
);

const _transform = common.mustCall((chunk, _, next) => {
  next();
});

const _final = common.mustCall((next) => {
  next();
});

const _flush = common.mustCall((next) => {
  next();
});

const t2 = new Transform({
  transform: _transform,
  flush: _flush,
  final: _final
});

assert.strictEqual(t2._transform, _transform);
assert.strictEqual(t2._flush, _flush);
assert.strictEqual(t2._final, _final);

t2.end(Buffer.from('blerg'));
t2.resume();
                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-transform-destroy.js                                          0000664 0000000 0000000 00000006725 14746647661 0023650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Transform } = require('stream');
const assert = require('assert');

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });

  transform.resume();

  transform.on('end', common.mustNotCall());
  transform.on('close', common.mustCall());
  transform.on('finish', common.mustNotCall());

  transform.destroy();
}

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });
  transform.resume();

  const expected = new Error('kaboom');

  transform.on('end', common.mustNotCall());
  transform.on('finish', common.mustNotCall());
  transform.on('close', common.mustCall());
  transform.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  transform.destroy(expected);
}

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });

  transform._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, expected);
    cb(err);
  }, 1);

  const expected = new Error('kaboom');

  transform.on('finish', common.mustNotCall('no finish event'));
  transform.on('close', common.mustCall());
  transform.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  transform.destroy(expected);
}

{
  const expected = new Error('kaboom');
  const transform = new Transform({
    transform(chunk, enc, cb) {},
    destroy: common.mustCall(function(err, cb) {
      assert.strictEqual(err, expected);
      cb();
    }, 1)
  });
  transform.resume();

  transform.on('end', common.mustNotCall('no end event'));
  transform.on('close', common.mustCall());
  transform.on('finish', common.mustNotCall('no finish event'));

  // Error is swallowed by the custom _destroy
  transform.on('error', common.mustNotCall('no error event'));

  transform.destroy(expected);
}

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });

  transform._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb();
  }, 1);

  transform.destroy();
}

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });
  transform.resume();

  transform._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    process.nextTick(() => {
      this.push(null);
      this.end();
      cb();
    });
  }, 1);

  const fail = common.mustNotCall('no event');

  transform.on('finish', fail);
  transform.on('end', fail);
  transform.on('close', common.mustCall());

  transform.destroy();

  transform.removeListener('end', fail);
  transform.removeListener('finish', fail);
  transform.on('end', common.mustCall());
  transform.on('finish', common.mustNotCall());
}

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });

  const expected = new Error('kaboom');

  transform._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb(expected);
  }, 1);

  transform.on('close', common.mustCall());
  transform.on('finish', common.mustNotCall('no finish event'));
  transform.on('end', common.mustNotCall('no end event'));
  transform.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  transform.destroy();
}

{
  const transform = new Transform({
    transform(chunk, enc, cb) {}
  });
  transform.on('error', common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
  transform.on('close', common.mustCall());
  transform[Symbol.asyncDispose]().then(common.mustCall());
}
                                           node-23.7.0/test/parallel/test-stream-transform-final-sync.js                                       0000664 0000000 0000000 00000004742 14746647661 0024217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const stream = require('stream');
let state = 0;


// What you do
//
// const stream = new stream.Transform({
//   transform: function transformCallback(chunk, _, next) {
//     // part 1
//     this.push(chunk);
//     //part 2
//     next();
//   },
//   final: function endCallback(done) {
//     // part 1
//     process.nextTick(function () {
//       // part 2
//       done();
//     });
//   },
//   flush: function flushCallback(done) {
//     // part 1
//     process.nextTick(function () {
//       // part 2
//       done();
//     });
//   }
// });
// t.on('data', dataListener);
// t.on('end', endListener);
// t.on('finish', finishListener);
// t.write(1);
// t.write(4);
// t.end(7, endMethodCallback);
//
// The order things are called
//
// 1. transformCallback part 1
// 2. dataListener
// 3. transformCallback part 2
// 4. transformCallback part 1
// 5. dataListener
// 6. transformCallback part 2
// 7. transformCallback part 1
// 8. dataListener
// 9. transformCallback part 2
// 10. finalCallback part 1
// 11. finalCallback part 2
// 12. flushCallback part 1
// 13. finishListener
// 14. endMethodCallback
// 15. flushCallback part 2
// 16. endListener

const t = new stream.Transform({
  objectMode: true,
  transform: common.mustCall(function(chunk, _, next) {
    // transformCallback part 1
    assert.strictEqual(++state, chunk);
    this.push(state);
    // transformCallback part 2
    assert.strictEqual(++state, chunk + 2);
    process.nextTick(next);
  }, 3),
  final: common.mustCall(function(done) {
    state++;
    // finalCallback part 1
    assert.strictEqual(state, 10);
    state++;
    // finalCallback part 2
    assert.strictEqual(state, 11);
    done();
  }, 1),
  flush: common.mustCall(function(done) {
    state++;
    // fluchCallback part 1
    assert.strictEqual(state, 12);
    process.nextTick(function() {
      state++;
      // fluchCallback part 2
      assert.strictEqual(state, 13);
      done();
    });
  }, 1)
});
t.on('finish', common.mustCall(function() {
  state++;
  // finishListener
  assert.strictEqual(state, 15);
}, 1));
t.on('end', common.mustCall(function() {
  state++;
  // endEvent
  assert.strictEqual(state, 16);
}, 1));
t.on('data', common.mustCall(function(d) {
  // dataListener
  assert.strictEqual(++state, d + 1);
}, 3));
t.write(1);
t.write(4);
t.end(7, common.mustCall(function() {
  state++;
  // endMethodCallback
  assert.strictEqual(state, 14);
}, 1));
                              node-23.7.0/test/parallel/test-stream-transform-final.js                                            0000664 0000000 0000000 00000005023 14746647661 0023236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const stream = require('stream');
let state = 0;


// What you do:
//
// const stream = new stream.Transform({
//   transform: function transformCallback(chunk, _, next) {
//     // part 1
//     this.push(chunk);
//     //part 2
//     next();
//   },
//   final: function endCallback(done) {
//     // part 1
//     process.nextTick(function () {
//       // part 2
//       done();
//     });
//   },
//   flush: function flushCallback(done) {
//     // part 1
//     process.nextTick(function () {
//       // part 2
//       done();
//     });
//   }
// });
// t.on('data', dataListener);
// t.on('end', endListener);
// t.on('finish', finishListener);
// t.write(1);
// t.write(4);
// t.end(7, endMethodCallback);
//
// The order things are called

// 1. transformCallback part 1
// 2. dataListener
// 3. transformCallback part 2
// 4. transformCallback part 1
// 5. dataListener
// 6. transformCallback part 2
// 7. transformCallback part 1
// 8. dataListener
// 9. transformCallback part 2
// 10. finalCallback part 1
// 11. finalCallback part 2
// 12. flushCallback part 1
// 13. finishListener
// 14. endMethodCallback
// 15. flushCallback part 2
// 16. endListener

const t = new stream.Transform({
  objectMode: true,
  transform: common.mustCall(function(chunk, _, next) {
    // transformCallback part 1
    assert.strictEqual(++state, chunk);
    this.push(state);
    // transformCallback part 2
    assert.strictEqual(++state, chunk + 2);
    process.nextTick(next);
  }, 3),
  final: common.mustCall(function(done) {
    state++;
    // finalCallback part 1
    assert.strictEqual(state, 10);
    setTimeout(function() {
      state++;
      // finalCallback part 2
      assert.strictEqual(state, 11);
      done();
    }, 100);
  }, 1),
  flush: common.mustCall(function(done) {
    state++;
    // flushCallback part 1
    assert.strictEqual(state, 12);
    process.nextTick(function() {
      state++;
      // flushCallback part 2
      assert.strictEqual(state, 13);
      done();
    });
  }, 1)
});
t.on('finish', common.mustCall(function() {
  state++;
  // finishListener
  assert.strictEqual(state, 15);
}, 1));
t.on('end', common.mustCall(function() {
  state++;
  // end event
  assert.strictEqual(state, 16);
}, 1));
t.on('data', common.mustCall(function(d) {
  // dataListener
  assert.strictEqual(++state, d + 1);
}, 3));
t.write(1);
t.write(4);
t.end(7, common.mustCall(function() {
  state++;
  // endMethodCallback
  assert.strictEqual(state, 14);
}, 1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-transform-flush-data.js                                       0000664 0000000 0000000 00000000635 14746647661 0024201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const assert = require('assert');
const Transform = require('stream').Transform;


const expected = 'asdf';


function _transform(d, e, n) {
  n();
}

function _flush(n) {
  n(null, expected);
}

const t = new Transform({
  transform: _transform,
  flush: _flush
});

t.end(Buffer.from('blerg'));
t.on('data', (data) => {
  assert.strictEqual(data.toString(), expected);
});
                                                                                                   node-23.7.0/test/parallel/test-stream-transform-hwm0.js                                             0000664 0000000 0000000 00000001264 14746647661 0023023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Transform } = require('stream');

const t = new Transform({
  objectMode: true, highWaterMark: 0,
  transform(chunk, enc, callback) {
    process.nextTick(() => callback(null, chunk, enc));
  }
});

assert.strictEqual(t.write(1), false);
t.on('drain', common.mustCall(() => {
  assert.strictEqual(t.write(2), false);
  t.end();
}));

t.once('readable', common.mustCall(() => {
  assert.strictEqual(t.read(), 1);
  setImmediate(common.mustCall(() => {
    assert.strictEqual(t.read(), null);
    t.once('readable', common.mustCall(() => {
      assert.strictEqual(t.read(), 2);
    }));
  }));
}));
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-transform-objectmode-falsey-value.js                          0000664 0000000 0000000 00000003544 14746647661 0026661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');

const stream = require('stream');
const PassThrough = stream.PassThrough;

const src = new PassThrough({ objectMode: true });
const tx = new PassThrough({ objectMode: true });
const dest = new PassThrough({ objectMode: true });

const expect = [ -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
const results = [];

dest.on('data', common.mustCall(function(x) {
  results.push(x);
}, expect.length));

src.pipe(tx).pipe(dest);

let i = -1;
const int = setInterval(common.mustCall(function() {
  if (results.length === expect.length) {
    src.end();
    clearInterval(int);
    assert.deepStrictEqual(results, expect);
  } else {
    src.write(i++);
  }
}, expect.length + 1), 1);
                                                                                                                                                            node-23.7.0/test/parallel/test-stream-transform-split-highwatermark.js                              0000664 0000000 0000000 00000004172 14746647661 0026137 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

const { Transform, Readable, Writable, getDefaultHighWaterMark } = require('stream');

const DEFAULT = getDefaultHighWaterMark();

function testTransform(expectedReadableHwm, expectedWritableHwm, options) {
  const t = new Transform(options);
  assert.strictEqual(t._readableState.highWaterMark, expectedReadableHwm);
  assert.strictEqual(t._writableState.highWaterMark, expectedWritableHwm);
}

// Test overriding defaultHwm
testTransform(666, DEFAULT, { readableHighWaterMark: 666 });
testTransform(DEFAULT, 777, { writableHighWaterMark: 777 });
testTransform(666, 777, {
  readableHighWaterMark: 666,
  writableHighWaterMark: 777,
});

// Test highWaterMark overriding
testTransform(555, 555, {
  highWaterMark: 555,
  readableHighWaterMark: 666,
});
testTransform(555, 555, {
  highWaterMark: 555,
  writableHighWaterMark: 777,
});
testTransform(555, 555, {
  highWaterMark: 555,
  readableHighWaterMark: 666,
  writableHighWaterMark: 777,
});

// Test undefined, null
[undefined, null].forEach((v) => {
  testTransform(DEFAULT, DEFAULT, { readableHighWaterMark: v });
  testTransform(DEFAULT, DEFAULT, { writableHighWaterMark: v });
  testTransform(666, DEFAULT, { highWaterMark: v, readableHighWaterMark: 666 });
  testTransform(DEFAULT, 777, { highWaterMark: v, writableHighWaterMark: 777 });
});

// test NaN
{
  assert.throws(() => {
    new Transform({ readableHighWaterMark: NaN });
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_VALUE',
    message: "The property 'options.readableHighWaterMark' is invalid. " +
      'Received NaN'
  });

  assert.throws(() => {
    new Transform({ writableHighWaterMark: NaN });
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_VALUE',
    message: "The property 'options.writableHighWaterMark' is invalid. " +
      'Received NaN'
  });
}

// Test non Duplex streams ignore the options
{
  const r = new Readable({ readableHighWaterMark: 666 });
  assert.strictEqual(r._readableState.highWaterMark, DEFAULT);
  const w = new Writable({ writableHighWaterMark: 777 });
  assert.strictEqual(w._writableState.highWaterMark, DEFAULT);
}
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-transform-split-objectmode.js                                 0000664 0000000 0000000 00000005467 14746647661 0025425 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

const Transform = require('stream').Transform;

const parser = new Transform({
  readableObjectMode: true
});

assert(parser._readableState.objectMode);
assert(!parser._writableState.objectMode);
assert.strictEqual(parser.readableHighWaterMark, 16);
assert.strictEqual(parser.writableHighWaterMark, process.platform === 'win32' ? 16 * 1024 : 64 * 1024);
assert.strictEqual(parser.readableHighWaterMark,
                   parser._readableState.highWaterMark);
assert.strictEqual(parser.writableHighWaterMark,
                   parser._writableState.highWaterMark);

parser._transform = function(chunk, enc, callback) {
  callback(null, { val: chunk[0] });
};

let parsed;

parser.on('data', function(obj) {
  parsed = obj;
});

parser.end(Buffer.from([42]));

process.on('exit', function() {
  assert.strictEqual(parsed.val, 42);
});


const serializer = new Transform({ writableObjectMode: true });

assert(!serializer._readableState.objectMode);
assert(serializer._writableState.objectMode);
assert.strictEqual(serializer.readableHighWaterMark, process.platform === 'win32' ? 16 * 1024 : 64 * 1024);
assert.strictEqual(serializer.writableHighWaterMark, 16);
assert.strictEqual(parser.readableHighWaterMark,
                   parser._readableState.highWaterMark);
assert.strictEqual(parser.writableHighWaterMark,
                   parser._writableState.highWaterMark);

serializer._transform = function(obj, _, callback) {
  callback(null, Buffer.from([obj.val]));
};

let serialized;

serializer.on('data', function(chunk) {
  serialized = chunk;
});

serializer.write({ val: 42 });

process.on('exit', function() {
  assert.strictEqual(serialized[0], 42);
});
                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-typedarray.js                                                 0000664 0000000 0000000 00000004623 14746647661 0022325 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { Readable, Writable } = require('stream');

const buffer = Buffer.from('ABCD');
const views = common.getArrayBufferViews(buffer);

{
  // Simple Writable test.
  let n = 0;
  const writable = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      assert(chunk instanceof Buffer);
      assert(ArrayBuffer.isView(chunk));
      assert.deepStrictEqual(common.getBufferSources(chunk)[n], views[n]);
      n++;
      cb();
    }, views.length),
  });

  views.forEach((msg) => writable.write(msg));
  writable.end();
}

{
  // Writable test with object mode True.
  let n = 0;
  const writable = new Writable({
    objectMode: true,
    write: common.mustCall((chunk, encoding, cb) => {
      assert(!(chunk instanceof Buffer));
      assert(ArrayBuffer.isView(chunk));
      assert.deepStrictEqual(common.getBufferSources(chunk)[n], views[n]);
      n++;
      cb();
    }, views.length),
  });

  views.forEach((msg) => writable.write(msg));
  writable.end();
}


{
  // Writable test, multiple writes carried out via writev.
  let n = 0;
  let callback;
  const writable = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      assert(chunk instanceof Buffer);
      assert(ArrayBuffer.isView(chunk));
      assert.deepStrictEqual(common.getBufferSources(chunk)[n], views[n]);
      n++;
      callback = cb;
    }),

    writev: common.mustCall((chunks, cb) => {
      assert.strictEqual(chunks.length, views.length);
      let res = '';
      for (const chunk of chunks) {
        assert.strictEqual(chunk.encoding, 'buffer');
        res += chunk.chunk;
      }
      assert.strictEqual(res, 'ABCD'.repeat(9));
    }),

  });
  views.forEach((msg) => writable.write(msg));
  writable.end(views[0]);
  callback();
}


{
  // Simple Readable test.
  const readable = new Readable({
    read() {}
  });

  readable.push(views[1]);
  readable.push(views[2]);
  readable.unshift(views[0]);

  const buf = readable.read();
  assert(buf instanceof Buffer);
  assert.deepStrictEqual([...buf], [...views[0], ...views[1], ...views[2]]);
}

{
  // Readable test, setEncoding.
  const readable = new Readable({
    read() {}
  });

  readable.setEncoding('utf8');

  readable.push(views[1]);
  readable.push(views[2]);
  readable.unshift(views[0]);

  const out = readable.read();
  assert.strictEqual(out, 'ABCD'.repeat(3));
}
                                                                                                             node-23.7.0/test/parallel/test-stream-uint8array.js                                                 0000664 0000000 0000000 00000004321 14746647661 0022242 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { Readable, Writable } = require('stream');

const ABC = new Uint8Array([0x41, 0x42, 0x43]);
const DEF = new Uint8Array([0x44, 0x45, 0x46]);
const GHI = new Uint8Array([0x47, 0x48, 0x49]);

{
  // Simple Writable test.

  let n = 0;
  const writable = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      assert(chunk instanceof Buffer);
      if (n++ === 0) {
        assert.strictEqual(String(chunk), 'ABC');
      } else {
        assert.strictEqual(String(chunk), 'DEF');
      }

      cb();
    }, 2)
  });

  writable.write(ABC);
  writable.end(DEF);
}

{
  // Writable test, pass in Uint8Array in object mode.

  const writable = new Writable({
    objectMode: true,
    write: common.mustCall((chunk, encoding, cb) => {
      assert(!(chunk instanceof Buffer));
      assert(chunk instanceof Uint8Array);
      assert.strictEqual(chunk, ABC);
      assert.strictEqual(encoding, undefined);
      cb();
    })
  });

  writable.end(ABC);
}

{
  // Writable test, multiple writes carried out via writev.
  let callback;

  const writable = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      assert(chunk instanceof Buffer);
      assert.strictEqual(encoding, 'buffer');
      assert.strictEqual(String(chunk), 'ABC');
      callback = cb;
    }),
    writev: common.mustCall((chunks, cb) => {
      assert.strictEqual(chunks.length, 2);
      assert.strictEqual(chunks[0].encoding, 'buffer');
      assert.strictEqual(chunks[1].encoding, 'buffer');
      assert.strictEqual(chunks[0].chunk + chunks[1].chunk, 'DEFGHI');
    })
  });

  writable.write(ABC);
  writable.write(DEF);
  writable.end(GHI);
  callback();
}

{
  // Simple Readable test.
  const readable = new Readable({
    read() {}
  });

  readable.push(DEF);
  readable.unshift(ABC);

  const buf = readable.read();
  assert(buf instanceof Buffer);
  assert.deepStrictEqual([...buf], [...ABC, ...DEF]);
}

{
  // Readable test, setEncoding.
  const readable = new Readable({
    read() {}
  });

  readable.setEncoding('utf8');

  readable.push(DEF);
  readable.unshift(ABC);

  const out = readable.read();
  assert.strictEqual(out, 'ABCDEF');
}
                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-unpipe-event.js                                               0000664 0000000 0000000 00000004123 14746647661 0022553 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Writable, Readable } = require('stream');
class NullWriteable extends Writable {
  _write(chunk, encoding, callback) {
    return callback();
  }
}
class QuickEndReadable extends Readable {
  _read() {
    this.push(null);
  }
}
class NeverEndReadable extends Readable {
  _read() {}
}

{
  const dest = new NullWriteable();
  const src = new QuickEndReadable();
  dest.on('pipe', common.mustCall());
  dest.on('unpipe', common.mustCall());
  src.pipe(dest);
  setImmediate(() => {
    assert.strictEqual(src._readableState.pipes.length, 0);
  });
}

{
  const dest = new NullWriteable();
  const src = new NeverEndReadable();
  dest.on('pipe', common.mustCall());
  dest.on('unpipe', common.mustNotCall('unpipe should not have been emitted'));
  src.pipe(dest);
  setImmediate(() => {
    assert.strictEqual(src._readableState.pipes.length, 1);
  });
}

{
  const dest = new NullWriteable();
  const src = new NeverEndReadable();
  dest.on('pipe', common.mustCall());
  dest.on('unpipe', common.mustCall());
  src.pipe(dest);
  src.unpipe(dest);
  setImmediate(() => {
    assert.strictEqual(src._readableState.pipes.length, 0);
  });
}

{
  const dest = new NullWriteable();
  const src = new QuickEndReadable();
  dest.on('pipe', common.mustCall());
  dest.on('unpipe', common.mustCall());
  src.pipe(dest, { end: false });
  setImmediate(() => {
    assert.strictEqual(src._readableState.pipes.length, 0);
  });
}

{
  const dest = new NullWriteable();
  const src = new NeverEndReadable();
  dest.on('pipe', common.mustCall());
  dest.on('unpipe', common.mustNotCall('unpipe should not have been emitted'));
  src.pipe(dest, { end: false });
  setImmediate(() => {
    assert.strictEqual(src._readableState.pipes.length, 1);
  });
}

{
  const dest = new NullWriteable();
  const src = new NeverEndReadable();
  dest.on('pipe', common.mustCall());
  dest.on('unpipe', common.mustCall());
  src.pipe(dest, { end: false });
  src.unpipe(dest);
  setImmediate(() => {
    assert.strictEqual(src._readableState.pipes.length, 0);
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-unshift-empty-chunk.js                                        0000664 0000000 0000000 00000004640 14746647661 0024062 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

// This test verifies that stream.unshift(Buffer.alloc(0)) or
// stream.unshift('') does not set state.reading=false.
const Readable = require('stream').Readable;

const r = new Readable();
let nChunks = 10;
const chunk = Buffer.alloc(10, 'x');

r._read = function(n) {
  setImmediate(() => {
    r.push(--nChunks === 0 ? null : chunk);
  });
};

let readAll = false;
const seen = [];
r.on('readable', () => {
  let chunk;
  while ((chunk = r.read()) !== null) {
    seen.push(chunk.toString());
    // Simulate only reading a certain amount of the data,
    // and then putting the rest of the chunk back into the
    // stream, like a parser might do.  We just fill it with
    // 'y' so that it's easy to see which bits were touched,
    // and which were not.
    const putBack = Buffer.alloc(readAll ? 0 : 5, 'y');
    readAll = !readAll;
    r.unshift(putBack);
  }
});

const expect =
  [ 'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy',
    'xxxxxxxxxx',
    'yyyyy' ];

r.on('end', () => {
  assert.deepStrictEqual(seen, expect);
  console.log('ok');
});
                                                                                                node-23.7.0/test/parallel/test-stream-unshift-read-race.js                                          0000664 0000000 0000000 00000007511 14746647661 0023441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');

// This test verifies that:
// 1. unshift() does not cause colliding _read() calls.
// 2. unshift() after the 'end' event is an error, but after the EOF
//    signalling null, it is ok, and just creates a new readable chunk.
// 3. push() after the EOF signaling null is an error.
// 4. _read() is not called after pushing the EOF null chunk.

const stream = require('stream');
const hwm = 10;
const r = stream.Readable({ highWaterMark: hwm, autoDestroy: false });
const chunks = 10;

const data = Buffer.allocUnsafe(chunks * hwm + Math.ceil(hwm / 2));
for (let i = 0; i < data.length; i++) {
  const c = 'asdf'.charCodeAt(i % 4);
  data[i] = c;
}

let pos = 0;
let pushedNull = false;
r._read = function(n) {
  assert(!pushedNull, '_read after null push');

  // Every third chunk is fast
  push(!(chunks % 3));

  function push(fast) {
    assert(!pushedNull, 'push() after null push');
    const c = pos >= data.length ? null : data.slice(pos, pos + n);
    pushedNull = c === null;
    if (fast) {
      pos += n;
      r.push(c);
      if (c === null) pushError();
    } else {
      setTimeout(function() {
        pos += n;
        r.push(c);
        if (c === null) pushError();
      }, 1);
    }
  }
};

function pushError() {
  r.unshift(Buffer.allocUnsafe(1));
  w.end();

  assert.throws(() => {
    r.push(Buffer.allocUnsafe(1));
  }, {
    code: 'ERR_STREAM_PUSH_AFTER_EOF',
    name: 'Error',
    message: 'stream.push() after EOF'
  });
}


const w = stream.Writable();
const written = [];
w._write = function(chunk, encoding, cb) {
  written.push(chunk.toString());
  cb();
};

r.on('end', common.mustNotCall());

r.on('readable', function() {
  let chunk;
  while (null !== (chunk = r.read(10))) {
    w.write(chunk);
    if (chunk.length > 4)
      r.unshift(Buffer.from('1234'));
  }
});

w.on('finish', common.mustCall(function() {
  // Each chunk should start with 1234, and then be asfdasdfasdf...
  // The first got pulled out before the first unshift('1234'), so it's
  // lacking that piece.
  assert.strictEqual(written[0], 'asdfasdfas');
  let asdf = 'd';
  console.error(`0: ${written[0]}`);
  for (let i = 1; i < written.length; i++) {
    console.error(`${i.toString(32)}: ${written[i]}`);
    assert.strictEqual(written[i].slice(0, 4), '1234');
    for (let j = 4; j < written[i].length; j++) {
      const c = written[i].charAt(j);
      assert.strictEqual(c, asdf);
      switch (asdf) {
        case 'a': asdf = 's'; break;
        case 's': asdf = 'd'; break;
        case 'd': asdf = 'f'; break;
        case 'f': asdf = 'a'; break;
      }
    }
  }
}));

process.on('exit', function() {
  assert.strictEqual(written.length, 18);
  console.log('ok');
});
                                                                                                                                                                                       node-23.7.0/test/parallel/test-stream-wrap-drain.js                                                 0000664 0000000 0000000 00000002523 14746647661 0022202 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
const common = require('../common');
const assert = require('assert');
const { StreamWrap } = require('internal/js_stream_socket');
const { Duplex } = require('stream');
const { internalBinding } = require('internal/test/binding');
const { ShutdownWrap } = internalBinding('stream_wrap');

// This test makes sure that when a wrapped stream is waiting for
// a "drain" event to `doShutdown`, the instance will work correctly when a
// "drain" event emitted.
{
  let resolve = null;

  class TestDuplex extends Duplex {
    _write(chunk, encoding, callback) {
      // We will resolve the write later.
      resolve = () => {
        callback();
      };
    }

    _read() {}
  }

  const testDuplex = new TestDuplex();
  const socket = new StreamWrap(testDuplex);

  socket.write(
    // Make the buffer long enough so that the `Writable` will emit "drain".
    Buffer.allocUnsafe(socket.writableHighWaterMark * 2),
    common.mustCall()
  );

  // Make sure that the 'drain' events will be emitted.
  testDuplex.on('drain', common.mustCall(() => {
    console.log('testDuplex drain');
  }));

  assert.strictEqual(typeof resolve, 'function');

  const req = new ShutdownWrap();
  req.oncomplete = common.mustCall();
  req.handle = socket._handle;
  // Should not throw.
  socket._handle.shutdown(req);

  resolve();
}
                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-wrap-encoding.js                                              0000664 0000000 0000000 00000001503 14746647661 0022670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
const common = require('../common');

const StreamWrap = require('internal/js_stream_socket');
const Duplex = require('stream').Duplex;

{
  const stream = new Duplex({
    read() {},
    write() {}
  });

  stream.setEncoding('ascii');

  const wrap = new StreamWrap(stream);

  wrap.on('error', common.expectsError({
    name: 'Error',
    code: 'ERR_STREAM_WRAP',
    message: 'Stream has StringDecoder set or is in objectMode'
  }));

  stream.push('ohai');
}

{
  const stream = new Duplex({
    read() {},
    write() {},
    objectMode: true
  });

  const wrap = new StreamWrap(stream);

  wrap.on('error', common.expectsError({
    name: 'Error',
    code: 'ERR_STREAM_WRAP',
    message: 'Stream has StringDecoder set or is in objectMode'
  }));

  stream.push(new Error('foo'));
}
                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-wrap.js                                                       0000664 0000000 0000000 00000001370 14746647661 0021106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
const common = require('../common');
const assert = require('assert');

const { internalBinding } = require('internal/test/binding');
const StreamWrap = require('internal/js_stream_socket');
const { Duplex } = require('stream');
const { ShutdownWrap } = internalBinding('stream_wrap');

function testShutdown(callback) {
  const stream = new Duplex({
    read: function() {
    },
    write: function() {
    }
  });

  const wrap = new StreamWrap(stream);

  const req = new ShutdownWrap();
  req.oncomplete = function(code) {
    assert(code < 0);
    callback();
  };
  req.handle = wrap._handle;

  // Close the handle to simulate
  wrap.destroy();
  req.handle.shutdown(req);
}

testShutdown(common.mustCall());
                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-stream-writable-aborted.js                                           0000664 0000000 0000000 00000001011 14746647661 0023354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const { Writable } = require('stream');

{
  const writable = new Writable({
    write() {
    }
  });
  assert.strictEqual(writable.writableAborted, false);
  writable.destroy();
  assert.strictEqual(writable.writableAborted, true);
}

{
  const writable = new Writable({
    write() {
    }
  });
  assert.strictEqual(writable.writableAborted, false);
  writable.end();
  writable.destroy();
  assert.strictEqual(writable.writableAborted, true);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-stream-writable-change-default-encoding.js                           0000664 0000000 0000000 00000004643 14746647661 0026405 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

const stream = require('stream');

class MyWritable extends stream.Writable {
  constructor(fn, options) {
    super(options);
    this.fn = fn;
  }

  _write(chunk, encoding, callback) {
    this.fn(Buffer.isBuffer(chunk), typeof chunk, encoding);
    callback();
  }
}

(function defaultCondingIsUtf8() {
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(enc, 'utf8');
  }, { decodeStrings: false });
  m.write('foo');
  m.end();
}());

(function changeDefaultEncodingToAscii() {
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(enc, 'ascii');
  }, { decodeStrings: false });
  m.setDefaultEncoding('ascii');
  m.write('bar');
  m.end();
}());

// Change default encoding to invalid value.
assert.throws(() => {
  const m = new MyWritable(
    (isBuffer, type, enc) => {},
    { decodeStrings: false });
  m.setDefaultEncoding({});
  m.write('bar');
  m.end();
}, {
  name: 'TypeError',
  code: 'ERR_UNKNOWN_ENCODING',
  message: 'Unknown encoding: {}'
});

(function checkVariableCaseEncoding() {
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(enc, 'ascii');
  }, { decodeStrings: false });
  m.setDefaultEncoding('AsCii');
  m.write('bar');
  m.end();
}());
                                                                                             node-23.7.0/test/parallel/test-stream-writable-clear-buffer.js                                      0000664 0000000 0000000 00000001554 14746647661 0024305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This test ensures that the _writeableState.bufferedRequestCount and
// the actual buffered request count are the same.

const common = require('../common');
const Stream = require('stream');
const assert = require('assert');

class StreamWritable extends Stream.Writable {
  constructor() {
    super({ objectMode: true });
  }

  // Refs: https://github.com/nodejs/node/issues/6758
  // We need a timer like on the original issue thread.
  // Otherwise the code will never reach our test case.
  _write(chunk, encoding, cb) {
    setImmediate(cb);
  }
}

const testStream = new StreamWritable();
testStream.cork();

for (let i = 1; i <= 5; i++) {
  testStream.write(i, common.mustCall(() => {
    assert.strictEqual(
      testStream._writableState.bufferedRequestCount,
      testStream._writableState.getBuffer().length
    );
  }));
}

testStream.end();
                                                                                                                                                    node-23.7.0/test/parallel/test-stream-writable-constructor-set-methods.js                           0000664 0000000 0000000 00000001421 14746647661 0026560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const assert = require('assert');
const { Writable } = require('stream');

const bufferBlerg = Buffer.from('blerg');
const w = new Writable();

assert.throws(
  () => {
    w.end(bufferBlerg);
  },
  {
    name: 'Error',
    code: 'ERR_METHOD_NOT_IMPLEMENTED',
    message: 'The _write() method is not implemented'
  }
);

const _write = common.mustCall((chunk, _, next) => {
  next();
});

const _writev = common.mustCall((chunks, next) => {
  assert.strictEqual(chunks.length, 2);
  next();
});

const w2 = new Writable({ write: _write, writev: _writev });

assert.strictEqual(w2._write, _write);
assert.strictEqual(w2._writev, _writev);

w2.write(bufferBlerg);

w2.cork();
w2.write(bufferBlerg);
w2.write(bufferBlerg);

w2.end();
                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-writable-decoded-encoding.js                                  0000664 0000000 0000000 00000005520 14746647661 0025120 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

const stream = require('stream');

class MyWritable extends stream.Writable {
  constructor(fn, options) {
    super(options);
    this.fn = fn;
  }

  _write(chunk, encoding, callback) {
    this.fn(Buffer.isBuffer(chunk), typeof chunk, encoding);
    callback();
  }
}

{
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert(isBuffer);
    assert.strictEqual(type, 'object');
    assert.strictEqual(enc, 'buffer');
  }, { decodeStrings: true });
  m.write('some-text', 'utf8');
  m.end();
}

{
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert(!isBuffer);
    assert.strictEqual(type, 'string');
    assert.strictEqual(enc, 'utf8');
  }, { decodeStrings: false });
  m.write('some-text', 'utf8');
  m.end();
}

{
  assert.throws(() => {
    const m = new MyWritable(null, {
      defaultEncoding: 'my invalid encoding',
    });
    m.end();
  }, {
    code: 'ERR_UNKNOWN_ENCODING',
  });
}

{
  const w = new MyWritable(function(isBuffer, type, enc) {
    assert(!isBuffer);
    assert.strictEqual(type, 'string');
    assert.strictEqual(enc, 'hex');
  }, {
    defaultEncoding: 'hex',
    decodeStrings: false
  });
  w.write('asd');
  w.end();
}

{
  const w = new MyWritable(function(isBuffer, type, enc) {
    assert(!isBuffer);
    assert.strictEqual(type, 'string');
    assert.strictEqual(enc, 'utf8');
  }, {
    defaultEncoding: null,
    decodeStrings: false
  });
  w.write('asd');
  w.end();
}

{
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(type, 'object');
    assert.strictEqual(enc, 'utf8');
  }, { defaultEncoding: 'hex',
       objectMode: true });
  m.write({ foo: 'bar' }, 'utf8');
  m.end();
}
                                                                                                                                                                                node-23.7.0/test/parallel/test-stream-writable-destroy.js                                           0000664 0000000 0000000 00000026147 14746647661 0023446 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Writable, addAbortSignal } = require('stream');
const assert = require('assert');

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write.on('finish', common.mustNotCall());
  write.on('close', common.mustCall());

  write.destroy();
  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) {
      this.destroy(new Error('asd'));
      cb();
    }
  });

  write.on('error', common.mustCall());
  write.on('finish', common.mustNotCall());
  write.end('asd');
  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  const expected = new Error('kaboom');

  write.on('finish', common.mustNotCall());
  write.on('close', common.mustCall());
  write.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  write.destroy(expected);
  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write._destroy = function(err, cb) {
    assert.strictEqual(err, expected);
    cb(err);
  };

  const expected = new Error('kaboom');

  write.on('finish', common.mustNotCall('no finish event'));
  write.on('close', common.mustCall());
  write.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  write.destroy(expected);
  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); },
    destroy: common.mustCall(function(err, cb) {
      assert.strictEqual(err, expected);
      cb();
    })
  });

  const expected = new Error('kaboom');

  write.on('finish', common.mustNotCall('no finish event'));
  write.on('close', common.mustCall());

  // Error is swallowed by the custom _destroy
  write.on('error', common.mustNotCall('no error event'));

  write.destroy(expected);
  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb();
  });

  write.destroy();
  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    process.nextTick(() => {
      this.end();
      cb();
    });
  });

  const fail = common.mustNotCall('no finish event');

  write.on('finish', fail);
  write.on('close', common.mustCall());

  write.destroy();

  assert.strictEqual(write.destroyed, true);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  const expected = new Error('kaboom');

  write._destroy = common.mustCall(function(err, cb) {
    assert.strictEqual(err, null);
    cb(expected);
  });

  write.on('close', common.mustCall());
  write.on('finish', common.mustNotCall('no finish event'));
  write.on('error', common.mustCall((err) => {
    assert.strictEqual(err, expected);
  }));

  write.destroy();
  assert.strictEqual(write.destroyed, true);
}

{
  // double error case
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  let ticked = false;
  write.on('close', common.mustCall(() => {
    assert.strictEqual(ticked, true);
  }));
  write.on('error', common.mustCall((err) => {
    assert.strictEqual(ticked, true);
    assert.strictEqual(err.message, 'kaboom 1');
    assert.strictEqual(write._writableState.errorEmitted, true);
  }));

  const expected = new Error('kaboom 1');
  write.destroy(expected);
  write.destroy(new Error('kaboom 2'));
  assert.strictEqual(write._writableState.errored, expected);
  assert.strictEqual(write._writableState.errorEmitted, false);
  assert.strictEqual(write.destroyed, true);
  ticked = true;
}

{
  const writable = new Writable({
    destroy: common.mustCall(function(err, cb) {
      process.nextTick(cb, new Error('kaboom 1'));
    }),
    write(chunk, enc, cb) {
      cb();
    }
  });

  let ticked = false;
  writable.on('close', common.mustCall(() => {
    writable.on('error', common.mustNotCall());
    writable.destroy(new Error('hello'));
    assert.strictEqual(ticked, true);
    assert.strictEqual(writable._writableState.errorEmitted, true);
  }));
  writable.on('error', common.mustCall((err) => {
    assert.strictEqual(ticked, true);
    assert.strictEqual(err.message, 'kaboom 1');
    assert.strictEqual(writable._writableState.errorEmitted, true);
  }));

  writable.destroy();
  assert.strictEqual(writable.destroyed, true);
  assert.strictEqual(writable._writableState.errored, null);
  assert.strictEqual(writable._writableState.errorEmitted, false);

  // Test case where `writable.destroy()` is called again with an error before
  // the `_destroy()` callback is called.
  writable.destroy(new Error('kaboom 2'));
  assert.strictEqual(writable._writableState.errorEmitted, false);
  assert.strictEqual(writable._writableState.errored, null);

  ticked = true;
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write.destroyed = true;
  assert.strictEqual(write.destroyed, true);

  // The internal destroy() mechanism should not be triggered
  write.on('close', common.mustNotCall());
  write.destroy();
}

{
  function MyWritable() {
    assert.strictEqual(this.destroyed, false);
    this.destroyed = false;
    Writable.call(this);
  }

  Object.setPrototypeOf(MyWritable.prototype, Writable.prototype);
  Object.setPrototypeOf(MyWritable, Writable);

  new MyWritable();
}

{
  // Destroy and destroy callback
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write.destroy();

  const expected = new Error('kaboom');

  write.destroy(expected, common.mustCall((err) => {
    assert.strictEqual(err, undefined);
  }));
}

{
  // Checks that `._undestroy()` restores the state so that `final` will be
  // called again.
  const write = new Writable({
    write: common.mustNotCall(),
    final: common.mustCall((cb) => cb(), 2),
    autoDestroy: true
  });

  write.end();
  write.once('close', common.mustCall(() => {
    write._undestroy();
    write.end();
  }));
}

{
  const write = new Writable();

  write.destroy();
  write.on('error', common.mustNotCall());
  write.write('asd', common.expectsError({
    name: 'Error',
    code: 'ERR_STREAM_DESTROYED',
    message: 'Cannot call write after a stream was destroyed'
  }));
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write.on('error', common.mustNotCall());

  write.cork();
  write.write('asd', common.mustCall());
  write.uncork();

  write.cork();
  write.write('asd', common.expectsError({
    name: 'Error',
    code: 'ERR_STREAM_DESTROYED',
    message: 'Cannot call write after a stream was destroyed'
  }));
  write.destroy();
  write.write('asd', common.expectsError({
    name: 'Error',
    code: 'ERR_STREAM_DESTROYED',
    message: 'Cannot call write after a stream was destroyed'
  }));
  write.uncork();
}

{
  // Call end(cb) after error & destroy

  const write = new Writable({
    write(chunk, enc, cb) { cb(new Error('asd')); }
  });
  write.on('error', common.mustCall(() => {
    write.destroy();
    let ticked = false;
    write.end(common.mustCall((err) => {
      assert.strictEqual(ticked, true);
      assert.strictEqual(err.code, 'ERR_STREAM_DESTROYED');
    }));
    ticked = true;
  }));
  write.write('asd');
}

{
  // Call end(cb) after finish & destroy

  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });
  write.on('finish', common.mustCall(() => {
    write.destroy();
    let ticked = false;
    write.end(common.mustCall((err) => {
      assert.strictEqual(ticked, true);
      assert.strictEqual(err.code, 'ERR_STREAM_ALREADY_FINISHED');
    }));
    ticked = true;
  }));
  write.end();
}

{
  // Call end(cb) after error & destroy and don't trigger
  // unhandled exception.

  const write = new Writable({
    write(chunk, enc, cb) { process.nextTick(cb); }
  });
  const _err = new Error('asd');
  write.once('error', common.mustCall((err) => {
    assert.strictEqual(err.message, 'asd');
  }));
  write.end('asd', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  write.destroy(_err);
}

{
  // Call buffered write callback with error

  const _err = new Error('asd');
  const write = new Writable({
    write(chunk, enc, cb) {
      process.nextTick(cb, _err);
    },
    autoDestroy: false
  });
  write.cork();
  write.write('asd', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  write.write('asd', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  write.on('error', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  write.uncork();
}

{
  // Ensure callback order.

  let state = 0;
  const write = new Writable({
    write(chunk, enc, cb) {
      // `setImmediate()` is used on purpose to ensure the callback is called
      // after `process.nextTick()` callbacks.
      setImmediate(cb);
    }
  });
  write.write('asd', common.mustCall(() => {
    assert.strictEqual(state++, 0);
  }));
  write.write('asd', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_DESTROYED');
    assert.strictEqual(state++, 1);
  }));
  write.destroy();
}

{
  const write = new Writable({
    autoDestroy: false,
    write(chunk, enc, cb) {
      cb();
      cb();
    }
  });

  write.on('error', common.mustCall(() => {
    assert(write._writableState.errored);
  }));
  write.write('asd');
}

{
  const ac = new AbortController();
  const write = addAbortSignal(ac.signal, new Writable({
    write(chunk, enc, cb) { cb(); }
  }));

  write.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
    assert.strictEqual(write.destroyed, true);
  }));
  write.write('asd');
  ac.abort();
}

{
  const ac = new AbortController();
  const write = new Writable({
    signal: ac.signal,
    write(chunk, enc, cb) { cb(); }
  });

  write.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
    assert.strictEqual(write.destroyed, true);
  }));
  write.write('asd');
  ac.abort();
}

{
  const signal = AbortSignal.abort();

  const write = new Writable({
    signal,
    write(chunk, enc, cb) { cb(); }
  });

  write.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
    assert.strictEqual(write.destroyed, true);
  }));
}

{
  // Destroy twice
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write.end(common.mustCall());
  write.destroy();
  write.destroy();
}

{
  // https://github.com/nodejs/node/issues/39356
  const s = new Writable({
    final() {}
  });
  const _err = new Error('oh no');
  // Remove `callback` and it works
  s.end(common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  s.on('error', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  s.destroy(_err);
}

{
  const write = new Writable({
    write(chunk, enc, cb) { cb(); }
  });

  write.on('error', common.mustCall((e) => {
    assert.strictEqual(e.name, 'AbortError');
    assert.strictEqual(write.destroyed, true);
  }));
  write[Symbol.asyncDispose]().then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-writable-end-cb-error.js                                      0000664 0000000 0000000 00000004003 14746647661 0024217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const stream = require('stream');

{
  // Invoke end callback on failure.
  const writable = new stream.Writable();

  const _err = new Error('kaboom');
  writable._write = (chunk, encoding, cb) => {
    process.nextTick(cb, _err);
  };

  writable.on('error', common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  writable.write('asd');
  writable.end(common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
  writable.end(common.mustCall((err) => {
    assert.strictEqual(err, _err);
  }));
}

{
  // Don't invoke end callback twice
  const writable = new stream.Writable();

  writable._write = (chunk, encoding, cb) => {
    process.nextTick(cb);
  };

  let called = false;
  writable.end('asd', common.mustCall((err) => {
    called = true;
    assert.strictEqual(err, null);
  }));

  writable.on('error', common.mustCall((err) => {
    assert.strictEqual(err.message, 'kaboom');
  }));
  writable.on('finish', common.mustCall(() => {
    assert.strictEqual(called, true);
    writable.emit('error', new Error('kaboom'));
  }));
}

{
  const w = new stream.Writable({
    write(chunk, encoding, callback) {
      setImmediate(callback);
    },
    finish(callback) {
      setImmediate(callback);
    }
  });
  w.end('testing ended state', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');
  }));
  assert.strictEqual(w.destroyed, false);
  assert.strictEqual(w.writableEnded, true);
  w.end(common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');
  }));
  assert.strictEqual(w.destroyed, false);
  assert.strictEqual(w.writableEnded, true);
  w.end('end', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');
  }));
  assert.strictEqual(w.destroyed, true);
  w.on('error', common.mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');
  }));
  w.on('finish', common.mustNotCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-writable-end-cb-uncaught.js                                   0000664 0000000 0000000 00000000773 14746647661 0024716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const stream = require('stream');

process.on('uncaughtException', common.mustCall((err) => {
  assert.strictEqual(err.message, 'kaboom');
}));

const writable = new stream.Writable();
const _err = new Error('kaboom');

writable._write = (chunk, encoding, cb) => {
  cb();
};
writable._final = (cb) => {
  cb(_err);
};

writable.write('asd');
writable.end(common.mustCall((err) => {
  assert.strictEqual(err, _err);
}));
     node-23.7.0/test/parallel/test-stream-writable-end-multiple.js                                      0000664 0000000 0000000 00000001074 14746647661 0024344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('assert');
const stream = require('stream');

const writable = new stream.Writable();
writable._write = (chunk, encoding, cb) => {
  setTimeout(() => cb(), 10);
};

writable.end('testing ended state', common.mustCall());
writable.end(common.mustCall());
writable.on('finish', common.mustCall(() => {
  let ticked = false;
  writable.end(common.mustCall((err) => {
    assert.strictEqual(ticked, true);
    assert.strictEqual(err.code, 'ERR_STREAM_ALREADY_FINISHED');
  }));
  ticked = true;
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-stream-writable-ended-state.js                                       0000664 0000000 0000000 00000002152 14746647661 0024140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('assert');
const stream = require('stream');

const writable = new stream.Writable();

writable._write = (chunk, encoding, cb) => {
  assert.strictEqual(writable._writableState.ended, false);
  assert.strictEqual(writable._writableState.writable, undefined);
  assert.strictEqual(writable.writableEnded, false);
  cb();
};

assert.strictEqual(writable._writableState.ended, false);
assert.strictEqual(writable._writableState.writable, undefined);
assert.strictEqual(writable.writable, true);
assert.strictEqual(writable.writableEnded, false);

writable.end('testing ended state', common.mustCall(() => {
  assert.strictEqual(writable._writableState.ended, true);
  assert.strictEqual(writable._writableState.writable, undefined);
  assert.strictEqual(writable.writable, false);
  assert.strictEqual(writable.writableEnded, true);
}));

assert.strictEqual(writable._writableState.ended, true);
assert.strictEqual(writable._writableState.writable, undefined);
assert.strictEqual(writable.writable, false);
assert.strictEqual(writable.writableEnded, true);
                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-stream-writable-final-async.js                                       0000664 0000000 0000000 00000000741 14746647661 0024151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Duplex,
} = require('stream');
const { setTimeout } = require('timers/promises');

{
  class Foo extends Duplex {
    async _final(callback) {
      await setTimeout(common.platformTimeout(1));
      callback();
    }

    _read() {}
  }

  const foo = new Foo();
  foo._write = common.mustCall((chunk, encoding, cb) => {
    cb();
  });
  foo.end('test', common.mustCall());
  foo.on('error', common.mustNotCall());
}
                               node-23.7.0/test/parallel/test-stream-writable-final-destroy.js                                     0000664 0000000 0000000 00000000624 14746647661 0024525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const { Writable } = require('stream');

{
  const w = new Writable({
    write(chunk, encoding, callback) {
      callback(null);
    },
    final(callback) {
      queueMicrotask(callback);
    }
  });
  w.end();
  w.destroy();

  w.on('prefinish', common.mustNotCall());
  w.on('finish', common.mustNotCall());
  w.on('close', common.mustCall());
}
                                                                                                            node-23.7.0/test/parallel/test-stream-writable-final-throw.js                                       0000664 0000000 0000000 00000000640 14746647661 0024175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  Duplex,
} = require('stream');

{
  class Foo extends Duplex {
    _final(callback) {
      throw new Error('fhqwhgads');
    }

    _read() {}
  }

  const foo = new Foo();
  foo._write = common.mustCall((chunk, encoding, cb) => {
    cb();
  });
  foo.end('test', common.expectsError({ message: 'fhqwhgads' }));
  foo.on('error', common.mustCall());
}
                                                                                                node-23.7.0/test/parallel/test-stream-writable-finish-destroyed.js                                  0000664 0000000 0000000 00000001313 14746647661 0025221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Writable } = require('stream');

{
  const w = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      w.on('close', common.mustCall(() => {
        cb();
      }));
    })
  });

  w.on('finish', common.mustNotCall());
  w.end('asd');
  w.destroy();
}

{
  const w = new Writable({
    write: common.mustCall((chunk, encoding, cb) => {
      w.on('close', common.mustCall(() => {
        cb();
        w.end();
      }));
    })
  });

  w.on('finish', common.mustNotCall());
  w.write('asd');
  w.destroy();
}

{
  const w = new Writable({
    write() {
    }
  });
  w.on('finish', common.mustNotCall());
  w.end();
  w.destroy();
}
                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-stream-writable-finished-state.js                                    0000664 0000000 0000000 00000001076 14746647661 0024656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('assert');
const stream = require('stream');

const writable = new stream.Writable();

writable._write = (chunk, encoding, cb) => {
  // The state finished should start in false.
  assert.strictEqual(writable._writableState.finished, false);
  cb();
};

writable.on('finish', common.mustCall(() => {
  assert.strictEqual(writable._writableState.finished, true);
}));

writable.end('testing finished state', common.mustCall(() => {
  assert.strictEqual(writable._writableState.finished, true);
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-stream-writable-finished.js                                          0000664 0000000 0000000 00000003245 14746647661 0023540 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Writable } = require('stream');
const assert = require('assert');

// basic
{
  // Find it on Writable.prototype
  assert(Object.hasOwn(Writable.prototype, 'writableFinished'));
}

// event
{
  const writable = new Writable();

  writable._write = (chunk, encoding, cb) => {
    // The state finished should start in false.
    assert.strictEqual(writable.writableFinished, false);
    cb();
  };

  writable.on('finish', common.mustCall(() => {
    assert.strictEqual(writable.writableFinished, true);
  }));

  writable.end('testing finished state', common.mustCall(() => {
    assert.strictEqual(writable.writableFinished, true);
  }));
}

{
  // Emit finish asynchronously.

  const w = new Writable({
    write(chunk, encoding, cb) {
      cb();
    }
  });

  w.end();
  w.on('finish', common.mustCall());
}

{
  // Emit prefinish synchronously.

  const w = new Writable({
    write(chunk, encoding, cb) {
      cb();
    }
  });

  let sync = true;
  w.on('prefinish', common.mustCall(() => {
    assert.strictEqual(sync, true);
  }));
  w.end();
  sync = false;
}

{
  // Emit prefinish synchronously w/ final.

  const w = new Writable({
    write(chunk, encoding, cb) {
      cb();
    },
    final(cb) {
      cb();
    }
  });

  let sync = true;
  w.on('prefinish', common.mustCall(() => {
    assert.strictEqual(sync, true);
  }));
  w.end();
  sync = false;
}


{
  // Call _final synchronously.

  let sync = true;
  const w = new Writable({
    write(chunk, encoding, cb) {
      cb();
    },
    final: common.mustCall((cb) => {
      assert.strictEqual(sync, true);
      cb();
    })
  });

  w.end();
  sync = false;
}
                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-writable-invalid-chunk.js                                     0000664 0000000 0000000 00000001752 14746647661 0024504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');
const assert = require('assert');

function testWriteType(val, objectMode, code) {
  const writable = new stream.Writable({
    objectMode,
    write: () => {}
  });
  writable.on('error', common.mustNotCall());
  if (code) {
    assert.throws(() => {
      writable.write(val);
    }, { code });
  } else {
    writable.write(val);
  }
}

testWriteType([], false, 'ERR_INVALID_ARG_TYPE');
testWriteType({}, false, 'ERR_INVALID_ARG_TYPE');
testWriteType(0, false, 'ERR_INVALID_ARG_TYPE');
testWriteType(true, false, 'ERR_INVALID_ARG_TYPE');
testWriteType(0.0, false, 'ERR_INVALID_ARG_TYPE');
testWriteType(undefined, false, 'ERR_INVALID_ARG_TYPE');
testWriteType(null, false, 'ERR_STREAM_NULL_VALUES');

testWriteType([], true);
testWriteType({}, true);
testWriteType(0, true);
testWriteType(true, true);
testWriteType(0.0, true);
testWriteType(undefined, true);
testWriteType(null, true, 'ERR_STREAM_NULL_VALUES');
                      node-23.7.0/test/parallel/test-stream-writable-needdrain-state.js                                   0000664 0000000 0000000 00000001145 14746647661 0025013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const stream = require('stream');
const assert = require('assert');

const transform = new stream.Transform({
  transform: _transform,
  highWaterMark: 1
});

function _transform(chunk, encoding, cb) {
  process.nextTick(() => {
    assert.strictEqual(transform._writableState.needDrain, true);
    cb();
  });
}

assert.strictEqual(transform._writableState.needDrain, false);

transform.write('asdasd', common.mustCall(() => {
  assert.strictEqual(transform._writableState.needDrain, false);
}));

assert.strictEqual(transform._writableState.needDrain, true);
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-stream-writable-null.js                                              0000664 0000000 0000000 00000001742 14746647661 0022721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const stream = require('stream');

class MyWritable extends stream.Writable {
  constructor(options) {
    super({ autoDestroy: false, ...options });
  }
  _write(chunk, encoding, callback) {
    assert.notStrictEqual(chunk, null);
    callback();
  }
}

{
  const m = new MyWritable({ objectMode: true });
  m.on('error', common.mustNotCall());
  assert.throws(() => {
    m.write(null);
  }, {
    code: 'ERR_STREAM_NULL_VALUES'
  });
}

{
  const m = new MyWritable();
  m.on('error', common.mustNotCall());
  assert.throws(() => {
    m.write(false);
  }, {
    code: 'ERR_INVALID_ARG_TYPE'
  });
}

{ // Should not throw.
  const m = new MyWritable({ objectMode: true });
  m.write(false, assert.ifError);
}

{ // Should not throw.
  const m = new MyWritable({ objectMode: true }).on('error', (e) => {
    assert.ifError(e || new Error('should not get here'));
  });
  m.write(false, assert.ifError);
}
                              node-23.7.0/test/parallel/test-stream-writable-properties.js                                        0000664 0000000 0000000 00000001015 14746647661 0024134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

const { Writable } = require('stream');

{
  const w = new Writable();
  assert.strictEqual(w.writableCorked, 0);
  w.uncork();
  assert.strictEqual(w.writableCorked, 0);
  w.cork();
  assert.strictEqual(w.writableCorked, 1);
  w.cork();
  assert.strictEqual(w.writableCorked, 2);
  w.uncork();
  assert.strictEqual(w.writableCorked, 1);
  w.uncork();
  assert.strictEqual(w.writableCorked, 0);
  w.uncork();
  assert.strictEqual(w.writableCorked, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-stream-writable-samecb-singletick.js                                 0000664 0000000 0000000 00000001734 14746647661 0025334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Console } = require('console');
const { Writable } = require('stream');
const async_hooks = require('async_hooks');

// Make sure that repeated calls to console.log(), and by extension
// stream.write() for the underlying stream, allocate exactly 1 tick object.
// At the time of writing, that is enough to ensure a flat memory profile
// from repeated console.log() calls, rather than having callbacks pile up
// over time, assuming that data can be written synchronously.
// Refs: https://github.com/nodejs/node/issues/18013
// Refs: https://github.com/nodejs/node/issues/18367

const checkTickCreated = common.mustCall();

async_hooks.createHook({
  init(id, type, triggerId, resource) {
    if (type === 'TickObject') checkTickCreated();
  }
}).enable();

const console = new Console(new Writable({
  write: common.mustCall((chunk, encoding, cb) => {
    cb();
  }, 100)
}));

for (let i = 0; i < 100; i++)
  console.log(i);
                                    node-23.7.0/test/parallel/test-stream-writable-writable.js                                          0000664 0000000 0000000 00000001730 14746647661 0023555 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { Writable } = require('stream');

{
  const w = new Writable({
    write() {}
  });
  assert.strictEqual(w.writable, true);
  w.destroy();
  assert.strictEqual(w.writable, false);
}

{
  const w = new Writable({
    write: common.mustCall((chunk, encoding, callback) => {
      callback(new Error());
    })
  });
  assert.strictEqual(w.writable, true);
  w.write('asd');
  assert.strictEqual(w.writable, false);
  w.on('error', common.mustCall());
}

{
  const w = new Writable({
    write: common.mustCall((chunk, encoding, callback) => {
      process.nextTick(() => {
        callback(new Error());
        assert.strictEqual(w.writable, false);
      });
    })
  });
  w.write('asd');
  w.on('error', common.mustCall());
}

{
  const w = new Writable({
    write: common.mustNotCall()
  });
  assert.strictEqual(w.writable, true);
  w.end();
  assert.strictEqual(w.writable, false);
}
                                        node-23.7.0/test/parallel/test-stream-writable-write-cb-error.js                                    0000664 0000000 0000000 00000002361 14746647661 0024610 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Writable } = require('stream');
const assert = require('assert');

// Ensure callback is always invoked before
// error is emitted. Regardless if error was
// sync or async.

{
  let callbackCalled = false;
  // Sync Error
  const writable = new Writable({
    write: common.mustCall((buf, enc, cb) => {
      cb(new Error());
    })
  });
  writable.on('error', common.mustCall(() => {
    assert.strictEqual(callbackCalled, true);
  }));
  writable.write('hi', common.mustCall(() => {
    callbackCalled = true;
  }));
}

{
  let callbackCalled = false;
  // Async Error
  const writable = new Writable({
    write: common.mustCall((buf, enc, cb) => {
      process.nextTick(cb, new Error());
    })
  });
  writable.on('error', common.mustCall(() => {
    assert.strictEqual(callbackCalled, true);
  }));
  writable.write('hi', common.mustCall(() => {
    callbackCalled = true;
  }));
}

{
  // Sync Error
  const writable = new Writable({
    write: common.mustCall((buf, enc, cb) => {
      cb(new Error());
    })
  });

  writable.on('error', common.mustCall());

  let cnt = 0;
  // Ensure we don't live lock on sync error
  while (writable.write('a'))
    cnt++;

  assert.strictEqual(cnt, 0);
}
                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-writable-write-cb-twice.js                                    0000664 0000000 0000000 00000001753 14746647661 0024576 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Writable } = require('stream');

{
  // Sync + Sync
  const writable = new Writable({
    write: common.mustCall((buf, enc, cb) => {
      cb();
      cb();
    })
  });
  writable.write('hi');
  writable.on('error', common.expectsError({
    code: 'ERR_MULTIPLE_CALLBACK',
    name: 'Error'
  }));
}

{
  // Sync + Async
  const writable = new Writable({
    write: common.mustCall((buf, enc, cb) => {
      cb();
      process.nextTick(() => {
        cb();
      });
    })
  });
  writable.write('hi');
  writable.on('error', common.expectsError({
    code: 'ERR_MULTIPLE_CALLBACK',
    name: 'Error'
  }));
}

{
  // Async + Async
  const writable = new Writable({
    write: common.mustCall((buf, enc, cb) => {
      process.nextTick(cb);
      process.nextTick(() => {
        cb();
      });
    })
  });
  writable.write('hi');
  writable.on('error', common.expectsError({
    code: 'ERR_MULTIPLE_CALLBACK',
    name: 'Error'
  }));
}
                     node-23.7.0/test/parallel/test-stream-writable-write-error.js                                       0000664 0000000 0000000 00000002701 14746647661 0024224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const { Writable } = require('stream');

function expectError(w, args, code, sync) {
  if (sync) {
    if (code) {
      assert.throws(() => w.write(...args), { code });
    } else {
      w.write(...args);
    }
  } else {
    let errorCalled = false;
    let ticked = false;
    w.write(...args, common.mustCall((err) => {
      assert.strictEqual(ticked, true);
      assert.strictEqual(errorCalled, false);
      assert.strictEqual(err.code, code);
    }));
    ticked = true;
    w.on('error', common.mustCall((err) => {
      errorCalled = true;
      assert.strictEqual(err.code, code);
    }));
  }
}

function test(autoDestroy) {
  {
    const w = new Writable({
      autoDestroy,
      _write() {}
    });
    w.end();
    expectError(w, ['asd'], 'ERR_STREAM_WRITE_AFTER_END');
  }

  {
    const w = new Writable({
      autoDestroy,
      _write() {}
    });
    w.destroy();
  }

  {
    const w = new Writable({
      autoDestroy,
      _write() {}
    });
    expectError(w, [null], 'ERR_STREAM_NULL_VALUES', true);
  }

  {
    const w = new Writable({
      autoDestroy,
      _write() {}
    });
    expectError(w, [{}], 'ERR_INVALID_ARG_TYPE', true);
  }

  {
    const w = new Writable({
      decodeStrings: false,
      autoDestroy,
      _write() {}
    });
    expectError(w, ['asd', 'noencoding'], 'ERR_UNKNOWN_ENCODING', true);
  }
}

test(false);
test(true);
                                                               node-23.7.0/test/parallel/test-stream-writable-write-writev-finish.js                               0000664 0000000 0000000 00000006363 14746647661 0025701 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const stream = require('stream');

// Ensure consistency between the finish event when using cork()
// and writev and when not using them

{
  const writable = new stream.Writable();

  writable._write = (chunks, encoding, cb) => {
    cb(new Error('write test error'));
  };

  writable.on('finish', common.mustNotCall());
  writable.on('prefinish', common.mustNotCall());
  writable.on('error', common.mustCall((er) => {
    assert.strictEqual(er.message, 'write test error');
  }));

  writable.end('test');
}

{
  const writable = new stream.Writable();

  writable._write = (chunks, encoding, cb) => {
    setImmediate(cb, new Error('write test error'));
  };

  writable.on('finish', common.mustNotCall());
  writable.on('prefinish', common.mustNotCall());
  writable.on('error', common.mustCall((er) => {
    assert.strictEqual(er.message, 'write test error');
  }));

  writable.end('test');
}

{
  const writable = new stream.Writable();

  writable._write = (chunks, encoding, cb) => {
    cb(new Error('write test error'));
  };

  writable._writev = (chunks, cb) => {
    cb(new Error('writev test error'));
  };

  writable.on('finish', common.mustNotCall());
  writable.on('prefinish', common.mustNotCall());
  writable.on('error', common.mustCall((er) => {
    assert.strictEqual(er.message, 'writev test error');
  }));

  writable.cork();
  writable.write('test');

  setImmediate(function() {
    writable.end('test');
  });
}

{
  const writable = new stream.Writable();

  writable._write = (chunks, encoding, cb) => {
    setImmediate(cb, new Error('write test error'));
  };

  writable._writev = (chunks, cb) => {
    setImmediate(cb, new Error('writev test error'));
  };

  writable.on('finish', common.mustNotCall());
  writable.on('prefinish', common.mustNotCall());
  writable.on('error', common.mustCall((er) => {
    assert.strictEqual(er.message, 'writev test error');
  }));

  writable.cork();
  writable.write('test');

  setImmediate(function() {
    writable.end('test');
  });
}

// Regression test for
// https://github.com/nodejs/node/issues/13812

{
  const rs = new stream.Readable();
  rs.push('ok');
  rs.push(null);
  rs._read = () => {};

  const ws = new stream.Writable();

  ws.on('finish', common.mustNotCall());
  ws.on('error', common.mustCall());

  ws._write = (chunk, encoding, done) => {
    setImmediate(done, new Error());
  };
  rs.pipe(ws);
}

{
  const rs = new stream.Readable();
  rs.push('ok');
  rs.push(null);
  rs._read = () => {};

  const ws = new stream.Writable();

  ws.on('finish', common.mustNotCall());
  ws.on('error', common.mustCall());

  ws._write = (chunk, encoding, done) => {
    done(new Error());
  };
  rs.pipe(ws);
}

{
  const w = new stream.Writable();
  w._write = (chunk, encoding, cb) => {
    process.nextTick(cb);
  };
  w.on('error', common.mustCall());
  w.on('finish', common.mustNotCall());
  w.on('prefinish', () => {
    w.write("shouldn't write in prefinish listener");
  });
  w.end();
}

{
  const w = new stream.Writable();
  w._write = (chunk, encoding, cb) => {
    process.nextTick(cb);
  };
  w.on('error', common.mustCall());
  w.on('finish', () => {
    w.write("shouldn't write in finish listener");
  });
  w.end();
}
                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-writableState-ending.js                                       0000664 0000000 0000000 00000001624 14746647661 0024213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const assert = require('assert');
const stream = require('stream');

const writable = new stream.Writable();

function testStates(ending, finished, ended) {
  assert.strictEqual(writable._writableState.ending, ending);
  assert.strictEqual(writable._writableState.finished, finished);
  assert.strictEqual(writable._writableState.ended, ended);
}

writable._write = (chunk, encoding, cb) => {
  // Ending, finished, ended start in false.
  testStates(false, false, false);
  cb();
};

writable.on('finish', () => {
  // Ending, finished, ended = true.
  testStates(true, true, true);
});

const result = writable.end('testing function end()', () => {
  // Ending, finished, ended = true.
  testStates(true, true, true);
});

// End returns the writable instance
assert.strictEqual(result, writable);

// Ending, ended = true.
// finished = false.
testStates(true, false, true);
                                                                                                            node-23.7.0/test/parallel/test-stream-writableState-uncorked-bufferedRequestCount.js                0000664 0000000 0000000 00000003144 14746647661 0030722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const stream = require('stream');

const writable = new stream.Writable();

writable._writev = common.mustCall((chunks, cb) => {
  assert.strictEqual(chunks.length, 2);
  cb();
}, 1);

writable._write = common.mustCall((chunk, encoding, cb) => {
  cb();
}, 1);

// first cork
writable.cork();
assert.strictEqual(writable._writableState.corked, 1);
assert.strictEqual(writable._writableState.bufferedRequestCount, 0);

// cork again
writable.cork();
assert.strictEqual(writable._writableState.corked, 2);

// The first chunk is buffered
writable.write('first chunk');
assert.strictEqual(writable._writableState.bufferedRequestCount, 1);

// First uncork does nothing
writable.uncork();
assert.strictEqual(writable._writableState.corked, 1);
assert.strictEqual(writable._writableState.bufferedRequestCount, 1);

process.nextTick(uncork);

// The second chunk is buffered, because we uncork at the end of tick
writable.write('second chunk');
assert.strictEqual(writable._writableState.corked, 1);
assert.strictEqual(writable._writableState.bufferedRequestCount, 2);

function uncork() {
  // Second uncork flushes the buffer
  writable.uncork();
  assert.strictEqual(writable._writableState.corked, 0);
  assert.strictEqual(writable._writableState.bufferedRequestCount, 0);

  // Verify that end() uncorks correctly
  writable.cork();
  writable.write('third chunk');
  writable.end();

  // End causes an uncork() as well
  assert.strictEqual(writable._writableState.corked, 0);
  assert.strictEqual(writable._writableState.bufferedRequestCount, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-stream-write-destroy.js                                              0000664 0000000 0000000 00000003267 14746647661 0022765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { Writable } = require('stream');

// Test interaction between calling .destroy() on a writable and pending
// writes.

for (const withPendingData of [ false, true ]) {
  for (const useEnd of [ false, true ]) {
    const callbacks = [];

    const w = new Writable({
      write(data, enc, cb) {
        callbacks.push(cb);
      },
      // Effectively disable the HWM to observe 'drain' events more easily.
      highWaterMark: 1
    });

    let chunksWritten = 0;
    let drains = 0;
    w.on('drain', () => drains++);

    function onWrite(err) {
      if (err) {
        assert.strictEqual(w.destroyed, true);
        assert.strictEqual(err.code, 'ERR_STREAM_DESTROYED');
      } else {
        chunksWritten++;
      }
    }

    w.write('abc', onWrite);
    assert.strictEqual(chunksWritten, 0);
    assert.strictEqual(drains, 0);
    callbacks.shift()();
    assert.strictEqual(chunksWritten, 1);
    assert.strictEqual(drains, 1);

    if (withPendingData) {
      // Test 2 cases: There either is or is not data still in the write queue.
      // (The second write will never actually get executed either way.)
      w.write('def', onWrite);
    }
    if (useEnd) {
      // Again, test 2 cases: Either we indicate that we want to end the
      // writable or not.
      w.end('ghi', onWrite);
    } else {
      w.write('ghi', onWrite);
    }

    assert.strictEqual(chunksWritten, 1);
    w.destroy();
    assert.strictEqual(chunksWritten, 1);
    callbacks.shift()();
    assert.strictEqual(chunksWritten, useEnd && !withPendingData ? 1 : 2);
    assert.strictEqual(callbacks.length, 0);
    assert.strictEqual(drains, 1);
  }
}
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-stream-write-drain.js                                                0000664 0000000 0000000 00000000443 14746647661 0022362 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Writable } = require('stream');

// Don't emit 'drain' if ended

const w = new Writable({
  write(data, enc, cb) {
    process.nextTick(cb);
  },
  highWaterMark: 1
});

w.on('drain', common.mustNotCall());
w.write('asd');
w.end();
                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-stream-write-final.js                                                0000664 0000000 0000000 00000001021 14746647661 0022347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

const stream = require('stream');
let shutdown = false;

const w = new stream.Writable({
  final: common.mustCall(function(cb) {
    assert.strictEqual(this, w);
    setTimeout(function() {
      shutdown = true;
      cb();
    }, 100);
  }),
  write: function(chunk, e, cb) {
    process.nextTick(cb);
  }
});
w.on('finish', common.mustCall(function() {
  assert(shutdown);
}));
w.write(Buffer.allocUnsafe(1));
w.end(Buffer.allocUnsafe(0));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-stream-writev.js                                                     0000664 0000000 0000000 00000007252 14746647661 0021462 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');

const stream = require('stream');

const queue = [];
for (let decode = 0; decode < 2; decode++) {
  for (let uncork = 0; uncork < 2; uncork++) {
    for (let multi = 0; multi < 2; multi++) {
      queue.push([!!decode, !!uncork, !!multi]);
    }
  }
}

run();

function run() {
  const t = queue.pop();
  if (t)
    