.format('%s %s', 42), '42 %s');
assert.strictEqual(util.format('%s', 42n), '42n');
assert.strictEqual(util.format('%s', Symbol('foo')), 'Symbol(foo)');
assert.strictEqual(util.format('%s', true), 'true');
assert.strictEqual(util.format('%s', { a: [1, 2, 3] }), '{ a: [Array] }');
assert.strictEqual(util.format('%s', { toString() { return 'Foo'; } }), 'Foo');
assert.strictEqual(util.format('%s', { toString: 5 }), '{ toString: 5 }');
assert.strictEqual(util.format('%s', () => 5), '() => 5');
assert.strictEqual(util.format('%s', Infinity), 'Infinity');
assert.strictEqual(util.format('%s', -Infinity), '-Infinity');

// String format specifier including `toString` properties on the prototype.
{
  class Foo { toString() { return 'Bar'; } }
  assert.strictEqual(util.format('%s', new Foo()), 'Bar');
  assert.strictEqual(
    util.format('%s', Object.setPrototypeOf(new Foo(), null)),
    '[Foo: null prototype] {}'
  );
  globalThis.Foo = Foo;
  assert.strictEqual(util.format('%s', new Foo()), 'Bar');
  delete globalThis.Foo;
  class Bar { abc = true; }
  assert.strictEqual(util.format('%s', new Bar()), 'Bar { abc: true }');
  class Foobar extends Array { aaa = true; }
  assert.strictEqual(
    util.format('%s', new Foobar(5)),
    'Foobar(5) [ <5 empty items>, aaa: true ]'
  );

  // Subclassing:
  class B extends Foo {}

  function C() {}
  C.prototype.toString = function() {
    return 'Custom';
  };

  function D() {
    C.call(this);
  }
  D.prototype = { __proto__: C.prototype };

  assert.strictEqual(
    util.format('%s', new B()),
    'Bar'
  );
  assert.strictEqual(
    util.format('%s', new C()),
    'Custom'
  );
  assert.strictEqual(
    util.format('%s', new D()),
    'Custom'
  );

  D.prototype.constructor = D;
  assert.strictEqual(
    util.format('%s', new D()),
    'Custom'
  );

  D.prototype.constructor = null;
  assert.strictEqual(
    util.format('%s', new D()),
    'Custom'
  );

  D.prototype.constructor = { name: 'Foobar' };
  assert.strictEqual(
    util.format('%s', new D()),
    'Custom'
  );

  Object.defineProperty(D.prototype, 'constructor', {
    get() {
      throw new Error();
    },
    configurable: true
  });
  assert.strictEqual(
    util.format('%s', new D()),
    'Custom'
  );

  assert.strictEqual(
    util.format('%s', { __proto__: null }),
    '[Object: null prototype] {}'
  );
}

// Symbol.toPrimitive handling for string format specifier
{
  const objectWithToPrimitive = {
    [Symbol.toPrimitive](hint) {
      switch (hint) {
        case 'number':
          return 42;
        case 'string':
          return 'string representation';
        case 'default':
        default:
          return 'default context';
      }
    }
  };

  assert.strictEqual(util.format('%s', +objectWithToPrimitive), '42');
  assert.strictEqual(util.format('%s', objectWithToPrimitive), 'string representation');
  assert.strictEqual(util.format('%s', objectWithToPrimitive + ''), 'default context');
}

// JSON format specifier
assert.strictEqual(util.format('%j'), '%j');
assert.strictEqual(util.format('%j', 42), '42');
assert.strictEqual(util.format('%j', '42'), '"42"');
assert.strictEqual(util.format('%j %j', 42, 43), '42 43');
assert.strictEqual(util.format('%j %j', 42), '42 %j');

// Object format specifier
const obj = {
  foo: 'bar',
  foobar: 1,
  func: function() {}
};
const nestedObj = {
  foo: 'bar',
  foobar: {
    foo: 'bar',
    func: function() {}
  }
};
const nestedObj2 = {
  foo: 'bar',
  foobar: 1,
  func: [{ a: function() {} }]
};
assert.strictEqual(util.format('%o'), '%o');
assert.strictEqual(util.format('%o', 42), '42');
assert.strictEqual(util.format('%o', 'foo'), '\'foo\'');
assert.strictEqual(
  util.format('%o', obj),
  '{\n' +
  '  foo: \'bar\',\n' +
  '  foobar: 1,\n' +
  '  func: <ref *1> [Function: func] {\n' +
  '    [length]: 0,\n' +
  '    [name]: \'func\',\n' +
  '    [prototype]: { [constructor]: [Circular *1] }\n' +
  '  }\n' +
  '}');
assert.strictEqual(
  util.format('%o', nestedObj2),
  '{\n' +
  '  foo: \'bar\',\n' +
  '  foobar: 1,\n' +
  '  func: [\n' +
  '    {\n' +
  '      a: <ref *1> [Function: a] {\n' +
  '        [length]: 0,\n' +
  '        [name]: \'a\',\n' +
  '        [prototype]: { [constructor]: [Circular *1] }\n' +
  '      }\n' +
  '    },\n' +
  '    [length]: 1\n' +
  '  ]\n' +
  '}');
assert.strictEqual(
  util.format('%o', nestedObj),
  '{\n' +
  '  foo: \'bar\',\n' +
  '  foobar: {\n' +
  '    foo: \'bar\',\n' +
  '    func: <ref *1> [Function: func] {\n' +
  '      [length]: 0,\n' +
  '      [name]: \'func\',\n' +
  '      [prototype]: { [constructor]: [Circular *1] }\n' +
  '    }\n' +
  '  }\n' +
  '}');
assert.strictEqual(
  util.format('%o %o', obj, obj),
  '{\n' +
  '  foo: \'bar\',\n' +
  '  foobar: 1,\n' +
  '  func: <ref *1> [Function: func] {\n' +
  '    [length]: 0,\n' +
  '    [name]: \'func\',\n' +
  '    [prototype]: { [constructor]: [Circular *1] }\n' +
  '  }\n' +
  '} {\n' +
  '  foo: \'bar\',\n' +
  '  foobar: 1,\n' +
  '  func: <ref *1> [Function: func] {\n' +
  '    [length]: 0,\n' +
  '    [name]: \'func\',\n' +
  '    [prototype]: { [constructor]: [Circular *1] }\n' +
  '  }\n' +
  '}');
assert.strictEqual(
  util.format('%o %o', obj),
  '{\n' +
  '  foo: \'bar\',\n' +
  '  foobar: 1,\n' +
  '  func: <ref *1> [Function: func] {\n' +
  '    [length]: 0,\n' +
  '    [name]: \'func\',\n' +
  '    [prototype]: { [constructor]: [Circular *1] }\n' +
  '  }\n' +
  '} %o');

assert.strictEqual(util.format('%O'), '%O');
assert.strictEqual(util.format('%O', 42), '42');
assert.strictEqual(util.format('%O', 'foo'), '\'foo\'');
assert.strictEqual(
  util.format('%O', obj),
  '{ foo: \'bar\', foobar: 1, func: [Function: func] }');
assert.strictEqual(
  util.format('%O', nestedObj),
  '{ foo: \'bar\', foobar: { foo: \'bar\', func: [Function: func] } }');
assert.strictEqual(
  util.format('%O %O', obj, obj),
  '{ foo: \'bar\', foobar: 1, func: [Function: func] } ' +
  '{ foo: \'bar\', foobar: 1, func: [Function: func] }');
assert.strictEqual(
  util.format('%O %O', obj),
  '{ foo: \'bar\', foobar: 1, func: [Function: func] } %O');

// Various format specifiers
assert.strictEqual(util.format('%%s%s', 'foo'), '%sfoo');
assert.strictEqual(util.format('%s:%s'), '%s:%s');
assert.strictEqual(util.format('%s:%s', undefined), 'undefined:%s');
assert.strictEqual(util.format('%s:%s', 'foo'), 'foo:%s');
assert.strictEqual(util.format('%s:%i', 'foo'), 'foo:%i');
assert.strictEqual(util.format('%s:%f', 'foo'), 'foo:%f');
assert.strictEqual(util.format('%s:%s', 'foo', 'bar'), 'foo:bar');
assert.strictEqual(util.format('%s:%s', 'foo', 'bar', 'baz'), 'foo:bar baz');
assert.strictEqual(util.format('%%%s%%', 'hi'), '%hi%');
assert.strictEqual(util.format('%%%s%%%%', 'hi'), '%hi%%');
assert.strictEqual(util.format('%sbc%%def', 'a'), 'abc%def');
assert.strictEqual(util.format('%d:%d', 12, 30), '12:30');
assert.strictEqual(util.format('%d:%d', 12), '12:%d');
assert.strictEqual(util.format('%d:%d'), '%d:%d');
assert.strictEqual(util.format('%i:%i', 12, 30), '12:30');
assert.strictEqual(util.format('%i:%i', 12), '12:%i');
assert.strictEqual(util.format('%i:%i'), '%i:%i');
assert.strictEqual(util.format('%f:%f', 12, 30), '12:30');
assert.strictEqual(util.format('%f:%f', 12), '12:%f');
assert.strictEqual(util.format('%f:%f'), '%f:%f');
assert.strictEqual(util.format('o: %j, a: %j', {}, []), 'o: {}, a: []');
assert.strictEqual(util.format('o: %j, a: %j', {}), 'o: {}, a: %j');
assert.strictEqual(util.format('o: %j, a: %j'), 'o: %j, a: %j');
assert.strictEqual(util.format('o: %o, a: %O', {}, []), 'o: {}, a: []');
assert.strictEqual(util.format('o: %o, a: %o', {}), 'o: {}, a: %o');
assert.strictEqual(util.format('o: %O, a: %O'), 'o: %O, a: %O');


// Invalid format specifiers
assert.strictEqual(util.format('a% b', 'x'), 'a% b x');
assert.strictEqual(util.format('percent: %d%, fraction: %d', 10, 0.1),
                   'percent: 10%, fraction: 0.1');
assert.strictEqual(util.format('abc%', 1), 'abc% 1');

// Additional arguments after format specifiers
assert.strictEqual(util.format('%i', 1, 'number'), '1 number');
assert.strictEqual(util.format('%i', 1, () => {}), '1 [Function (anonymous)]');

// %c from https://console.spec.whatwg.org/
assert.strictEqual(util.format('%c'), '%c');
assert.strictEqual(util.format('%cab'), '%cab');
assert.strictEqual(util.format('%cab', 'color: blue'), 'ab');
assert.strictEqual(util.format('%cab', 'color: blue', 'c'), 'ab c');

{
  const o = {};
  o.o = o;
  assert.strictEqual(util.format('%j', o), '[Circular]');
}

{
  const o = {
    toJSON() {
      throw new Error('Not a circular object but still not serializable');
    }
  };
  assert.throws(() => util.format('%j', o),
                /^Error: Not a circular object but still not serializable$/);
}

// Errors
const err = new Error('foo');
assert.strictEqual(util.format(err), err.stack);
class CustomError extends Error {
  constructor(msg) {
    super();
    Object.defineProperty(this, 'message',
                          { value: msg, enumerable: false });
    Object.defineProperty(this, 'name',
                          { value: 'CustomError', enumerable: false });
    Error.captureStackTrace(this, CustomError);
  }
}
const customError = new CustomError('bar');
assert.strictEqual(util.format(customError), customError.stack);
// Doesn't capture stack trace
function BadCustomError(msg) {
  Error.call(this);
  Object.defineProperty(this, 'message',
                        { value: msg, enumerable: false });
  Object.defineProperty(this, 'name',
                        { value: 'BadCustomError', enumerable: false });
}
Object.setPrototypeOf(BadCustomError.prototype, Error.prototype);
Object.setPrototypeOf(BadCustomError, Error);
assert.strictEqual(util.format(new BadCustomError('foo')),
                   '[BadCustomError: foo]');

// The format of arguments should not depend on type of the first argument
assert.strictEqual(util.format('1', '1'), '1 1');
assert.strictEqual(util.format(1, '1'), '1 1');
assert.strictEqual(util.format('1', 1), '1 1');
assert.strictEqual(util.format(1, -0), '1 -0');
assert.strictEqual(util.format('1', () => {}), '1 [Function (anonymous)]');
assert.strictEqual(util.format(1, () => {}), '1 [Function (anonymous)]');
assert.strictEqual(util.format('1', "'"), "1 '");
assert.strictEqual(util.format(1, "'"), "1 '");
assert.strictEqual(util.format('1', 'number'), '1 number');
assert.strictEqual(util.format(1, 'number'), '1 number');
assert.strictEqual(util.format(5n), '5n');
assert.strictEqual(util.format(5n, 5n), '5n 5n');

// Check `formatWithOptions`.
assert.strictEqual(
  util.formatWithOptions(
    { colors: true },
    true, undefined, Symbol(), 1, 5n, null, 'foobar'
  ),
  '\u001b[33mtrue\u001b[39m ' +
    '\u001b[90mundefined\u001b[39m ' +
    '\u001b[32mSymbol()\u001b[39m ' +
    '\u001b[33m1\u001b[39m ' +
    '\u001b[33m5n\u001b[39m ' +
    '\u001b[1mnull\u001b[22m ' +
    'foobar'
);

assert.strictEqual(
  util.format(new SharedArrayBuffer(4)),
  'SharedArrayBuffer { [Uint8Contents]: <00 00 00 00>, byteLength: 4 }'
);

assert.strictEqual(
  util.formatWithOptions(
    { colors: true, compact: 3 },
    '%s', [ 1, { a: true }]
  ),
  '[ 1, [Object] ]'
);

[
  undefined,
  null,
  false,
  5n,
  5,
  'test',
  Symbol(),
].forEach((invalidOptions) => {
  assert.throws(() => {
    util.formatWithOptions(invalidOptions, { a: true });
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /"inspectOptions".+object/
  });
});
                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-util-getcallsite.js                                                  0000664 0000000 0000000 00000000433 14746647661 0022116 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const { getCallSite } = require('node:util');
const { expectWarning } = require('../common');

const warning = 'The `util.getCallSite` API has been renamed to `util.getCallSites()`.';
expectWarning('ExperimentalWarning', warning);
getCallSite();
                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-util-getcallsites.js                                                 0000664 0000000 0000000 00000010620 14746647661 0022300 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const fixtures = require('../common/fixtures');
const file = fixtures.path('get-call-sites.js');

const { getCallSites } = require('node:util');
const { spawnSync } = require('node:child_process');
const assert = require('node:assert');

{
  const callSites = getCallSites();
  assert.ok(callSites.length > 1);
  assert.match(
    callSites[0].scriptName,
    /test-util-getcallsites/,
    'node:util should be ignored',
  );
}

{
  const callSites = getCallSites(3);
  assert.strictEqual(callSites.length, 3);
  assert.match(
    callSites[0].scriptName,
    /test-util-getcallsites/,
    'node:util should be ignored',
  );
}

// Guarantee dot-left numbers are ignored
{
  const callSites = getCallSites(3.6);
  assert.strictEqual(callSites.length, 3);
}

{
  const callSites = getCallSites(3.4);
  assert.strictEqual(callSites.length, 3);
}

{
  assert.throws(() => {
    // Max than kDefaultMaxCallStackSizeToCapture
    getCallSites(201);
  }, common.expectsError({
    code: 'ERR_OUT_OF_RANGE'
  }));
  assert.throws(() => {
    getCallSites(-1);
  }, common.expectsError({
    code: 'ERR_OUT_OF_RANGE'
  }));
  assert.throws(() => {
    getCallSites([]);
  }, common.expectsError({
    code: 'ERR_INVALID_ARG_TYPE'
  }));
  assert.throws(() => {
    getCallSites({}, {});
  }, common.expectsError({
    code: 'ERR_INVALID_ARG_TYPE'
  }));
  assert.throws(() => {
    getCallSites(10, 10);
  }, common.expectsError({
    code: 'ERR_INVALID_ARG_TYPE'
  }));
}

{
  const callSites = getCallSites(1);
  assert.strictEqual(callSites.length, 1);
  assert.match(
    callSites[0].scriptName,
    /test-util-getcallsites/,
    'node:util should be ignored',
  );
}

// ScriptId is a string.
{
  const callSites = getCallSites(1);
  assert.strictEqual(callSites.length, 1);
  assert.strictEqual(typeof callSites[0].scriptId, 'string');
}

// Guarantee [eval] will appear on stacktraces when using -e
{
  const { status, stderr, stdout } = spawnSync(
    process.execPath,
    [
      '-e',
      `const util = require('util');
       const assert = require('assert');
       assert.ok(util.getCallSites().length > 1);
       process.stdout.write(util.getCallSites()[0].scriptName);
      `,
    ],
  );
  assert.strictEqual(status, 0, stderr.toString());
  assert.strictEqual(stdout.toString(), '[eval]');
}

// Guarantee the stacktrace[0] is the filename
{
  const { status, stderr, stdout } = spawnSync(
    process.execPath,
    [file],
  );
  assert.strictEqual(status, 0, stderr.toString());
  assert.strictEqual(stdout.toString(), file);
}

// Error.stackTraceLimit should not influence callsite size
{
  const originalStackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const callSites = getCallSites();
  assert.notStrictEqual(callSites.length, 0);
  Error.stackTraceLimit = originalStackTraceLimit;
}

{
  const { status, stderr, stdout } = spawnSync(process.execPath, [
    '--no-warnings',
    '--experimental-transform-types',
    fixtures.path('typescript/ts/test-get-callsite.ts'),
  ]);

  const output = stdout.toString();
  assert.strictEqual(stderr.toString(), '');
  assert.match(output, /lineNumber: 8/);
  assert.match(output, /column: 18/);
  assert.match(output, /columnNumber: 18/);
  assert.match(output, /test-get-callsite\.ts/);
  assert.strictEqual(status, 0);
}

{
  const { status, stderr, stdout } = spawnSync(process.execPath, [
    '--no-warnings',
    '--experimental-transform-types',
    '--no-enable-source-maps',
    fixtures.path('typescript/ts/test-get-callsite.ts'),
  ]);

  const output = stdout.toString();
  assert.strictEqual(stderr.toString(), '');
  // Line should be wrong when sourcemaps are disable
  assert.match(output, /lineNumber: 2/);
  assert.match(output, /column: 18/);
  assert.match(output, /columnNumber: 18/);
  assert.match(output, /test-get-callsite\.ts/);
  assert.strictEqual(status, 0);
}

{
  // Source maps should be disabled when options.sourceMap is false
  const { status, stderr, stdout } = spawnSync(process.execPath, [
    '--no-warnings',
    '--experimental-transform-types',
    fixtures.path('typescript/ts/test-get-callsite-explicit.ts'),
  ]);

  const output = stdout.toString();
  assert.strictEqual(stderr.toString(), '');
  assert.match(output, /lineNumber: 2/);
  assert.match(output, /column: 18/);
  assert.match(output, /columnNumber: 18/);
  assert.match(output, /test-get-callsite-explicit\.ts/);
  assert.strictEqual(status, 0);
}
                                                                                                                node-23.7.0/test/parallel/test-util-inherits.js                                                     0000664 0000000 0000000 00000004444 14746647661 0021451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const { inherits } = require('util');

// Super constructor
function A() {
  this._a = 'a';
}
A.prototype.a = function() { return this._a; };

// One level of inheritance
function B(value) {
  A.call(this);
  this._b = value;
}
inherits(B, A);
B.prototype.b = function() { return this._b; };

assert.deepStrictEqual(
  Object.getOwnPropertyDescriptor(B, 'super_'),
  {
    value: A,
    enumerable: false,
    configurable: true,
    writable: true
  }
);

const b = new B('b');
assert.strictEqual(b.a(), 'a');
assert.strictEqual(b.b(), 'b');
assert.strictEqual(b.constructor, B);

// Two levels of inheritance
function C() {
  B.call(this, 'b');
  this._c = 'c';
}
inherits(C, B);
C.prototype.c = function() { return this._c; };
C.prototype.getValue = function() { return this.a() + this.b() + this.c(); };

assert.strictEqual(C.super_, B);

const c = new C();
assert.strictEqual(c.getValue(), 'abc');
assert.strictEqual(c.constructor, C);

// Inherits can be called after setting prototype properties
function D() {
  C.call(this);
  this._d = 'd';
}

D.prototype.d = function() { return this._d; };
inherits(D, C);

assert.strictEqual(D.super_, C);

const d = new D();
assert.strictEqual(d.c(), 'c');
assert.strictEqual(d.d(), 'd');
assert.strictEqual(d.constructor, D);

// ES6 classes can inherit from a constructor function
class E {
  constructor() {
    D.call(this);
    this._e = 'e';
  }
  e() { return this._e; }
}
inherits(E, D);

assert.strictEqual(E.super_, D);

const e = new E();
assert.strictEqual(e.getValue(), 'abc');
assert.strictEqual(e.d(), 'd');
assert.strictEqual(e.e(), 'e');
assert.strictEqual(e.constructor, E);

// Should throw with invalid arguments
assert.throws(() => {
  inherits(A, {});
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: 'The "superCtor.prototype" property must be of type object. ' +
           'Received undefined'
});

assert.throws(() => {
  inherits(A, null);
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: 'The "superCtor" argument must be of type function. ' +
           'Received null'
});

assert.throws(() => {
  inherits(null, A);
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: 'The "ctor" argument must be of type function. Received null'
});
                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-util-inspect-getters-accessing-this.js                               0000664 0000000 0000000 00000002044 14746647661 0025640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// This test ensures that util.inspect logs getters
// which access this.

const assert = require('assert');

const { inspect } = require('util');

{
  class X {
    constructor() {
      this._y = 123;
    }

    get y() {
      return this._y;
    }
  }

  const result = inspect(new X(), {
    getters: true,
    showHidden: true
  });

  assert.strictEqual(
    result,
    'X { _y: 123, [y]: [Getter: 123] }'
  );
}

// Regression test for https://github.com/nodejs/node/issues/37054
{
  class A {
    constructor(B) {
      this.B = B;
    }
    get b() {
      return this.B;
    }
  }

  class B {
    constructor() {
      this.A = new A(this);
    }
    get a() {
      return this.A;
    }
  }

  const result = inspect(new B(), {
    depth: 1,
    getters: true,
    showHidden: true
  });

  assert.strictEqual(
    result,
    '<ref *1> B {\n' +
    '  A: A { B: [Circular *1], [b]: [Getter] [Circular *1] },\n' +
    '  [a]: [Getter] A { B: [Circular *1], [b]: [Getter] [Circular *1] }\n' +
    '}',
  );
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-util-inspect-long-running.js                                         0000664 0000000 0000000 00000000764 14746647661 0023705 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// Test that huge objects don't crash due to exceeding the maximum heap size.

const util = require('util');

// Create a difficult to stringify object. Without the artificial limitation
// this would crash or throw an maximum string size error.
let last = {};
const obj = last;

for (let i = 0; i < 1000; i++) {
  last.next = { circular: obj, last, obj: { a: 1, b: 2, c: true } };
  last = last.next;
  obj[i] = last;
}

util.inspect(obj, { depth: Infinity });
            node-23.7.0/test/parallel/test-util-inspect-namespace.js                                            0000664 0000000 0000000 00000001113 14746647661 0023211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-vm-modules
'use strict';
const common = require('../common');
const assert = require('assert');

const { SourceTextModule } = require('vm');
const { inspect } = require('util');

(async () => {
  const m = new SourceTextModule('export const a = 1; export var b = 2');
  await m.link(() => 0);
  assert.strictEqual(
    inspect(m.namespace),
    '[Module: null prototype] { a: <uninitialized>, b: undefined }');
  await m.evaluate();
  assert.strictEqual(
    inspect(m.namespace),
    '[Module: null prototype] { a: 1, b: 2 }'
  );
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-util-inspect-proxy.js                                                0000664 0000000 0000000 00000015072 14746647661 0022447 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

require('../common');
const assert = require('assert');
const util = require('util');
const { internalBinding } = require('internal/test/binding');
const processUtil = internalBinding('util');
const opts = { showProxy: true };

let proxyObj;
let called = false;
const target = {
  [util.inspect.custom](depth, { showProxy }) {
    if (showProxy === false) {
      called = true;
      if (proxyObj !== this) {
        throw new Error('Failed');
      }
    }
    return [1, 2, 3];
  }
};
const handler = {
  getPrototypeOf() { throw new Error('getPrototypeOf'); },
  setPrototypeOf() { throw new Error('setPrototypeOf'); },
  isExtensible() { throw new Error('isExtensible'); },
  preventExtensions() { throw new Error('preventExtensions'); },
  getOwnPropertyDescriptor() { throw new Error('getOwnPropertyDescriptor'); },
  defineProperty() { throw new Error('defineProperty'); },
  has() { throw new Error('has'); },
  get() { throw new Error('get'); },
  set() { throw new Error('set'); },
  deleteProperty() { throw new Error('deleteProperty'); },
  ownKeys() { throw new Error('ownKeys'); },
  apply() { throw new Error('apply'); },
  construct() { throw new Error('construct'); }
};
proxyObj = new Proxy(target, handler);

// Inspecting the proxy should not actually walk it's properties
util.inspect(proxyObj, opts);

// Make sure inspecting object does not trigger any proxy traps.
util.format('%s', proxyObj);

// getProxyDetails is an internal method, not intended for public use.
// This is here to test that the internals are working correctly.
let details = processUtil.getProxyDetails(proxyObj, true);
assert.strictEqual(target, details[0]);
assert.strictEqual(handler, details[1]);

details = processUtil.getProxyDetails(proxyObj);
assert.strictEqual(target, details[0]);
assert.strictEqual(handler, details[1]);

details = processUtil.getProxyDetails(proxyObj, false);
assert.strictEqual(target, details);

details = processUtil.getProxyDetails({}, true);
assert.strictEqual(details, undefined);

const r = Proxy.revocable({}, {});
r.revoke();

details = processUtil.getProxyDetails(r.proxy, true);
assert.strictEqual(details[0], null);
assert.strictEqual(details[1], null);

details = processUtil.getProxyDetails(r.proxy, false);
assert.strictEqual(details, null);

assert.strictEqual(util.inspect(r.proxy), '<Revoked Proxy>');
assert.strictEqual(
  util.inspect(r, { showProxy: true }),
  '{ proxy: <Revoked Proxy>, revoke: [Function (anonymous)] }',
);

assert.strictEqual(util.format('%s', r.proxy), '<Revoked Proxy>');

assert.strictEqual(
  util.inspect(proxyObj, opts),
  'Proxy [\n' +
  '  [ 1, 2, 3 ],\n' +
  '  {\n' +
  '    getPrototypeOf: [Function: getPrototypeOf],\n' +
  '    setPrototypeOf: [Function: setPrototypeOf],\n' +
  '    isExtensible: [Function: isExtensible],\n' +
  '    preventExtensions: [Function: preventExtensions],\n' +
  '    getOwnPropertyDescriptor: [Function: getOwnPropertyDescriptor],\n' +
  '    defineProperty: [Function: defineProperty],\n' +
  '    has: [Function: has],\n' +
  '    get: [Function: get],\n' +
  '    set: [Function: set],\n' +
  '    deleteProperty: [Function: deleteProperty],\n' +
  '    ownKeys: [Function: ownKeys],\n' +
  '    apply: [Function: apply],\n' +
  '    construct: [Function: construct]\n' +
  '  }\n' +
  ']'
);

// Using getProxyDetails with non-proxy returns undefined
assert.strictEqual(processUtil.getProxyDetails({}), undefined);

// Inspecting a proxy without the showProxy option set to true should not
// trigger any proxy handlers.
assert.strictEqual(util.inspect(proxyObj), '[ 1, 2, 3 ]');
assert(called);

// Yo dawg, I heard you liked Proxy so I put a Proxy
// inside your Proxy that proxies your Proxy's Proxy.
const proxy1 = new Proxy({}, {});
const proxy2 = new Proxy(proxy1, {});
const proxy3 = new Proxy(proxy2, proxy1);
const proxy4 = new Proxy(proxy1, proxy2);
const proxy5 = new Proxy(proxy3, proxy4);
const proxy6 = new Proxy(proxy5, proxy5);
const expected0 = '{}';
const expected1 = 'Proxy [ {}, {} ]';
const expected2 = 'Proxy [ Proxy [ {}, {} ], {} ]';
const expected3 = 'Proxy [ Proxy [ Proxy [ {}, {} ], {} ], Proxy [ {}, {} ] ]';
const expected4 = 'Proxy [ Proxy [ {}, {} ], Proxy [ Proxy [ {}, {} ], {} ] ]';
const expected5 = 'Proxy [\n  ' +
                  'Proxy [ Proxy [ Proxy [Array], {} ], Proxy [ {}, {} ] ],\n' +
                  '  Proxy [ Proxy [ {}, {} ], Proxy [ Proxy [Array], {} ] ]' +
                  '\n]';
const expected6 = 'Proxy [\n' +
                  '  Proxy [\n' +
                  '    Proxy [ Proxy [Array], Proxy [Array] ],\n' +
                  '    Proxy [ Proxy [Array], Proxy [Array] ]\n' +
                  '  ],\n' +
                  '  Proxy [\n' +
                  '    Proxy [ Proxy [Array], Proxy [Array] ],\n' +
                  '    Proxy [ Proxy [Array], Proxy [Array] ]\n' +
                  '  ]\n' +
                  ']';
assert.strictEqual(
  util.inspect(proxy1, { showProxy: 1, depth: null }),
  expected1);
assert.strictEqual(util.inspect(proxy2, opts), expected2);
assert.strictEqual(util.inspect(proxy3, opts), expected3);
assert.strictEqual(util.inspect(proxy4, opts), expected4);
assert.strictEqual(util.inspect(proxy5, opts), expected5);
assert.strictEqual(util.inspect(proxy6, opts), expected6);
assert.strictEqual(util.inspect(proxy1), expected0);
assert.strictEqual(util.inspect(proxy2), expected0);
assert.strictEqual(util.inspect(proxy3), expected0);
assert.strictEqual(util.inspect(proxy4), expected0);
assert.strictEqual(util.inspect(proxy5), expected0);
assert.strictEqual(util.inspect(proxy6), expected0);

// Just for fun, let's create a Proxy using Arrays.
const proxy7 = new Proxy([], []);
const expected7 = 'Proxy [ [], [] ]';
assert.strictEqual(util.inspect(proxy7, opts), expected7);
assert.strictEqual(util.inspect(proxy7), '[]');

// Now we're just getting silly, right?
const proxy8 = new Proxy(Date, []);
const proxy9 = new Proxy(Date, String);
const expected8 = 'Proxy [ [Function: Date], [] ]';
const expected9 = 'Proxy [ [Function: Date], [Function: String] ]';
assert.strictEqual(util.inspect(proxy8, opts), expected8);
assert.strictEqual(util.inspect(proxy9, opts), expected9);
assert.strictEqual(util.inspect(proxy8), '[Function: Date]');
assert.strictEqual(util.inspect(proxy9), '[Function: Date]');

const proxy10 = new Proxy(() => {}, {});
const proxy11 = new Proxy(() => {}, {
  get() {
    return proxy11;
  },
  apply() {
    return proxy11;
  }
});
const expected10 = '[Function (anonymous)]';
const expected11 = '[Function (anonymous)]';
assert.strictEqual(util.inspect(proxy10), expected10);
assert.strictEqual(util.inspect(proxy11), expected11);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-util-inspect.js                                                      0000664 0000000 0000000 00000326227 14746647661 0021277 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
const common = require('../common');
const assert = require('assert');
const { internalBinding } = require('internal/test/binding');
const JSStream = internalBinding('js_stream').JSStream;
const util = require('util');
const vm = require('vm');
const v8 = require('v8');
const { previewEntries } = internalBinding('util');
const { inspect } = util;
const { MessageChannel } = require('worker_threads');
const url = require('url');

assert.strictEqual(util.inspect(1), '1');
assert.strictEqual(util.inspect(false), 'false');
assert.strictEqual(util.inspect(''), "''");
assert.strictEqual(util.inspect('hello'), "'hello'");
assert.strictEqual(util.inspect(function abc() {}), '[Function: abc]');
assert.strictEqual(util.inspect(() => {}), '[Function (anonymous)]');
assert.strictEqual(
  util.inspect(async function() {}),
  '[AsyncFunction (anonymous)]'
);
assert.strictEqual(util.inspect(async () => {}), '[AsyncFunction (anonymous)]');

// Special function inspection.
{
  const fn = (() => function*() {})();
  assert.strictEqual(
    util.inspect(fn),
    '[GeneratorFunction (anonymous)]'
  );
  assert.strictEqual(
    util.inspect(async function* abc() {}),
    '[AsyncGeneratorFunction: abc]'
  );
  Object.setPrototypeOf(fn, Object.getPrototypeOf(async () => {}));
  assert.strictEqual(
    util.inspect(fn),
    '[GeneratorFunction (anonymous)] AsyncFunction'
  );
  Object.defineProperty(fn, 'name', { value: 5, configurable: true });
  assert.strictEqual(
    util.inspect(fn),
    '[GeneratorFunction: 5] AsyncFunction'
  );
  Object.defineProperty(fn, Symbol.toStringTag, {
    value: 'Foobar',
    configurable: true
  });
  assert.strictEqual(
    util.inspect({ ['5']: fn }),
    "{ '5': [GeneratorFunction: 5] AsyncFunction [Foobar] }"
  );
  Object.defineProperty(fn, 'name', { value: '5', configurable: true });
  Object.setPrototypeOf(fn, null);
  assert.strictEqual(
    util.inspect(fn),
    '[GeneratorFunction (null prototype): 5] [Foobar]'
  );
  assert.strictEqual(
    util.inspect({ ['5']: fn }),
    "{ '5': [GeneratorFunction (null prototype): 5] [Foobar] }"
  );
}

assert.strictEqual(util.inspect(undefined), 'undefined');
assert.strictEqual(util.inspect(null), 'null');
assert.strictEqual(util.inspect(/foo(bar\n)?/gi), '/foo(bar\\n)?/gi');
assert.strictEqual(
  util.inspect(new Date('Sun, 14 Feb 2010 11:48:40 GMT')),
  new Date('2010-02-14T12:48:40+01:00').toISOString()
);
assert.strictEqual(util.inspect(new Date('')), (new Date('')).toString());
assert.strictEqual(util.inspect('\n\x01'), "'\\n\\x01'");
assert.strictEqual(
  util.inspect(`${Array(75).fill(1)}'\n\x1d\n\x03\x85\x7f\x7e\x9f\xa0`),
  // eslint-disable-next-line no-irregular-whitespace
  `"${Array(75).fill(1)}'\\n" +\n  '\\x1D\\n' +\n  '\\x03\\x85\\x7F~\\x9F '`
);
assert.strictEqual(util.inspect([]), '[]');
assert.strictEqual(util.inspect({ __proto__: [] }), 'Array {}');
assert.strictEqual(util.inspect([1, 2]), '[ 1, 2 ]');
assert.strictEqual(util.inspect([1, [2, 3]]), '[ 1, [ 2, 3 ] ]');
assert.strictEqual(util.inspect({}), '{}');
assert.strictEqual(util.inspect({ a: 1 }), '{ a: 1 }');
assert.strictEqual(util.inspect({ a: function() {} }), '{ a: [Function: a] }');
assert.strictEqual(util.inspect({ a: () => {} }), '{ a: [Function: a] }');
// eslint-disable-next-line func-name-matching
assert.strictEqual(util.inspect({ a: async function abc() {} }),
                   '{ a: [AsyncFunction: abc] }');
assert.strictEqual(util.inspect({ a: async () => {} }),
                   '{ a: [AsyncFunction: a] }');
assert.strictEqual(util.inspect({ a: function*() {} }),
                   '{ a: [GeneratorFunction: a] }');
assert.strictEqual(util.inspect({ a: 1, b: 2 }), '{ a: 1, b: 2 }');
assert.strictEqual(util.inspect({ 'a': {} }), '{ a: {} }');
assert.strictEqual(util.inspect({ 'a': { 'b': 2 } }), '{ a: { b: 2 } }');
assert.strictEqual(util.inspect({ 'a': { 'b': { 'c': { 'd': 2 } } } }),
                   '{ a: { b: { c: [Object] } } }');
assert.strictEqual(
  util.inspect({ 'a': { 'b': { 'c': { 'd': 2 } } } }, false, null),
  '{\n  a: { b: { c: { d: 2 } } }\n}');
assert.strictEqual(util.inspect([1, 2, 3], true), '[ 1, 2, 3, [length]: 3 ]');
assert.strictEqual(util.inspect({ 'a': { 'b': { 'c': 2 } } }, false, 0),
                   '{ a: [Object] }');
assert.strictEqual(util.inspect({ 'a': { 'b': { 'c': 2 } } }, false, 1),
                   '{ a: { b: [Object] } }');
assert.strictEqual(util.inspect({ 'a': { 'b': ['c'] } }, false, 1),
                   '{ a: { b: [Array] } }');
assert.strictEqual(util.inspect(new Uint8Array(0)), 'Uint8Array(0) []');
assert(inspect(new Uint8Array(0), { showHidden: true }).includes('[buffer]'));
assert.strictEqual(
  util.inspect(
    Object.create(
      {},
      { visible: { value: 1, enumerable: true }, hidden: { value: 2 } }
    )
  ),
  '{ visible: 1 }'
);
assert.strictEqual(
  util.inspect(
    Object.assign(new String('hello'), { [Symbol('foo')]: 123 }),
    { showHidden: true }
  ),
  "[String: 'hello'] { [length]: 5, [Symbol(foo)]: 123 }"
);

assert.match(util.inspect((new JSStream())._externalStream),
             /^\[External: [0-9a-f]+\]$/);

{
  const regexp = /regexp/;
  regexp.aprop = 42;
  assert.strictEqual(util.inspect({ a: regexp }, false, 0), '{ a: /regexp/ }');
}

assert.match(
  util.inspect({ a: { a: { a: { a: {} } } } }, undefined, undefined, true),
  /Object/
);
assert.doesNotMatch(
  util.inspect({ a: { a: { a: { a: {} } } } }, undefined, null, true),
  /Object/
);

{
  const showHidden = true;
  const ab = new Uint8Array([1, 2, 3, 4]).buffer;
  const dv = new DataView(ab, 1, 2);
  assert.strictEqual(
    util.inspect(ab, showHidden),
    'ArrayBuffer { [Uint8Contents]: <01 02 03 04>, byteLength: 4 }'
  );
  assert.strictEqual(util.inspect(new DataView(ab, 1, 2), showHidden),
                     'DataView {\n' +
                     '  byteLength: 2,\n' +
                     '  byteOffset: 1,\n' +
                     '  buffer: ArrayBuffer {' +
                      ' [Uint8Contents]: <01 02 03 04>, byteLength: 4 }\n}');
  assert.strictEqual(
    util.inspect(ab, showHidden),
    'ArrayBuffer { [Uint8Contents]: <01 02 03 04>, byteLength: 4 }'
  );
  assert.strictEqual(util.inspect(dv, showHidden),
                     'DataView {\n' +
                     '  byteLength: 2,\n' +
                     '  byteOffset: 1,\n' +
                     '  buffer: ArrayBuffer { [Uint8Contents]: ' +
                       '<01 02 03 04>, byteLength: 4 }\n}');
  ab.x = 42;
  dv.y = 1337;
  assert.strictEqual(util.inspect(ab, showHidden),
                     'ArrayBuffer { [Uint8Contents]: <01 02 03 04>, ' +
                       'byteLength: 4, x: 42 }');
  assert.strictEqual(util.inspect(dv, showHidden),
                     'DataView {\n' +
                     '  byteLength: 2,\n' +
                     '  byteOffset: 1,\n' +
                     '  buffer: ArrayBuffer { [Uint8Contents]: <01 02 03 04>,' +
                       ' byteLength: 4, x: 42 },\n' +
                     '  y: 1337\n}');
}

{
  const ab = new ArrayBuffer(42);
  assert.strictEqual(ab.byteLength, 42);
  new MessageChannel().port1.postMessage(ab, [ ab ]);
  assert.strictEqual(ab.byteLength, 0);
  assert.strictEqual(util.inspect(ab),
                     'ArrayBuffer { (detached), byteLength: 0 }');
}

// Truncate output for ArrayBuffers using plural or singular bytes
{
  const ab = new ArrayBuffer(3);
  assert.strictEqual(util.inspect(ab, { showHidden: true, maxArrayLength: 2 }),
                     'ArrayBuffer { [Uint8Contents]' +
                      ': <00 00 ... 1 more byte>, byteLength: 3 }');
  assert.strictEqual(util.inspect(ab, { showHidden: true, maxArrayLength: 1 }),
                     'ArrayBuffer { [Uint8Contents]' +
                      ': <00 ... 2 more bytes>, byteLength: 3 }');
}

// Now do the same checks but from a different context.
{
  const showHidden = false;
  const ab = vm.runInNewContext('new ArrayBuffer(4)');
  const dv = vm.runInNewContext('new DataView(ab, 1, 2)', { ab });
  assert.strictEqual(
    util.inspect(ab, showHidden),
    'ArrayBuffer { [Uint8Contents]: <00 00 00 00>, byteLength: 4 }'
  );
  assert.strictEqual(util.inspect(new DataView(ab, 1, 2), showHidden),
                     'DataView {\n' +
                     '  byteLength: 2,\n' +
                     '  byteOffset: 1,\n' +
                     '  buffer: ArrayBuffer { [Uint8Contents]: <00 00 00 00>,' +
                       ' byteLength: 4 }\n}');
  assert.strictEqual(
    util.inspect(ab, showHidden),
    'ArrayBuffer { [Uint8Contents]: <00 00 00 00>, byteLength: 4 }'
  );
  assert.strictEqual(util.inspect(dv, showHidden),
                     'DataView {\n' +
                     '  byteLength: 2,\n' +
                     '  byteOffset: 1,\n' +
                     '  buffer: ArrayBuffer { [Uint8Contents]: <00 00 00 00>,' +
                       ' byteLength: 4 }\n}');
  ab.x = 42;
  dv.y = 1337;
  assert.strictEqual(util.inspect(ab, showHidden),
                     'ArrayBuffer { [Uint8Contents]: <00 00 00 00>, ' +
                       'byteLength: 4, x: 42 }');
  assert.strictEqual(util.inspect(dv, showHidden),
                     'DataView {\n' +
                     '  byteLength: 2,\n' +
                     '  byteOffset: 1,\n' +
                     '  buffer: ArrayBuffer { [Uint8Contents]: <00 00 00 00>,' +
                       ' byteLength: 4, x: 42 },\n' +
                     '  y: 1337\n}');
}

[ Float32Array,
  Float64Array,
  Int16Array,
  Int32Array,
  Int8Array,
  Uint16Array,
  Uint32Array,
  Uint8Array,
  Uint8ClampedArray ].forEach((constructor) => {
  const length = 2;
  const byteLength = length * constructor.BYTES_PER_ELEMENT;
  const array = new constructor(new ArrayBuffer(byteLength), 0, length);
  array[0] = 65;
  array[1] = 97;
  assert.strictEqual(
    util.inspect(array, { showHidden: true }),
    `${constructor.name}(${length}) [\n` +
      '  65,\n' +
      '  97,\n' +
      `  [BYTES_PER_ELEMENT]: ${constructor.BYTES_PER_ELEMENT},\n` +
      `  [length]: ${length},\n` +
      `  [byteLength]: ${byteLength},\n` +
      '  [byteOffset]: 0,\n' +
      `  [buffer]: ArrayBuffer { byteLength: ${byteLength} }\n]`);
  assert.strictEqual(
    util.inspect(array, false),
    `${constructor.name}(${length}) [ 65, 97 ]`
  );
});

// Now check that declaring a TypedArray in a different context works the same.
[ Float32Array,
  Float64Array,
  Int16Array,
  Int32Array,
  Int8Array,
  Uint16Array,
  Uint32Array,
  Uint8Array,
  Uint8ClampedArray ].forEach((constructor) => {
  const length = 2;
  const byteLength = length * constructor.BYTES_PER_ELEMENT;
  const array = vm.runInNewContext(
    'new constructor(new ArrayBuffer(byteLength), 0, length)',
    { constructor, byteLength, length }
  );
  array[0] = 65;
  array[1] = 97;
  assert.strictEqual(
    util.inspect(array, true),
    `${constructor.name}(${length}) [\n` +
      '  65,\n' +
      '  97,\n' +
      `  [BYTES_PER_ELEMENT]: ${constructor.BYTES_PER_ELEMENT},\n` +
      `  [length]: ${length},\n` +
      `  [byteLength]: ${byteLength},\n` +
      '  [byteOffset]: 0,\n' +
      `  [buffer]: ArrayBuffer { byteLength: ${byteLength} }\n]`);
  assert.strictEqual(
    util.inspect(array, false),
    `${constructor.name}(${length}) [ 65, 97 ]`
  );
});

{
  const brokenLength = new Float32Array(2);
  Object.defineProperty(brokenLength, 'length', { value: -1 });
  assert.strictEqual(inspect(brokenLength), 'Float32Array(2) [ 0n, 0n ]');
}

assert.strictEqual(
  util.inspect(Object.create({}, {
    visible: { value: 1, enumerable: true },
    hidden: { value: 2 }
  }), { showHidden: true }),
  '{ visible: 1, [hidden]: 2 }'
);
// Objects without prototype.
assert.strictEqual(
  util.inspect(Object.create(null, {
    name: { value: 'Tim', enumerable: true },
    hidden: { value: 'secret' }
  }), { showHidden: true }),
  "[Object: null prototype] { name: 'Tim', [hidden]: 'secret' }"
);

assert.strictEqual(
  util.inspect(Object.create(null, {
    name: { value: 'Tim', enumerable: true },
    hidden: { value: 'secret' }
  })),
  "[Object: null prototype] { name: 'Tim' }"
);

// Dynamic properties.
{
  assert.strictEqual(
    util.inspect({ get readonly() { return 1; } }),
    '{ readonly: [Getter] }');

  assert.strictEqual(
    util.inspect({ get readwrite() { return 1; }, set readwrite(val) {} }),
    '{ readwrite: [Getter/Setter] }');

  assert.strictEqual(
    // eslint-disable-next-line accessor-pairs
    util.inspect({ set writeonly(val) {} }),
    '{ writeonly: [Setter] }');

  const value = {};
  value.a = value;
  assert.strictEqual(util.inspect(value), '<ref *1> { a: [Circular *1] }');
  const getterFn = {
    get one() {
      return null;
    }
  };
  assert.strictEqual(
    util.inspect(getterFn, { getters: true }),
    '{ one: [Getter: null] }'
  );
}

// Array with dynamic properties.
{
  const value = [1, 2, 3];
  Object.defineProperty(
    value,
    'growingLength',
    {
      enumerable: true,
      get: function() { this.push(true); return this.length; }
    }
  );
  Object.defineProperty(
    value,
    '-1',
    {
      enumerable: true,
      value: -1
    }
  );
  assert.strictEqual(util.inspect(value),
                     "[ 1, 2, 3, growingLength: [Getter], '-1': -1 ]");
}

// Array with inherited number properties.
{
  class CustomArray extends Array {}
  CustomArray.prototype[5] = 'foo';
  CustomArray.prototype[49] = 'bar';
  CustomArray.prototype.foo = true;
  const arr = new CustomArray(50);
  arr[49] = 'I win';
  assert.strictEqual(
    util.inspect(arr),
    "CustomArray(50) [ <49 empty items>, 'I win' ]"
  );
  assert.strictEqual(
    util.inspect(arr, { showHidden: true }),
    'CustomArray(50) [\n' +
    '  <49 empty items>,\n' +
    "  'I win',\n" +
    '  [length]: 50,\n' +
    "  '5': 'foo',\n" +
    '  foo: true\n' +
    ']'
  );
}

// Array with extra properties.
{
  const arr = [1, 2, 3, , ]; // eslint-disable-line no-sparse-arrays
  arr.foo = 'bar';
  assert.strictEqual(util.inspect(arr),
                     "[ 1, 2, 3, <1 empty item>, foo: 'bar' ]");

  const arr2 = [];
  assert.strictEqual(util.inspect([], { showHidden: true }), '[ [length]: 0 ]');
  arr2['00'] = 1;
  assert.strictEqual(util.inspect(arr2), "[ '00': 1 ]");
  assert.strictEqual(util.inspect(arr2, { showHidden: true }),
                     "[ [length]: 0, '00': 1 ]");
  arr2[1] = 0;
  assert.strictEqual(util.inspect(arr2), "[ <1 empty item>, 0, '00': 1 ]");
  assert.strictEqual(util.inspect(arr2, { showHidden: true }),
                     "[ <1 empty item>, 0, [length]: 2, '00': 1 ]");
  delete arr2[1];
  assert.strictEqual(util.inspect(arr2), "[ <2 empty items>, '00': 1 ]");
  assert.strictEqual(util.inspect(arr2, { showHidden: true }),
                     "[ <2 empty items>, [length]: 2, '00': 1 ]");
  arr2['01'] = 2;
  assert.strictEqual(util.inspect(arr2),
                     "[ <2 empty items>, '00': 1, '01': 2 ]");
  assert.strictEqual(util.inspect(arr2, { showHidden: true }),
                     "[ <2 empty items>, [length]: 2, '00': 1, '01': 2 ]");
  delete arr2['00'];
  arr2[0] = 0;
  assert.strictEqual(util.inspect(arr2),
                     "[ 0, <1 empty item>, '01': 2 ]");
  assert.strictEqual(util.inspect(arr2, { showHidden: true }),
                     "[ 0, <1 empty item>, [length]: 2, '01': 2 ]");
  delete arr2['01'];
  arr2[2 ** 32 - 2] = 'max';
  arr2[2 ** 32 - 1] = 'too far';
  assert.strictEqual(
    util.inspect(arr2),
    "[ 0, <4294967293 empty items>, 'max', '4294967295': 'too far' ]"
  );

  const arr3 = [];
  arr3[-1] = -1;
  assert.strictEqual(util.inspect(arr3), "[ '-1': -1 ]");
}

// Indices out of bounds.
{
  const arr = [];
  arr[2 ** 32] = true; // Not a valid array index.
  assert.strictEqual(util.inspect(arr), "[ '4294967296': true ]");
  arr[0] = true;
  arr[10] = true;
  assert.strictEqual(util.inspect(arr),
                     "[ true, <9 empty items>, true, '4294967296': true ]");
  arr[2 ** 32 - 2] = true;
  arr[2 ** 32 - 1] = true;
  arr[2 ** 32 + 1] = true;
  delete arr[0];
  delete arr[10];
  assert.strictEqual(util.inspect(arr),
                     ['[',
                      '<4294967294 empty items>,',
                      'true,',
                      "'4294967296': true,",
                      "'4294967295': true,",
                      "'4294967297': true\n]",
                     ].join('\n  '));
}

// Function with properties.
{
  const value = () => {};
  value.aprop = 42;
  assert.strictEqual(util.inspect(value), '[Function: value] { aprop: 42 }');
}

// Anonymous function with properties.
{
  const value = (() => function() {})();
  value.aprop = 42;
  assert.strictEqual(
    util.inspect(value),
    '[Function (anonymous)] { aprop: 42 }'
  );
}

// Regular expressions with properties.
{
  const value = /123/ig;
  value.aprop = 42;
  assert.strictEqual(util.inspect(value), '/123/gi { aprop: 42 }');
}

// Dates with properties.
{
  const value = new Date('Sun, 14 Feb 2010 11:48:40 GMT');
  value.aprop = 42;
  assert.strictEqual(util.inspect(value),
                     '2010-02-14T11:48:40.000Z { aprop: 42 }');
}

// Test the internal isDate implementation.
{
  const Date2 = vm.runInNewContext('Date');
  const d = new Date2();
  const orig = util.inspect(d);
  Date2.prototype.foo = 'bar';
  const after = util.inspect(d);
  assert.strictEqual(orig, after);
}

// Test positive/negative zero.
assert.strictEqual(util.inspect(0), '0');
assert.strictEqual(util.inspect(-0), '-0');
// Edge case from check.
assert.strictEqual(util.inspect(-5e-324), '-5e-324');

// Test for sparse array.
{
  const a = ['foo', 'bar', 'baz'];
  assert.strictEqual(util.inspect(a), "[ 'foo', 'bar', 'baz' ]");
  delete a[1];
  assert.strictEqual(util.inspect(a), "[ 'foo', <1 empty item>, 'baz' ]");
  assert.strictEqual(
    util.inspect(a, true),
    "[ 'foo', <1 empty item>, 'baz', [length]: 3 ]"
  );
  assert.strictEqual(util.inspect(new Array(5)), '[ <5 empty items> ]');
  a[3] = 'bar';
  a[100] = 'qux';
  assert.strictEqual(
    util.inspect(a, { breakLength: Infinity }),
    "[ 'foo', <1 empty item>, 'baz', 'bar', <96 empty items>, 'qux' ]"
  );
  delete a[3];
  assert.strictEqual(
    util.inspect(a, { maxArrayLength: 4 }),
    "[ 'foo', <1 empty item>, 'baz', <97 empty items>, ... 1 more item ]"
  );
  // test 4 special case
  assert.strictEqual(util.inspect(a, {
    maxArrayLength: 2
  }), "[ 'foo', <1 empty item>, ... 99 more items ]");
}

// Test for Array constructor in different context.
{
  const map = new Map();
  map.set(1, 2);
  // Passing only a single argument to indicate a set iterator.
  const valsSetIterator = previewEntries(map.entries());
  // Passing through true to indicate a map iterator.
  const valsMapIterEntries = previewEntries(map.entries(), true);
  const valsMapIterKeys = previewEntries(map.keys(), true);

  assert.strictEqual(util.inspect(valsSetIterator), '[ 1, 2 ]');
  assert.strictEqual(util.inspect(valsMapIterEntries), '[ [ 1, 2 ], true ]');
  assert.strictEqual(util.inspect(valsMapIterKeys), '[ [ 1 ], false ]');
}

// Test for other constructors in different context.
{
  let obj = vm.runInNewContext('(function(){return {}})()', {});
  assert.strictEqual(util.inspect(obj), '{}');
  obj = vm.runInNewContext('const m=new Map();m.set(1,2);m', {});
  assert.strictEqual(util.inspect(obj), 'Map(1) { 1 => 2 }');
  obj = vm.runInNewContext('const s=new Set();s.add(1);s.add(2);s', {});
  assert.strictEqual(util.inspect(obj), 'Set(2) { 1, 2 }');
  obj = vm.runInNewContext('fn=function(){};new Promise(fn,fn)', {});
  assert.strictEqual(util.inspect(obj), 'Promise { <pending> }');
}

// Test for property descriptors.
{
  const getter = Object.create(null, {
    a: {
      get: function() { return 'aaa'; }
    }
  });
  const setter = Object.create(null, {
    b: { // eslint-disable-line accessor-pairs
      set: function() {}
    }
  });
  const getterAndSetter = Object.create(null, {
    c: {
      get: function() { return 'ccc'; },
      set: function() {}
    }
  });
  assert.strictEqual(
    util.inspect(getter, true),
    '[Object: null prototype] { [a]: [Getter] }'
  );
  assert.strictEqual(
    util.inspect(setter, true),
    '[Object: null prototype] { [b]: [Setter] }'
  );
  assert.strictEqual(
    util.inspect(getterAndSetter, true),
    '[Object: null prototype] { [c]: [Getter/Setter] }'
  );
}

// Exceptions should print the error message, not '{}'.
{
  [
    new Error(),
    new Error('FAIL'),
    new TypeError('FAIL'),
    new SyntaxError('FAIL'),
  ].forEach((err) => {
    assert.strictEqual(util.inspect(err), err.stack);
  });
  assert.throws(
    () => undef(), // eslint-disable-line no-undef
    (e) => {
      assert.strictEqual(util.inspect(e), e.stack);
      return true;
    }
  );

  const ex = util.inspect(new Error('FAIL'), true);
  assert(ex.includes('Error: FAIL'));
  assert(ex.includes('[stack]'));
  assert(ex.includes('[message]'));
}

{
  const falsyCause1 = new Error('', { cause: false });
  delete falsyCause1.stack;
  const falsyCause2 = new Error(undefined, { cause: null });
  falsyCause2.stack = '';
  const undefinedCause = new Error('', { cause: undefined });
  undefinedCause.stack = '';

  assert.strictEqual(util.inspect(falsyCause1), '[Error] { [cause]: false }');
  assert.strictEqual(util.inspect(falsyCause2), '[Error] { [cause]: null }');
  assert.strictEqual(
    util.inspect(undefinedCause),
    '[Error] { [cause]: undefined }'
  );
}

{
  const tmp = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const err = new Error('foo');
  const err2 = new Error('foo\nbar');
  assert.strictEqual(util.inspect(err, { compact: true }), '[Error: foo]');
  assert(err.stack);
  delete err.stack;
  assert(!err.stack);
  assert.strictEqual(util.inspect(err, { compact: true }), '[Error: foo]');
  assert.strictEqual(
    util.inspect(err2, { compact: true }),
    '[Error: foo\nbar]'
  );

  err.bar = true;
  err2.bar = true;

  assert.strictEqual(
    util.inspect(err, { compact: true }),
    '{ [Error: foo] bar: true }'
  );
  assert.strictEqual(
    util.inspect(err2, { compact: true }),
    '{ [Error: foo\nbar]\n  bar: true }'
  );
  assert.strictEqual(
    util.inspect(err, { compact: true, breakLength: 5 }),
    '{ [Error: foo]\n  bar: true }'
  );
  assert.strictEqual(
    util.inspect(err, { compact: true, breakLength: 1 }),
    '{ [Error: foo]\n  bar:\n   true }'
  );
  assert.strictEqual(
    util.inspect(err2, { compact: true, breakLength: 5 }),
    '{ [Error: foo\nbar]\n  bar: true }'
  );
  assert.strictEqual(
    util.inspect(err, { compact: false }),
    '[Error: foo] {\n  bar: true\n}'
  );
  assert.strictEqual(
    util.inspect(err2, { compact: false }),
    '[Error: foo\nbar] {\n  bar: true\n}'
  );

  Error.stackTraceLimit = tmp;
}

// Prevent enumerable error properties from being printed.
{
  let err = new Error();
  err.message = 'foobar';
  let out = util.inspect(err).split('\n');
  assert.strictEqual(out[0], 'Error: foobar');
  assert(out[out.length - 1].startsWith('    at '));
  // Reset the error, the stack is otherwise not recreated.
  err = new Error();
  err.message = 'foobar';
  err.name = 'Unique';
  Object.defineProperty(err, 'stack', { value: err.stack, enumerable: true });
  out = util.inspect(err).split('\n');
  assert.strictEqual(out[0], 'Unique: foobar');
  assert(out[out.length - 1].startsWith('    at '));
  err.name = 'Baz';
  out = util.inspect(err).split('\n');
  assert.strictEqual(out[0], 'Unique: foobar');
  assert.strictEqual(out[out.length - 2], "  name: 'Baz'");
  assert.strictEqual(out[out.length - 1], '}');
}

// Doesn't capture stack trace.
{
  function BadCustomError(msg) {
    Error.call(this);
    Object.defineProperty(this, 'message',
                          { value: msg, enumerable: false });
    Object.defineProperty(this, 'name',
                          { value: 'BadCustomError', enumerable: false });
  }
  Object.setPrototypeOf(BadCustomError.prototype, Error.prototype);
  Object.setPrototypeOf(BadCustomError, Error);
  assert.strictEqual(
    util.inspect(new BadCustomError('foo')),
    '[BadCustomError: foo]'
  );
}

// Tampered error stack or name property (different type than string).
// Note: Symbols are not supported by `Error#toString()` which is called by
// accessing the `stack` property.
[
  [404, '404 [RangeError]: foo', '[404]'],
  [0, '0 [RangeError]: foo', '[RangeError: foo]'],
  [0n, '0 [RangeError]: foo', '[RangeError: foo]'],
  [null, 'null: foo', '[RangeError: foo]'],
  [undefined, 'RangeError: foo', '[RangeError: foo]'],
  [false, 'false [RangeError]: foo', '[RangeError: foo]'],
  ['', 'foo', '[RangeError: foo]'],
  [[1, 2, 3], '1,2,3 [RangeError]: foo', '[[\n  1,\n  2,\n  3\n]]'],
].forEach(([value, outputStart, stack]) => {
  let err = new RangeError('foo');
  err.name = value;
  const result = util.inspect(err);
  assert(
    result.startsWith(outputStart),
    util.format(
      'The name set to %o did not result in the expected output "%s", got "%s"',
      value,
      outputStart,
      result.split('\n')[0]
    )
  );

  err = new RangeError('foo');
  err.stack = value;
  assert.strictEqual(util.inspect(err), stack);
});

// https://github.com/nodejs/node-v0.x-archive/issues/1941
assert.strictEqual(util.inspect({ __proto__: Date.prototype }), 'Date {}');

// https://github.com/nodejs/node-v0.x-archive/issues/1944
{
  const d = new Date();
  d.toUTCString = null;
  util.inspect(d);
}

// Should not throw.
{
  const d = new Date();
  d.toISOString = null;
  util.inspect(d);
}

// Should not throw.
{
  const r = /regexp/;
  r.toString = null;
  util.inspect(r);
}

// See https://github.com/nodejs/node-v0.x-archive/issues/2225
{
  const x = { [util.inspect.custom]: util.inspect };
  assert(util.inspect(x).includes(
    '[Symbol(nodejs.util.inspect.custom)]: [Function: inspect] {\n'));
}

// `util.inspect` should display the escaped value of a key.
{
  const w = {
    '\\': 1,
    '\\\\': 2,
    '\\\\\\': 3,
    '\\\\\\\\': 4,
    '\n': 5,
    '\r': 6
  };

  const y = ['a', 'b', 'c'];
  y['\\\\'] = 'd';
  y['\n'] = 'e';
  y['\r'] = 'f';

  assert.strictEqual(
    util.inspect(w),
    "{ '\\\\': 1, '\\\\\\\\': 2, '\\\\\\\\\\\\': 3, " +
    "'\\\\\\\\\\\\\\\\': 4, '\\n': 5, '\\r': 6 }"
  );
  assert.strictEqual(
    util.inspect(y),
    "[ 'a', 'b', 'c', '\\\\\\\\': 'd', " +
    "'\\n': 'e', '\\r': 'f' ]"
  );
}

// Escape unpaired surrogate pairs.
{
  const edgeChar = String.fromCharCode(0xd799);

  for (let charCode = 0xD800; charCode < 0xDFFF; charCode++) {
    const surrogate = String.fromCharCode(charCode);

    assert.strictEqual(
      util.inspect(surrogate),
      `'\\u${charCode.toString(16)}'`
    );
    assert.strictEqual(
      util.inspect(`${'a'.repeat(200)}${surrogate}`),
      `'${'a'.repeat(200)}\\u${charCode.toString(16)}'`
    );
    assert.strictEqual(
      util.inspect(`${surrogate}${'a'.repeat(200)}`),
      `'\\u${charCode.toString(16)}${'a'.repeat(200)}'`
    );
    if (charCode < 0xdc00) {
      const highSurrogate = surrogate;
      const lowSurrogate = String.fromCharCode(charCode + 1024);
      assert(
        !util.inspect(
          `${edgeChar}${highSurrogate}${lowSurrogate}${edgeChar}`
        ).includes('\\u')
      );
      assert.strictEqual(
        (util.inspect(
          `${highSurrogate}${highSurrogate}${lowSurrogate}`
        ).match(/\\u/g) ?? []).length,
        1
      );
    } else {
      assert.strictEqual(
        util.inspect(`${edgeChar}${surrogate}${edgeChar}`),
        `'${edgeChar}\\u${charCode.toString(16)}${edgeChar}'`
      );
    }
  }
}

// Test util.inspect.styles and util.inspect.colors.
{
  function testColorStyle(style, input) {
    const colorName = util.inspect.styles[style];
    let color = ['', ''];
    if (util.inspect.colors[colorName])
      color = util.inspect.colors[colorName];

    const withoutColor = util.inspect(input, false, 0, false);
    const withColor = util.inspect(input, false, 0, true);
    const expect = `\u001b[${color[0]}m${withoutColor}\u001b[${color[1]}m`;
    assert.strictEqual(
      withColor,
      expect,
      `util.inspect color for style ${style}`);
  }

  testColorStyle('special', function() {});
  testColorStyle('number', 123.456);
  testColorStyle('boolean', true);
  testColorStyle('undefined', undefined);
  testColorStyle('null', null);
  testColorStyle('string', 'test string');
  testColorStyle('date', new Date());
  testColorStyle('regexp', /regexp/);
}

// An object with "hasOwnProperty" overwritten should not throw.
util.inspect({ hasOwnProperty: null });

// New API, accepts an "options" object.
{
  const subject = { foo: 'bar', hello: 31, a: { b: { c: { d: 0 } } } };
  Object.defineProperty(subject, 'hidden', { enumerable: false, value: null });

  assert.strictEqual(
    util.inspect(subject, { showHidden: false }).includes('hidden'),
    false
  );
  assert.strictEqual(
    util.inspect(subject, { showHidden: true }).includes('hidden'),
    true
  );
  assert.strictEqual(
    util.inspect(subject, { colors: false }).includes('\u001b[32m'),
    false
  );
  assert.strictEqual(
    util.inspect(subject, { colors: true }).includes('\u001b[32m'),
    true
  );
  assert.strictEqual(
    util.inspect(subject, { depth: 2 }).includes('c: [Object]'),
    true
  );
  assert.strictEqual(
    util.inspect(subject, { depth: 0 }).includes('a: [Object]'),
    true
  );
  assert.strictEqual(
    util.inspect(subject, { depth: null }).includes('{ d: 0 }'),
    true
  );
  assert.strictEqual(
    util.inspect(subject, { depth: undefined }).includes('{ d: 0 }'),
    true
  );
}

{
  // "customInspect" option can enable/disable calling [util.inspect.custom]().
  const subject = { [util.inspect.custom]: () => 123 };

  assert.strictEqual(
    util.inspect(subject, { customInspect: true }).includes('123'),
    true
  );
  assert.strictEqual(
    util.inspect(subject, { customInspect: true }).includes('inspect'),
    false
  );
  assert.strictEqual(
    util.inspect(subject, { customInspect: false }).includes('123'),
    false
  );
  assert.strictEqual(
    util.inspect(subject, { customInspect: false }).includes('inspect'),
    true
  );

  // A custom [util.inspect.custom]() should be able to return other Objects.
  subject[util.inspect.custom] = () => ({ foo: 'bar' });

  assert.strictEqual(util.inspect(subject), "{ foo: 'bar' }");

  subject[util.inspect.custom] = common.mustCall((depth, opts, inspect) => {
    const clone = { ...opts };
    // This might change at some point but for now we keep the stylize function.
    // The function should either be documented or an alternative should be
    // implemented.
    assert.strictEqual(typeof opts.stylize, 'function');
    assert.strictEqual(opts.seen, undefined);
    assert.strictEqual(opts.budget, undefined);
    assert.strictEqual(opts.indentationLvl, undefined);
    assert.strictEqual(opts.showHidden, false);
    assert.strictEqual(inspect, util.inspect);
    assert.deepStrictEqual(
      new Set(Object.keys(inspect.defaultOptions).concat(['stylize'])),
      new Set(Object.keys(opts))
    );
    opts.showHidden = true;
    return { [inspect.custom]: common.mustCall((depth, opts2) => {
      assert.deepStrictEqual(clone, opts2);
    }) };
  });

  util.inspect(subject);

  // util.inspect.custom is a shared symbol which can be accessed as
  // Symbol.for("nodejs.util.inspect.custom").
  const inspect = Symbol.for('nodejs.util.inspect.custom');

  subject[inspect] = () => ({ baz: 'quux' });

  assert.strictEqual(util.inspect(subject), '{ baz: \'quux\' }');

  subject[inspect] = (depth, opts) => {
    assert.strictEqual(opts.customInspectOptions, true);
    assert.strictEqual(opts.seen, null);
    return {};
  };

  util.inspect(subject, { customInspectOptions: true, seen: null });
}

{
  const subject = { [util.inspect.custom]: common.mustCall((depth, opts) => {
    assert.strictEqual(depth, null);
    assert.strictEqual(opts.compact, true);
  }) };
  util.inspect(subject, { depth: null, compact: true });
}

{
  // Returning `this` from a custom inspection function works.
  const subject = { a: 123, [util.inspect.custom]() { return this; } };
  const UIC = 'nodejs.util.inspect.custom';
  assert.strictEqual(
    util.inspect(subject),
    `{\n  a: 123,\n  [Symbol(${UIC})]: [Function: [${UIC}]]\n}`
  );
}

// Verify that it's possible to use the stylize function to manipulate input.
assert.strictEqual(
  util.inspect([1, 2, 3], { stylize() { return 'x'; } }),
  '[ x, x, x ]'
);

// Using `util.inspect` with "colors" option should produce as many lines as
// without it.
{
  function testLines(input) {
    const countLines = (str) => (str.match(/\n/g) || []).length;
    const withoutColor = util.inspect(input);
    const withColor = util.inspect(input, { colors: true });
    assert.strictEqual(countLines(withoutColor), countLines(withColor));
  }

  const bigArray = new Array(100).fill().map((value, index) => index);

  testLines([1, 2, 3, 4, 5, 6, 7]);
  testLines(bigArray);
  testLines({ foo: 'bar', baz: 35, b: { a: 35 } });
  testLines({ a: { a: 3, b: 1, c: 1, d: 1, e: 1, f: 1, g: 1, h: 1 }, b: 1 });
  testLines({
    foo: 'bar',
    baz: 35,
    b: { a: 35 },
    veryLongKey: 'very long value',
    evenLongerKey: ['with even longer value in array']
  });
}

// Test boxed primitives output the correct values.
assert.strictEqual(util.inspect(new String('test')), "[String: 'test']");
assert.strictEqual(
  util.inspect(new String('test'), { colors: true }),
  "\u001b[32m[String: 'test']\u001b[39m"
);
assert.strictEqual(
  util.inspect(Object(Symbol('test'))),
  '[Symbol: Symbol(test)]'
);
assert.strictEqual(util.inspect(new Boolean(false)), '[Boolean: false]');
assert.strictEqual(
  util.inspect(Object.setPrototypeOf(new Boolean(true), null)),
  '[Boolean (null prototype): true]'
);
assert.strictEqual(util.inspect(new Number(0)), '[Number: 0]');
assert.strictEqual(
  util.inspect(
    Object.defineProperty(
      Object.setPrototypeOf(new Number(-0), Array.prototype),
      Symbol.toStringTag,
      { value: 'Foobar' }
    )
  ),
  '[Number (Array): -0] [Foobar]'
);
assert.strictEqual(util.inspect(new Number(-1.1)), '[Number: -1.1]');
assert.strictEqual(util.inspect(new Number(13.37)), '[Number: 13.37]');

// Test boxed primitives with own properties.
{
  const str = new String('baz');
  str.foo = 'bar';
  assert.strictEqual(util.inspect(str), "[String: 'baz'] { foo: 'bar' }");

  const bool = new Boolean(true);
  bool.foo = 'bar';
  assert.strictEqual(util.inspect(bool), "[Boolean: true] { foo: 'bar' }");

  const num = new Number(13.37);
  num.foo = 'bar';
  assert.strictEqual(util.inspect(num), "[Number: 13.37] { foo: 'bar' }");

  const sym = Object(Symbol('foo'));
  sym.foo = 'bar';
  assert.strictEqual(util.inspect(sym), "[Symbol: Symbol(foo)] { foo: 'bar' }");

  const big = Object(BigInt(55));
  big.foo = 'bar';
  assert.strictEqual(util.inspect(big), "[BigInt: 55n] { foo: 'bar' }");
}

// Test es6 Symbol.
if (typeof Symbol !== 'undefined') {
  assert.strictEqual(util.inspect(Symbol()), 'Symbol()');
  assert.strictEqual(util.inspect(Symbol(123)), 'Symbol(123)');
  assert.strictEqual(util.inspect(Symbol('hi')), 'Symbol(hi)');
  assert.strictEqual(util.inspect([Symbol()]), '[ Symbol() ]');
  assert.strictEqual(util.inspect({ foo: Symbol() }), '{ foo: Symbol() }');

  const options = { showHidden: true };
  let subject = {};

  subject[Symbol('sym\nbol')] = 42;

  assert.strictEqual(util.inspect(subject), '{ [Symbol(sym\\nbol)]: 42 }');
  assert.strictEqual(
    util.inspect(subject, options),
    '{ [Symbol(sym\\nbol)]: 42 }'
  );

  Object.defineProperty(
    subject,
    Symbol(),
    { enumerable: false, value: 'non-enum' });
  assert.strictEqual(util.inspect(subject), '{ [Symbol(sym\\nbol)]: 42 }');
  assert.strictEqual(
    util.inspect(subject, options),
    "{ [Symbol(sym\\nbol)]: 42, [Symbol()]: 'non-enum' }"
  );

  subject = [1, 2, 3];
  subject[Symbol('symbol')] = 42;

  assert.strictEqual(util.inspect(subject),
                     '[ 1, 2, 3, [Symbol(symbol)]: 42 ]');
}

// Test Set.
{
  assert.strictEqual(util.inspect(new Set()), 'Set(0) {}');
  assert.strictEqual(util.inspect(new Set([1, 2, 3])), 'Set(3) { 1, 2, 3 }');
  assert.strictEqual(util.inspect(new Set([1, 2, 3]), { maxArrayLength: 1 }), 'Set(3) { 1, ... 2 more items }');
  const set = new Set(['foo']);
  set.bar = 42;
  assert.strictEqual(
    util.inspect(set, { showHidden: true }),
    "Set(1) { 'foo', bar: 42 }"
  );
}

// Test circular Set.
{
  const set = new Set();
  set.add(set);
  assert.strictEqual(util.inspect(set), '<ref *1> Set(1) { [Circular *1] }');
}

// Test Map.
{
  assert.strictEqual(util.inspect(new Map()), 'Map(0) {}');
  assert.strictEqual(util.inspect(new Map([[1, 'a'], [2, 'b'], [3, 'c']])),
                     "Map(3) { 1 => 'a', 2 => 'b', 3 => 'c' }");
  assert.strictEqual(util.inspect(new Map([[1, 'a'], [2, 'b'], [3, 'c']]), { maxArrayLength: 1 }),
                     "Map(3) { 1 => 'a', ... 2 more items }");
  const map = new Map([['foo', null]]);
  map.bar = 42;
  assert.strictEqual(util.inspect(map, true),
                     "Map(1) { 'foo' => null, bar: 42 }");
}

// Test circular Map.
{
  const map = new Map();
  map.set(map, 'map');
  assert.strictEqual(
    inspect(map),
    "<ref *1> Map(1) { [Circular *1] => 'map' }"
  );
  map.set(map, map);
  assert.strictEqual(
    inspect(map),
    '<ref *1> Map(1) { [Circular *1] => [Circular *1] }'
  );
  map.delete(map);
  map.set('map', map);
  assert.strictEqual(
    inspect(map),
    "<ref *1> Map(1) { 'map' => [Circular *1] }"
  );
}

// Test multiple circular references.
{
  const obj = {};
  obj.a = [obj];
  obj.b = {};
  obj.b.inner = obj.b;
  obj.b.obj = obj;

  assert.strictEqual(
    inspect(obj),
    '<ref *1> {\n' +
    '  a: [ [Circular *1] ],\n' +
    '  b: <ref *2> { inner: [Circular *2], obj: [Circular *1] }\n' +
    '}'
  );
}

// Test Promise.
{
  const resolved = Promise.resolve(3);
  assert.strictEqual(util.inspect(resolved), 'Promise { 3 }');

  const rejected = Promise.reject(3);
  assert.strictEqual(util.inspect(rejected), 'Promise { <rejected> 3 }');
  // Squelch UnhandledPromiseRejection.
  rejected.catch(() => {});

  const pending = new Promise(() => {});
  assert.strictEqual(util.inspect(pending), 'Promise { <pending> }');

  const promiseWithProperty = Promise.resolve('foo');
  promiseWithProperty.bar = 42;
  assert.strictEqual(util.inspect(promiseWithProperty),
                     "Promise { 'foo', bar: 42 }");
}

// Make sure it doesn't choke on polyfills. Unlike Set/Map, there is no standard
// interface to synchronously inspect a Promise, so our techniques only work on
// a bonafide native Promise.
{
  const oldPromise = Promise;
  globalThis.Promise = function() { this.bar = 42; };
  assert.strictEqual(util.inspect(new Promise()), '{ bar: 42 }');
  globalThis.Promise = oldPromise;
}

// Test Map iterators.
{
  const map = new Map([['foo', 'bar']]);
  assert.strictEqual(util.inspect(map.keys()), '[Map Iterator] { \'foo\' }');
  const mapValues = map.values();
  Object.defineProperty(mapValues, Symbol.toStringTag, { value: 'Foo' });
  assert.strictEqual(
    util.inspect(mapValues),
    '[Foo] [Map Iterator] { \'bar\' }'
  );
  map.set('A', 'B!');
  assert.strictEqual(util.inspect(map.entries(), { maxArrayLength: 1 }),
                     "[Map Entries] { [ 'foo', 'bar' ], ... 1 more item }");
  // Make sure the iterator doesn't get consumed.
  const keys = map.keys();
  assert.strictEqual(util.inspect(keys), "[Map Iterator] { 'foo', 'A' }");
  assert.strictEqual(util.inspect(keys), "[Map Iterator] { 'foo', 'A' }");
  keys.extra = true;
  assert.strictEqual(
    util.inspect(keys, { maxArrayLength: 0 }),
    '[Map Iterator] { ... 2 more items, extra: true }');
}

// Test Set iterators.
{
  const aSet = new Set([1]);
  assert.strictEqual(util.inspect(aSet.entries(), { compact: false }),
                     '[Set Entries] {\n  [\n    1,\n    1\n  ]\n}');
  aSet.add(3);
  assert.strictEqual(util.inspect(aSet.keys()), '[Set Iterator] { 1, 3 }');
  assert.strictEqual(util.inspect(aSet.values()), '[Set Iterator] { 1, 3 }');
  const setEntries = aSet.entries();
  Object.defineProperty(setEntries, Symbol.toStringTag, { value: 'Foo' });
  assert.strictEqual(util.inspect(setEntries),
                     '[Foo] [Set Entries] { [ 1, 1 ], [ 3, 3 ] }');
  // Make sure the iterator doesn't get consumed.
  const keys = aSet.keys();
  Object.defineProperty(keys, Symbol.toStringTag, { value: null });
  assert.strictEqual(util.inspect(keys), '[Set Iterator] { 1, 3 }');
  assert.strictEqual(util.inspect(keys), '[Set Iterator] { 1, 3 }');
  keys.extra = true;
  assert.strictEqual(
    util.inspect(keys, { maxArrayLength: 1 }),
    '[Set Iterator] { 1, ... 1 more item, extra: true }');
}

// Minimal inspection should still return as much information as possible about
// the constructor and Symbol.toStringTag.
{
  class Foo {
    get [Symbol.toStringTag]() {
      return 'ABC';
    }
  }
  const a = new Foo();
  assert.strictEqual(inspect(a, { depth: -1 }), 'Foo [ABC] {}');
  a.foo = true;
  assert.strictEqual(inspect(a, { depth: -1 }), '[Foo [ABC]]');
  Object.defineProperty(a, Symbol.toStringTag, {
    value: 'Foo',
    configurable: true,
    writable: true
  });
  assert.strictEqual(inspect(a, { depth: -1 }), '[Foo]');
  delete a[Symbol.toStringTag];
  Object.setPrototypeOf(a, null);
  assert.strictEqual(inspect(a, { depth: -1 }), '[Foo: null prototype]');
  delete a.foo;
  assert.strictEqual(inspect(a, { depth: -1 }), '[Foo: null prototype] {}');
  Object.defineProperty(a, Symbol.toStringTag, {
    value: 'ABC',
    configurable: true
  });
  assert.strictEqual(
    inspect(a, { depth: -1 }),
    '[Foo: null prototype] [ABC] {}'
  );
  Object.defineProperty(a, Symbol.toStringTag, {
    value: 'Foo',
    configurable: true
  });
  assert.strictEqual(
    inspect(a, { depth: -1 }),
    '[Object: null prototype] [Foo] {}'
  );
}

// Test alignment of items in container.
// Assumes that the first numeric character is the start of an item.
{
  function checkAlignment(container, start, lineX, end) {
    const lines = util.inspect(container).split('\n');
    lines.forEach((line, i) => {
      if (i === 0) {
        assert.strictEqual(line, start);
      } else if (i === lines.length - 1) {
        assert.strictEqual(line, end);
      } else {
        let expected = lineX.replace('X', i - 1);
        if (i !== lines.length - 2)
          expected += ',';
        assert.strictEqual(line, expected);
      }
    });
  }

  const bigArray = [];
  for (let i = 0; i < 100; i++) {
    bigArray.push(i);
  }

  const obj = {};
  bigArray.forEach((prop) => {
    obj[prop] = null;
  });

  checkAlignment(obj, '{', "  'X': null", '}');
  checkAlignment(new Set(bigArray), 'Set(100) {', '  X', '}');
  checkAlignment(
    new Map(bigArray.map((number) => [number, null])),
    'Map(100) {', '  X => null', '}'
  );
}


// Test display of constructors.
{
  class ObjectSubclass {}
  class ArraySubclass extends Array {}
  class SetSubclass extends Set {}
  class MapSubclass extends Map {}
  class PromiseSubclass extends Promise {}
  class SymbolNameClass {
    static name = Symbol('name');
  }

  const x = new ObjectSubclass();
  x.foo = 42;
  assert.strictEqual(util.inspect(x),
                     'ObjectSubclass { foo: 42 }');
  assert.strictEqual(util.inspect(new ArraySubclass(1, 2, 3)),
                     'ArraySubclass(3) [ 1, 2, 3 ]');
  assert.strictEqual(util.inspect(new SetSubclass([1, 2, 3])),
                     'SetSubclass(3) [Set] { 1, 2, 3 }');
  assert.strictEqual(util.inspect(new MapSubclass([['foo', 42]])),
                     "MapSubclass(1) [Map] { 'foo' => 42 }");
  assert.strictEqual(util.inspect(new PromiseSubclass(() => {})),
                     'PromiseSubclass [Promise] { <pending> }');
  assert.strictEqual(util.inspect(new SymbolNameClass()),
                     'Symbol(name) {}');
  assert.strictEqual(
    util.inspect({ a: { b: new ArraySubclass([1, [2], 3]) } }, { depth: 1 }),
    '{ a: { b: [ArraySubclass] } }'
  );
  assert.strictEqual(
    util.inspect(Object.setPrototypeOf(x, null)),
    '[ObjectSubclass: null prototype] { foo: 42 }'
  );
}

// Empty and circular before depth.
{
  const arr = [[[[]]]];
  assert.strictEqual(util.inspect(arr), '[ [ [ [] ] ] ]');
  arr[0][0][0][0] = [];
  assert.strictEqual(util.inspect(arr), '[ [ [ [Array] ] ] ]');
  arr[0][0][0] = {};
  assert.strictEqual(util.inspect(arr), '[ [ [ {} ] ] ]');
  arr[0][0][0] = { a: 2 };
  assert.strictEqual(util.inspect(arr), '[ [ [ [Object] ] ] ]');
  arr[0][0][0] = arr;
  assert.strictEqual(util.inspect(arr), '<ref *1> [ [ [ [Circular *1] ] ] ]');
  arr[0][0][0] = arr[0][0];
  assert.strictEqual(util.inspect(arr), '[ [ <ref *1> [ [Circular *1] ] ] ]');
}

// Corner cases.
{
  const x = { constructor: 42 };
  assert.strictEqual(util.inspect(x), '{ constructor: 42 }');
}

{
  const x = {};
  Object.defineProperty(x, 'constructor', {
    get: function() {
      throw new Error('should not access constructor');
    },
    enumerable: true
  });
  assert.strictEqual(util.inspect(x), '{ constructor: [Getter] }');
}

{
  const x = new function() {}; // eslint-disable-line @stylistic/js/new-parens
  assert.strictEqual(util.inspect(x), '{}');
}

{
  const x = { __proto__: null };
  assert.strictEqual(util.inspect(x), '[Object: null prototype] {}');
}

{
  const x = [];
  x[''] = 1;
  assert.strictEqual(util.inspect(x), "[ '': 1 ]");
}

// The following maxArrayLength tests were introduced after v6.0.0 was released.
// Do not backport to v5/v4 unless all of
// https://github.com/nodejs/node/pull/6334 is backported.
{
  const x = new Array(101).fill();
  assert(util.inspect(x).endsWith('1 more item\n]'));
  assert(!util.inspect(x, { maxArrayLength: 101 }).endsWith('1 more item\n]'));
  assert.strictEqual(
    util.inspect(x, { maxArrayLength: -1 }),
    '[ ... 101 more items ]'
  );
  assert.strictEqual(util.inspect(x, { maxArrayLength: 0 }),
                     '[ ... 101 more items ]');
}

{
  const x = Array(101);
  assert.strictEqual(util.inspect(x, { maxArrayLength: 0 }),
                     '[ ... 101 more items ]');
  assert(!util.inspect(x, { maxArrayLength: null }).endsWith('1 more item\n]'));
  assert(!util.inspect(
    x, { maxArrayLength: Infinity }
  ).endsWith('1 more item ]'));
}

{
  const x = new Uint8Array(101);
  assert(util.inspect(x).endsWith('1 more item\n]'));
  assert(!util.inspect(x, { maxArrayLength: 101 }).includes('1 more item'));
  assert.strictEqual(util.inspect(x, { maxArrayLength: 0 }),
                     'Uint8Array(101) [ ... 101 more items ]');
  assert(!util.inspect(x, { maxArrayLength: null }).includes('1 more item'));
  assert(util.inspect(x, { maxArrayLength: Infinity }).endsWith(' 0, 0\n]'));
}

{
  const obj = { foo: 'abc', bar: 'xyz' };
  const oneLine = util.inspect(obj, { breakLength: Infinity });
  // Subtract four for the object's two curly braces and two spaces of padding.
  // Add one more to satisfy the strictly greater than condition in the code.
  const breakpoint = oneLine.length - 5;
  const twoLines = util.inspect(obj, { breakLength: breakpoint });

  assert.strictEqual(oneLine, "{ foo: 'abc', bar: 'xyz' }");
  assert.strictEqual(
    util.inspect(obj, { breakLength: breakpoint + 1 }),
    twoLines
  );
  assert.strictEqual(twoLines, "{\n  foo: 'abc',\n  bar: 'xyz'\n}");
}

// util.inspect.defaultOptions tests.
{
  const arr = new Array(101).fill();
  const obj = { a: { a: { a: { a: 1 } } } };

  const oldOptions = { ...util.inspect.defaultOptions };

  // Set single option through property assignment.
  util.inspect.defaultOptions.maxArrayLength = null;
  assert.doesNotMatch(util.inspect(arr), /1 more item/);
  util.inspect.defaultOptions.maxArrayLength = oldOptions.maxArrayLength;
  assert.match(util.inspect(arr), /1 more item/);
  util.inspect.defaultOptions.depth = null;
  assert.doesNotMatch(util.inspect(obj), /Object/);
  util.inspect.defaultOptions.depth = oldOptions.depth;
  assert.match(util.inspect(obj), /Object/);
  assert.strictEqual(
    JSON.stringify(util.inspect.defaultOptions),
    JSON.stringify(oldOptions)
  );

  // Set multiple options through object assignment.
  util.inspect.defaultOptions = { maxArrayLength: null, depth: 2 };
  assert.doesNotMatch(util.inspect(arr), /1 more item/);
  assert.match(util.inspect(obj), /Object/);
  util.inspect.defaultOptions = oldOptions;
  assert.match(util.inspect(arr), /1 more item/);
  assert.match(util.inspect(obj), /Object/);
  assert.strictEqual(
    JSON.stringify(util.inspect.defaultOptions),
    JSON.stringify(oldOptions)
  );

  assert.throws(() => {
    util.inspect.defaultOptions = null;
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The "options" argument must be of type object. ' +
             'Received null'
  }
  );

  assert.throws(() => {
    util.inspect.defaultOptions = 'bad';
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The "options" argument must be of type object. ' +
             "Received type string ('bad')"
  }
  );
}

util.inspect(process);

// Setting custom inspect property to a non-function should do nothing.
{
  const obj = { [util.inspect.custom]: 'fhqwhgads' };
  assert.strictEqual(
    util.inspect(obj),
    "{ [Symbol(nodejs.util.inspect.custom)]: 'fhqwhgads' }"
  );
}

{
  // @@toStringTag
  const obj = { [Symbol.toStringTag]: 'a' };
  assert.strictEqual(
    util.inspect(obj),
    "{ [Symbol(Symbol.toStringTag)]: 'a' }"
  );
  Object.defineProperty(obj, Symbol.toStringTag, {
    value: 'a',
    enumerable: false
  });
  assert.strictEqual(util.inspect(obj), 'Object [a] {}');
  assert.strictEqual(
    util.inspect(obj, { showHidden: true }),
    "{ [Symbol(Symbol.toStringTag)]: 'a' }"
  );

  class Foo {
    constructor() {
      this.foo = 'bar';
    }

    get [Symbol.toStringTag]() {
      return this.foo;
    }
  }

  assert.strictEqual(util.inspect(
    Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } })),
                     '[Object: null prototype] [foo] {}');

  assert.strictEqual(util.inspect(new Foo()), "Foo [bar] { foo: 'bar' }");

  assert.strictEqual(
    util.inspect(new (class extends Foo {})()),
    "Foo [bar] { foo: 'bar' }");

  assert.strictEqual(
    util.inspect(Object.create({ __proto__: Foo.prototype }, {
      foo: { value: 'bar', enumerable: true }
    })),
    "Foo [bar] { foo: 'bar' }");

  class ThrowingClass {
    get [Symbol.toStringTag]() {
      throw new Error('toStringTag error');
    }
  }

  assert.throws(() => util.inspect(new ThrowingClass()), /toStringTag error/);

  const y = {
    get [Symbol.toStringTag]() {
      return JSON.stringify(this);
    }
  };
  const x = { y };
  y.x = x;
  assert.throws(() => util.inspect(x), /TypeError: Converting circular structure to JSON/);

  class NotStringClass {
    get [Symbol.toStringTag]() {
      return null;
    }
  }

  assert.strictEqual(util.inspect(new NotStringClass()),
                     'NotStringClass {}');
}

{
  const o = {
    a: [1, 2, [[
      'Lorem ipsum dolor\nsit amet,\tconsectetur adipiscing elit, sed do ' +
        'eiusmod tempor incididunt ut labore et dolore magna aliqua.',
      'test',
      'foo']], 4],
    b: new Map([['za', 1], ['zb', 'test']])
  };

  let out = util.inspect(o, { compact: true, depth: 5, breakLength: 80 });
  let expect = [
    '{ a:',
    '   [ 1,',
    '     2,',
    "     [ [ 'Lorem ipsum dolor\\nsit amet,\\tconsectetur adipiscing elit, " +
      "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',",
    "         'test',",
    "         'foo' ] ],",
    '     4 ],',
    "  b: Map(2) { 'za' => 1, 'zb' => 'test' } }",
  ].join('\n');
  assert.strictEqual(out, expect);

  out = util.inspect(o, { compact: false, depth: 5, breakLength: 60 });
  expect = [
    '{',
    '  a: [',
    '    1,',
    '    2,',
    '    [',
    '      [',
    "        'Lorem ipsum dolor\\n' +",
    "          'sit amet,\\tconsectetur adipiscing elit, sed do eiusmod " +
      "tempor incididunt ut labore et dolore magna aliqua.',",
    "        'test',",
    "        'foo'",
    '      ]',
    '    ],',
    '    4',
    '  ],',
    '  b: Map(2) {',
    "    'za' => 1,",
    "    'zb' => 'test'",
    '  }',
    '}',
  ].join('\n');
  assert.strictEqual(out, expect);

  out = util.inspect(o.a[2][0][0], { compact: false, breakLength: 30 });
  expect = [
    "'Lorem ipsum dolor\\n' +",
    "  'sit amet,\\tconsectetur adipiscing elit, sed do eiusmod tempor " +
      "incididunt ut labore et dolore magna aliqua.'",
  ].join('\n');
  assert.strictEqual(out, expect);

  out = util.inspect(
    '12345678901234567890123456789012345678901234567890',
    { compact: false, breakLength: 3 });
  expect = "'12345678901234567890123456789012345678901234567890'";
  assert.strictEqual(out, expect);

  out = util.inspect(
    '12 45 78 01 34 67 90 23 56 89 123456789012345678901234567890',
    { compact: false, breakLength: 3 });
  expect = [
    "'12 45 78 01 34 67 90 23 56 89 123456789012345678901234567890'",
  ].join('\n');
  assert.strictEqual(out, expect);

  o.a = () => {};
  o.b = new Number(3);
  out = util.inspect(o, { compact: false, breakLength: 3 });
  expect = [
    '{',
    '  a: [Function (anonymous)],',
    '  b: [Number: 3]',
    '}',
  ].join('\n');
  assert.strictEqual(out, expect);

  out = util.inspect(o, { compact: false, breakLength: 3, showHidden: true });
  expect = [
    '{',
    '  a: [Function (anonymous)] {',
    '    [length]: 0,',
    "    [name]: ''",
    '  },',
    '  b: [Number: 3]',
    '}',
  ].join('\n');
  assert.strictEqual(out, expect);

  o[util.inspect.custom] = () => 42;
  out = util.inspect(o, { compact: false, breakLength: 3 });
  expect = '42';
  assert.strictEqual(out, expect);

  o[util.inspect.custom] = () => '12 45 78 01 34 67 90 23';
  out = util.inspect(o, { compact: false, breakLength: 3 });
  expect = '12 45 78 01 34 67 90 23';
  assert.strictEqual(out, expect);

  o[util.inspect.custom] = () => ({ a: '12 45 78 01 34 67 90 23' });
  out = util.inspect(o, { compact: false, breakLength: 3 });
  expect = "{\n  a: '12 45 78 01 34 67 90 23'\n}";
  assert.strictEqual(out, expect);
}

// Check compact indentation.
{
  const typed = new Uint8Array();
  typed.buffer.foo = true;
  const set = new Set([[1, 2]]);
  const promise = Promise.resolve([[1, set]]);
  const map = new Map([[promise, typed]]);
  map.set(set.values(), map.values());

  let out = util.inspect(map, { compact: false, showHidden: true, depth: 9 });
  let expected = [
    'Map(2) {',
    '  Promise {',
    '    [',
    '      [',
    '        1,',
    '        Set(1) {',
    '          [',
    '            1,',
    '            2,',
    '            [length]: 2',
    '          ]',
    '        },',
    '        [length]: 2',
    '      ],',
    '      [length]: 1',
    '    ]',
    '  } => Uint8Array(0) [',
    '    [BYTES_PER_ELEMENT]: 1,',
    '    [length]: 0,',
    '    [byteLength]: 0,',
    '    [byteOffset]: 0,',
    '    [buffer]: ArrayBuffer {',
    '      byteLength: 0,',
    '      foo: true',
    '    }',
    '  ],',
    '  [Set Iterator] {',
    '    [',
    '      1,',
    '      2,',
    '      [length]: 2',
    '    ],',
    "    [Symbol(Symbol.toStringTag)]: 'Set Iterator'",
    '  } => <ref *1> [Map Iterator] {',
    '    Uint8Array(0) [',
    '      [BYTES_PER_ELEMENT]: 1,',
    '      [length]: 0,',
    '      [byteLength]: 0,',
    '      [byteOffset]: 0,',
    '      [buffer]: ArrayBuffer {',
    '        byteLength: 0,',
    '        foo: true',
    '      }',
    '    ],',
    '    [Circular *1],',
    "    [Symbol(Symbol.toStringTag)]: 'Map Iterator'",
    '  }',
    '}',
  ].join('\n');

  assert.strict.equal(out, expected);

  out = util.inspect(map, { compact: 2, showHidden: true, depth: 9 });

  expected = [
    'Map(2) {',
    '  Promise {',
    '    [',
    '      [',
    '        1,',
    '        Set(1) { [ 1, 2, [length]: 2 ] },',
    '        [length]: 2',
    '      ],',
    '      [length]: 1',
    '    ]',
    '  } => Uint8Array(0) [',
    '    [BYTES_PER_ELEMENT]: 1,',
    '    [length]: 0,',
    '    [byteLength]: 0,',
    '    [byteOffset]: 0,',
    '    [buffer]: ArrayBuffer { byteLength: 0, foo: true }',
    '  ],',
    '  [Set Iterator] {',
    '    [ 1, 2, [length]: 2 ],',
    "    [Symbol(Symbol.toStringTag)]: 'Set Iterator'",
    '  } => <ref *1> [Map Iterator] {',
    '    Uint8Array(0) [',
    '      [BYTES_PER_ELEMENT]: 1,',
    '      [length]: 0,',
    '      [byteLength]: 0,',
    '      [byteOffset]: 0,',
    '      [buffer]: ArrayBuffer { byteLength: 0, foo: true }',
    '    ],',
    '    [Circular *1],',
    "    [Symbol(Symbol.toStringTag)]: 'Map Iterator'",
    '  }',
    '}',
  ].join('\n');

  assert.strict.equal(out, expected);

  out = util.inspect(map, {
    showHidden: true, depth: 9, breakLength: 4, compact: true
  });
  expected = [
    'Map(2) {',
    '  Promise {',
    '    [ [ 1,',
    '        Set(1) {',
    '          [ 1,',
    '            2,',
    '            [length]: 2 ] },',
    '        [length]: 2 ],',
    '      [length]: 1 ] } => Uint8Array(0) [',
    '    [BYTES_PER_ELEMENT]: 1,',
    '    [length]: 0,',
    '    [byteLength]: 0,',
    '    [byteOffset]: 0,',
    '    [buffer]: ArrayBuffer {',
    '      byteLength: 0,',
    '      foo: true } ],',
    '  [Set Iterator] {',
    '    [ 1,',
    '      2,',
    '      [length]: 2 ],',
    '    [Symbol(Symbol.toStringTag)]:',
    "     'Set Iterator' } => <ref *1> [Map Iterator] {",
    '    Uint8Array(0) [',
    '      [BYTES_PER_ELEMENT]: 1,',
    '      [length]: 0,',
    '      [byteLength]: 0,',
    '      [byteOffset]: 0,',
    '      [buffer]: ArrayBuffer {',
    '        byteLength: 0,',
    '        foo: true } ],',
    '    [Circular *1],',
    '    [Symbol(Symbol.toStringTag)]:',
    "     'Map Iterator' } }",
  ].join('\n');

  assert.strict.equal(out, expected);
}

{ // Test WeakMap && WeakSet
  const obj = {};
  const arr = [];
  const weakMap = new WeakMap([[obj, arr], [arr, obj]]);
  let out = util.inspect(weakMap, { showHidden: true });
  let expect = 'WeakMap { [ [length]: 0 ] => {}, {} => [ [length]: 0 ] }';
  assert.strictEqual(out, expect);

  out = util.inspect(weakMap);
  expect = 'WeakMap { <items unknown> }';
  assert.strictEqual(out, expect);

  out = util.inspect(weakMap, { maxArrayLength: 0, showHidden: true });
  expect = 'WeakMap { ... 2 more items }';
  assert.strictEqual(out, expect);

  weakMap.extra = true;
  out = util.inspect(weakMap, { maxArrayLength: 1, showHidden: true });
  // It is not possible to determine the output reliable.
  expect = 'WeakMap { [ [length]: 0 ] => {}, ... 1 more item, extra: true }';
  let expectAlt = 'WeakMap { {} => [ [length]: 0 ], ... 1 more item, ' +
                  'extra: true }';
  assert(out === expect || out === expectAlt,
         `Found: "${out}"\nrather than: "${expect}"\nor: "${expectAlt}"`);

  // Test WeakSet
  arr.push(1);
  const weakSet = new WeakSet([obj, arr]);
  out = util.inspect(weakSet, { showHidden: true });
  expect = 'WeakSet { [ 1, [length]: 1 ], {} }';
  assert.strictEqual(out, expect);

  out = util.inspect(weakSet);
  expect = 'WeakSet { <items unknown> }';
  assert.strictEqual(out, expect);

  out = util.inspect(weakSet, { maxArrayLength: -2, showHidden: true });
  expect = 'WeakSet { ... 2 more items }';
  assert.strictEqual(out, expect);

  weakSet.extra = true;
  out = util.inspect(weakSet, { maxArrayLength: 1, showHidden: true });
  // It is not possible to determine the output reliable.
  expect = 'WeakSet { {}, ... 1 more item, extra: true }';
  expectAlt = 'WeakSet { [ 1, [length]: 1 ], ... 1 more item, extra: true }';
  assert(out === expect || out === expectAlt,
         `Found: "${out}"\nrather than: "${expect}"\nor: "${expectAlt}"`);
  // Keep references to the WeakMap entries, otherwise they could be GCed too
  // early.
  assert(obj && arr);
}

{ // Test argument objects.
  const args = (function() { return arguments; })('a');
  assert.strictEqual(util.inspect(args), "[Arguments] { '0': 'a' }");
}

{
  // Test that a long linked list can be inspected without throwing an error.
  const list = {};
  let head = list;
  // A linked list of length 100k should be inspectable in some way, even though
  // the real cutoff value is much lower than 100k.
  for (let i = 0; i < 100000; i++)
    head = head.next = {};
  assert.strictEqual(
    util.inspect(list),
    '{ next: { next: { next: [Object] } } }'
  );
  const longList = util.inspect(list, { depth: Infinity });
  const match = longList.match(/next/g);
  assert(match.length > 500 && match.length < 10000);
  assert(longList.includes('[Object: Inspection interrupted ' +
    'prematurely. Maximum call stack size exceeded.]'));
}

// Do not escape single quotes if no double quote or backtick is present.
assert.strictEqual(util.inspect("'"), '"\'"');
assert.strictEqual(util.inspect('"\''), '`"\'`');
// eslint-disable-next-line no-template-curly-in-string
assert.strictEqual(util.inspect('"\'${a}'), "'\"\\'${a}'");

// Errors should visualize as much information as possible.
// If the name is not included in the stack, visualize it as well.
[
  [class Foo extends TypeError {}, 'test'],
  [class Foo extends TypeError {}, undefined],
  [class BarError extends Error {}, 'test'],
  [class BazError extends Error {
    get name() {
      return 'BazError';
    }
  }, undefined],
].forEach(([Class, message], i) => {
  console.log('Test %i', i);
  const foo = new Class(message);
  const name = foo.name;
  const extra = Class.name.includes('Error') ? '' : ` [${foo.name}]`;
  assert(
    util.inspect(foo).startsWith(
      `${Class.name}${extra}${message ? `: ${message}` : '\n'}`),
    util.inspect(foo)
  );
  Object.defineProperty(foo, Symbol.toStringTag, {
    value: 'WOW',
    writable: true,
    configurable: true
  });
  const stack = foo.stack;
  foo.stack = 'This is a stack';
  assert.strictEqual(
    util.inspect(foo),
    '[This is a stack]'
  );
  foo.stack = stack;
  assert(
    util.inspect(foo).startsWith(
      `${Class.name} [WOW]${extra}${message ? `: ${message}` : '\n'}`),
    util.inspect(foo)
  );
  Object.setPrototypeOf(foo, null);
  assert(
    util.inspect(foo).startsWith(
      `[${name}: null prototype] [WOW]${message ? `: ${message}` : '\n'}`
    ),
    util.inspect(foo)
  );
  foo.bar = true;
  delete foo[Symbol.toStringTag];
  assert(
    util.inspect(foo).startsWith(
      `[${name}: null prototype]${message ? `: ${message}` : '\n'}`),
    util.inspect(foo)
  );
  foo.stack = 'This is a stack';
  assert.strictEqual(
    util.inspect(foo),
    '[[Error: null prototype]: This is a stack] { bar: true }'
  );
  foo.stack = stack.split('\n')[0];
  assert.strictEqual(
    util.inspect(foo),
    `[[${name}: null prototype]${message ? `: ${message}` : ''}] { bar: true }`
  );
});

// Verify that classes are properly inspected.
[
  /* eslint-disable @stylistic/js/spaced-comment, @stylistic/js/no-multi-spaces, @stylistic/js/brace-style */
  // The whitespace is intentional.
  [class   { }, '[class (anonymous)]'],
  [class extends Error { log() {} }, '[class (anonymous) extends Error]'],
  [class A { constructor(a) { this.a = a; } log() { return this.a; } },
   '[class A]'],
  [class
  // Random { // comments /* */ are part of the toString() result
  /* eslint-disable-next-line @stylistic/js/space-before-blocks */
  äß/**/extends/*{*/TypeError{}, '[class äß extends TypeError]'],
  /* The whitespace and new line is intended! */
  // Foobar !!!
  [class X   extends /****/ Error
  // More comments
  {}, '[class X extends Error]'],
  /* eslint-enable @stylistic/js/spaced-comment, @stylistic/js/no-multi-spaces, @stylistic/js/brace-style */
].forEach(([clazz, string]) => {
  const inspected = util.inspect(clazz);
  assert.strictEqual(inspected, string);
  Object.defineProperty(clazz, Symbol.toStringTag, {
    value: 'Woohoo'
  });
  const parts = inspected.slice(0, -1).split(' ');
  const [, name, ...rest] = parts;
  rest.unshift('[Woohoo]');
  if (rest.length) {
    rest[rest.length - 1] += ']';
  }
  assert.strictEqual(
    util.inspect(clazz),
    ['[class', name, ...rest].join(' ')
  );
  if (rest.length) {
    rest[rest.length - 1] = rest[rest.length - 1].slice(0, -1);
    rest.length = 1;
  }
  Object.setPrototypeOf(clazz, Map.prototype);
  assert.strictEqual(
    util.inspect(clazz),
    ['[class', name, '[Map]', ...rest].join(' ') + ']'
  );
  Object.setPrototypeOf(clazz, null);
  assert.strictEqual(
    util.inspect(clazz),
    ['[class', name, ...rest, 'extends [null prototype]]'].join(' ')
  );
  Object.defineProperty(clazz, 'name', { value: 'Foo' });
  const res = ['[class', 'Foo', ...rest, 'extends [null prototype]]'].join(' ');
  assert.strictEqual(util.inspect(clazz), res);
  clazz.foo = true;
  assert.strictEqual(util.inspect(clazz), `${res} { foo: true }`);
});

// "class" properties should not be detected as "class".
{
  // eslint-disable-next-line @stylistic/js/space-before-function-paren
  let obj = { class () {} };
  assert.strictEqual(
    util.inspect(obj),
    '{ class: [Function: class] }'
  );
  obj = { class: () => {} };
  assert.strictEqual(
    util.inspect(obj),
    '{ class: [Function: class] }'
  );
  obj = { ['class Foo {}']() {} };
  assert.strictEqual(
    util.inspect(obj),
    "{ 'class Foo {}': [Function: class Foo {}] }"
  );
  function Foo() {}
  Object.defineProperty(Foo, 'toString', { value: () => 'class Foo {}' });
  assert.strictEqual(
    util.inspect(Foo),
    '[Function: Foo]'
  );
  function fn() {}
  Object.defineProperty(fn, 'name', { value: 'class Foo {}' });
  assert.strictEqual(
    util.inspect(fn),
    '[Function: class Foo {}]'
  );
}

// Verify that throwing in valueOf and toString still produces nice results.
[
  [new String(55), "[String: '55']"],
  [new Boolean(true), '[Boolean: true]'],
  [new Number(55), '[Number: 55]'],
  [Object(BigInt(55)), '[BigInt: 55n]'],
  [Object(Symbol('foo')), '[Symbol: Symbol(foo)]'],
  [function() {}, '[Function (anonymous)]'],
  [() => {}, '[Function (anonymous)]'],
  [[1, 2], '[ 1, 2 ]'],
  // eslint-disable-next-line no-sparse-arrays
  [[, , 5, , , , ], '[ <2 empty items>, 5, <3 empty items> ]'],
  [{ a: 5 }, '{ a: 5 }'],
  [new Set([1, 2]), 'Set(2) { 1, 2 }'],
  [new Map([[1, 2]]), 'Map(1) { 1 => 2 }'],
  [new Set([1, 2]).entries(), '[Set Entries] { [ 1, 1 ], [ 2, 2 ] }'],
  [new Map([[1, 2]]).keys(), '[Map Iterator] { 1 }'],
  [new Date(2000), '1970-01-01T00:00:02.000Z'],
  [new Uint8Array(2), 'Uint8Array(2) [ 0, 0 ]'],
  [new Promise((resolve) => setTimeout(resolve, 10)), 'Promise { <pending> }'],
  [new WeakSet(), 'WeakSet { <items unknown> }'],
  [new WeakMap(), 'WeakMap { <items unknown> }'],
  [/foobar/g, '/foobar/g'],
].forEach(([value, expected]) => {
  Object.defineProperty(value, 'valueOf', {
    get() {
      throw new Error('valueOf');
    }
  });
  Object.defineProperty(value, 'toString', {
    get() {
      throw new Error('toString');
    }
  });
  assert.strictEqual(util.inspect(value), expected);
  value.foo = 'bar';
  assert.notStrictEqual(util.inspect(value), expected);
  delete value.foo;
  value[Symbol('foo')] = 'yeah';
  assert.notStrictEqual(util.inspect(value), expected);
});

// Verify that having no prototype still produces nice results.
[
  [[1, 3, 4], '[Array(3): null prototype] [ 1, 3, 4 ]'],
  [new Set([1, 2]), '[Set(2): null prototype] { 1, 2 }'],
  [new Map([[1, 2]]), '[Map(1): null prototype] { 1 => 2 }'],
  [new Promise((resolve) => setTimeout(resolve, 10)),
   '[Promise: null prototype] { <pending> }'],
  [new WeakSet(), '[WeakSet: null prototype] { <items unknown> }'],
  [new WeakMap(), '[WeakMap: null prototype] { <items unknown> }'],
  [new Uint8Array(2), '[Uint8Array(2): null prototype] [ 0, 0 ]'],
  [new Uint16Array(2), '[Uint16Array(2): null prototype] [ 0, 0 ]'],
  [new Uint32Array(2), '[Uint32Array(2): null prototype] [ 0, 0 ]'],
  [new Int8Array(2), '[Int8Array(2): null prototype] [ 0, 0 ]'],
  [new Int16Array(2), '[Int16Array(2): null prototype] [ 0, 0 ]'],
  [new Int32Array(2), '[Int32Array(2): null prototype] [ 0, 0 ]'],
  [new Float32Array(2), '[Float32Array(2): null prototype] [ 0, 0 ]'],
  [new Float64Array(2), '[Float64Array(2): null prototype] [ 0, 0 ]'],
  [new BigInt64Array(2), '[BigInt64Array(2): null prototype] [ 0n, 0n ]'],
  [new BigUint64Array(2), '[BigUint64Array(2): null prototype] [ 0n, 0n ]'],
  [new ArrayBuffer(16), '[ArrayBuffer: null prototype] {\n' +
     '  [Uint8Contents]: <00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00>,\n' +
     '  byteLength: undefined\n}'],
  [new DataView(new ArrayBuffer(16)),
   '[DataView: null prototype] {\n  byteLength: undefined,\n  ' +
     'byteOffset: undefined,\n  buffer: undefined\n}'],
  [new SharedArrayBuffer(2), '[SharedArrayBuffer: null prototype] ' +
     '{\n  [Uint8Contents]: <00 00>,\n  byteLength: undefined\n}'],
  [/foobar/, '[RegExp: null prototype] /foobar/'],
  [new Date('Sun, 14 Feb 2010 11:48:40 GMT'),
   '[Date: null prototype] 2010-02-14T11:48:40.000Z'],
].forEach(([value, expected]) => {
  assert.strictEqual(
    util.inspect(Object.setPrototypeOf(value, null)),
    expected
  );
  value.foo = 'bar';
  assert.notStrictEqual(util.inspect(value), expected);
  delete value.foo;
  value[Symbol('foo')] = 'yeah';
  assert.notStrictEqual(util.inspect(value), expected);
});

// Verify that subclasses with and without prototype produce nice results.
[
  [RegExp, ['foobar', 'g'], '/foobar/g'],
  [WeakSet, [[{}]], '{ <items unknown> }'],
  [WeakMap, [[[{}, {}]]], '{ <items unknown> }'],
  [BigInt64Array,
   [10],
   '[\n  0n, 0n, 0n, 0n, 0n,\n  0n, 0n, 0n, 0n, 0n\n]'],
  [Date, ['Sun, 14 Feb 2010 11:48:40 GMT'], '2010-02-14T11:48:40.000Z'],
  [Date, ['invalid_date'], 'Invalid Date'],
].forEach(([base, input, rawExpected]) => {
  class Foo extends base {}
  const value = new Foo(...input);
  const symbol = value[Symbol.toStringTag];
  const size = base.name.includes('Array') ? `(${input[0]})` : '';
  const expected = `Foo${size} ${symbol ? `[${symbol}] ` : ''}${rawExpected}`;
  const expectedWithoutProto =
    `[${base.name}${size}: null prototype] ${rawExpected}`;
  assert.strictEqual(util.inspect(value), expected);
  value.foo = 'bar';
  assert.notStrictEqual(util.inspect(value), expected);
  delete value.foo;
  assert.strictEqual(
    util.inspect(Object.setPrototypeOf(value, null)),
    expectedWithoutProto
  );
  value.foo = 'bar';
  let res = util.inspect(value);
  assert.notStrictEqual(res, expectedWithoutProto);
  assert.match(res, /foo: 'bar'/);
  delete value.foo;
  value[Symbol('foo')] = 'yeah';
  res = util.inspect(value);
  assert.notStrictEqual(res, expectedWithoutProto);
  assert.match(res, /\[Symbol\(foo\)]: 'yeah'/);
});

assert.strictEqual(inspect(1n), '1n');
assert.strictEqual(inspect(Object(-1n)), '[BigInt: -1n]');
assert.strictEqual(inspect(Object(13n)), '[BigInt: 13n]');
assert.strictEqual(inspect(new BigInt64Array([0n])), 'BigInt64Array(1) [ 0n ]');
assert.strictEqual(
  inspect(new BigUint64Array([0n])), 'BigUint64Array(1) [ 0n ]');

// Verify non-enumerable keys get escaped.
{
  const obj = {};
  Object.defineProperty(obj, 'Non\nenumerable\tkey', { value: true });
  assert.strictEqual(
    util.inspect(obj, { showHidden: true }),
    '{ [Non\\nenumerable\\tkey]: true }'
  );
}

// Check for special colors.
{
  const special = inspect.colors[inspect.styles.special];
  const string = inspect.colors[inspect.styles.string];

  assert.strictEqual(
    inspect(new WeakSet(), { colors: true }),
    `WeakSet { \u001b[${special[0]}m<items unknown>\u001b[${special[1]}m }`
  );
  assert.strictEqual(
    inspect(new WeakMap(), { colors: true }),
    `WeakMap { \u001b[${special[0]}m<items unknown>\u001b[${special[1]}m }`
  );
  assert.strictEqual(
    inspect(new Promise(() => {}), { colors: true }),
    `Promise { \u001b[${special[0]}m<pending>\u001b[${special[1]}m }`
  );

  const rejection = Promise.reject('Oh no!');
  assert.strictEqual(
    inspect(rejection, { colors: true }),
    `Promise { \u001b[${special[0]}m<rejected>\u001b[${special[1]}m ` +
    `\u001b[${string[0]}m'Oh no!'\u001b[${string[1]}m }`
  );
  rejection.catch(() => {});

  // Verify that aliases do not show up as key while checking `inspect.colors`.
  const colors = Object.keys(inspect.colors);
  const aliases = Object.getOwnPropertyNames(inspect.colors)
                  .filter((c) => !colors.includes(c));
  assert(!colors.includes('grey'));
  assert(colors.includes('gray'));
  // Verify that all aliases are correctly mapped.
  for (const alias of aliases) {
    assert(Array.isArray(inspect.colors[alias]));
  }
  // Check consistent naming.
  [
    'black',
    'red',
    'green',
    'yellow',
    'blue',
    'magenta',
    'cyan',
    'white',
  ].forEach((color, i) => {
    assert.deepStrictEqual(inspect.colors[color], [30 + i, 39]);
    assert.deepStrictEqual(inspect.colors[`${color}Bright`], [90 + i, 39]);
    const bgColor = `bg${color[0].toUpperCase()}${color.slice(1)}`;
    assert.deepStrictEqual(inspect.colors[bgColor], [40 + i, 49]);
    assert.deepStrictEqual(inspect.colors[`${bgColor}Bright`], [100 + i, 49]);
  });

  // Unknown colors are handled gracefully:
  const stringStyle = inspect.styles.string;
  inspect.styles.string = 'UNKNOWN';
  assert.strictEqual(inspect('foobar', { colors: true }), "'foobar'");
  inspect.styles.string = stringStyle;
}

assert.strictEqual(
  inspect([1, 3, 2], { sorted: true }),
  inspect([1, 3, 2])
);
assert.strictEqual(
  inspect({ c: 3, a: 1, b: 2 }, { sorted: true }),
  '{ a: 1, b: 2, c: 3 }'
);
assert.strictEqual(
  inspect(
    { a200: 4, a100: 1, a102: 3, a101: 2 },
    { sorted(a, b) { return b.localeCompare(a); } }
  ),
  '{ a200: 4, a102: 3, a101: 2, a100: 1 }'
);

// Non-indices array properties are sorted as well.
{
  const arr = [3, 2, 1];
  arr.b = 2;
  arr.c = 3;
  arr.a = 1;
  arr[Symbol('b')] = true;
  arr[Symbol('a')] = false;
  assert.strictEqual(
    inspect(arr, { sorted: true }),
    '[ 3, 2, 1, [Symbol(a)]: false, [Symbol(b)]: true, a: 1, b: 2, c: 3 ]'
  );
}

// Manipulate the prototype in weird ways.
{
  let obj = { a: true };
  let value = (function() { return function() {}; })();
  Object.setPrototypeOf(value, null);
  Object.setPrototypeOf(obj, value);
  assert.strictEqual(
    util.inspect(obj),
    'Object <[Function (null prototype) (anonymous)]> { a: true }'
  );
  assert.strictEqual(
    util.inspect(obj, { colors: true }),
    'Object <\u001b[36m[Function (null prototype) (anonymous)]\u001b[39m> ' +
      '{ a: \u001b[33mtrue\u001b[39m }'
  );

  obj = { a: true };
  value = [];
  Object.setPrototypeOf(value, null);
  Object.setPrototypeOf(obj, value);
  assert.strictEqual(
    util.inspect(obj),
    'Object <[Array(0): null prototype] []> { a: true }'
  );

  function StorageObject() {}
  StorageObject.prototype = { __proto__: null };
  assert.strictEqual(
    util.inspect(new StorageObject()),
    'StorageObject <[Object: null prototype] {}> {}'
  );

  obj = [1, 2, 3];
  Object.setPrototypeOf(obj, Number.prototype);
  assert.strictEqual(inspect(obj), "Number { '0': 1, '1': 2, '2': 3 }");

  Object.setPrototypeOf(obj, { __proto__: null });
  assert.strictEqual(
    inspect(obj),
    "Array <[Object: null prototype] {}> { '0': 1, '1': 2, '2': 3 }"
  );

  StorageObject.prototype = { __proto__: null };
  Object.setPrototypeOf(StorageObject.prototype, { __proto__: null });
  Object.setPrototypeOf(
    Object.getPrototypeOf(StorageObject.prototype),
    { __proto__: null }
  );
  assert.strictEqual(
    util.inspect(new StorageObject()),
    'StorageObject <Object <Object <[Object: null prototype] {}>>> {}'
  );
  assert.strictEqual(
    util.inspect(new StorageObject(), { depth: 1 }),
    'StorageObject <Object <Object <Complex prototype>>> {}'
  );
}

// Check that the fallback always works.
{
  const obj = new Set([1, 2]);
  const iterator = obj[Symbol.iterator];
  Object.setPrototypeOf(obj, null);
  Object.defineProperty(obj, Symbol.iterator, {
    value: iterator,
    configurable: true
  });
  assert.strictEqual(util.inspect(obj), '[Set(2): null prototype] { 1, 2 }');
  Object.defineProperty(obj, Symbol.iterator, {
    value: true,
    configurable: true
  });
  Object.defineProperty(obj, 'size', {
    value: NaN,
    configurable: true,
    enumerable: true
  });
  assert.strictEqual(
    util.inspect(obj),
    '[Set(2): null prototype] { 1, 2, size: NaN }'
  );
}

// Check the getter option.
{
  let foo = 1;
  const get = { get foo() { return foo; } };
  const getset = {
    get foo() { return foo; },
    set foo(val) { foo = val; },
    get inc() { return ++foo; }
  };
  const thrower = { get foo() { throw new Error('Oops'); } };
  assert.strictEqual(
    inspect(get, { getters: true, colors: true }),
    '{ foo: \u001b[36m[Getter:\u001b[39m ' +
      '\u001b[33m1\u001b[39m\u001b[36m]\u001b[39m }');
  assert.strictEqual(
    inspect(thrower, { getters: true }),
    '{ foo: [Getter: <Inspection threw (Oops)>] }');
  assert.strictEqual(
    inspect(getset, { getters: true }),
    '{ foo: [Getter/Setter: 1], inc: [Getter: 2] }');
  assert.strictEqual(
    inspect(getset, { getters: 'get' }),
    '{ foo: [Getter/Setter], inc: [Getter: 3] }');
  assert.strictEqual(
    inspect(getset, { getters: 'set' }),
    '{ foo: [Getter/Setter: 3], inc: [Getter] }');
  getset.foo = new Set([[{ a: true }, 2, {}], 'foobar', { x: 1 }]);
  assert.strictEqual(
    inspect(getset, { getters: true }),
    '{\n  foo: [Getter/Setter] Set(3) { [ [Object], 2, {} ], ' +
      "'foobar', { x: 1 } },\n  inc: [Getter: NaN]\n}");
}

// Check compact number mode.
{
  let obj = {
    a: {
      b: {
        x: 5,
        c: {
          x: '10000000000000000 00000000000000000 '.repeat(1e1),
          d: 2,
          e: 3
        }
      }
    },
    b: [
      1,
      2,
      [ 1, 2, { a: 1, b: 2, c: 3 } ],
    ],
    c: ['foo', 4, 444444],
    d: Array.from({ length: 101 }).map((e, i) => {
      return i % 2 === 0 ? i * i : i;
    }),
    e: Array(6).fill('foobar'),
    f: Array(9).fill('foobar'),
    g: Array(21).fill('foobar baz'),
    h: [100].concat(Array.from({ length: 9 }).map((e, n) => (n))),
    long: Array(9).fill('This text is too long for grouping!')
  };

  let out = util.inspect(obj, { compact: 3, depth: 10, breakLength: 60 });
  let expected = [
    '{',
    '  a: {',
    '    b: {',
    '      x: 5,',
    '      c: {',
    "        x: '10000000000000000 00000000000000000 10000000000000000 " +
      '00000000000000000 10000000000000000 00000000000000000 ' +
      '10000000000000000 00000000000000000 10000000000000000 ' +
      '00000000000000000 10000000000000000 00000000000000000 ' +
      '10000000000000000 00000000000000000 10000000000000000 ' +
      '00000000000000000 10000000000000000 00000000000000000 ' +
      "10000000000000000 00000000000000000 ',",
    '        d: 2,',
    '        e: 3',
    '      }',
    '    }',
    '  },',
    '  b: [ 1, 2, [ 1, 2, { a: 1, b: 2, c: 3 } ] ],',
    "  c: [ 'foo', 4, 444444 ],",
    '  d: [',
    '       0,    1,    4,    3,   16,    5,   36,    7,   64,',
    '       9,  100,   11,  144,   13,  196,   15,  256,   17,',
    '     324,   19,  400,   21,  484,   23,  576,   25,  676,',
    '      27,  784,   29,  900,   31, 1024,   33, 1156,   35,',
    '    1296,   37, 1444,   39, 1600,   41, 1764,   43, 1936,',
    '      45, 2116,   47, 2304,   49, 2500,   51, 2704,   53,',
    '    2916,   55, 3136,   57, 3364,   59, 3600,   61, 3844,',
    '      63, 4096,   65, 4356,   67, 4624,   69, 4900,   71,',
    '    5184,   73, 5476,   75, 5776,   77, 6084,   79, 6400,',
    '      81, 6724,   83, 7056,   85, 7396,   87, 7744,   89,',
    '    8100,   91, 8464,   93, 8836,   95, 9216,   97, 9604,',
    '      99,',
    '    ... 1 more item',
    '  ],',
    '  e: [',
    "    'foobar',",
    "    'foobar',",
    "    'foobar',",
    "    'foobar',",
    "    'foobar',",
    "    'foobar'",
    '  ],',
    '  f: [',
    "    'foobar', 'foobar',",
    "    'foobar', 'foobar',",
    "    'foobar', 'foobar',",
    "    'foobar', 'foobar',",
    "    'foobar'",
    '  ],',
    '  g: [',
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz', 'foobar baz',",
    "    'foobar baz'",
    '  ],',
    '  h: [',
    '    100, 0, 1, 2, 3,',
    '      4, 5, 6, 7, 8',
    '  ],',
    '  long: [',
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!',",
    "    'This text is too long for grouping!'",
    '  ]',
    '}',
  ].join('\n');

  assert.strictEqual(out, expected);

  obj = [
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 123456789,
  ];

  out = util.inspect(obj, { compact: 3 });

  expected = [
    '[',
    '  1, 1,         1, 1,',
    '  1, 1,         1, 1,',
    '  1, 1,         1, 1,',
    '  1, 1,         1, 1,',
    '  1, 1,         1, 1,',
    '  1, 1,         1, 1,',
    '  1, 1, 123456789',
    ']',
  ].join('\n');

  assert.strictEqual(out, expected);

  // Unicode support. あ has a length of one and a width of two.
  obj = [
    '123', '123', '123', '123', 'あああ',
    '123', '123', '123', '123', 'あああ',
  ];

  out = util.inspect(obj, { compact: 3 });

  expected = [
    '[',
    "  '123',    '123',",
    "  '123',    '123',",
    "  'あああ', '123',",
    "  '123',    '123',",
    "  '123',    'あああ'",
    ']',
  ].join('\n');

  assert.strictEqual(out, expected);

  // Array grouping should prevent lining up outer elements on a single line.
  obj = [[[1, 2, 3, 4, 5, 6, 7, 8, 9]]];

  out = util.inspect(obj, { compact: 3 });

  expected = [
    '[',
    '  [',
    '    [',
    '      1, 2, 3, 4, 5,',
    '      6, 7, 8, 9',
    '    ]',
    '  ]',
    ']',
  ].join('\n');

  assert.strictEqual(out, expected);

  // Verify that array grouping and line consolidation does not happen together.
  obj = {
    a: {
      b: {
        x: 5,
        c: {
          d: 2,
          e: 3
        }
      }
    },
    b: Array.from({ length: 9 }).map((e, n) => {
      return n % 2 === 0 ? 'foobar' : 'baz';
    })
  };

  out = util.inspect(obj, { compact: 1, breakLength: Infinity, colors: true });

  expected = [
    '{',
    '  a: {',
    '    b: { x: \u001b[33m5\u001b[39m, c: \u001b[36m[Object]\u001b[39m }',
    '  },',
    '  b: [',
    "    \u001b[32m'foobar'\u001b[39m, \u001b[32m'baz'\u001b[39m,",
    "    \u001b[32m'foobar'\u001b[39m, \u001b[32m'baz'\u001b[39m,",
    "    \u001b[32m'foobar'\u001b[39m, \u001b[32m'baz'\u001b[39m,",
    "    \u001b[32m'foobar'\u001b[39m, \u001b[32m'baz'\u001b[39m,",
    "    \u001b[32m'foobar'\u001b[39m",
    '  ]',
    '}',
  ].join('\n');

  assert.strictEqual(out, expected);

  obj = Array.from({ length: 60 }).map((e, i) => i);
  out = util.inspect(obj, { compact: 1, breakLength: Infinity, colors: true });

  expected = [
    '[',
    '   \u001b[33m0\u001b[39m,  \u001b[33m1\u001b[39m,  \u001b[33m2\u001b[39m,  \u001b[33m3\u001b[39m,',
    '   \u001b[33m4\u001b[39m,  \u001b[33m5\u001b[39m,  \u001b[33m6\u001b[39m,  \u001b[33m7\u001b[39m,',
    '   \u001b[33m8\u001b[39m,  \u001b[33m9\u001b[39m, \u001b[33m10\u001b[39m, \u001b[33m11\u001b[39m,',
    '  \u001b[33m12\u001b[39m, \u001b[33m13\u001b[39m, \u001b[33m14\u001b[39m, \u001b[33m15\u001b[39m,',
    '  \u001b[33m16\u001b[39m, \u001b[33m17\u001b[39m, \u001b[33m18\u001b[39m, \u001b[33m19\u001b[39m,',
    '  \u001b[33m20\u001b[39m, \u001b[33m21\u001b[39m, \u001b[33m22\u001b[39m, \u001b[33m23\u001b[39m,',
    '  \u001b[33m24\u001b[39m, \u001b[33m25\u001b[39m, \u001b[33m26\u001b[39m, \u001b[33m27\u001b[39m,',
    '  \u001b[33m28\u001b[39m, \u001b[33m29\u001b[39m, \u001b[33m30\u001b[39m, \u001b[33m31\u001b[39m,',
    '  \u001b[33m32\u001b[39m, \u001b[33m33\u001b[39m, \u001b[33m34\u001b[39m, \u001b[33m35\u001b[39m,',
    '  \u001b[33m36\u001b[39m, \u001b[33m37\u001b[39m, \u001b[33m38\u001b[39m, \u001b[33m39\u001b[39m,',
    '  \u001b[33m40\u001b[39m, \u001b[33m41\u001b[39m, \u001b[33m42\u001b[39m, \u001b[33m43\u001b[39m,',
    '  \u001b[33m44\u001b[39m, \u001b[33m45\u001b[39m, \u001b[33m46\u001b[39m, \u001b[33m47\u001b[39m,',
    '  \u001b[33m48\u001b[39m, \u001b[33m49\u001b[39m, \u001b[33m50\u001b[39m, \u001b[33m51\u001b[39m,',
    '  \u001b[33m52\u001b[39m, \u001b[33m53\u001b[39m, \u001b[33m54\u001b[39m, \u001b[33m55\u001b[39m,',
    '  \u001b[33m56\u001b[39m, \u001b[33m57\u001b[39m, \u001b[33m58\u001b[39m, \u001b[33m59\u001b[39m',
    ']',
  ].join('\n');

  assert.strictEqual(out, expected);

  out = util.inspect([1, 2, 3, 4], { compact: 1, colors: true });
  expected = '[ \u001b[33m1\u001b[39m, \u001b[33m2\u001b[39m, ' +
    '\u001b[33m3\u001b[39m, \u001b[33m4\u001b[39m ]';

  assert.strictEqual(out, expected);

  obj = [
    'Object', 'Function', 'Array',
    'Number', 'parseFloat', 'parseInt',
    'Infinity', 'NaN', 'undefined',
    'Boolean', 'String', 'Symbol',
    'Date', 'Promise', 'RegExp',
    'Error', 'EvalError', 'RangeError',
    'ReferenceError', 'SyntaxError', 'TypeError',
    'URIError', 'JSON', 'Math',
    'console', 'Intl', 'ArrayBuffer',
    'Uint8Array', 'Int8Array', 'Uint16Array',
    'Int16Array', 'Uint32Array', 'Int32Array',
    'Float32Array', 'Float64Array', 'Uint8ClampedArray',
    'BigUint64Array', 'BigInt64Array', 'DataView',
    'Map', 'BigInt', 'Set',
    'WeakMap', 'WeakSet', 'Proxy',
    'Reflect', 'decodeURI', 'decodeURIComponent',
    'encodeURI', 'encodeURIComponent', 'escape',
    'unescape', 'eval', 'isFinite',
    'isNaN', 'SharedArrayBuffer', 'Atomics',
    'globalThis', 'WebAssembly', 'global',
    'process', 'Buffer', 'URL',
    'URLSearchParams', 'TextEncoder', 'TextDecoder',
    'clearInterval', 'clearTimeout', 'setInterval',
    'setTimeout', 'queueMicrotask', 'clearImmediate',
    'setImmediate', 'module', 'require',
    'assert', 'async_hooks', 'buffer',
    'child_process', 'cluster', 'crypto',
    'dgram', 'dns', 'domain',
    'events', 'fs', 'http',
    'http2', 'https', 'inspector',
    'net', 'os', 'path',
    'perf_hooks', 'punycode', 'querystring',
    'readline', 'repl', 'stream',
    'string_decoder', 'tls', 'trace_events',
    'tty', 'url', 'v8',
    'vm', 'worker_threads', 'zlib',
    '_', '_error', 'util',
  ];

  out = util.inspect(
    obj,
    { compact: 3, breakLength: 80, maxArrayLength: 250 }
  );
  expected = [
    '[',
    "  'Object',          'Function',           'Array',",
    "  'Number',          'parseFloat',         'parseInt',",
    "  'Infinity',        'NaN',                'undefined',",
    "  'Boolean',         'String',             'Symbol',",
    "  'Date',            'Promise',            'RegExp',",
    "  'Error',           'EvalError',          'RangeError',",
    "  'ReferenceError',  'SyntaxError',        'TypeError',",
    "  'URIError',        'JSON',               'Math',",
    "  'console',         'Intl',               'ArrayBuffer',",
    "  'Uint8Array',      'Int8Array',          'Uint16Array',",
    "  'Int16Array',      'Uint32Array',        'Int32Array',",
    "  'Float32Array',    'Float64Array',       'Uint8ClampedArray',",
    "  'BigUint64Array',  'BigInt64Array',      'DataView',",
    "  'Map',             'BigInt',             'Set',",
    "  'WeakMap',         'WeakSet',            'Proxy',",
    "  'Reflect',         'decodeURI',          'decodeURIComponent',",
    "  'encodeURI',       'encodeURIComponent', 'escape',",
    "  'unescape',        'eval',               'isFinite',",
    "  'isNaN',           'SharedArrayBuffer',  'Atomics',",
    "  'globalThis',      'WebAssembly',        'global',",
    "  'process',         'Buffer',             'URL',",
    "  'URLSearchParams', 'TextEncoder',        'TextDecoder',",
    "  'clearInterval',   'clearTimeout',       'setInterval',",
    "  'setTimeout',      'queueMicrotask',     'clearImmediate',",
    "  'setImmediate',    'module',             'require',",
    "  'assert',          'async_hooks',        'buffer',",
    "  'child_process',   'cluster',            'crypto',",
    "  'dgram',           'dns',                'domain',",
    "  'events',          'fs',                 'http',",
    "  'http2',           'https',              'inspector',",
    "  'net',             'os',                 'path',",
    "  'perf_hooks',      'punycode',           'querystring',",
    "  'readline',        'repl',               'stream',",
    "  'string_decoder',  'tls',                'trace_events',",
    "  'tty',             'url',                'v8',",
    "  'vm',              'worker_threads',     'zlib',",
    "  '_',               '_error',             'util'",
    ']',
  ].join('\n');

  assert.strictEqual(out, expected);
}

{
  const originalCWD = process.cwd();

  process.cwd = () => (process.platform === 'win32' ?
    'C:\\workspace\\node-test-binary-windows js-suites-%percent-encoded\\node' :
    '/home/user directory/repository%encoded/node');

  // Use a fake stack to verify the expected colored outcome.
  const stack = [
    'Error: CWD is grayed out, even cwd that are percent encoded!',
    '    at A.<anonymous> (/test/node_modules/foo/node_modules/bar/baz.js:2:7)',
    '    at Module._compile (node:internal/modules/cjs/loader:827:30)',
    '    at Fancy (node:vm:697:32)',
    // This file is not an actual Node.js core file.
    '    at tryModuleLoad (node:internal/modules/cjs/foo:629:12)',
    '    at Function.Module._load (node:internal/modules/cjs/loader:621:3)',
    // This file is not an actual Node.js core file.
    '    at Module.require [as weird/name] (node:internal/aaaaa/loader:735:19)',
    '    at require (node:internal/modules/helpers:14:16)',
    '    at Array.forEach (<anonymous>)',
    `    at ${process.cwd()}/test/parallel/test-util-inspect.js:2760:12`,
    `    at Object.<anonymous> (${process.cwd()}/node_modules/hyper_module/folder/file.js:2753:10)`,
    '    at /test/test-util-inspect.js:2239:9',
    '    at getActual (node:assert:592:5)',
  ];
  const err = new Error('CWD is grayed out, even cwd that are percent encoded!');
  err.stack = stack.join('\n');
  if (process.platform === 'win32') {
    err.stack = stack.map((frame) => (frame.includes('node:') ?
      frame :
      frame.replaceAll('/', '\\'))
    ).join('\n');
  }
  const escapedCWD = util.inspect(process.cwd()).slice(1, -1);
  util.inspect(err, { colors: true }).split('\n').forEach((line, i) => {
    let expected = stack[i].replace(/node_modules\/([^/]+)/gi, (_, m) => {
      return `node_modules/\u001b[4m${m}\u001b[24m`;
    }).replaceAll(new RegExp(`(\\(?${escapedCWD}(\\\\|/))`, 'gi'), (_, m) => {
      return `\x1B[90m${m}\x1B[39m`;
    });
    if (expected.includes(process.cwd()) && expected.endsWith(')')) {
      expected = `${expected.slice(0, -1)}\x1B[90m)\x1B[39m`;
    }
    if (line.includes('node:')) {
      if (!line.includes('foo') && !line.includes('aaa')) {
        expected = `\u001b[90m${expected}\u001b[39m`;
      }
    } else if (process.platform === 'win32') {
      expected = expected.replaceAll('/', '\\');
    }
    assert.strictEqual(line, expected);
  });

  // Check ESM
  const encodedCwd = url.pathToFileURL(process.cwd());
  const sl = process.platform === 'win32' ? '\\' : '/';

  // Use a fake stack to verify the expected colored outcome.
  err.stack = 'Error: ESM and CJS mixed are both grayed out!\n' +
              `    at ${encodedCwd}/test/parallel/test-esm.mjs:2760:12\n` +
              `    at Object.<anonymous> (${encodedCwd}/node_modules/esm_module/folder/file.js:2753:10)\n` +
              `    at ${process.cwd()}${sl}test${sl}parallel${sl}test-cjs.js:2760:12\n` +
              `    at Object.<anonymous> (${process.cwd()}${sl}node_modules${sl}cjs_module${sl}folder${sl}file.js:2753:10)`;

  let actual = util.inspect(err, { colors: true });
  let expected = 'Error: ESM and CJS mixed are both grayed out!\n' +
    `    at \x1B[90m${encodedCwd}/\x1B[39mtest/parallel/test-esm.mjs:2760:12\n` +
    `    at Object.<anonymous> \x1B[90m(${encodedCwd}/\x1B[39mnode_modules/\x1B[4mesm_module\x1B[24m/folder/file.js:2753:10\x1B[90m)\x1B[39m\n` +
    `    at \x1B[90m${process.cwd()}${sl}\x1B[39mtest${sl}parallel${sl}test-cjs.js:2760:12\n` +
    `    at Object.<anonymous> \x1B[90m(${process.cwd()}${sl}\x1B[39mnode_modules${sl}\x1B[4mcjs_module\x1B[24m${sl}folder${sl}file.js:2753:10\x1B[90m)\x1B[39m`;

  assert.strictEqual(actual, expected);

  // ESM without need for encoding
  process.cwd = () => (process.platform === 'win32' ?
    'C:\\workspace\\node-test-binary-windows-js-suites\\node' :
    '/home/user/repository/node');
  let expectedCwd = process.cwd();
  if (process.platform === 'win32') {
    expectedCwd = `/${expectedCwd.replaceAll('\\', '/')}`;
  }
  // Use a fake stack to verify the expected colored outcome.
  err.stack = 'Error: ESM without need for encoding!\n' +
              `    at file://${expectedCwd}/file.js:15:15`;

  actual = util.inspect(err, { colors: true });
  expected = 'Error: ESM without need for encoding!\n' +
  `    at \x1B[90mfile://${expectedCwd}/\x1B[39mfile.js:15:15`;
  assert.strictEqual(actual, expected);

  process.cwd = originalCWD;
}

{
  // Cross platform checks.
  const err = new Error('foo');
  util.inspect(err, { colors: true }).split('\n').forEach((line, i) => {
    assert(i < 2 || line.startsWith('\u001b[90m'));
  });
}

{
  // Tracing class respects inspect depth.
  try {
    const trace = require('trace_events').createTracing({ categories: ['fo'] });
    const actualDepth0 = util.inspect({ trace }, { depth: 0 });
    assert.strictEqual(actualDepth0, '{ trace: Tracing {} }');
    const actualDepth1 = util.inspect({ trace }, { depth: 1 });
    assert.strictEqual(
      actualDepth1,
      "{ trace: Tracing { enabled: false, categories: 'fo' } }"
    );
  } catch (err) {
    if (err.code !== 'ERR_TRACE_EVENTS_UNAVAILABLE')
      throw err;
  }
}

// Inspect prototype properties.
{
  class Foo extends Map {
    prop = false;
    prop2 = true;
    get abc() {
      return true;
    }
    get def() {
      return false;
    }
    set def(v) {}
    get xyz() {
      return 'Should be ignored';
    }
    func(a) {}
    [util.inspect.custom]() {
      return this;
    }
  }

  class Bar extends Foo {
    abc = true;
    prop = true;
    get xyz() {
      return 'YES!';
    }
    [util.inspect.custom]() {
      return this;
    }
  }

  const bar = new Bar();

  assert.strictEqual(
    inspect(bar),
    'Bar(0) [Map] { prop: true, prop2: true, abc: true }'
  );
  assert.strictEqual(
    inspect(bar, { showHidden: true, getters: true, colors: false }),
    'Bar(0) [Map] {\n' +
    '  prop: true,\n' +
    '  prop2: true,\n' +
    '  abc: true,\n' +
    "  [xyz]: [Getter: 'YES!'],\n" +
    '  [def]: [Getter/Setter: false]\n' +
    '}'
  );
  assert.strictEqual(
    inspect(bar, { showHidden: true, getters: false, colors: true }),
    'Bar(0) [Map] {\n' +
    '  prop: \x1B[33mtrue\x1B[39m,\n' +
    '  prop2: \x1B[33mtrue\x1B[39m,\n' +
    '  abc: \x1B[33mtrue\x1B[39m,\n' +
    '  \x1B[2m[xyz]: \x1B[36m[Getter]\x1B[39m\x1B[22m,\n' +
    '  \x1B[2m[def]: \x1B[36m[Getter/Setter]\x1B[39m\x1B[22m\n' +
    '}'
  );

  const obj = { __proto__: { abc: true, def: 5, toString() {} } };
  assert.strictEqual(
    inspect(obj, { showHidden: true, colors: true }),
    '{ \x1B[2mabc: \x1B[33mtrue\x1B[39m\x1B[22m, ' +
      '\x1B[2mdef: \x1B[33m5\x1B[39m\x1B[22m }'
  );

  assert.strictEqual(
    inspect(Object.getPrototypeOf(bar), { showHidden: true, getters: true }),
    '<ref *1> Foo [Map] {\n' +
    '    [constructor]: [class Bar extends Foo] {\n' +
    '      [length]: 0,\n' +
    "      [name]: 'Bar',\n" +
    '      [prototype]: [Circular *1],\n' +
    '      [Symbol(Symbol.species)]: [Getter: <Inspection threw ' +
      "(Symbol.prototype.toString requires that 'this' be a Symbol)>]\n" +
    '    },\n' +
    "    [xyz]: [Getter: 'YES!'],\n" +
    '    [Symbol(nodejs.util.inspect.custom)]: ' +
      '[Function: [nodejs.util.inspect.custom]] {\n' +
    '      [length]: 0,\n' +
    "      [name]: '[nodejs.util.inspect.custom]'\n" +
    '    },\n' +
    '    [abc]: [Getter: true],\n' +
    '    [def]: [Getter/Setter: false]\n' +
    '  }'
  );

  assert.strictEqual(
    inspect(Object.getPrototypeOf(bar)),
    'Foo [Map] {}'
  );

  assert.strictEqual(
    inspect(Object.getPrototypeOf(new Foo())),
    'Map {}'
  );
}

// Check that prototypes with a null prototype are inspectable.
// Regression test for https://github.com/nodejs/node/issues/35730
{
  function Func() {}
  Func.prototype = null;
  const object = {};
  object.constructor = Func;

  assert.strictEqual(util.inspect(object), '{ constructor: [Function: Func] }');
}

// Test changing util.inspect.colors colors and aliases.
{
  const colors = util.inspect.colors;

  const originalValue = colors.gray;

  // "grey" is reference-equal alias of "gray".
  assert.strictEqual(colors.grey, colors.gray);

  // Assigninging one should assign the other. This tests that the alias setter
  // function keeps things reference-equal.
  colors.gray = [0, 0];
  assert.deepStrictEqual(colors.gray, [0, 0]);
  assert.strictEqual(colors.grey, colors.gray);

  colors.grey = [1, 1];
  assert.deepStrictEqual(colors.grey, [1, 1]);
  assert.strictEqual(colors.grey, colors.gray);

  // Restore original value to avoid side effects in other tests.
  colors.gray = originalValue;
  assert.deepStrictEqual(colors.gray, originalValue);
  assert.strictEqual(colors.grey, colors.gray);
}

// https://github.com/nodejs/node/issues/31889
{
  v8.setFlagsFromString('--allow-natives-syntax');
  const undetectable = vm.runInThisContext('%GetUndetectable()');
  v8.setFlagsFromString('--no-allow-natives-syntax');
  assert.strictEqual(inspect(undetectable), '{}');
}

// Truncate output for Primitives with 1 character left
{
  assert.strictEqual(util.inspect('bl', { maxStringLength: 1 }),
                     "'b'... 1 more character");
}

{
  const x = 'a'.repeat(1e6);
  assert(util.inspect(x).endsWith('... 990000 more characters'));
  assert.strictEqual(
    util.inspect(x, { maxStringLength: 4 }),
    "'aaaa'... 999996 more characters"
  );
  assert.match(util.inspect(x, { maxStringLength: null }), /a'$/);
}

{
  // Verify that util.inspect() invokes custom inspect functions on objects
  // from other vm.Contexts but does not pass data from its own Context to that
  // function.
  const target = vm.runInNewContext(`
    ({
      [Symbol.for('nodejs.util.inspect.custom')](depth, ctx) {
        this.depth = depth;
        this.ctx = ctx;
        try {
          this.stylized = ctx.stylize('🐈');
        } catch (e) {
          this.stylizeException = e;
        }
        return this.stylized;
      }
    })
  `, { __proto__: null });
  assert.strictEqual(target.ctx, undefined);

  {
    // Subtest 1: Just try to inspect the object with default options.
    assert.strictEqual(util.inspect(target), '🐈');
    assert.strictEqual(typeof target.ctx, 'object');
    const objectGraph = fullObjectGraph(target);
    assert(!objectGraph.has(Object));
    assert(!objectGraph.has(Function));
  }

  {
    // Subtest 2: Use a stylize function that returns a non-primitive.
    const output = util.inspect(target, {
      stylize: common.mustCall((str) => {
        return {};
      })
    });
    assert.strictEqual(output, '[object Object]');
    assert.strictEqual(typeof target.ctx, 'object');
    const objectGraph = fullObjectGraph(target);
    assert(!objectGraph.has(Object));
    assert(!objectGraph.has(Function));
  }

  {
    // Subtest 3: Use a stylize function that throws an exception.
    const output = util.inspect(target, {
      stylize: common.mustCall((str) => {
        throw new Error('oops');
      })
    });
    assert.strictEqual(output, '🐈');
    assert.strictEqual(typeof target.ctx, 'object');
    const objectGraph = fullObjectGraph(target);
    assert(!objectGraph.has(Object));
    assert(!objectGraph.has(Function));
  }

  function fullObjectGraph(value) {
    const graph = new Set([value]);

    for (const entry of graph) {
      if ((typeof entry !== 'object' && typeof entry !== 'function') ||
          entry === null) {
        continue;
      }

      graph.add(Object.getPrototypeOf(entry));
      const descriptors = Object.values(
        Object.getOwnPropertyDescriptors(entry));
      for (const descriptor of descriptors) {
        graph.add(descriptor.value);
        graph.add(descriptor.set);
        graph.add(descriptor.get);
      }
    }

    return graph;
  }

  // Consistency check.
  assert(fullObjectGraph(globalThis).has(Function.prototype));
}

{
  // Confirm that own constructor value displays correctly.

  function Fhqwhgads() {}

  const sterrance = new Fhqwhgads();
  sterrance.constructor = Fhqwhgads;

  assert.strictEqual(
    util.inspect(sterrance, { showHidden: true }),
    'Fhqwhgads {\n' +
      '  constructor: <ref *1> [Function: Fhqwhgads] {\n' +
      '    [length]: 0,\n' +
      "    [name]: 'Fhqwhgads',\n" +
      '    [prototype]: { [constructor]: [Circular *1] }\n' +
      '  }\n' +
      '}'
  );
}

{
  // Confirm null prototype of generator prototype displays as expected.

  function getProtoOfProto() {
    return Object.getPrototypeOf(Object.getPrototypeOf(function* () {}));
  }

  function* generator() {}

  const generatorPrototype = Object.getPrototypeOf(generator);
  const originalProtoOfProto = Object.getPrototypeOf(generatorPrototype);
  assert.strictEqual(getProtoOfProto(), originalProtoOfProto);
  Object.setPrototypeOf(generatorPrototype, null);
  assert.notStrictEqual(getProtoOfProto, originalProtoOfProto);

  // This is the actual test. The other assertions in this block are about
  // making sure the test is set up correctly and isn't polluting other tests.
  assert.strictEqual(
    util.inspect(generator, { showHidden: true }),
    '[GeneratorFunction: generator] {\n' +
    '  [length]: 0,\n' +
    "  [name]: 'generator',\n" +
    "  [prototype]: Object [Generator] { [Symbol(Symbol.toStringTag)]: 'Generator' },\n" + // eslint-disable-line @stylistic/js/max-len
    "  [Symbol(Symbol.toStringTag)]: 'GeneratorFunction'\n" +
    '}'
  );

  // Reset so we don't pollute other tests
  Object.setPrototypeOf(generatorPrototype, originalProtoOfProto);
  assert.strictEqual(getProtoOfProto(), originalProtoOfProto);
}

{
  // Test for when breakLength results in a single column.
  const obj = Array(9).fill('fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf');
  assert.strictEqual(
    util.inspect(obj, { breakLength: 256 }),
    '[\n' +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf',\n" +
    "  'fhqwhgadshgnsdhjsdbkhsdabkfabkveybvf'\n" +
    ']'
  );
}

{
  assert.strictEqual(
    util.inspect({ ['__proto__']: { a: 1 } }),
    "{ ['__proto__']: { a: 1 } }"
  );
}

{
  const { numericSeparator } = util.inspect.defaultOptions;
  util.inspect.defaultOptions.numericSeparator = true;

  assert.strictEqual(
    // eslint-disable-next-line no-loss-of-precision
    util.inspect(1234567891234567891234),
    '1.234567891234568e+21'
  );
  assert.strictEqual(
    util.inspect(123456789.12345678),
    '123_456_789.123_456_78'
  );

  assert.strictEqual(util.inspect(10_000_000), '10_000_000');
  assert.strictEqual(util.inspect(1_000_000), '1_000_000');
  assert.strictEqual(util.inspect(100_000), '100_000');
  assert.strictEqual(util.inspect(99_999.9), '99_999.9');
  assert.strictEqual(util.inspect(9_999), '9_999');
  assert.strictEqual(util.inspect(999), '999');
  assert.strictEqual(util.inspect(NaN), 'NaN');
  assert.strictEqual(util.inspect(Infinity), 'Infinity');
  assert.strictEqual(util.inspect(-Infinity), '-Infinity');

  assert.strictEqual(
    util.inspect(new Float64Array([100_000_000])),
    'Float64Array(1) [ 100_000_000 ]'
  );
  assert.strictEqual(
    util.inspect(new BigInt64Array([9_100_000_100n])),
    'BigInt64Array(1) [ 9_100_000_100n ]'
  );

  assert.strictEqual(
    util.inspect(123456789),
    '123_456_789'
  );
  assert.strictEqual(
    util.inspect(123456789n),
    '123_456_789n'
  );

  util.inspect.defaultOptions.numericSeparator = numericSeparator;

  assert.strictEqual(
    util.inspect(123456789.12345678, { numericSeparator: true }),
    '123_456_789.123_456_78'
  );

  assert.strictEqual(
    util.inspect(-123456789.12345678, { numericSeparator: true }),
    '-123_456_789.123_456_78'
  );
}

// Regression test for https://github.com/nodejs/node/issues/41244
{
  assert.strictEqual(util.inspect({
    get [Symbol.iterator]() {
      throw new Error();
    }
  }), '{ [Symbol(Symbol.iterator)]: [Getter] }');
}

{
  const o = {};
  const { prototype: BuiltinPrototype } = Object;
  const desc = Reflect.getOwnPropertyDescriptor(BuiltinPrototype, 'constructor');
  Object.defineProperty(BuiltinPrototype, 'constructor', {
    get: () => BuiltinPrototype,
    configurable: true,
  });
  assert.strictEqual(
    util.inspect(o),
    '{}',
  );
  Object.defineProperty(BuiltinPrototype, 'constructor', desc);
}

{
  const o = { f() {} };
  const { prototype: BuiltinPrototype } = Function;
  const desc = Reflect.getOwnPropertyDescriptor(BuiltinPrototype, 'constructor');
  Object.defineProperty(BuiltinPrototype, 'constructor', {
    get: () => BuiltinPrototype,
    configurable: true,
  });
  assert.strictEqual(
    util.inspect(o),
    '{ f: [Function: f] }',
  );
  Object.defineProperty(BuiltinPrototype, 'constructor', desc);
}
{
  const prototypes = [
    Array.prototype,
    ArrayBuffer.prototype,
    Buffer.prototype,
    Function.prototype,
    Map.prototype,
    Object.prototype,
    Reflect.getPrototypeOf(Uint8Array.prototype),
    Set.prototype,
    Uint8Array.prototype,
  ];
  const descriptors = new Map();
  const buffer = Buffer.from('Hello');
  const o = {
    arrayBuffer: new ArrayBuffer(), buffer, typedArray: Uint8Array.from(buffer),
    array: [], func() {}, set: new Set([1]), map: new Map(),
  };
  for (const BuiltinPrototype of prototypes) {
    descriptors.set(BuiltinPrototype, Reflect.getOwnPropertyDescriptor(BuiltinPrototype, 'constructor'));
    Object.defineProperty(BuiltinPrototype, 'constructor', {
      get: () => BuiltinPrototype,
      configurable: true,
    });
  }
  assert.strictEqual(
    util.inspect(o),
    '{\n' +
    '  arrayBuffer: ArrayBuffer { [Uint8Contents]: <>, byteLength: 0 },\n' +
    '  buffer: <Buffer 48 65 6c 6c 6f>,\n' +
    '  typedArray: TypedArray(5) [Uint8Array] [ 72, 101, 108, 108, 111 ],\n' +
    '  array: [],\n' +
    '  func: [Function: func],\n' +
    '  set: Set(1) { 1 },\n' +
    '  map: Map(0) {}\n' +
    '}',
  );
  for (const [BuiltinPrototype, desc] of descriptors) {
    Object.defineProperty(BuiltinPrototype, 'constructor', desc);
  }
}

{
  function f() {}
  Object.defineProperty(f, 'name', { value: Symbol('f') });

  assert.strictEqual(
    util.inspect(f),
    '[Function: Symbol(f)]',
  );
}

{
  const error = new EvalError();
  const re = /a/g;
  error.name = re;
  assert.strictEqual(error.name, re);
  assert.strictEqual(
    util.inspect(error),
    `${re} [EvalError]
${error.stack.split('\n').slice(1).join('\n')}`,
  );
}

{
  const error = new Error();
  error.stack = [Symbol('foo')];

  assert.strictEqual(
    inspect(error),
    '[[\n  Symbol(foo)\n]]'
  );
}
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-util-internal.js                                                     0000664 0000000 0000000 00000001345 14746647661 0021435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals

require('../common');
const assert = require('assert');
const fixtures = require('../common/fixtures');
const { internalBinding } = require('internal/test/binding');

const {
  privateSymbols: {
    arrow_message_private_symbol,
  },
} = internalBinding('util');

const obj = {};
assert.strictEqual(obj[arrow_message_private_symbol], undefined);

obj[arrow_message_private_symbol] = 'bar';
assert.strictEqual(obj[arrow_message_private_symbol], 'bar');
assert.deepStrictEqual(Reflect.ownKeys(obj), []);

let arrowMessage;

try {
  require(fixtures.path('syntax', 'bad_syntax'));
} catch (err) {
  arrowMessage = err[arrow_message_private_symbol];
}

assert.match(arrowMessage, /bad_syntax\.js:1/);
                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-util-isDeepStrictEqual.js                                            0000664 0000000 0000000 00000006537 14746647661 0023223 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Confirm functionality of `util.isDeepStrictEqual()`.

require('../common');

const assert = require('assert');
const util = require('util');

function utilIsDeepStrict(a, b) {
  assert.strictEqual(util.isDeepStrictEqual(a, b), true);
  assert.strictEqual(util.isDeepStrictEqual(b, a), true);
}

function notUtilIsDeepStrict(a, b) {
  assert.strictEqual(util.isDeepStrictEqual(a, b), false);
  assert.strictEqual(util.isDeepStrictEqual(b, a), false);
}

// Handle boxed primitives
{
  const boxedString = new String('test');
  const boxedSymbol = Object(Symbol());
  notUtilIsDeepStrict(new Boolean(true), Object(false));
  notUtilIsDeepStrict(Object(true), new Number(1));
  notUtilIsDeepStrict(new Number(2), new Number(1));
  notUtilIsDeepStrict(boxedSymbol, Object(Symbol()));
  notUtilIsDeepStrict(boxedSymbol, {});
  utilIsDeepStrict(boxedSymbol, boxedSymbol);
  utilIsDeepStrict(Object(true), Object(true));
  utilIsDeepStrict(Object(2), Object(2));
  utilIsDeepStrict(boxedString, Object('test'));
  boxedString.slow = true;
  notUtilIsDeepStrict(boxedString, Object('test'));
  boxedSymbol.slow = true;
  notUtilIsDeepStrict(boxedSymbol, {});
  utilIsDeepStrict(Object(BigInt(1)), Object(BigInt(1)));
  notUtilIsDeepStrict(Object(BigInt(1)), Object(BigInt(2)));

  const booleanish = new Boolean(true);
  Object.defineProperty(booleanish, Symbol.toStringTag, { value: 'String' });
  Object.setPrototypeOf(booleanish, String.prototype);
  notUtilIsDeepStrict(booleanish, new String('true'));

  const numberish = new Number(42);
  Object.defineProperty(numberish, Symbol.toStringTag, { value: 'String' });
  Object.setPrototypeOf(numberish, String.prototype);
  notUtilIsDeepStrict(numberish, new String('42'));

  const stringish = new String('0');
  Object.defineProperty(stringish, Symbol.toStringTag, { value: 'Number' });
  Object.setPrototypeOf(stringish, Number.prototype);
  notUtilIsDeepStrict(stringish, new Number(0));

  const bigintish = new Object(BigInt(42));
  Object.defineProperty(bigintish, Symbol.toStringTag, { value: 'String' });
  Object.setPrototypeOf(bigintish, String.prototype);
  notUtilIsDeepStrict(bigintish, new String('42'));

  const symbolish = new Object(Symbol('fhqwhgads'));
  Object.defineProperty(symbolish, Symbol.toStringTag, { value: 'String' });
  Object.setPrototypeOf(symbolish, String.prototype);
  notUtilIsDeepStrict(symbolish, new String('fhqwhgads'));
}

// Handle symbols (enumerable only)
{
  const symbol1 = Symbol();
  const obj1 = { [symbol1]: 1 };
  const obj2 = { [symbol1]: 1 };
  const obj3 = { [Symbol()]: 1 };
  const obj4 = { };
  // Add a non enumerable symbol as well. It is going to be ignored!
  Object.defineProperty(obj2, Symbol(), { value: 1 });
  Object.defineProperty(obj4, symbol1, { value: 1 });
  notUtilIsDeepStrict(obj1, obj3);
  utilIsDeepStrict(obj1, obj2);
  notUtilIsDeepStrict(obj1, obj4);
  // TypedArrays have a fast path. Test for this as well.
  const a = new Uint8Array(4);
  const b = new Uint8Array(4);
  a[symbol1] = true;
  b[symbol1] = false;
  notUtilIsDeepStrict(a, b);
  b[symbol1] = true;
  utilIsDeepStrict(a, b);
  // The same as TypedArrays is valid for boxed primitives
  const boxedStringA = new String('test');
  const boxedStringB = new String('test');
  boxedStringA[symbol1] = true;
  notUtilIsDeepStrict(boxedStringA, boxedStringB);
  boxedStringA[symbol1] = true;
  utilIsDeepStrict(a, b);
}
                                                                                                                                                                 node-23.7.0/test/parallel/test-util-parse-env.js                                                    0000664 0000000 0000000 00000005473 14746647661 0021527 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const fixtures = require('../../test/common/fixtures');
const assert = require('node:assert');
const util = require('node:util');
const fs = require('node:fs');

{
  const validEnvFilePath = fixtures.path('dotenv/valid.env');
  const validContent = fs.readFileSync(validEnvFilePath, 'utf8');

  assert.deepStrictEqual(util.parseEnv(validContent), {
    AFTER_LINE: 'after_line',
    BACKTICKS: 'backticks',
    BACKTICKS_INSIDE_DOUBLE: '`backticks` work inside double quotes',
    BACKTICKS_INSIDE_SINGLE: '`backticks` work inside single quotes',
    BACKTICKS_SPACED: '    backticks    ',
    BASIC: 'basic',
    DONT_EXPAND_SQUOTED: 'dontexpand\\nnewlines',
    DONT_EXPAND_UNQUOTED: 'dontexpand\\nnewlines',
    DOUBLE_AND_SINGLE_QUOTES_INSIDE_BACKTICKS: "double \"quotes\" and single 'quotes' work inside backticks",
    DOUBLE_QUOTES: 'double_quotes',
    DOUBLE_QUOTES_INSIDE_BACKTICKS: 'double "quotes" work inside backticks',
    DOUBLE_QUOTES_INSIDE_SINGLE: 'double "quotes" work inside single quotes',
    DOUBLE_QUOTES_SPACED: '    double quotes    ',
    DOUBLE_QUOTES_WITH_NO_SPACE_BRACKET: '{ port: $MONGOLAB_PORT}',
    EDGE_CASE_INLINE_COMMENTS: 'VALUE1',
    EMAIL: 'therealnerdybeast@example.tld',
    EMPTY: '',
    EMPTY_BACKTICKS: '',
    EMPTY_DOUBLE_QUOTES: '',
    EMPTY_SINGLE_QUOTES: '',
    EQUAL_SIGNS: 'equals==',
    EXPORT_EXAMPLE: 'ignore export',
    EXPAND_NEWLINES: 'expand\nnew\nlines',
    INLINE_COMMENTS: 'inline comments',
    INLINE_COMMENTS_BACKTICKS: 'inline comments outside of #backticks',
    INLINE_COMMENTS_DOUBLE_QUOTES: 'inline comments outside of #doublequotes',
    INLINE_COMMENTS_SINGLE_QUOTES: 'inline comments outside of #singlequotes',
    INLINE_COMMENTS_SPACE: 'inline comments start with a',
    MULTI_BACKTICKED: 'THIS\nIS\nA\n"MULTILINE\'S"\nSTRING',
    MULTI_DOUBLE_QUOTED: 'THIS\nIS\nA\nMULTILINE\nSTRING',
    MULTI_NOT_VALID: 'THIS',
    MULTI_NOT_VALID_QUOTE: '"',
    MULTI_SINGLE_QUOTED: 'THIS\nIS\nA\nMULTILINE\nSTRING',
    RETAIN_INNER_QUOTES: '{"foo": "bar"}',
    RETAIN_INNER_QUOTES_AS_BACKTICKS: '{"foo": "bar\'s"}',
    RETAIN_INNER_QUOTES_AS_STRING: '{"foo": "bar"}',
    SINGLE_QUOTES: 'single_quotes',
    SINGLE_QUOTES_INSIDE_BACKTICKS: "single 'quotes' work inside backticks",
    SINGLE_QUOTES_INSIDE_DOUBLE: "single 'quotes' work inside double quotes",
    SINGLE_QUOTES_SPACED: '    single quotes    ',
    SPACED_KEY: 'parsed',
    SPACE_BEFORE_DOUBLE_QUOTES: 'space before double quotes',
    TRIM_SPACE_FROM_UNQUOTED: 'some spaced out string',
  });
}

assert.deepStrictEqual(util.parseEnv(''), {});
assert.deepStrictEqual(util.parseEnv('FOO=bar\nFOO=baz\n'), { FOO: 'baz' });

// Test for invalid input.
assert.throws(() => {
  for (const value of [null, undefined, {}, []]) {
    util.parseEnv(value);
  }
}, {
  code: 'ERR_INVALID_ARG_TYPE',
});
                                                                                                                                                                                                     node-23.7.0/test/parallel/test-util-primordial-monkeypatching.js                                    0000664 0000000 0000000 00000000535 14746647661 0025001 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Monkeypatch Object.keys() so that it throws an unexpected error. This tests
// that `util.inspect()` is unaffected by monkey-patching `Object`.

require('../common');
const assert = require('assert');
const util = require('util');

Object.keys = () => { throw new Error('fhqwhgads'); };
assert.strictEqual(util.inspect({}), '{}');
                                                                                                                                                                   node-23.7.0/test/parallel/test-util-promisify-custom-names.mjs                                      0000664 0000000 0000000 00000001426 14746647661 0024430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import '../common/index.mjs';
import assert from 'node:assert';
import { promisify } from 'node:util';

// Test that customly promisified methods in [util.promisify.custom]
// have appropriate names

import fs from 'node:fs';
import readline from 'node:readline';
import stream from 'node:stream';
import timers from 'node:timers';


assert.strictEqual(
  promisify(fs.exists).name,
  'exists'
);

assert.strictEqual(
  promisify(readline.Interface.prototype.question).name,
  'question',
);

assert.strictEqual(
  promisify(stream.finished).name,
  'finished'
);
assert.strictEqual(
  promisify(stream.pipeline).name,
  'pipeline'
);

assert.strictEqual(
  promisify(timers.setImmediate).name,
  'setImmediate'
);
assert.strictEqual(
  promisify(timers.setTimeout).name,
  'setTimeout'
);
                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-util-promisify.js                                                    0000664 0000000 0000000 00000012305 14746647661 0021640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals
const common = require('../common');
const assert = require('assert');
const fs = require('fs');
const vm = require('vm');
const { promisify } = require('util');
const { customPromisifyArgs } = require('internal/util');

{
  const warningHandler = common.mustNotCall();
  process.on('warning', warningHandler);
  function foo() {}
  foo.constructor = (async () => {}).constructor;
  promisify(foo);
  process.off('warning', warningHandler);
}

common.expectWarning(
  'DeprecationWarning',
  'Calling promisify on a function that returns a Promise is likely a mistake.',
  'DEP0174');
promisify(async (callback) => { callback(); })().then(common.mustCall(() => {
  // We must add the second `expectWarning` call in the `.then` handler, when
  // the first warning has already been triggered.
  common.expectWarning(
    'DeprecationWarning',
    'Calling promisify on a function that returns a Promise is likely a mistake.',
    'DEP0174');
  promisify(async () => {})().then(common.mustNotCall());
}));

const stat = promisify(fs.stat);

{
  const promise = stat(__filename);
  assert(promise instanceof Promise);
  promise.then(common.mustCall((value) => {
    assert.deepStrictEqual(value, fs.statSync(__filename));
  }));
}

{
  const promise = stat('/dontexist');
  promise.catch(common.mustCall((error) => {
    assert(error.message.includes('ENOENT: no such file or directory, stat'));
  }));
}

{
  function fn() {}

  function promisifedFn() {}
  fn[promisify.custom] = promisifedFn;
  assert.strictEqual(promisify(fn), promisifedFn);
  assert.strictEqual(promisify(promisify(fn)), promisifedFn);
}

{
  function fn() {}

  function promisifiedFn() {}

  // util.promisify.custom is a shared symbol which can be accessed
  // as `Symbol.for("nodejs.util.promisify.custom")`.
  const kCustomPromisifiedSymbol = Symbol.for('nodejs.util.promisify.custom');
  fn[kCustomPromisifiedSymbol] = promisifiedFn;

  assert.strictEqual(kCustomPromisifiedSymbol, promisify.custom);
  assert.strictEqual(promisify(fn), promisifiedFn);
  assert.strictEqual(promisify(promisify(fn)), promisifiedFn);
}

{
  function fn() {}
  fn[promisify.custom] = 42;
  assert.throws(
    () => promisify(fn),
    { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' }
  );
}

{
  const firstValue = 5;
  const secondValue = 17;

  function fn(callback) {
    callback(null, firstValue, secondValue);
  }

  fn[customPromisifyArgs] = ['first', 'second'];

  promisify(fn)().then(common.mustCall((obj) => {
    assert.deepStrictEqual(obj, { first: firstValue, second: secondValue });
  }));
}

{
  const fn = vm.runInNewContext('(function() {})');
  assert.notStrictEqual(Object.getPrototypeOf(promisify(fn)),
                        Function.prototype);
}

{
  function fn(callback) {
    callback(null, 'foo', 'bar');
  }
  promisify(fn)().then(common.mustCall((value) => {
    assert.strictEqual(value, 'foo');
  }));
}

{
  function fn(callback) {
    callback(null);
  }
  promisify(fn)().then(common.mustCall((value) => {
    assert.strictEqual(value, undefined);
  }));
}

{
  function fn(callback) {
    callback();
  }
  promisify(fn)().then(common.mustCall((value) => {
    assert.strictEqual(value, undefined);
  }));
}

{
  function fn(err, val, callback) {
    callback(err, val);
  }
  promisify(fn)(null, 42).then(common.mustCall((value) => {
    assert.strictEqual(value, 42);
  }));
}

{
  function fn(err, val, callback) {
    callback(err, val);
  }
  promisify(fn)(new Error('oops'), null).catch(common.mustCall((err) => {
    assert.strictEqual(err.message, 'oops');
  }));
}

{
  function fn(err, val, callback) {
    callback(err, val);
  }

  (async () => {
    const value = await promisify(fn)(null, 42);
    assert.strictEqual(value, 42);
  })().then(common.mustCall());
}

{
  const o = {};
  const fn = promisify(function(cb) {

    cb(null, this === o);
  });

  o.fn = fn;

  o.fn().then(common.mustCall((val) => assert(val)));
}

{
  const err = new Error('Should not have called the callback with the error.');
  const stack = err.stack;

  const fn = promisify(function(cb) {
    cb(null);
    cb(err);
  });

  (async () => {
    await fn();
    await Promise.resolve();
    return assert.strictEqual(stack, err.stack);
  })().then(common.mustCall());
}

{
  function c() { }
  const a = promisify(function() { });
  const b = promisify(a);
  assert.notStrictEqual(c, a);
  assert.strictEqual(a, b);
}

{
  let errToThrow;
  const thrower = promisify(function(a, b, c, cb) {
    errToThrow = new Error();
    throw errToThrow;
  });
  thrower(1, 2, 3)
    .then(assert.fail)
    .then(assert.fail, (e) => assert.strictEqual(e, errToThrow));
}

{
  const err = new Error();

  const a = promisify((cb) => cb(err))();
  const b = promisify(() => { throw err; })();

  Promise.all([
    a.then(assert.fail, function(e) {
      assert.strictEqual(err, e);
    }),
    b.then(assert.fail, function(e) {
      assert.strictEqual(err, e);
    }),
  ]);
}

[undefined, null, true, 0, 'str', {}, [], Symbol()].forEach((input) => {
  assert.throws(
    () => promisify(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The "original" argument must be of type function.' +
               common.invalidArgTypeHelper(input)
    });
});
                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-util-sigint-watchdog.js                                              0000664 0000000 0000000 00000003701 14746647661 0022712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
const common = require('../common');
if (common.isWindows) {
  // No way to send CTRL_C_EVENT to processes from JS right now.
  common.skip('platform not supported');
}

const assert = require('assert');
const { internalBinding } = require('internal/test/binding');
const binding = internalBinding('contextify');

[(next) => {
  // Test with no signal observed.
  binding.startSigintWatchdog();
  const hadPendingSignals = binding.stopSigintWatchdog();
  assert.strictEqual(hadPendingSignals, false);
  next();
},
 (next) => {
   // Test with one call to the watchdog, one signal.
   binding.startSigintWatchdog();
   process.kill(process.pid, 'SIGINT');
   waitForPendingSignal(common.mustCall(() => {
     const hadPendingSignals = binding.stopSigintWatchdog();
     assert.strictEqual(hadPendingSignals, true);
     next();
   }));
 },
 (next) => {
   // Nested calls are okay.
   binding.startSigintWatchdog();
   binding.startSigintWatchdog();
   process.kill(process.pid, 'SIGINT');
   waitForPendingSignal(common.mustCall(() => {
     const hadPendingSignals1 = binding.stopSigintWatchdog();
     const hadPendingSignals2 = binding.stopSigintWatchdog();
     assert.strictEqual(hadPendingSignals1, true);
     assert.strictEqual(hadPendingSignals2, false);
     next();
   }));
 },
 () => {
   // Signal comes in after first call to stop.
   binding.startSigintWatchdog();
   binding.startSigintWatchdog();
   const hadPendingSignals1 = binding.stopSigintWatchdog();
   process.kill(process.pid, 'SIGINT');
   waitForPendingSignal(common.mustCall(() => {
     const hadPendingSignals2 = binding.stopSigintWatchdog();
     assert.strictEqual(hadPendingSignals1, false);
     assert.strictEqual(hadPendingSignals2, true);
   }));
 }].reduceRight((a, b) => common.mustCall(b).bind(null, a))();

function waitForPendingSignal(cb) {
  if (binding.watchdogHasPendingSigint())
    cb();
  else
    setTimeout(waitForPendingSignal, 10, cb);
}
                                                               node-23.7.0/test/parallel/test-util-sleep.js                                                        0000664 0000000 0000000 00000000707 14746647661 0020732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
require('../common');
const assert = require('assert');
const { sleep } = require('internal/util');

[undefined, null, '', {}, true, false].forEach((value) => {
  assert.throws(
    () => { sleep(value); },
    /The "msec" argument must be of type number/
  );
});

[-1, 3.14, NaN, 4294967296].forEach((value) => {
  assert.throws(
    () => { sleep(value); },
    /The value of "msec" is out of range/
  );
});
                                                         node-23.7.0/test/parallel/test-util-stripvtcontrolcharacters.js                                     0000664 0000000 0000000 00000001705 14746647661 0024775 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const util = require('util');
const { test } = require('node:test');

// Ref: https://github.com/chalk/ansi-regex/blob/main/test.js
const tests = [
  // [before, expected]
  ['\u001B[0m\u001B[4m\u001B[42m\u001B[31mfoo\u001B[39m\u001B[49m\u001B[24mfoo\u001B[0m', 'foofoo'], // Basic ANSI
  ['\u001B[0;33;49;3;9;4mbar\u001B[0m', 'bar'], // Advanced colors
  ['foo\u001B[0gbar', 'foobar'], // Clear tabs
  ['foo\u001B[Kbar', 'foobar'], // Clear line
  ['foo\u001B[2Jbar', 'foobar'], // Clear screen
];

for (const ST of ['\u0007', '\u001B\u005C', '\u009C']) {
  tests.push(
    [`\u001B]8;;mailto:no-replay@mail.com${ST}mail\u001B]8;;${ST}`, 'mail'],
    [`\u001B]8;k=v;https://example-a.com/?a_b=1&c=2#tit%20le${ST}click\u001B]8;;${ST}`, 'click'],
  );
}

test('util.stripVTControlCharacters', (t) => {
  for (const [before, expected] of tests) {
    t.assert.strictEqual(util.stripVTControlCharacters(before), expected);
  }
});
                                                           node-23.7.0/test/parallel/test-util-styletext.js                                                    0000664 0000000 0000000 00000005140 14746647661 0021663 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('node:assert');
const util = require('node:util');
const { WriteStream } = require('node:tty');

const styled = '\u001b[31mtest\u001b[39m';
const noChange = 'test';

[
  undefined,
  null,
  false,
  5n,
  5,
  Symbol(),
  () => {},
  {},
].forEach((invalidOption) => {
  assert.throws(() => {
    util.styleText(invalidOption, 'test');
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
  });
  assert.throws(() => {
    util.styleText('red', invalidOption);
  }, {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

assert.throws(() => {
  util.styleText('invalid', 'text');
}, {
  code: 'ERR_INVALID_ARG_VALUE',
});

assert.strictEqual(
  util.styleText('red', 'test', { validateStream: false }),
  '\u001b[31mtest\u001b[39m',
);

assert.strictEqual(
  util.styleText(['bold', 'red'], 'test', { validateStream: false }),
  '\u001b[1m\u001b[31mtest\u001b[39m\u001b[22m',
);

assert.strictEqual(
  util.styleText(['bold', 'red'], 'test', { validateStream: false }),
  util.styleText(
    'bold',
    util.styleText('red', 'test', { validateStream: false }),
    { validateStream: false },
  ),
);

assert.throws(() => {
  util.styleText(['invalid'], 'text');
}, {
  code: 'ERR_INVALID_ARG_VALUE',
});

assert.throws(() => {
  util.styleText('red', 'text', { stream: {} });
}, {
  code: 'ERR_INVALID_ARG_TYPE',
});

// does not throw
util.styleText('red', 'text', { stream: {}, validateStream: false });

assert.strictEqual(
  util.styleText('red', 'test', { validateStream: false }),
  styled,
);

const fd = common.getTTYfd();
if (fd !== -1) {
  const writeStream = new WriteStream(fd);

  const originalEnv = process.env;
  [
    { isTTY: true, env: {}, expected: styled },
    { isTTY: false, env: {}, expected: noChange },
    { isTTY: true, env: { NODE_DISABLE_COLORS: '1' }, expected: noChange },
    { isTTY: true, env: { NO_COLOR: '1' }, expected: noChange },
    { isTTY: true, env: { FORCE_COLOR: '1' }, expected: styled },
    { isTTY: true, env: { FORCE_COLOR: '1', NODE_DISABLE_COLORS: '1' }, expected: styled },
    { isTTY: false, env: { FORCE_COLOR: '1', NO_COLOR: '1', NODE_DISABLE_COLORS: '1' }, expected: styled },
    { isTTY: true, env: { FORCE_COLOR: '1', NO_COLOR: '1', NODE_DISABLE_COLORS: '1' }, expected: styled },
  ].forEach((testCase) => {
    writeStream.isTTY = testCase.isTTY;
    process.env = {
      ...process.env,
      ...testCase.env
    };
    const output = util.styleText('red', 'test', { stream: writeStream });
    assert.strictEqual(output, testCase.expected);
    process.env = originalEnv;
  });
} else {
  common.skip('Could not create TTY fd');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-util-text-decoder.js                                                 0000664 0000000 0000000 00000000744 14746647661 0022212 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const test = require('node:test');
const assert = require('node:assert');

test('TextDecoder correctly decodes windows-1252 encoded data', { skip: !common.hasIntl }, () => {
  const latin1Bytes = new Uint8Array([0xc1, 0xe9, 0xf3]);

  const expectedString = 'Áéó';

  const decoder = new TextDecoder('windows-1252');
  const decodedString = decoder.decode(latin1Bytes);

  assert.strictEqual(decodedString, expectedString);
});
                            node-23.7.0/test/parallel/test-util-types-exists.js                                                 0000664 0000000 0000000 00000000212 14746647661 0022272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

assert.strictEqual(require('util/types'), require('util').types);
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-util-types.js                                                        0000664 0000000 0000000 00000024303 14746647661 0020764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-vm-modules --expose-internals
'use strict';
const common = require('../common');
const assert = require('assert');
const { types, inspect } = require('util');
const vm = require('vm');
const { internalBinding } = require('internal/test/binding');
const { JSStream } = internalBinding('js_stream');

const external = (new JSStream())._externalStream;

for (const [ value, _method ] of [
  [ external, 'isExternal' ],
  [ new Date() ],
  [ (function() { return arguments; })(), 'isArgumentsObject' ],
  [ new Boolean(), 'isBooleanObject' ],
  [ new Number(), 'isNumberObject' ],
  [ new String(), 'isStringObject' ],
  [ Object(Symbol()), 'isSymbolObject' ],
  [ Object(BigInt(0)), 'isBigIntObject' ],
  [ new Error(), 'isNativeError' ],
  [ new RegExp() ],
  [ async function() {}, 'isAsyncFunction' ],
  [ function*() {}, 'isGeneratorFunction' ],
  [ (function*() {})(), 'isGeneratorObject' ],
  [ Promise.resolve() ],
  [ new Map() ],
  [ new Set() ],
  [ (new Map())[Symbol.iterator](), 'isMapIterator' ],
  [ (new Set())[Symbol.iterator](), 'isSetIterator' ],
  [ new WeakMap() ],
  [ new WeakSet() ],
  [ new ArrayBuffer() ],
  [ new Uint8Array() ],
  [ new Uint8ClampedArray() ],
  [ new Uint16Array() ],
  [ new Uint32Array() ],
  [ new Int8Array() ],
  [ new Int16Array() ],
  [ new Int32Array() ],
  [ new Float32Array() ],
  [ new Float64Array() ],
  [ new BigInt64Array() ],
  [ new BigUint64Array() ],
  [ Object.defineProperty(new Uint8Array(),
                          Symbol.toStringTag,
                          { value: 'foo' }) ],
  [ new DataView(new ArrayBuffer()) ],
  [ new SharedArrayBuffer() ],
  [ new Proxy({}, {}), 'isProxy' ],
]) {
  const method = _method || `is${value.constructor.name}`;
  assert(method in types, `Missing ${method} for ${inspect(value)}`);
  assert(types[method](value), `Want ${inspect(value)} to match ${method}`);

  for (const key of Object.keys(types)) {
    if ((types.isArrayBufferView(value) ||
         types.isAnyArrayBuffer(value)) && key.includes('Array') ||
         key === 'isBoxedPrimitive') {
      continue;
    }

    assert.strictEqual(types[key](value),
                       key === method,
                       `${inspect(value)}: ${key}, ` +
                       `${method}, ${types[key](value)}`);
  }
}

// Check boxed primitives.
[
  new Boolean(),
  new Number(),
  new String(),
  Object(Symbol()),
  Object(BigInt(0)),
].forEach((entry) => assert(types.isBoxedPrimitive(entry)));

{
  assert(!types.isUint8Array({ [Symbol.toStringTag]: 'Uint8Array' }));
  assert(types.isUint8Array(vm.runInNewContext('new Uint8Array')));

  assert(!types.isUint8ClampedArray({
    [Symbol.toStringTag]: 'Uint8ClampedArray'
  }));
  assert(types.isUint8ClampedArray(
    vm.runInNewContext('new Uint8ClampedArray')
  ));

  assert(!types.isUint16Array({ [Symbol.toStringTag]: 'Uint16Array' }));
  assert(types.isUint16Array(vm.runInNewContext('new Uint16Array')));

  assert(!types.isUint32Array({ [Symbol.toStringTag]: 'Uint32Array' }));
  assert(types.isUint32Array(vm.runInNewContext('new Uint32Array')));

  assert(!types.isInt8Array({ [Symbol.toStringTag]: 'Int8Array' }));
  assert(types.isInt8Array(vm.runInNewContext('new Int8Array')));

  assert(!types.isInt16Array({ [Symbol.toStringTag]: 'Int16Array' }));
  assert(types.isInt16Array(vm.runInNewContext('new Int16Array')));

  assert(!types.isInt32Array({ [Symbol.toStringTag]: 'Int32Array' }));
  assert(types.isInt32Array(vm.runInNewContext('new Int32Array')));

  assert(!types.isFloat32Array({ [Symbol.toStringTag]: 'Float32Array' }));
  assert(types.isFloat32Array(vm.runInNewContext('new Float32Array')));

  assert(!types.isFloat64Array({ [Symbol.toStringTag]: 'Float64Array' }));
  assert(types.isFloat64Array(vm.runInNewContext('new Float64Array')));

  assert(!types.isBigInt64Array({ [Symbol.toStringTag]: 'BigInt64Array' }));
  assert(types.isBigInt64Array(vm.runInNewContext('new BigInt64Array')));

  assert(!types.isBigUint64Array({ [Symbol.toStringTag]: 'BigUint64Array' }));
  assert(types.isBigUint64Array(vm.runInNewContext('new BigUint64Array')));
}

{
  const primitive = true;
  const arrayBuffer = new ArrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  const dataView = new DataView(arrayBuffer);
  const uint8Array = new Uint8Array(arrayBuffer);
  const uint8ClampedArray = new Uint8ClampedArray(arrayBuffer);
  const uint16Array = new Uint16Array(arrayBuffer);
  const uint32Array = new Uint32Array(arrayBuffer);
  const int8Array = new Int8Array(arrayBuffer);
  const int16Array = new Int16Array(arrayBuffer);
  const int32Array = new Int32Array(arrayBuffer);
  const float32Array = new Float32Array(arrayBuffer);
  const float64Array = new Float64Array(arrayBuffer);
  const bigInt64Array = new BigInt64Array(arrayBuffer);
  const bigUint64Array = new BigUint64Array(arrayBuffer);

  const fakeBuffer = { __proto__: Buffer.prototype };
  const fakeDataView = { __proto__: DataView.prototype };
  const fakeUint8Array = { __proto__: Uint8Array.prototype };
  const fakeUint8ClampedArray = { __proto__: Uint8ClampedArray.prototype };
  const fakeUint16Array = { __proto__: Uint16Array.prototype };
  const fakeUint32Array = { __proto__: Uint32Array.prototype };
  const fakeInt8Array = { __proto__: Int8Array.prototype };
  const fakeInt16Array = { __proto__: Int16Array.prototype };
  const fakeInt32Array = { __proto__: Int32Array.prototype };
  const fakeFloat32Array = { __proto__: Float32Array.prototype };
  const fakeFloat64Array = { __proto__: Float64Array.prototype };
  const fakeBigInt64Array = { __proto__: BigInt64Array.prototype };
  const fakeBigUint64Array = { __proto__: BigUint64Array.prototype };

  const stealthyDataView =
    Object.setPrototypeOf(new DataView(arrayBuffer), Uint8Array.prototype);
  const stealthyUint8Array =
    Object.setPrototypeOf(new Uint8Array(arrayBuffer), ArrayBuffer.prototype);
  const stealthyUint8ClampedArray =
    Object.setPrototypeOf(
      new Uint8ClampedArray(arrayBuffer), ArrayBuffer.prototype
    );
  const stealthyUint16Array =
    Object.setPrototypeOf(new Uint16Array(arrayBuffer), Uint16Array.prototype);
  const stealthyUint32Array =
    Object.setPrototypeOf(new Uint32Array(arrayBuffer), Uint32Array.prototype);
  const stealthyInt8Array =
    Object.setPrototypeOf(new Int8Array(arrayBuffer), Int8Array.prototype);
  const stealthyInt16Array =
    Object.setPrototypeOf(new Int16Array(arrayBuffer), Int16Array.prototype);
  const stealthyInt32Array =
    Object.setPrototypeOf(new Int32Array(arrayBuffer), Int32Array.prototype);
  const stealthyFloat32Array =
    Object.setPrototypeOf(
      new Float32Array(arrayBuffer), Float32Array.prototype
    );
  const stealthyFloat64Array =
    Object.setPrototypeOf(
      new Float64Array(arrayBuffer), Float64Array.prototype
    );
  const stealthyBigInt64Array =
    Object.setPrototypeOf(
      new BigInt64Array(arrayBuffer), BigInt64Array.prototype
    );
  const stealthyBigUint64Array =
    Object.setPrototypeOf(
      new BigUint64Array(arrayBuffer), BigUint64Array.prototype
    );

  const all = [
    primitive, arrayBuffer, buffer, fakeBuffer,
    dataView, fakeDataView, stealthyDataView,
    uint8Array, fakeUint8Array, stealthyUint8Array,
    uint8ClampedArray, fakeUint8ClampedArray, stealthyUint8ClampedArray,
    uint16Array, fakeUint16Array, stealthyUint16Array,
    uint32Array, fakeUint32Array, stealthyUint32Array,
    int8Array, fakeInt8Array, stealthyInt8Array,
    int16Array, fakeInt16Array, stealthyInt16Array,
    int32Array, fakeInt32Array, stealthyInt32Array,
    float32Array, fakeFloat32Array, stealthyFloat32Array,
    float64Array, fakeFloat64Array, stealthyFloat64Array,
    bigInt64Array, fakeBigInt64Array, stealthyBigInt64Array,
    bigUint64Array, fakeBigUint64Array, stealthyBigUint64Array,
  ];

  const expected = {
    isArrayBufferView: [
      buffer,
      dataView, stealthyDataView,
      uint8Array, stealthyUint8Array,
      uint8ClampedArray, stealthyUint8ClampedArray,
      uint16Array, stealthyUint16Array,
      uint32Array, stealthyUint32Array,
      int8Array, stealthyInt8Array,
      int16Array, stealthyInt16Array,
      int32Array, stealthyInt32Array,
      float32Array, stealthyFloat32Array,
      float64Array, stealthyFloat64Array,
      bigInt64Array, stealthyBigInt64Array,
      bigUint64Array, stealthyBigUint64Array,
    ],
    isTypedArray: [
      buffer,
      uint8Array, stealthyUint8Array,
      uint8ClampedArray, stealthyUint8ClampedArray,
      uint16Array, stealthyUint16Array,
      uint32Array, stealthyUint32Array,
      int8Array, stealthyInt8Array,
      int16Array, stealthyInt16Array,
      int32Array, stealthyInt32Array,
      float32Array, stealthyFloat32Array,
      float64Array, stealthyFloat64Array,
      bigInt64Array, stealthyBigInt64Array,
      bigUint64Array, stealthyBigUint64Array,
    ],
    isUint8Array: [
      buffer, uint8Array, stealthyUint8Array,
    ],
    isUint8ClampedArray: [
      uint8ClampedArray, stealthyUint8ClampedArray,
    ],
    isUint16Array: [
      uint16Array, stealthyUint16Array,
    ],
    isUint32Array: [
      uint32Array, stealthyUint32Array,
    ],
    isInt8Array: [
      int8Array, stealthyInt8Array,
    ],
    isInt16Array: [
      int16Array, stealthyInt16Array,
    ],
    isInt32Array: [
      int32Array, stealthyInt32Array,
    ],
    isFloat32Array: [
      float32Array, stealthyFloat32Array,
    ],
    isFloat64Array: [
      float64Array, stealthyFloat64Array,
    ],
    isBigInt64Array: [
      bigInt64Array, stealthyBigInt64Array,
    ],
    isBigUint64Array: [
      bigUint64Array, stealthyBigUint64Array,
    ]
  };

  for (const testedFunc of Object.keys(expected)) {
    const func = types[testedFunc];
    const yup = [];
    for (const value of all) {
      if (func(value)) {
        yup.push(value);
      }
    }
    console.log('Testing', testedFunc);
    assert.deepStrictEqual(yup, expected[testedFunc]);
  }
}

(async () => {
  const m = new vm.SourceTextModule('');
  await m.link(() => 0);
  await m.evaluate();
  assert.ok(types.isModuleNamespaceObject(m.namespace));
})().then(common.mustCall());

{
  // eslint-disable-next-line node-core/crypto-check
  if (common.hasCrypto) {
    const crypto = require('crypto');
    assert.ok(!types.isKeyObject(crypto.createHash('sha1')));
  }
  assert.ok(!types.isCryptoKey());
  assert.ok(!types.isKeyObject());
}
                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-util.js                                                              0000664 0000000 0000000 00000007132 14746647661 0017623 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Flags: --expose-internals
const common = require('../common');
const assert = require('assert');
const util = require('util');
const errors = require('internal/errors');
const context = require('vm').runInNewContext;

// isArray
assert.strictEqual(util.isArray([]), true);
assert.strictEqual(util.isArray(Array()), true);
assert.strictEqual(util.isArray(new Array()), true);
assert.strictEqual(util.isArray(new Array(5)), true);
assert.strictEqual(util.isArray(new Array('with', 'some', 'entries')), true);
assert.strictEqual(util.isArray(context('Array')()), true);
assert.strictEqual(util.isArray({}), false);
assert.strictEqual(util.isArray({ push: function() {} }), false);
assert.strictEqual(util.isArray(/regexp/), false);
assert.strictEqual(util.isArray(new Error()), false);
assert.strictEqual(util.isArray({ __proto__: Array.prototype }), false);

// _extend
assert.deepStrictEqual(util._extend({ a: 1 }), { a: 1 });
assert.deepStrictEqual(util._extend({ a: 1 }, []), { a: 1 });
assert.deepStrictEqual(util._extend({ a: 1 }, null), { a: 1 });
assert.deepStrictEqual(util._extend({ a: 1 }, true), { a: 1 });
assert.deepStrictEqual(util._extend({ a: 1 }, false), { a: 1 });
assert.deepStrictEqual(util._extend({ a: 1 }, { b: 2 }), { a: 1, b: 2 });
assert.deepStrictEqual(util._extend({ a: 1, b: 2 }, { b: 3 }), { a: 1, b: 3 });

assert.strictEqual(util.toUSVString('string\ud801'), 'string\ufffd');

{
  assert.strictEqual(util.types.isNativeError(new Error()), true);
  assert.strictEqual(util.types.isNativeError(new TypeError()), true);
  assert.strictEqual(util.types.isNativeError(new SyntaxError()), true);
  assert.strictEqual(util.types.isNativeError(new (context('Error'))()), true);
  assert.strictEqual(
    util.types.isNativeError(new (context('TypeError'))()),
    true
  );
  assert.strictEqual(
    util.types.isNativeError(new (context('SyntaxError'))()),
    true
  );
  assert.strictEqual(util.types.isNativeError({}), false);
  assert.strictEqual(
    util.types.isNativeError({ name: 'Error', message: '' }),
    false
  );
  assert.strictEqual(util.types.isNativeError([]), false);
  assert.strictEqual(
    util.types.isNativeError({ __proto__: Error.prototype }),
    false
  );
  assert.strictEqual(
    util.types.isNativeError(new errors.codes.ERR_IPC_CHANNEL_CLOSED()),
    true
  );
}

assert.throws(() => {
  util.stripVTControlCharacters({});
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  message: 'The "str" argument must be of type string.' +
           common.invalidArgTypeHelper({})
});
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-uv-binding-constant.js                                               0000664 0000000 0000000 00000000742 14746647661 0022537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

require('../common');
const assert = require('assert');
const { internalBinding } = require('internal/test/binding');
const uv = internalBinding('uv');

// Ensures that the `UV_...` values in internalBinding('uv')
// are constants.

const keys = Object.keys(uv);
keys.forEach((key) => {
  if (key.startsWith('UV_')) {
    const val = uv[key];
    assert.throws(() => uv[key] = 1, TypeError);
    assert.strictEqual(uv[key], val);
  }
});
                              node-23.7.0/test/parallel/test-uv-errmap.js                                                         0000664 0000000 0000000 00000001032 14746647661 0020555 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

require('../common');
const assert = require('assert');
const {
  getSystemErrorMap,
  _errnoException
} = require('util');

const { internalBinding } = require('internal/test/binding');
const uv = internalBinding('uv');
const uvKeys = Object.keys(uv);

const errMap = getSystemErrorMap();

uvKeys.forEach((key) => {
  if (!key.startsWith('UV_'))
    return;

  const err = _errnoException(uv[key]);
  const name = uv.errname(uv[key]);
  assert.strictEqual(errMap.get(err.errno)[0], name);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-uv-errno.js                                                          0000664 0000000 0000000 00000003232 14746647661 0020420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('assert');
const {
  getSystemErrorName,
  getSystemErrorMessage,
  _errnoException
} = require('util');

const { internalBinding } = require('internal/test/binding');
const uv = internalBinding('uv');
const keys = Object.keys(uv);

assert.strictEqual(uv.errname(-111111), 'Unknown system error -111111');
assert.strictEqual(uv.getErrorMessage(-111111), 'Unknown system error -111111');

keys.forEach((key) => {
  if (!key.startsWith('UV_'))
    return;

  const err = _errnoException(uv[key], 'test');
  const name = uv.errname(uv[key]);
  assert.strictEqual(getSystemErrorName(uv[key]), name);
  assert.notStrictEqual(getSystemErrorMessage(uv[key]),
                        `Unknown system error ${key}`);
  assert.strictEqual(err.code, name);
  assert.strictEqual(err.code, getSystemErrorName(err.errno));
  assert.strictEqual(err.message, `test ${name}`);
});

function runTest(fn) {
  ['test', {}, []].forEach((err) => {
    assert.throws(
      () => fn(err),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The "err" argument must be of type number.' +
                 common.invalidArgTypeHelper(err)
      });
  });

  [0, 1, Infinity, -Infinity, NaN].forEach((err) => {
    assert.throws(
      () => fn(err),
      {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of "err" is out of range. ' +
                 'It must be a negative integer. ' +
                 `Received ${err}`
      });
  });
}

runTest(_errnoException);
runTest(getSystemErrorName);
runTest(getSystemErrorMessage);
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-uv-unmapped-exception.js                                             0000664 0000000 0000000 00000001606 14746647661 0023103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';
require('../common');
const assert = require('assert');
const { UVException, UVExceptionWithHostPort } = require('internal/errors');

{
  const exception = new UVException({ errno: 100, syscall: 'open' });

  assert.strictEqual(exception.message, 'UNKNOWN: unknown error, open');
  assert.strictEqual(exception.errno, 100);
  assert.strictEqual(exception.syscall, 'open');
  assert.strictEqual(exception.code, 'UNKNOWN');
}

{
  const exception = new UVExceptionWithHostPort(100, 'listen', '127.0.0.1', 80);

  assert.strictEqual(exception.message,
                     'listen UNKNOWN: unknown error 127.0.0.1:80');
  assert.strictEqual(exception.code, 'UNKNOWN');
  assert.strictEqual(exception.errno, 100);
  assert.strictEqual(exception.syscall, 'listen');
  assert.strictEqual(exception.address, '127.0.0.1');
  assert.strictEqual(exception.port, 80);
}
                                                                                                                          node-23.7.0/test/parallel/test-v8-collect-gc-profile-exit-before-stop.js                            0000664 0000000 0000000 00000000471 14746647661 0026044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const { GCProfiler } = require('v8');

// Test if it makes the process crash.
{
  const profiler = new GCProfiler();
  profiler.start();
  profiler.stop();
  profiler.start();
  profiler.stop();
}
{
  const profiler = new GCProfiler();
  profiler.start();
  profiler.stop();
}
                                                                                                                                                                                                       node-23.7.0/test/parallel/test-v8-collect-gc-profile-in-worker.js                                   0000664 0000000 0000000 00000000531 14746647661 0024562 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-gc
'use strict';
require('../common');
const { Worker } = require('worker_threads');
const { testGCProfiler } = require('../common/v8');

if (!process.env.isWorker) {
  process.env.isWorker = 1;
  new Worker(__filename);
} else {
  testGCProfiler();
  for (let i = 0; i < 100; i++) {
    new Array(100);
  }
  global?.gc();
}
                                                                                                                                                                       node-23.7.0/test/parallel/test-v8-collect-gc-profile.js                                             0000664 0000000 0000000 00000000305 14746647661 0022646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-gc
'use strict';
require('../common');
const { testGCProfiler } = require('../common/v8');

testGCProfiler();

for (let i = 0; i < 100; i++) {
  new Array(100);
}

global?.gc();
                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-v8-coverage.js                                                       0000664 0000000 0000000 00000017340 14746647661 0020776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

if (!process.features.inspector) return;

const common = require('../common');
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const tmpdir = require('../common/tmpdir');
tmpdir.refresh();

let dirc = 0;
function nextdir() {
  return `cov_${++dirc}`;
}

// Outputs coverage when event loop is drained, with no async logic.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/basic'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('basic.js', coverageDirectory);
  assert.ok(fixtureCoverage);
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[1].count, 0);
}

// Outputs coverage when error is thrown in first tick.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/throw'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 1) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 1);
  const fixtureCoverage = getFixtureCoverage('throw.js', coverageDirectory);
  assert.ok(fixtureCoverage, 'coverage not found for file');
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[1].count, 0);
}

// Outputs coverage when process.exit(1) exits process.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/exit-1'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 1) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 1);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('exit-1.js', coverageDirectory);
  assert.ok(fixtureCoverage, 'coverage not found for file');
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[1].count, 0);
}

// Outputs coverage when process.kill(process.pid, "SIGINT"); exits process.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/sigint'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (!common.isWindows) {
    if (output.signal !== 'SIGINT') {
      console.log(output.stderr.toString());
    }
    assert.strictEqual(output.signal, 'SIGINT');
  }
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('sigint.js', coverageDirectory);
  assert.ok(fixtureCoverage);
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[1].count, 0);
}

// Outputs coverage from subprocess.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/spawn-subprocess'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('subprocess.js',
                                             coverageDirectory);
  assert.ok(fixtureCoverage);
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[1].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[1].ranges[1].count, 0);
}

// Outputs coverage from worker.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/worker'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('subprocess.js',
                                             coverageDirectory);
  assert.ok(fixtureCoverage);
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[1].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[1].ranges[1].count, 0);
}

// Does not output coverage if NODE_V8_COVERAGE is empty.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/spawn-subprocess-no-cov'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('subprocess.js',
                                             coverageDirectory);
  assert.strictEqual(fixtureCoverage, undefined);
}

// Disables async hooks before writing coverage.
{
  const coverageDirectory = tmpdir.resolve(nextdir());
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/async-hooks'),
  ], { env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory } });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('async-hooks.js',
                                             coverageDirectory);
  assert.ok(fixtureCoverage);
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[0].count, 1);
}

// Outputs coverage when the coverage directory is not absolute.
{
  const coverageDirectory = nextdir();
  const absoluteCoverageDirectory = tmpdir.resolve(coverageDirectory);
  const output = spawnSync(process.execPath, [
    require.resolve('../fixtures/v8-coverage/basic'),
  ], {
    cwd: tmpdir.path,
    env: { ...process.env, NODE_V8_COVERAGE: coverageDirectory }
  });
  if (output.status !== 0) {
    console.log(output.stderr.toString());
  }
  assert.strictEqual(output.status, 0);
  assert.strictEqual(output.stderr.toString(), '');
  const fixtureCoverage = getFixtureCoverage('basic.js',
                                             absoluteCoverageDirectory);
  assert.ok(fixtureCoverage);
  // First branch executed.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[0].count, 1);
  // Second branch did not execute.
  assert.strictEqual(fixtureCoverage.functions[0].ranges[1].count, 0);
}

// Extracts the coverage object for a given fixture name.
function getFixtureCoverage(fixtureFile, coverageDirectory) {
  const coverageFiles = fs.readdirSync(coverageDirectory);
  for (const coverageFile of coverageFiles) {
    const coverage = require(path.join(coverageDirectory, coverageFile));
    for (const fixtureCoverage of coverage.result) {
      if (fixtureCoverage.url.indexOf(`/${fixtureFile}`) !== -1) {
        return fixtureCoverage;
      }
    }
  }
}
                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-v8-deserialize-buffer.js                                             0000664 0000000 0000000 00000000631 14746647661 0022745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const v8 = require('v8');

process.on('warning', common.mustNotCall());
v8.deserialize(v8.serialize(Buffer.alloc(0)));
v8.deserialize(v8.serialize({ a: new Int32Array(1024) }));
v8.deserialize(v8.serialize({ b: new Int16Array(8192) }));
v8.deserialize(v8.serialize({ c: new Uint32Array(1024) }));
v8.deserialize(v8.serialize({ d: new Uint16Array(8192) }));
                                                                                                       node-23.7.0/test/parallel/test-v8-flag-pool-size-0.js                                               0000664 0000000 0000000 00000000434 14746647661 0022164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --v8-pool-size=0 --expose-gc

'use strict';

require('../common');

// This verifies that V8 tasks scheduled by GC are handled on worker threads if
// `--v8-pool-size=0` is given. The worker threads are managed by Node.js'
// `v8::Platform` implementation.
globalThis.gc();
                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-v8-flag-type-check.js                                                0000664 0000000 0000000 00000000621 14746647661 0022140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const v8 = require('v8');

[1, undefined].forEach((value) => {
  assert.throws(
    () => v8.setFlagsFromString(value),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The "flags" argument must be of type string.' +
               common.invalidArgTypeHelper(value)
    }
  );
});
                                                                                                               node-23.7.0/test/parallel/test-v8-flags.js                                                          0000664 0000000 0000000 00000001353 14746647661 0020274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const v8 = require('v8');
const vm = require('vm');

// Note: changing V8 flags after an isolate started is not guaranteed to work.
// Specifically here, V8 may cache compiled scripts between the flip of the
// flag. We use a different script each time to work around this problem.
v8.setFlagsFromString('--allow_natives_syntax');
assert(eval('%IsSmi(42)'));
assert(vm.runInThisContext('%IsSmi(43)'));

v8.setFlagsFromString('--noallow_natives_syntax');
assert.throws(function() { eval('%IsSmi(44)'); },
              /^SyntaxError: Unexpected token '%'$/);
assert.throws(function() { vm.runInThisContext('%IsSmi(45)'); },
              /^SyntaxError: Unexpected token '%'$/);
                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-v8-getheapsnapshot-twice.js                                          0000664 0000000 0000000 00000000510 14746647661 0023500 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const v8 = require('v8');

// Regression test for https://github.com/nodejs/node/issues/35559
// It is important that the return value of the first call is not used, i.e.
// that the first snapshot is GC-able while the second one is being created.
v8.getHeapSnapshot();
v8.getHeapSnapshot();
                                                                                                                                                                                        node-23.7.0/test/parallel/test-v8-global-setter.js                                                  0000664 0000000 0000000 00000002611 14746647661 0021742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');

// This test ensures v8 correctly sets a property on the global object if it
// has a setter interceptor in strict mode.
// https://github.com/nodejs/node-v0.x-archive/issues/6235

require('vm').runInNewContext('"use strict"; var v = 1; v = 2');
                                                                                                                       node-23.7.0/test/parallel/test-v8-query-objects.js                                                  0000664 0000000 0000000 00000007307 14746647661 0022001 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests the v8.queryObjects() API.

const common = require('../common');
const v8 = require('v8');
const assert = require('assert');
const { inspect } = require('util');

function format(obj) {
  return inspect(obj, { depth: 0 });
}

common.expectWarning(
  'ExperimentalWarning',
  'v8.queryObjects() is an experimental feature and might change at any time',
);

{
  for (const invalid of [undefined, 1, null, false, {}, 'foo']) {
    assert.throws(() => v8.queryObjects(invalid), { code: 'ERR_INVALID_ARG_TYPE' });
  }
  for (const invalid of [1, null, false, 'foo']) {
    assert.throws(() => v8.queryObjects(() => {}, invalid), { code: 'ERR_INVALID_ARG_TYPE' });
  }
  assert.throws(() => v8.queryObjects(() => {}, { format: 'invalid' }), { code: 'ERR_INVALID_ARG_VALUE' });
}

{
  class TestV8QueryObjectsClass {}
  // By default, returns count of objects with the constructor on the prototype.
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsClass), 0);
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsClass, { format: 'count' }), 0);
  // 'summary' format returns an array.
  assert.deepStrictEqual(v8.queryObjects(TestV8QueryObjectsClass, { format: 'summary' }), []);

  // Create an instance and check that it shows up in the results.
  const obj = new TestV8QueryObjectsClass();
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsClass), 1);
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsClass, { format: 'count' }), 1);
  assert.deepStrictEqual(
    v8.queryObjects(TestV8QueryObjectsClass, { format: 'summary' }),
    [ format(obj)]
  );
}

{
  // ES6 class inheritance.
  class TestV8QueryObjectsBaseClass {}
  class TestV8QueryObjectsChildClass extends TestV8QueryObjectsBaseClass {}
  const summary = v8.queryObjects(TestV8QueryObjectsBaseClass, { format: 'summary' });
  // TestV8QueryObjectsChildClass's prototype's [[Prototype]] slot is
  // TestV8QueryObjectsBaseClass's prototype so it shows up in the query.
  assert.deepStrictEqual(summary, [
    format(TestV8QueryObjectsChildClass.prototype),
  ]);
  const obj = new TestV8QueryObjectsChildClass();
  assert.deepStrictEqual(
    v8.queryObjects(TestV8QueryObjectsBaseClass, { format: 'summary' }).sort(),
    [
      format(TestV8QueryObjectsChildClass.prototype),
      format(obj),
    ].sort()
  );
  assert.deepStrictEqual(
    v8.queryObjects(TestV8QueryObjectsChildClass, { format: 'summary' }),
    [ format(obj) ],
  );
}

{
  function TestV8QueryObjectsCtor() {}
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsCtor), 0);
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsCtor, { format: 'count' }), 0);
  assert.deepStrictEqual(v8.queryObjects(TestV8QueryObjectsCtor, { format: 'summary' }), []);

  // Create an instance and check that it shows up in the results.
  const obj = new TestV8QueryObjectsCtor();
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsCtor), 1);
  assert.strictEqual(v8.queryObjects(TestV8QueryObjectsCtor, { format: 'count' }), 1);
  assert.deepStrictEqual(
    v8.queryObjects(TestV8QueryObjectsCtor, { format: 'summary' }),
    [ format(obj)]
  );
}

{
  // Classic inheritance.
  function TestV8QueryObjectsBaseCtor() {}

  function TestV8QueryObjectsChildCtor() {}
  Object.setPrototypeOf(TestV8QueryObjectsChildCtor.prototype, TestV8QueryObjectsBaseCtor.prototype);
  Object.setPrototypeOf(TestV8QueryObjectsChildCtor, TestV8QueryObjectsBaseCtor);

  const summary = v8.queryObjects(TestV8QueryObjectsBaseCtor, { format: 'summary' });
  assert.deepStrictEqual(summary, [
    format(TestV8QueryObjectsChildCtor.prototype),
  ]);
  const obj = new TestV8QueryObjectsChildCtor();
  assert.deepStrictEqual(
    v8.queryObjects(TestV8QueryObjectsChildCtor, { format: 'summary' }),
    [ format(obj) ],
  );
}
                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-v8-serdes.js                                                         0000664 0000000 0000000 00000016445 14746647661 0020475 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --js-float16array

'use strict';

const common = require('../common');
const { internalBinding } = require('internal/test/binding');
const assert = require('assert');
const v8 = require('v8');
const os = require('os');
// TODO(bartlomieju): once `Float16Array` is available in stable V8,
// remove this line and `--js-float16array` flag up top
const { Float16Array } = globalThis;

const circular = {};
circular.circular = circular;

const objects = [
  { foo: 'bar' },
  { bar: 'baz' },
  new Int8Array([1, 2, 3, 4]),
  new Uint8Array([1, 2, 3, 4]),
  new Int16Array([1, 2, 3, 4]),
  new Uint16Array([1, 2, 3, 4]),
  new Int32Array([1, 2, 3, 4]),
  new Uint32Array([1, 2, 3, 4]),
  new Float32Array([1, 2, 3, 4]),
  new Float64Array([1, 2, 3, 4]),
  new DataView(new ArrayBuffer(42)),
  Buffer.from([1, 2, 3, 4]),
  new BigInt64Array([42n]),
  new BigUint64Array([42n]),
  new Float16Array([1, 2, 3, 4]),
  undefined,
  null,
  42,
  circular,
];

const hostObject = new (internalBinding('js_stream').JSStream)();

{
  const ser = new v8.DefaultSerializer();
  ser.writeHeader();
  for (const obj of objects) {
    ser.writeValue(obj);
  }

  const des = new v8.DefaultDeserializer(ser.releaseBuffer());
  des.readHeader();

  for (const obj of objects) {
    assert.deepStrictEqual(des.readValue(), obj);
  }
}

{
  for (const obj of objects) {
    assert.deepStrictEqual(v8.deserialize(v8.serialize(obj)), obj);
  }
}

{
  const ser = new v8.DefaultSerializer();
  ser._getDataCloneError = common.mustCall((message) => {
    assert.strictEqual(message, '#<Object> could not be cloned.');
    return new Error('foobar');
  });

  ser.writeHeader();

  assert.throws(() => {
    ser.writeValue(new Proxy({}, {}));
  }, /foobar/);
}

{
  const ser = new v8.DefaultSerializer();
  ser._writeHostObject = common.mustCall((object) => {
    assert.strictEqual(object, hostObject);
    const buf = Buffer.from('hostObjectTag');

    ser.writeUint32(buf.length);
    ser.writeRawBytes(buf);

    ser.writeUint64(1, 2);
    ser.writeDouble(-0.25);
  });

  ser.writeHeader();
  ser.writeValue({ val: hostObject });

  const des = new v8.DefaultDeserializer(ser.releaseBuffer());
  des._readHostObject = common.mustCall(() => {
    const length = des.readUint32();
    const buf = des.readRawBytes(length);

    assert.strictEqual(buf.toString(), 'hostObjectTag');

    assert.deepStrictEqual(des.readUint64(), [1, 2]);
    assert.strictEqual(des.readDouble(), -0.25);
    return hostObject;
  });

  des.readHeader();

  assert.strictEqual(des.readValue().val, hostObject);
}

// This test ensures that `v8.Serializer.writeRawBytes()` support
// `TypedArray` and `DataView`.
{
  const text = 'hostObjectTag';
  const data = Buffer.from(text);

  // `buf` is one of `TypedArray` or `DataView`.
  function testWriteRawBytes(buf) {
    let writeHostObjectCalled = false;
    const ser = new v8.DefaultSerializer();

    ser._writeHostObject = common.mustCall((object) => {
      writeHostObjectCalled = true;
      ser.writeUint32(buf.byteLength);
      ser.writeRawBytes(buf);
    });

    ser.writeHeader();
    ser.writeValue({ val: hostObject });

    const des = new v8.DefaultDeserializer(ser.releaseBuffer());
    des._readHostObject = common.mustCall(() => {
      assert.strictEqual(writeHostObjectCalled, true);
      const length = des.readUint32();
      const buf = des.readRawBytes(length);
      assert.strictEqual(buf.toString(), text);

      return hostObject;
    });

    des.readHeader();

    assert.strictEqual(des.readValue().val, hostObject);
  }

  for (const buf of common.getArrayBufferViews(data)) {
    testWriteRawBytes(buf);
  }
}

{
  const ser = new v8.DefaultSerializer();
  ser._writeHostObject = common.mustCall((object) => {
    throw new Error('foobar');
  });

  ser.writeHeader();
  assert.throws(() => {
    ser.writeValue({ val: hostObject });
  }, /foobar/);
}

{
  assert.throws(() => v8.serialize(hostObject), {
    constructor: Error,
    message: 'Unserializable host object: JSStream {}'
  });
}

{
  // Test that an old serialized value can still be deserialized.
  const buf = Buffer.from('ff0d6f2203666f6f5e007b01', 'hex');

  const des = new v8.DefaultDeserializer(buf);
  des.readHeader();
  assert.strictEqual(des.getWireFormatVersion(), 0x0d);

  const value = des.readValue();
  assert.strictEqual(value, value.foo);
}

{
  const message = `New serialization format.

    This test is expected to fail when V8 changes its serialization format.
    When that happens, the "desStr" variable must be updated to the new value
    and the change should be mentioned in the release notes, as it is semver-major.

    Consider opening an issue as a heads up at https://github.com/nodejs/node/issues/new
  `;

  const desStr = 'ff0f6f2203666f6f5e007b01';

  const desBuf = Buffer.from(desStr, 'hex');
  const des = new v8.DefaultDeserializer(desBuf);
  des.readHeader();
  const value = des.readValue();

  const ser = new v8.DefaultSerializer();
  ser.writeHeader();
  ser.writeValue(value);

  const serBuf = ser.releaseBuffer();
  const serStr = serBuf.toString('hex');
  assert.deepStrictEqual(serStr, desStr, message);
}

{
  // Unaligned Uint16Array read, with padding in the underlying array buffer.
  let buf = Buffer.alloc(32 + 9);
  buf.write('ff0d5c0404addeefbe', 32, 'hex');
  buf = buf.slice(32);

  const expectedResult = os.endianness() === 'LE' ?
    new Uint16Array([0xdead, 0xbeef]) : new Uint16Array([0xadde, 0xefbe]);

  assert.deepStrictEqual(v8.deserialize(buf), expectedResult);
}

{
  assert.throws(() => v8.Serializer(), {
    constructor: TypeError,
    message: "Class constructor Serializer cannot be invoked without 'new'",
    code: 'ERR_CONSTRUCT_CALL_REQUIRED'
  });
  assert.throws(() => v8.Deserializer(), {
    constructor: TypeError,
    message: "Class constructor Deserializer cannot be invoked without 'new'",
    code: 'ERR_CONSTRUCT_CALL_REQUIRED'
  });
}


// `v8.deserialize()` and `new v8.Deserializer()` should support both
// `TypedArray` and `DataView`.
{
  for (const obj of objects) {
    const buf = v8.serialize(obj);

    for (const arrayBufferView of common.getArrayBufferViews(buf)) {
      assert.deepStrictEqual(v8.deserialize(arrayBufferView), obj);
    }

    for (const arrayBufferView of common.getArrayBufferViews(buf)) {
      const deserializer = new v8.DefaultDeserializer(arrayBufferView);
      deserializer.readHeader();
      const value = deserializer.readValue();
      assert.deepStrictEqual(value, obj);

      const serializer = new v8.DefaultSerializer();
      serializer.writeHeader();
      serializer.writeValue(value);
      assert.deepStrictEqual(buf, serializer.releaseBuffer());
    }
  }
}

{
  const INVALID_SOURCE = 'INVALID_SOURCE_TYPE';
  const serializer = new v8.Serializer();
  serializer.writeHeader();
  assert.throws(
    () => serializer.writeRawBytes(INVALID_SOURCE),
    /^TypeError: source must be a TypedArray or a DataView$/,
  );
  assert.throws(
    () => v8.deserialize(INVALID_SOURCE),
    /^TypeError: buffer must be a TypedArray or a DataView$/,
  );
  assert.throws(
    () => new v8.Deserializer(INVALID_SOURCE),
    /^TypeError: buffer must be a TypedArray or a DataView$/,
  );
}

{
  // Regression test for https://github.com/nodejs/node/issues/37978
  assert.throws(() => {
    new v8.Deserializer(new v8.Serializer().releaseBuffer()).readDouble();
  }, /ReadDouble\(\) failed/);
}
                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-v8-serialize-leak.js                                                 0000664 0000000 0000000 00000001607 14746647661 0022103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-gc

const common = require('../common');
const { gcUntil } = require('../common/gc');

// On IBMi, the rss memory always returns zero
if (common.isIBMi)
  common.skip('On IBMi, the rss memory always returns zero');

const v8 = require('v8');

const before = process.memoryUsage.rss();

for (let i = 0; i < 1000000; i++) {
  v8.serialize('');
}

async function main() {
  await gcUntil('RSS should go down', () => {
    const after = process.memoryUsage.rss();
    if (common.isASan) {
      console.log(`ASan: before=${before} after=${after}`);
      return after < before * 10;
    } else if (process.config.variables.node_builtin_modules_path) {
      console.log(`node_builtin_modules_path: before=${before} after=${after}`);
      return after < before * 10;
    }
    console.log(`before=${before} after=${after}`);
    return after < before * 10;
  });
}

main();
                                                                                                                         node-23.7.0/test/parallel/test-v8-startup-snapshot-api.js                                           0000664 0000000 0000000 00000001215 14746647661 0023303 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

const {
  isBuildingSnapshot,
  addSerializeCallback,
  addDeserializeCallback,
  setDeserializeMainFunction
} = require('v8').startupSnapshot;

// This test verifies that the v8.startupSnapshot APIs are not available when
// it is not building snapshot.

assert(!isBuildingSnapshot());

assert.throws(() => addSerializeCallback(() => {}), {
  code: 'ERR_NOT_BUILDING_SNAPSHOT',
});
assert.throws(() => addDeserializeCallback(() => {}), {
  code: 'ERR_NOT_BUILDING_SNAPSHOT',
});
assert.throws(() => setDeserializeMainFunction(() => {}), {
  code: 'ERR_NOT_BUILDING_SNAPSHOT',
});
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-v8-stats.js                                                          0000664 0000000 0000000 00000003743 14746647661 0020343 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const v8 = require('v8');

const s = v8.getHeapStatistics();
const keys = [
  'does_zap_garbage',
  'external_memory',
  'heap_size_limit',
  'malloced_memory',
  'number_of_detached_contexts',
  'number_of_native_contexts',
  'peak_malloced_memory',
  'total_available_size',
  'total_global_handles_size',
  'total_heap_size',
  'total_heap_size_executable',
  'total_physical_size',
  'used_global_handles_size',
  'used_heap_size'];
assert.deepStrictEqual(Object.keys(s).sort(), keys);
keys.forEach(function(key) {
  assert.strictEqual(typeof s[key], 'number');
});


const heapCodeStatistics = v8.getHeapCodeStatistics();
const heapCodeStatisticsKeys = [
  'bytecode_and_metadata_size',
  'code_and_metadata_size',
  'cpu_profiler_metadata_size',
  'external_script_source_size'];
assert.deepStrictEqual(Object.keys(heapCodeStatistics).sort(),
                       heapCodeStatisticsKeys);
heapCodeStatisticsKeys.forEach(function(key) {
  assert.strictEqual(typeof heapCodeStatistics[key], 'number');
});


const expectedHeapSpaces = [
  'code_large_object_space',
  'code_space',
  'large_object_space',
  'new_large_object_space',
  'new_space',
  'old_space',
  'read_only_space',
  'shared_large_object_space',
  'shared_space',
  'shared_trusted_large_object_space',
  'shared_trusted_space',
  'trusted_large_object_space',
  'trusted_space',
];
const heapSpaceStatistics = v8.getHeapSpaceStatistics();
const actualHeapSpaceNames = heapSpaceStatistics.map((s) => s.space_name);
assert.deepStrictEqual(actualHeapSpaceNames.sort(), expectedHeapSpaces.sort());
heapSpaceStatistics.forEach((heapSpace) => {
  assert.strictEqual(typeof heapSpace.space_name, 'string');
  assert.strictEqual(typeof heapSpace.space_size, 'number');
  assert.strictEqual(typeof heapSpace.space_used_size, 'number');
  assert.strictEqual(typeof heapSpace.space_available_size, 'number');
  assert.strictEqual(typeof heapSpace.physical_space_size, 'number');
});
                             node-23.7.0/test/parallel/test-v8-stop-coverage.js                                                  0000664 0000000 0000000 00000001572 14746647661 0021761 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

if (!process.features.inspector) return;

require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const fs = require('fs');
const { spawnSync } = require('child_process');

tmpdir.refresh();
const intervals = 20;

{
  const output = spawnSync(process.execPath, [
    '-r',
    fixtures.path('v8-coverage', 'stop-coverage'),
    '-r',
    fixtures.path('v8-coverage', 'take-coverage'),
    fixtures.path('v8-coverage', 'interval'),
  ], {
    env: {
      ...process.env,
      NODE_V8_COVERAGE: tmpdir.path,
      NODE_DEBUG_NATIVE: 'INSPECTOR_PROFILER',
      TEST_INTERVALS: intervals
    },
  });
  console.log(output.stderr.toString());
  assert.strictEqual(output.status, 0);
  const coverageFiles = fs.readdirSync(tmpdir.path);
  assert.strictEqual(coverageFiles.length, 0);
}
                                                                                                                                      node-23.7.0/test/parallel/test-v8-take-coverage-noop.js                                             0000664 0000000 0000000 00000001536 14746647661 0022671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

if (!process.features.inspector) return;

require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const fs = require('fs');
const { spawnSync } = require('child_process');

tmpdir.refresh();

// v8.takeCoverage() should be a noop if NODE_V8_COVERAGE is not set.
const intervals = 40;
{
  const output = spawnSync(process.execPath, [
    '-r',
    fixtures.path('v8-coverage', 'take-coverage'),
    fixtures.path('v8-coverage', 'interval'),
  ], {
    env: {
      ...process.env,
      NODE_DEBUG_NATIVE: 'INSPECTOR_PROFILER',
      TEST_INTERVALS: intervals
    },
  });
  console.log(output.stderr.toString());
  assert.strictEqual(output.status, 0);
  const coverageFiles = fs.readdirSync(tmpdir.path);
  assert.strictEqual(coverageFiles.length, 0);
}
                                                                                                                                                                  node-23.7.0/test/parallel/test-v8-take-coverage.js                                                  0000664 0000000 0000000 00000005340 14746647661 0021715 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

if (!process.features.inspector) return;

require('../common');
const fixtures = require('../common/fixtures');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const fs = require('fs');
const { spawnSync } = require('child_process');

tmpdir.refresh();
const intervals = 40;
// Outputs coverage when v8.takeCoverage() is invoked.
{
  const output = spawnSync(process.execPath, [
    '-r',
    fixtures.path('v8-coverage', 'take-coverage'),
    fixtures.path('v8-coverage', 'interval'),
  ], {
    env: {
      ...process.env,
      NODE_V8_COVERAGE: tmpdir.path,
      NODE_DEBUG_NATIVE: 'INSPECTOR_PROFILER',
      TEST_INTERVALS: intervals
    },
  });
  console.log(output.stderr.toString());
  assert.strictEqual(output.status, 0);
  const coverageFiles = fs.readdirSync(tmpdir.path);

  let coverages = [];
  for (const coverageFile of coverageFiles) {
    const coverage = require(tmpdir.resolve(coverageFile));
    for (const result of coverage.result) {
      if (result.url.includes('/interval')) {
        coverages.push({
          file: coverageFile,
          func: result.functions.find((f) => f.functionName === 'interval'),
          timestamp: coverage.timestamp
        });
      }
    }
  }

  coverages = coverages.sort((a, b) => { return a.timestamp - b.timestamp; });
  // There should be two coverages taken, one triggered by v8.takeCoverage(),
  // the other by process exit.
  console.log('Coverages:', coverages);
  assert.strictEqual(coverages.length, 3);

  let blockHitsTotal = 0;
  for (let i = 0; i < coverages.length; ++i) {
    const { ranges } = coverages[i].func;
    console.log('coverage', i, ranges);

    if (i !== coverages.length - 1) {
      // When the first two coverages are taken:
      assert.strictEqual(ranges.length, 2);
      const blockHits = ranges[0].count;
      // The block inside interval() should be hit at least once.
      assert.notStrictEqual(blockHits, 0);
      blockHitsTotal += blockHits;
      // The else branch should not be hit.
      const elseBranchHits = ranges[1].count;
      assert.strictEqual(elseBranchHits, 0);
    } else {
      // At process exit:
      assert.strictEqual(ranges.length, 3);
      const blockHits = ranges[0].count;
      // The block inside interval() should be hit at least once more.
      assert.notStrictEqual(blockHits, 0);
      blockHitsTotal += blockHits;
      // The else branch should be hit exactly once.
      const elseBranchHits = ranges[2].count;
      assert.strictEqual(elseBranchHits, 1);
      const ifBranchHits = ranges[1].count;
      assert.strictEqual(ifBranchHits, blockHits - elseBranchHits);
    }
  }

  // The block should be hit `intervals` times in total.
  assert.strictEqual(blockHitsTotal, intervals);
}
                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-v8-version-tag.js                                                    0000664 0000000 0000000 00000001307 14746647661 0021435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const v8 = require('v8');

const versionTag1 = v8.cachedDataVersionTag();
assert.strictEqual(typeof versionTag1, 'number');
assert.strictEqual(v8.cachedDataVersionTag(), versionTag1);

// The value returned by v8.cachedDataVersionTag() is derived from the V8
// version, command-line flags, and detected CPU features. Test that the value
// does indeed update when flags are toggled.
v8.setFlagsFromString('--allow_natives_syntax');

const versionTag2 = v8.cachedDataVersionTag();
assert.strictEqual(typeof versionTag2, 'number');
assert.strictEqual(v8.cachedDataVersionTag(), versionTag2);

assert.notStrictEqual(versionTag1, versionTag2);
                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-validators.js                                                        0000664 0000000 0000000 00000011544 14746647661 0021020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

require('../common');
const assert = require('assert');
const {
  validateArray,
  validateBoolean,
  validateInteger,
  validateNumber,
  validateObject,
  kValidateObjectAllowNullable,
  kValidateObjectAllowArray,
  kValidateObjectAllowFunction,
  validateString,
  validateInt32,
  validateUint32,
  validateLinkHeaderValue,
} = require('internal/validators');
const { MAX_SAFE_INTEGER, MIN_SAFE_INTEGER } = Number;
const outOfRangeError = {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
};
const invalidArgTypeError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
};
const invalidArgValueError = {
  code: 'ERR_INVALID_ARG_VALUE',
  name: 'TypeError',
};

{
  // validateInteger tests.

  // validateInteger() defaults to validating safe integers.
  validateInteger(MAX_SAFE_INTEGER, 'foo');
  validateInteger(MIN_SAFE_INTEGER, 'foo');
  assert.throws(() => {
    validateInteger(MAX_SAFE_INTEGER + 1, 'foo');
  }, outOfRangeError);
  assert.throws(() => {
    validateInteger(MIN_SAFE_INTEGER - 1, 'foo');
  }, outOfRangeError);

  // validateInteger() works with unsafe integers.
  validateInteger(MAX_SAFE_INTEGER + 1, 'foo', 0, MAX_SAFE_INTEGER + 1);
  validateInteger(MIN_SAFE_INTEGER - 1, 'foo', MIN_SAFE_INTEGER - 1);

  // validateInt32() and validateUint32()
  [
    Symbol(), 1n, {}, [], false, true, undefined, null, () => {}, '', '1',
  ].forEach((val) => assert.throws(() => validateInt32(val, 'name'), {
    code: 'ERR_INVALID_ARG_TYPE'
  }));
  [
    2147483647 + 1, -2147483648 - 1, NaN,
  ].forEach((val) => assert.throws(() => validateInt32(val, 'name'), {
    code: 'ERR_OUT_OF_RANGE'
  }));
  [
    0, 1, -1,
  ].forEach((val) => validateInt32(val, 'name'));
  [
    Symbol(), 1n, {}, [], false, true, undefined, null, () => {}, '', '1',
  ].forEach((val) => assert.throws(() => validateUint32(val, 'name'), {
    code: 'ERR_INVALID_ARG_TYPE'
  }));
  [
    4294967296, -1, NaN,
  ].forEach((val) => assert.throws(() => validateUint32(val, 'name'), {
    code: 'ERR_OUT_OF_RANGE'
  }));
  [
    0, 1,
  ].forEach((val) => validateUint32(val, 'name'));
}

{
  // validateArray tests.
  validateArray([], 'foo');
  validateArray([1, 2, 3], 'foo');

  [undefined, null, true, false, 0, 0.0, 42, '', 'string', {}]
    .forEach((val) => {
      assert.throws(() => {
        validateArray(val, 'foo');
      }, invalidArgTypeError);
    });

  validateArray([1], 'foo', 1);
  assert.throws(() => {
    validateArray([], 'foo', 1);
  }, invalidArgValueError);
}

{
  // validateBoolean tests.
  validateBoolean(true, 'foo');
  validateBoolean(false, 'foo');

  [undefined, null, 0, 0.0, 42, '', 'string', {}, []].forEach((val) => {
    assert.throws(() => {
      validateBoolean(val, 'foo');
    }, invalidArgTypeError);
  });
}

{
  // validateObject tests.
  validateObject({}, 'foo');
  validateObject({ a: 42, b: 'foo' }, 'foo');

  [undefined, null, true, false, 0, 0.0, 42, '', 'string', [], () => {}]
    .forEach((val) => {
      assert.throws(() => {
        validateObject(val, 'foo');
      }, invalidArgTypeError);
    });

  // validateObject options tests:
  validateObject(null, 'foo', kValidateObjectAllowNullable);
  validateObject([], 'foo', kValidateObjectAllowArray);
  validateObject(() => {}, 'foo', kValidateObjectAllowFunction);

  // validateObject should not be affected by Object.prototype tampering.
  assert.throws(() => validateObject(null, 'foo', kValidateObjectAllowArray), invalidArgTypeError);
  assert.throws(() => validateObject([], 'foo', kValidateObjectAllowNullable), invalidArgTypeError);
  assert.throws(() => validateObject(() => {}, 'foo', kValidateObjectAllowNullable), invalidArgTypeError);
}

{
  // validateString type validation.
  [
    -1, {}, [], false, true,
    1, Infinity, -Infinity, NaN,
    undefined, null, 1.1,
  ].forEach((i) => assert.throws(() => validateString(i, 'name'), {
    code: 'ERR_INVALID_ARG_TYPE'
  }));
}
{
  // validateNumber type validation.
  [
    'a', {}, [], false, true,
    undefined, null, '', ' ', '0x',
    '-0x1', '-0o1', '-0b1', '0o', '0b',
  ].forEach((i) => assert.throws(() => validateNumber(i, 'name'), {
    code: 'ERR_INVALID_ARG_TYPE'
  }));
}

{
  // validateLinkHeaderValue type validation.
  [
    ['</styles.css>; rel=preload; as=style', '</styles.css>; rel=preload; as=style'],
    ['</styles.css>; rel=preload; title=hello', '</styles.css>; rel=preload; title=hello'],
    ['</styles.css>; rel=preload; crossorigin=hello', '</styles.css>; rel=preload; crossorigin=hello'],
    ['</styles.css>; rel=preload; disabled=true', '</styles.css>; rel=preload; disabled=true'],
    ['</styles.css>; rel=preload; fetchpriority=high', '</styles.css>; rel=preload; fetchpriority=high'],
    ['</styles.css>; rel=preload; referrerpolicy=origin', '</styles.css>; rel=preload; referrerpolicy=origin'],
  ].forEach(([value, expected]) => assert.strictEqual(validateLinkHeaderValue(value), expected));
}
                                                                                                                                                            node-23.7.0/test/parallel/test-vfs.js                                                               0000664 0000000 0000000 00000004712 14746647661 0017445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// This tests the creation of a vfs by monkey-patching fs and Module._stat.

const Module = require('module');
const fs = require('fs');
const tmpdir = require('../common/tmpdir');
const { deepStrictEqual, ok, strictEqual, throws } = require('assert');
const { join } = require('path');

const directory = tmpdir.resolve('directory');
const doesNotExist = tmpdir.resolve('does-not-exist');
const file = tmpdir.resolve('file.js');

tmpdir.refresh();
fs.writeFileSync(file, "module.exports = { a: 'b' }");
fs.mkdirSync(directory);

strictEqual(Module._stat(directory), 1);
ok(Module._stat(doesNotExist) < 0);
strictEqual(Module._stat(file), 0);

const vfsDirectory = join(process.execPath, 'directory');
const vfsDoesNotExist = join(process.execPath, 'does-not-exist');
const vfsFile = join(process.execPath, 'file.js');

ok(Module._stat(vfsDirectory) < 0);
ok(Module._stat(vfsDoesNotExist) < 0);
ok(Module._stat(vfsFile) < 0);

deepStrictEqual(require(file), { a: 'b' });
throws(() => require(vfsFile), { code: 'MODULE_NOT_FOUND' });

common.expectWarning(
  'ExperimentalWarning',
  'Module._stat is an experimental feature and might change at any time'
);

process.on('warning', common.mustCall());

const originalStat = Module._stat;
Module._stat = function(filename) {
  if (!filename.startsWith(process.execPath)) {
    return originalStat(filename);
  }

  if (filename === process.execPath) {
    return 1;
  }

  switch (filename) {
    case vfsDirectory:
      return 1;
    case vfsDoesNotExist:
      return -2;
    case vfsFile:
      return 0;
  }
};

const originalReadFileSync = fs.readFileSync;
// TODO(aduh95): We'd like to have a better way to achieve this without monkey-patching fs.
fs.readFileSync = function readFileSync(pathArgument, options) {
  if (!pathArgument.startsWith(process.execPath)) {
    return originalReadFileSync.apply(this, arguments);
  }
  if (pathArgument === vfsFile) {
    return "module.exports = { x: 'y' };";
  }
  throw new Error();
};

fs.realpathSync = function realpathSync(pathArgument, options) {
  return pathArgument;
};

strictEqual(Module._stat(directory), 1);
ok(Module._stat(doesNotExist) < 0);
strictEqual(Module._stat(file), 0);

strictEqual(Module._stat(vfsDirectory), 1);
ok(Module._stat(vfsDoesNotExist) < 0);
strictEqual(Module._stat(vfsFile), 0);

strictEqual(Module._stat(process.execPath), 1);

deepStrictEqual(require(file), { a: 'b' });
deepStrictEqual(require(vfsFile), { x: 'y' });
                                                      node-23.7.0/test/parallel/test-vm-access-process-env.js                                             0000664 0000000 0000000 00000003032 14746647661 0022764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Tests that node does neither crash nor throw an error when accessing
// process.env when inside a VM context.
// See https://github.com/nodejs/node-v0.x-archive/issues/7511.

require('../common');
const assert = require('assert');
const vm = require('vm');

const context = vm.createContext({ process });
const result = vm.runInContext('process.env["PATH"]', context);
assert.notStrictEqual(undefined, result);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-vm-api-handles-getter-errors.js                                      0000664 0000000 0000000 00000001713 14746647661 0024254 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Tests that vm.createScript and runInThisContext correctly handle errors
// thrown by option property getters.
// See https://github.com/nodejs/node/issues/12369.

const common = require('../common');
const assert = require('assert');
const execFile = require('child_process').execFile;

const scripts = [];

['filename', 'cachedData', 'produceCachedData', 'lineOffset', 'columnOffset']
  .forEach((prop) => {
    scripts.push(`vm.createScript('', {
      get ${prop} () {
        throw new Error('xyz');
      }
    })`);
  });

['breakOnSigint', 'timeout', 'displayErrors']
  .forEach((prop) => {
    scripts.push(`vm.createScript('').runInThisContext({
      get ${prop} () {
        throw new Error('xyz');
      }
    })`);
  });

scripts.forEach((script) => {
  const node = process.execPath;
  execFile(node, [ '-e', script ], common.mustCall((err, stdout, stderr) => {
    assert(stderr.includes('Error: xyz'), 'createScript crashes');
  }));
});
                                                     node-23.7.0/test/parallel/test-vm-attributes-property-not-on-sandbox.js                             0000664 0000000 0000000 00000001074 14746647661 0026201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

// Assert that accessor descriptors are not flattened on the sandbox.
// Issue: https://github.com/nodejs/node/issues/2734
const sandbox = {};
vm.createContext(sandbox);
const code = `Object.defineProperty(
               this,
               'foo',
               { get: function() {return 17} }
             );
             var desc = Object.getOwnPropertyDescriptor(this, 'foo');`;

vm.runInContext(code, sandbox);
assert.strictEqual(typeof sandbox.desc.get, 'function');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-basic.js                                                          0000664 0000000 0000000 00000023716 14746647661 0020355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');
const vm = require('vm');

// vm.runInNewContext
{
  const sandbox = {};
  const result = vm.runInNewContext(
    'foo = "bar"; this.typeofProcess = typeof process; typeof Object;',
    sandbox
  );
  assert.deepStrictEqual(sandbox, {
    foo: 'bar',
    typeofProcess: 'undefined',
  });
  assert.strictEqual(result, 'function');
}

// vm.runInContext
{
  const sandbox = { foo: 'bar' };
  const context = vm.createContext(sandbox);
  const result = vm.runInContext(
    'baz = foo; this.typeofProcess = typeof process; typeof Object;',
    context
  );
  assert.deepStrictEqual(sandbox, {
    foo: 'bar',
    baz: 'bar',
    typeofProcess: 'undefined'
  });
  assert.strictEqual(result, 'function');
}

// vm.runInThisContext
{
  const result = vm.runInThisContext(
    'vmResult = "foo"; Object.prototype.toString.call(process);'
  );
  assert.strictEqual(globalThis.vmResult, 'foo');
  assert.strictEqual(result, '[object process]');
  delete globalThis.vmResult;
}

// vm.runInNewContext
{
  const result = vm.runInNewContext(
    'vmResult = "foo"; typeof process;'
  );
  assert.strictEqual(globalThis.vmResult, undefined);
  assert.strictEqual(result, 'undefined');
}

// vm.createContext
{
  const sandbox = {};
  const context = vm.createContext(sandbox);
  assert.strictEqual(sandbox, context);
}

// Run script with filename
{
  const script = 'throw new Error("boom")';
  const filename = 'test-boom-error';
  const context = vm.createContext();

  function checkErr(err) {
    return err.stack.startsWith('test-boom-error:1');
  }

  assert.throws(() => vm.runInContext(script, context, filename), checkErr);
  assert.throws(() => vm.runInNewContext(script, context, filename), checkErr);
  assert.throws(() => vm.runInThisContext(script, filename), checkErr);
}

// Invalid arguments
[null, 'string'].forEach((input) => {
  assert.throws(() => {
    vm.createContext({}, input);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The "options" argument must be of type object.' +
             common.invalidArgTypeHelper(input)
  });
});

['name', 'origin'].forEach((propertyName) => {
  assert.throws(() => {
    vm.createContext({}, { [propertyName]: null });
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: `The "options.${propertyName}" property must be of type string. ` +
             'Received null'
  });
});

['contextName', 'contextOrigin'].forEach((propertyName) => {
  assert.throws(() => {
    vm.runInNewContext('', {}, { [propertyName]: null });
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: `The "options.${propertyName}" property must be of type string. ` +
             'Received null'
  });
});

// vm.compileFunction
{
  assert.strictEqual(
    vm.compileFunction('console.log("Hello, World!")').toString(),
    'function () {\nconsole.log("Hello, World!")\n}'
  );

  assert.strictEqual(
    vm.compileFunction(
      'return p + q + r + s + t',
      ['p', 'q', 'r', 's', 't']
    )('ab', 'cd', 'ef', 'gh', 'ij'),
    'abcdefghij'
  );

  vm.compileFunction('return'); // Should not throw on 'return'

  assert.throws(() => {
    vm.compileFunction(
      '});\n\n(function() {\nconsole.log(1);\n})();\n\n(function() {'
    );
  }, {
    name: 'SyntaxError',
    message: "Unexpected token '}'"
  });

  // Tests for failed argument validation
  assert.throws(() => vm.compileFunction(), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "code" argument must be of type string. ' +
      'Received undefined'
  });

  vm.compileFunction(''); // Should pass without params or options

  assert.throws(() => vm.compileFunction('', null), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "params" argument must be an instance of Array. ' +
      'Received null'
  });

  // Test for invalid options type
  assert.throws(() => {
    vm.compileFunction('', [], null);
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "options" argument must be of type object. Received null'
  });

  assert.throws(() => {
    vm.compileFunction('', [], 'string');
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "options" argument must be of type object. Received type string (\'string\')'
  });

  assert.throws(() => {
    vm.compileFunction('', [], 123);
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "options" argument must be of type object. Received type number (123)'
  });

  const optionTypes = {
    'filename': 'string',
    'columnOffset': 'number',
    'lineOffset': 'number',
    'cachedData': 'Buffer, TypedArray, or DataView',
    'produceCachedData': 'boolean',
  };

  for (const option in optionTypes) {
    const typeErrorMessage = `The "options.${option}" property must be ` +
      (option === 'cachedData' ? 'an instance of' : 'of type');
    assert.throws(() => {
      vm.compileFunction('', undefined, { [option]: null });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: typeErrorMessage +
        ` ${optionTypes[option]}. Received null`
    });
  }

  // Testing for context-based failures
  [Boolean(), Number(), null, String(), Symbol(), {}].forEach(
    (value) => {
      assert.throws(() => {
        vm.compileFunction('', undefined, { parsingContext: value });
      }, {
        name: 'TypeError',
        code: 'ERR_INVALID_ARG_TYPE',
        message: 'The "options.parsingContext" property must be an instance ' +
          `of Context.${common.invalidArgTypeHelper(value)}`
      });
    }
  );

  // Testing for non Array type-based failures
  [Boolean(), Number(), null, Object(), Symbol(), {}].forEach(
    (value) => {
      assert.throws(() => {
        vm.compileFunction('', value);
      }, {
        name: 'TypeError',
        code: 'ERR_INVALID_ARG_TYPE',
        message: 'The "params" argument must be an instance of Array.' +
          common.invalidArgTypeHelper(value)
      });
    }
  );

  assert.strictEqual(
    vm.compileFunction(
      'return a;',
      undefined,
      { contextExtensions: [{ a: 5 }] }
    )(),
    5
  );

  assert.throws(() => {
    vm.compileFunction('', undefined, { contextExtensions: null });
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "options.contextExtensions" property must be an instance of' +
       ' Array. Received null'
  });

  assert.throws(() => {
    vm.compileFunction('', undefined, { contextExtensions: [0] });
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "options.contextExtensions[0]" property must be of type ' +
       'object. Received type number (0)'
  });

  const oldLimit = Error.stackTraceLimit;
  // Setting value to run the last three tests
  Error.stackTraceLimit = 1;

  assert.throws(() => {
    vm.compileFunction('throw new Error("Sample Error")')();
  }, {
    message: 'Sample Error',
    stack: 'Error: Sample Error\n    at <anonymous>:1:7'
  });

  assert.throws(() => {
    vm.compileFunction(
      'throw new Error("Sample Error")',
      [],
      { lineOffset: 3 }
    )();
  }, {
    message: 'Sample Error',
    stack: 'Error: Sample Error\n    at <anonymous>:4:7'
  });

  assert.throws(() => {
    vm.compileFunction(
      'throw new Error("Sample Error")',
      [],
      { columnOffset: 3 }
    )();
  }, {
    message: 'Sample Error',
    stack: 'Error: Sample Error\n    at <anonymous>:1:10'
  });

  assert.strictEqual(
    vm.compileFunction(
      'return varInContext',
      [],
      {
        parsingContext: vm.createContext({ varInContext: 'abc' })
      }
    )(),
    'abc'
  );

  assert.throws(() => {
    vm.compileFunction(
      'return varInContext',
      []
    )();
  }, {
    message: 'varInContext is not defined',
    stack: 'ReferenceError: varInContext is not defined\n    at <anonymous>:1:1'
  });

  assert.notDeepStrictEqual(
    vm.compileFunction(
      'return global',
      [],
      {
        parsingContext: vm.createContext({ global: {} })
      }
    )(),
    global
  );

  assert.deepStrictEqual(
    vm.compileFunction(
      'return global',
      []
    )(),
    global
  );

  {
    const source = 'console.log("Hello, World!")';
    // Test compileFunction produceCachedData option
    const result = vm.compileFunction(source, [], {
      produceCachedData: true,
    });

    assert.ok(result.cachedDataProduced);
    assert.ok(result.cachedData.length > 0);

    // Test compileFunction cachedData consumption
    const result2 = vm.compileFunction(source, [], {
      cachedData: result.cachedData
    });
    assert.strictEqual(result2.cachedDataRejected, false);

    const result3 = vm.compileFunction('console.log("wrong source")', [], {
      cachedData: result.cachedData
    });
    assert.strictEqual(result3.cachedDataRejected, true);
  }

  // Resetting value
  Error.stackTraceLimit = oldLimit;
}
                                                  node-23.7.0/test/parallel/test-vm-cached-data.js                                                    0000664 0000000 0000000 00000004377 14746647661 0021414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const vm = require('vm');
const spawnSync = require('child_process').spawnSync;

function getSource(tag) {
  return `(function ${tag}() { return '${tag}'; })`;
}

function produce(source, count) {
  count ||= 1;

  const out = spawnSync(process.execPath, [ '-e', `
    'use strict';
    const assert = require('assert');
    const vm = require('vm');

    var data;
    for (var i = 0; i < ${count}; i++) {
      var script = new vm.Script(process.argv[1], {
        produceCachedData: true
      });

      assert(!script.cachedDataProduced || script.cachedData instanceof Buffer);

      if (script.cachedDataProduced)
        data = script.cachedData.toString('base64');
    }
    console.log(data);
  `, source]);

  assert.strictEqual(out.status, 0, String(out.stderr));

  return Buffer.from(out.stdout.toString(), 'base64');
}

function testProduceConsume() {
  const source = getSource('original');

  const data = produce(source);

  for (const cachedData of common.getArrayBufferViews(data)) {
    // It should consume code cache
    const script = new vm.Script(source, {
      cachedData
    });
    assert(!script.cachedDataRejected);
    assert.strictEqual(script.runInThisContext()(), 'original');
  }
}
testProduceConsume();

function testProduceMultiple() {
  const source = getSource('original');

  produce(source, 3);
}
testProduceMultiple();

function testRejectInvalid() {
  const source = getSource('invalid');

  const data = produce(source);

  // It should reject invalid code cache
  const script = new vm.Script(getSource('invalid_1'), {
    cachedData: data
  });
  assert(script.cachedDataRejected);
  assert.strictEqual(script.runInThisContext()(), 'invalid_1');
}
testRejectInvalid();

function testRejectSlice() {
  const source = getSource('slice');

  const data = produce(source).slice(4);

  const script = new vm.Script(source, {
    cachedData: data
  });
  assert(script.cachedDataRejected);
}
testRejectSlice();

// It should throw on non-Buffer cachedData
assert.throws(() => {
  new vm.Script('function abc() {}', {
    cachedData: 'ohai'
  });
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /must be an instance of Buffer, TypedArray, or DataView/
});
                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-vm-codegen.js                                                        0000664 0000000 0000000 00000003455 14746647661 0020676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

const { createContext, runInContext, runInNewContext } = require('vm');

const WASM_BYTES = Buffer.from(
  [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]);

{
  const ctx = createContext({ WASM_BYTES });
  const test = 'eval(""); new WebAssembly.Module(WASM_BYTES);';
  runInContext(test, ctx);

  runInNewContext(test, { WASM_BYTES }, {
    contextCodeGeneration: undefined,
  });
}

{
  const ctx = createContext({}, {
    codeGeneration: {
      strings: false,
    },
  });

  const EvalError = runInContext('EvalError', ctx);
  assert.throws(() => {
    runInContext('eval("x")', ctx);
  }, EvalError);
}

{
  const ctx = createContext({ WASM_BYTES }, {
    codeGeneration: {
      wasm: false,
    },
  });

  const CompileError = runInContext('WebAssembly.CompileError', ctx);
  assert.throws(() => {
    runInContext('new WebAssembly.Module(WASM_BYTES)', ctx);
  }, CompileError);
}

assert.throws(() => {
  runInNewContext('eval("x")', {}, {
    contextCodeGeneration: {
      strings: false,
    },
  });
}, {
  name: 'EvalError'
});

assert.throws(() => {
  runInNewContext('new WebAssembly.Module(WASM_BYTES)', { WASM_BYTES }, {
    contextCodeGeneration: {
      wasm: false,
    },
  });
}, {
  name: 'CompileError'
});

assert.throws(() => {
  createContext({}, {
    codeGeneration: {
      strings: 0,
    },
  });
}, {
  code: 'ERR_INVALID_ARG_TYPE',
});

assert.throws(() => {
  runInNewContext('eval("x")', {}, {
    contextCodeGeneration: {
      wasm: 1,
    },
  });
}, {
  code: 'ERR_INVALID_ARG_TYPE'
});

assert.throws(() => {
  createContext({}, {
    codeGeneration: 1,
  });
}, {
  code: 'ERR_INVALID_ARG_TYPE',
});

assert.throws(() => {
  createContext({}, {
    codeGeneration: null,
  });
}, {
  code: 'ERR_INVALID_ARG_TYPE',
});
                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-vm-context-async-script.js                                           0000664 0000000 0000000 00000002725 14746647661 0023372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');
const vm = require('vm');

const sandbox = { setTimeout };

const ctx = vm.createContext(sandbox);

vm.runInContext('setTimeout(function() { x = 3; }, 0);', ctx);
setTimeout(common.mustCall(() => {
  assert.strictEqual(sandbox.x, 3);
  assert.strictEqual(ctx.x, 3);
}), 1);
                                           node-23.7.0/test/parallel/test-vm-context-dont-contextify.js                                        0000664 0000000 0000000 00000016503 14746647661 0024110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Check vm.constants.DONT_CONTEXTIFY works.

const common = require('../common');

const assert = require('assert');
const vm = require('vm');
const fixtures = require('../common/fixtures');

{
  // Check identity of the returned object.
  const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
  // The globalThis in the new context should be reference equal to the returned object.
  assert.strictEqual(vm.runInContext('globalThis', context), context);
  assert(vm.isContext(context));
  assert.strictEqual(typeof context.Array, 'function');  // Can access builtins directly.
  assert.deepStrictEqual(Object.keys(context), []);  // Properties on the global proxy are not enumerable
}

{
  // Check that vm.createContext can return the original context if re-passed.
  const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
  const context2 = new vm.createContext(context);
  assert.strictEqual(context, context2);
}

{
  // Check that the context is vanilla and that Script.runInContext works.
  const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
  const result =
    new vm.Script('globalThis.hey = 1; Object.freeze(globalThis); globalThis.process')
      .runInContext(context);
  assert.strictEqual(globalThis.hey, undefined);  // Should not leak into current context.
  assert.strictEqual(result, undefined);  // Vanilla context has no Node.js globals
}

{
  // Check Script.runInNewContext works.
  const result =
    new vm.Script('globalThis.hey = 1; Object.freeze(globalThis); globalThis.process')
      .runInNewContext(vm.constants.DONT_CONTEXTIFY);
  assert.strictEqual(globalThis.hey, undefined);  // Should not leak into current context.
  assert.strictEqual(result, undefined);  // Vanilla context has no Node.js globals
}

{
  // Check that vm.runInNewContext() works
  const result = vm.runInNewContext(
    'globalThis.hey = 1; Object.freeze(globalThis); globalThis.process',
    vm.constants.DONT_CONTEXTIFY);
  assert.strictEqual(globalThis.hey, undefined);  // Should not leak into current context.
  assert.strictEqual(result, undefined);  // Vanilla context has no Node.js globals
}

{
  // Check that the global object of vanilla contexts work as expected.
  const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);

  // Check mutation via globalThis.
  vm.runInContext('globalThis.foo = 1;', context);
  assert.strictEqual(globalThis.foo, undefined);  // Should not pollute the current context.
  assert.strictEqual(context.foo, 1);
  assert.strictEqual(vm.runInContext('globalThis.foo', context), 1);
  assert.strictEqual(vm.runInContext('foo', context), 1);

  // Check mutation from outside.
  context.foo = 2;
  assert.strictEqual(context.foo, 2);
  assert.strictEqual(vm.runInContext('globalThis.foo', context), 2);
  assert.strictEqual(vm.runInContext('foo', context), 2);

  // Check contextual mutation.
  vm.runInContext('bar = 1;', context);
  assert.strictEqual(globalThis.bar, undefined);  // Should not pollute the current context.
  assert.strictEqual(context.bar, 1);
  assert.strictEqual(vm.runInContext('globalThis.bar', context), 1);
  assert.strictEqual(vm.runInContext('bar', context), 1);

  // Check adding new property from outside.
  context.baz = 1;
  assert.strictEqual(context.baz, 1);
  assert.strictEqual(vm.runInContext('globalThis.baz', context), 1);
  assert.strictEqual(vm.runInContext('baz', context), 1);

  // Check mutation via Object.defineProperty().
  vm.runInContext('Object.defineProperty(globalThis, "qux", {' +
    'enumerable: false, configurable: false, get() { return 1; } })', context);
  assert.strictEqual(globalThis.qux, undefined);  // Should not pollute the current context.
  assert.strictEqual(context.qux, 1);
  assert.strictEqual(vm.runInContext('qux', context), 1);
  const desc = Object.getOwnPropertyDescriptor(context, 'qux');
  assert.strictEqual(desc.enumerable, false);
  assert.strictEqual(desc.configurable, false);
  assert.strictEqual(typeof desc.get, 'function');
  assert.throws(() => { context.qux = 1; }, { name: 'TypeError' });
  assert.throws(() => { Object.defineProperty(context, 'qux', { value: 1 }); }, { name: 'TypeError' });
  // Setting a value without a setter fails silently.
  assert.strictEqual(vm.runInContext('qux = 2; qux', context), 1);
  assert.throws(() => {
    vm.runInContext('Object.defineProperty(globalThis, "qux", { value: 1 });');
  }, { name: 'TypeError' });
}

function checkFrozen(context) {
  // Check mutation via globalThis.
  vm.runInContext('globalThis.foo = 1', context);  // Invoking setters on freezed object fails silently.
  assert.strictEqual(context.foo, undefined);
  assert.strictEqual(vm.runInContext('globalThis.foo', context), undefined);
  assert.throws(() => {
    vm.runInContext('foo', context);  // It should not be looked up contextually.
  }, {
    name: 'ReferenceError'
  });

  // Check mutation from outside.
  assert.throws(() => {
    context.foo = 2;
  }, { name: 'TypeError' });
  assert.strictEqual(context.foo, undefined);
  assert.strictEqual(vm.runInContext('globalThis.foo', context), undefined);
  assert.throws(() => {
    vm.runInContext('foo', context);  // It should not be looked up contextually.
  }, {
    name: 'ReferenceError'
  });

  // Check contextual mutation.
  vm.runInContext('bar = 1', context);  // Invoking setters on freezed object fails silently.
  assert.strictEqual(context.bar, undefined);
  assert.strictEqual(vm.runInContext('globalThis.bar', context), undefined);
  assert.throws(() => {
    vm.runInContext('bar', context);  // It should not be looked up contextually.
  }, {
    name: 'ReferenceError'
  });

  // Check mutation via Object.defineProperty().
  assert.throws(() => {
    vm.runInContext('Object.defineProperty(globalThis, "qux", {' +
      'enumerable: false, configurable: false, get() { return 1; } })', context);
  }, {
    name: 'TypeError'
  });
  assert.strictEqual(context.qux, undefined);
  assert.strictEqual(vm.runInContext('globalThis.qux', context), undefined);
  assert.strictEqual(Object.getOwnPropertyDescriptor(context, 'qux'), undefined);
  assert.throws(() => { Object.defineProperty(context, 'qux', { value: 1 }); }, { name: 'TypeError' });
  assert.throws(() => {
    vm.runInContext('qux', context);
  }, {
    name: 'ReferenceError'
  });
}

{
  // Check freezing the vanilla context's global object from within the context.
  const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
  // Only vanilla contexts' globals can be freezed. Contextified global objects cannot be freezed
  // due to the presence of interceptors.
  vm.runInContext('Object.freeze(globalThis)', context);
  checkFrozen(context);
}

{
  // Check freezing the vanilla context's global object from outside the context.
  const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
  Object.freeze(context);
  checkFrozen(context);
}

// Check importModuleDynamically works.
(async function() {
  {
    const moduleUrl = fixtures.fileURL('es-modules', 'message.mjs');
    const namespace = await import(moduleUrl.href);
    // Check dynamic import works
    const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
    const script = new vm.Script(`import(${JSON.stringify(moduleUrl)})`, {
      importModuleDynamically: vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER,
    });
    const promise = script.runInContext(context);
    assert.strictEqual(await promise, namespace);
  }
})().catch(common.mustNotCall());
                                                                                                                                                                                             node-23.7.0/test/parallel/test-vm-context-property-forwarding.js                                    0000664 0000000 0000000 00000004214 14746647661 0024772 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

const sandbox = { x: 3 };

const ctx = vm.createContext(sandbox);

assert.strictEqual(vm.runInContext('x;', ctx), 3);
vm.runInContext('y = 4;', ctx);
assert.strictEqual(sandbox.y, 4);
assert.strictEqual(ctx.y, 4);

// Test `IndexedPropertyGetterCallback` and `IndexedPropertyDeleterCallback`
const x = { get 1() { return 5; } };
const pd_expected = Object.getOwnPropertyDescriptor(x, 1);
const ctx2 = vm.createContext(x);
const pd_actual = Object.getOwnPropertyDescriptor(ctx2, 1);

assert.deepStrictEqual(pd_actual, pd_expected);
assert.strictEqual(ctx2[1], 5);
delete ctx2[1];
assert.strictEqual(ctx2[1], undefined);

// https://github.com/nodejs/node/issues/33806
{
  const ctx = vm.createContext();

  Object.defineProperty(ctx, 'prop', {
    get() {
      return undefined;
    },
    set(val) {
      throw new Error('test error');
    },
  });

  assert.throws(() => {
    vm.runInContext('prop = 42', ctx);
  }, {
    message: 'test error',
  });
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-context.js                                                        0000664 0000000 0000000 00000007775 14746647661 0020767 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');
const Script = vm.Script;
let script = new Script('"passed";');

// Run in a new empty context
let context = vm.createContext();
let result = script.runInContext(context);
assert.strictEqual(result, 'passed');

// Create a new pre-populated context
context = vm.createContext({ 'foo': 'bar', 'thing': 'lala' });
assert.strictEqual(context.foo, 'bar');
assert.strictEqual(context.thing, 'lala');

// Test updating context
script = new Script('foo = 3;');
result = script.runInContext(context);
assert.strictEqual(context.foo, 3);
assert.strictEqual(context.thing, 'lala');

// Issue GH-227:
assert.throws(() => {
  vm.runInNewContext('', null, 'some.js');
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
});

// Issue GH-1140:
// Test runInContext signature
let gh1140Exception;
try {
  vm.runInContext('throw new Error()', context, 'expected-filename.js');
} catch (e) {
  gh1140Exception = e;
  assert.match(e.stack, /expected-filename/);
}
// This is outside of catch block to confirm catch block ran.
assert.strictEqual(gh1140Exception.toString(), 'Error');

const nonContextualObjectError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /must be of type object/
};
const contextifiedObjectError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /The "contextifiedObject" argument must be an vm\.Context/
};

[
  [undefined, nonContextualObjectError],
  [null, nonContextualObjectError],
  [0, nonContextualObjectError],
  [0.0, nonContextualObjectError],
  ['', nonContextualObjectError],
  [{}, contextifiedObjectError],
  [[], contextifiedObjectError],
].forEach((e) => {
  assert.throws(() => { script.runInContext(e[0]); }, e[1]);
  assert.throws(() => { vm.runInContext('', e[0]); }, e[1]);
});

// Issue GH-693:
// Test RegExp as argument to assert.throws
script = vm.createScript('const assert = require(\'assert\'); assert.throws(' +
                         'function() { throw "hello world"; }, /hello/);',
                         'some.js');
script.runInNewContext({ require });

// Issue GH-7529
script = vm.createScript('delete b');
let ctx = {};
Object.defineProperty(ctx, 'b', { configurable: false });
ctx = vm.createContext(ctx);
assert.strictEqual(script.runInContext(ctx), false);

// Error on the first line of a module should have the correct line and column
// number.
{
  let stack = null;
  assert.throws(() => {
    vm.runInContext(' throw new Error()', context, {
      filename: 'expected-filename.js',
      lineOffset: 32,
      columnOffset: 123
    });
  }, (err) => {
    stack = err.stack;
    return /^ \^/m.test(stack) &&
           /expected-filename\.js:33:131/.test(stack);
  }, `stack not formatted as expected: ${stack}`);
}

// https://github.com/nodejs/node/issues/6158
ctx = new Proxy({}, {});
assert.strictEqual(typeof vm.runInNewContext('String', ctx), 'function');
   node-23.7.0/test/parallel/test-vm-create-and-run-in-context.js                                      0000664 0000000 0000000 00000003701 14746647661 0024157 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Flags: --expose-gc
require('../common');
const assert = require('assert');

const vm = require('vm');

// Run in a new empty context
let context = vm.createContext();
let result = vm.runInContext('"passed";', context);
assert.strictEqual(result, 'passed');

// Create a new pre-populated context
context = vm.createContext({ 'foo': 'bar', 'thing': 'lala' });
assert.strictEqual(context.foo, 'bar');
assert.strictEqual(context.thing, 'lala');

// Test updating context
result = vm.runInContext('var foo = 3;', context);
assert.strictEqual(context.foo, 3);
assert.strictEqual(context.thing, 'lala');

// https://github.com/nodejs/node/issues/5768
// Run in contextified sandbox without referencing the context
const sandbox = { x: 1 };
vm.createContext(sandbox);
globalThis.gc();
vm.runInContext('x = 2', sandbox);
// Should not crash.
                                                               node-23.7.0/test/parallel/test-vm-create-context-accessors.js                                       0000664 0000000 0000000 00000003172 14746647661 0024176 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

let ctx = {};

Object.defineProperty(ctx, 'getter', {
  get: function() {
    return 'ok';
  }
});

let val;
Object.defineProperty(ctx, 'setter', {
  set: function(_val) {
    val = _val;
  },
  get: function() {
    return `ok=${val}`;
  }
});

ctx = vm.createContext(ctx);

const result = vm.runInContext('setter = "test";[getter,setter]', ctx);
assert.strictEqual(result[0], 'ok');
assert.strictEqual(result[1], 'ok=test');
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-vm-create-context-arg.js                                             0000664 0000000 0000000 00000002756 14746647661 0022771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

assert.throws(() => {
  vm.createContext('string is not supported');
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
});

// Should not throw.
vm.createContext({ a: 1 });
vm.createContext([0, 1, 2, 3]);

const sandbox = {};
vm.createContext(sandbox);
vm.createContext(sandbox);
                  node-23.7.0/test/parallel/test-vm-create-context-circular-reference.js                              0000664 0000000 0000000 00000002545 14746647661 0025754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

let sbx = {};
sbx.window = sbx;

sbx = vm.createContext(sbx);

sbx.test = 123;

assert.strictEqual(sbx.window.window.window.window.window.test, 123);
                                                                                                                                                           node-23.7.0/test/parallel/test-vm-createcacheddata.js                                               0000664 0000000 0000000 00000001000 14746647661 0022477 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const { Script } = require('vm');
const assert = require('assert');

const source = 'function x() {} const y = x();';

const script = new Script(source);
let cachedData = script.createCachedData();
assert(cachedData instanceof Buffer);

assert(!new Script(source, { cachedData }).cachedDataRejected);

script.runInNewContext();

for (let i = 0; i < 10; i += 1) {
  cachedData = script.createCachedData();

  assert(!new Script(source, { cachedData }).cachedDataRejected);
}
node-23.7.0/test/parallel/test-vm-cross-context.js                                                  0000664 0000000 0000000 00000002455 14746647661 0022104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');

const vm = require('vm');
const ctx = vm.createContext(globalThis);

// Should not throw.
vm.runInContext('!function() { var x = console.log; }()', ctx);
                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-vm-data-property-writable.js                                         0000664 0000000 0000000 00000001215 14746647661 0023664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Refs: https://github.com/nodejs/node/issues/10223

require('../common');
const vm = require('vm');
const assert = require('assert');

const context = vm.createContext({});

let code = `
   Object.defineProperty(this, 'foo', {value: 5});
   Object.getOwnPropertyDescriptor(this, 'foo');
`;

let desc = vm.runInContext(code, context);

assert.strictEqual(desc.writable, false);

// Check that interceptors work for symbols.
code = `
   const bar = Symbol('bar');
   Object.defineProperty(this, bar, {value: 6});
   Object.getOwnPropertyDescriptor(this, bar);
`;

desc = vm.runInContext(code, context);

assert.strictEqual(desc.value, 6);
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-vm-deleting-property.js                                              0000664 0000000 0000000 00000000534 14746647661 0022742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Refs: https://github.com/nodejs/node/issues/6287

require('../common');
const assert = require('assert');
const vm = require('vm');

const context = vm.createContext();
const res = vm.runInContext(`
  this.x = 'prop';
  delete this.x;
  Object.getOwnPropertyDescriptor(this, 'x');
`, context);

assert.strictEqual(res, undefined);
                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-dynamic-import-callback-missing-flag.js                           0000664 0000000 0000000 00000001451 14746647661 0026330 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Script, compileFunction } = require('vm');
const assert = require('assert');

assert(
  !process.execArgv.includes('--experimental-vm-modules'),
  'This test must be run without --experimental-vm-modules');

assert.rejects(async () => {
  const script = new Script('import("fs")', {
    importModuleDynamically: common.mustNotCall(),
  });
  const imported = script.runInThisContext();
  await imported;
}, {
  code: 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG'
}).then(common.mustCall());

assert.rejects(async () => {
  const imported = compileFunction('return import("fs")', [], {
    importModuleDynamically: common.mustNotCall(),
  })();
  await imported;
}, {
  code: 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG'
}).then(common.mustCall());
                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-vm-function-declaration.js                                           0000664 0000000 0000000 00000004045 14746647661 0023376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

const vm = require('vm');
const o = vm.createContext({ console });

// Function declaration and expression should both be copied to the
// sandboxed context.
let code = 'let a = function() {};\n';
code += 'function b(){}\n';
code += 'var c = function() {};\n';
code += 'var d = () => {};\n';
code += 'let e = () => {};\n';

// Grab the global b function as the completion value, to ensure that
// we are getting the global function, and not some other thing
code += '(function(){return this})().b;\n';

const res = vm.runInContext(code, o, 'test');
assert.strictEqual(typeof res, 'function');
assert.strictEqual(res.name, 'b');
assert.strictEqual(typeof o.a, 'undefined');
assert.strictEqual(typeof o.b, 'function');
assert.strictEqual(typeof o.c, 'function');
assert.strictEqual(typeof o.d, 'function');
assert.strictEqual(typeof o.e, 'undefined');
assert.strictEqual(res, o.b);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-vm-function-redefinition.js                                          0000664 0000000 0000000 00000000600 14746647661 0023561 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Refs: https://github.com/nodejs/node/issues/548
require('../common');
const assert = require('assert');
const vm = require('vm');
const context = vm.createContext();

vm.runInContext('function test() { return 0; }', context);
vm.runInContext('function test() { return 1; }', context);
const result = vm.runInContext('test()', context);
assert.strictEqual(result, 1);
                                                                                                                                node-23.7.0/test/parallel/test-vm-getters.js                                                        0000664 0000000 0000000 00000001263 14746647661 0020742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Refs: https://github.com/nodejs/node/issues/2734
require('../common');
const assert = require('assert');
const vm = require('vm');
const sandbox = {};

Object.defineProperty(sandbox, 'prop', {
  get() {
    return 'foo';
  }
});

const descriptor = Object.getOwnPropertyDescriptor(sandbox, 'prop');
const context = vm.createContext(sandbox);
const code = 'Object.getOwnPropertyDescriptor(this, "prop");';
const result = vm.runInContext(code, context);

// Ref: https://github.com/nodejs/node/issues/11803

assert.deepStrictEqual(Object.keys(result), Object.keys(descriptor));
for (const prop of Object.keys(result)) {
  assert.strictEqual(result[prop], descriptor[prop]);
}
                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-vm-global-assignment.js                                              0000664 0000000 0000000 00000000670 14746647661 0022674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Regression test for https://github.com/nodejs/node/issues/10806

require('../common');
const assert = require('assert');
const vm = require('vm');
const ctx = vm.createContext({ open() { } });
const window = vm.runInContext('this', ctx);
const other = 123;

assert.notStrictEqual(window.open, other);
window.open = other;
assert.strictEqual(window.open, other);
window.open = other;
assert.strictEqual(window.open, other);
                                                                        node-23.7.0/test/parallel/test-vm-global-configurable-properties.js                                 0000664 0000000 0000000 00000000666 14746647661 0025363 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// https://github.com/nodejs/node/issues/47799

require('../common');
const assert = require('assert');
const vm = require('vm');

const ctx = vm.createContext();

const window = vm.runInContext('this', ctx);

Object.defineProperty(window, 'x', { value: '1', configurable: true });
assert.strictEqual(window.x, '1');
Object.defineProperty(window, 'x', { value: '2', configurable: true });
assert.strictEqual(window.x, '2');
                                                                          node-23.7.0/test/parallel/test-vm-global-define-property.js                                         0000664 0000000 0000000 00000003346 14746647661 0023643 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');

const vm = require('vm');

const code =
    'Object.defineProperty(this, "f", {\n' +
    '  get: function() { return x; },\n' +
    '  set: function(k) { x = k; },\n' +
    '  configurable: true,\n' +
    '  enumerable: true\n' +
    '});\n' +
    'g = f;\n' +
    'f;\n';

const x = {};
const o = vm.createContext({ console, x });

const res = vm.runInContext(code, o, 'test');

assert(res);
assert.strictEqual(typeof res, 'object');
assert.strictEqual(res, x);
assert.strictEqual(o.f, res);
assert.deepStrictEqual(Object.keys(o), ['console', 'x', 'f', 'g']);
                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-vm-global-get-own.js                                                 0000664 0000000 0000000 00000007524 14746647661 0022111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

// These assertions check that we can set new keys to the global context,
// get them back and also list them via getOwnProperty* or in.
//
// Related to:
// - https://github.com/nodejs/node/issues/45983

const contextGlobal = vm.runInContext('this', vm.createContext());

function runAssertions(data, property, viaDefine, value1, value2, value3) {
  // Define the property for the first time
  setPropertyAndAssert(data, property, viaDefine, value1);
  // Update the property
  setPropertyAndAssert(data, property, viaDefine, value2);
  // Delete the property
  deletePropertyAndAssert(data, property);
  // Re-define the property
  setPropertyAndAssert(data, property, viaDefine, value3);
  // Delete the property again
  deletePropertyAndAssert(data, property);
}

const fun1 = () => 1;
const fun2 = () => 2;
const fun3 = () => 3;

function runAssertionsOnSandbox(builder) {
  const sandboxContext = vm.createContext({ runAssertions, fun1, fun2, fun3 });
  vm.runInContext(builder('this'), sandboxContext);
  vm.runInContext(builder('{}'), sandboxContext);
}

// Assertions on: define property
runAssertions(contextGlobal, 'toto', true, 1, 2, 3);
runAssertions(contextGlobal, Symbol.for('toto'), true, 1, 2, 3);
runAssertions(contextGlobal, 'tutu', true, fun1, fun2, fun3);
runAssertions(contextGlobal, Symbol.for('tutu'), true, fun1, fun2, fun3);
runAssertions(contextGlobal, 'tyty', true, fun1, 2, 3);
runAssertions(contextGlobal, Symbol.for('tyty'), true, fun1, 2, 3);

// Assertions on: direct assignment
runAssertions(contextGlobal, 'titi', false, 1, 2, 3);
runAssertions(contextGlobal, Symbol.for('titi'), false, 1, 2, 3);
runAssertions(contextGlobal, 'tata', false, fun1, fun2, fun3);
runAssertions(contextGlobal, Symbol.for('tata'), false, fun1, fun2, fun3);
runAssertions(contextGlobal, 'tztz', false, fun1, 2, 3);
runAssertions(contextGlobal, Symbol.for('tztz'), false, fun1, 2, 3);

// Assertions on: define property from sandbox
runAssertionsOnSandbox(
  (variable) => `
    runAssertions(${variable}, 'toto', true, 1, 2, 3);
    runAssertions(${variable}, Symbol.for('toto'), true, 1, 2, 3);
    runAssertions(${variable}, 'tutu', true, fun1, fun2, fun3);
    runAssertions(${variable}, Symbol.for('tutu'), true, fun1, fun2, fun3);
    runAssertions(${variable}, 'tyty', true, fun1, 2, 3);
    runAssertions(${variable}, Symbol.for('tyty'), true, fun1, 2, 3);`
);

// Assertions on: direct assignment from sandbox
runAssertionsOnSandbox(
  (variable) => `
    runAssertions(${variable}, 'titi', false, 1, 2, 3);
    runAssertions(${variable}, Symbol.for('titi'), false, 1, 2, 3);
    runAssertions(${variable}, 'tata', false, fun1, fun2, fun3);
    runAssertions(${variable}, Symbol.for('tata'), false, fun1, fun2, fun3);
    runAssertions(${variable}, 'tztz', false, fun1, 2, 3);
    runAssertions(${variable}, Symbol.for('tztz'), false, fun1, 2, 3);`
);

// Helpers

// Set the property on data and assert it worked
function setPropertyAndAssert(data, property, viaDefine, value) {
  if (viaDefine) {
    Object.defineProperty(data, property, {
      enumerable: true,
      writable: true,
      value: value,
      configurable: true,
    });
  } else {
    data[property] = value;
  }
  assert.strictEqual(data[property], value);
  assert.ok(property in data);
  if (typeof property === 'string') {
    assert.ok(Object.getOwnPropertyNames(data).includes(property));
  } else {
    assert.ok(Object.getOwnPropertySymbols(data).includes(property));
  }
}

// Delete the property from data and assert it worked
function deletePropertyAndAssert(data, property) {
  delete data[property];
  assert.strictEqual(data[property], undefined);
  assert.ok(!(property in data));
  assert.ok(!Object.getOwnPropertyNames(data).includes(property));
  assert.ok(!Object.getOwnPropertySymbols(data).includes(property));
}
                                                                                                                                                                            node-23.7.0/test/parallel/test-vm-global-identity.js                                                0000664 0000000 0000000 00000002614 14746647661 0022355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

const ctx = vm.createContext();
ctx.window = ctx;

const thisVal = vm.runInContext('this;', ctx);
const windowVal = vm.runInContext('window;', ctx);
assert.strictEqual(thisVal, windowVal);
                                                                                                                    node-23.7.0/test/parallel/test-vm-global-non-writable-properties.js                                 0000664 0000000 0000000 00000001171 14746647661 0025314 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// https://github.com/nodejs/node/issues/10223

require('../common');
const assert = require('assert');
const vm = require('vm');

const ctx = vm.createContext();
vm.runInContext('Object.defineProperty(this, "x", { value: 42 })', ctx);
assert.strictEqual(vm.runInContext('x', ctx), 42);
vm.runInContext('x = 0', ctx);                      // Does not throw but x...
assert.strictEqual(vm.runInContext('x', ctx), 42);  // ...should be unaltered.
assert.throws(() => vm.runInContext('"use strict"; x = 0', ctx),
              /Cannot assign to read only property 'x'/);
assert.strictEqual(vm.runInContext('x', ctx), 42);
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-vm-global-property-enumerator.js                                     0000664 0000000 0000000 00000005520 14746647661 0024566 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const globalNames = require('../common/globals');
const vm = require('vm');
const assert = require('assert');

// Regression of https://github.com/nodejs/node/issues/53346

const cases = [
  {
    get 1() {
      return 'value';
    },
    get key() {
      return 'value';
    },
  },
  {
    // Intentionally single setter.
    // eslint-disable-next-line accessor-pairs
    set key(value) {},
    // eslint-disable-next-line accessor-pairs
    set 1(value) {},
  },
  {},
  {
    key: 'value',
    1: 'value',
  },
  (new class GetterObject {
    get key() {
      return 'value';
    }
    get 1() {
      return 'value';
    }
  }()),
  (new class SetterObject {
    // Intentionally single setter.
    // eslint-disable-next-line accessor-pairs
    set key(value) {
      // noop
    }
    // eslint-disable-next-line accessor-pairs
    set 1(value) {
      // noop
    }
  }()),
  [],
  [['key', 'value']],
  {
    __proto__: {
      key: 'value',
      1: 'value',
    },
  },
  (() => {
    const obj = {
      __proto__: {
        [Symbol.toStringTag]: 'proto',
      },
    };
    Object.defineProperty(obj, '1', {
      value: 'value',
      enumerable: false,
      configurable: true,
    });
    Object.defineProperty(obj, 'key', {
      value: 'value',
      enumerable: false,
      configurable: true,
    });
    Object.defineProperty(obj, Symbol('symbol'), {
      value: 'value',
      enumerable: false,
      configurable: true,
    });
    Object.defineProperty(obj, Symbol('symbol-enumerable'), {
      value: 'value',
      enumerable: true,
      configurable: true,
    });
    return obj;
  })(),
];

for (const [idx, obj] of cases.entries()) {
  const ctx = vm.createContext(obj);
  const globalObj = vm.runInContext('this', ctx);
  assert.deepStrictEqual(Object.keys(globalObj), Object.keys(obj), `Case ${idx} failed: Object.keys`);

  const ownPropertyNamesInner = difference(Object.getOwnPropertyNames(globalObj), globalNames.intrinsics);
  const ownPropertyNamesOuter = Object.getOwnPropertyNames(obj);
  assert.deepStrictEqual(
    ownPropertyNamesInner,
    ownPropertyNamesOuter,
    `Case ${idx} failed: Object.getOwnPropertyNames`
  );

  // FIXME(legendecas): globalThis[@@toStringTag] is unconditionally
  // initialized to the sandbox's constructor name, even if it does not exist
  // on the sandbox object. This may incorrectly initialize the prototype
  // @@toStringTag on the globalThis as an own property, like
  // Window.prototype[@@toStringTag] should be a property on the prototype.
  assert.deepStrictEqual(
    Object.getOwnPropertySymbols(globalObj).filter((it) => it !== Symbol.toStringTag),
    Object.getOwnPropertySymbols(obj),
    `Case ${idx} failed: Object.getOwnPropertySymbols`
  );
}

function difference(arrA, arrB) {
  const setB = new Set(arrB);
  return arrA.filter((x) => !setB.has(x));
};
                                                                                                                                                                                node-23.7.0/test/parallel/test-vm-global-property-interceptors.js                                   0000664 0000000 0000000 00000006370 14746647661 0025132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

const dSymbol = Symbol('d');
const sandbox = {
  a: 'a',
  dSymbol
};

Object.defineProperties(sandbox, {
  b: {
    value: 'b'
  },
  c: {
    value: 'c',
    writable: true,
    enumerable: true
  },
  [dSymbol]: {
    value: 'd'
  },
  e: {
    value: 'e',
    configurable: true
  },
  f: {}
});

const ctx = vm.createContext(sandbox);

const result = vm.runInContext(`
const getDesc = (prop) => Object.getOwnPropertyDescriptor(this, prop);
const result = {
  a: getDesc('a'),
  b: getDesc('b'),
  c: getDesc('c'),
  d: getDesc(dSymbol),
  e: getDesc('e'),
  f: getDesc('f'),
  g: getDesc('g')
};
result;
`, ctx);

// eslint-disable-next-line no-restricted-properties
assert.deepEqual(result, {
  a: { value: 'a', writable: true, enumerable: true, configurable: true },
  b: { value: 'b', writable: false, enumerable: false, configurable: false },
  c: { value: 'c', writable: true, enumerable: true, configurable: false },
  d: { value: 'd', writable: false, enumerable: false, configurable: false },
  e: { value: 'e', writable: false, enumerable: false, configurable: true },
  f: {
    value: undefined,
    writable: false,
    enumerable: false,
    configurable: false
  },
  g: undefined
});

// Define new properties
vm.runInContext(`
Object.defineProperty(this, 'h', {value: 'h'});
Object.defineProperty(this, 'i', {});
Object.defineProperty(this, 'j', {
  get() { return 'j'; }
});
let kValue = 0;
Object.defineProperty(this, 'k', {
  get() { return kValue; },
  set(value) { kValue = value }
});
`, ctx);

assert.deepStrictEqual(Object.getOwnPropertyDescriptor(ctx, 'h'), {
  value: 'h',
  writable: false,
  enumerable: false,
  configurable: false
});

assert.deepStrictEqual(Object.getOwnPropertyDescriptor(ctx, 'i'), {
  value: undefined,
  writable: false,
  enumerable: false,
  configurable: false
});

const jDesc = Object.getOwnPropertyDescriptor(ctx, 'j');
assert.strictEqual(typeof jDesc.get, 'function');
assert.strictEqual(typeof jDesc.set, 'undefined');
assert.strictEqual(jDesc.enumerable, false);
assert.strictEqual(jDesc.configurable, false);

const kDesc = Object.getOwnPropertyDescriptor(ctx, 'k');
assert.strictEqual(typeof kDesc.get, 'function');
assert.strictEqual(typeof kDesc.set, 'function');
assert.strictEqual(kDesc.enumerable, false);
assert.strictEqual(kDesc.configurable, false);

assert.strictEqual(ctx.k, 0);
ctx.k = 1;
assert.strictEqual(ctx.k, 1);
assert.strictEqual(vm.runInContext('k;', ctx), 1);
vm.runInContext('k = 2;', ctx);
assert.strictEqual(ctx.k, 2);
assert.strictEqual(vm.runInContext('k;', ctx), 2);

// Redefine properties on the global object
assert.strictEqual(typeof vm.runInContext('encodeURI;', ctx), 'function');
assert.strictEqual(ctx.encodeURI, undefined);
vm.runInContext(`
Object.defineProperty(this, 'encodeURI', { value: 42 });
`, ctx);
assert.strictEqual(vm.runInContext('encodeURI;', ctx), 42);
assert.strictEqual(ctx.encodeURI, 42);

// Redefine properties on the sandbox
vm.runInContext(`
Object.defineProperty(this, 'e', { value: 'newE' });
`, ctx);
assert.strictEqual(ctx.e, 'newE');

assert.throws(() => vm.runInContext(`
'use strict';
Object.defineProperty(this, 'f', { value: 'newF' });
`, ctx), /TypeError: Cannot redefine property: f/);
                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-vm-global-property-prototype.js                                      0000664 0000000 0000000 00000015214 14746647661 0024453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

const outerProto = {
  onOuterProto: 'onOuterProto',
  bothProto: 'onOuterProto',
};
function onOuterProtoGetter() {
  return 'onOuterProtoGetter';
}
Object.defineProperties(outerProto, {
  onOuterProtoGetter: {
    get: onOuterProtoGetter,
  },
  bothProtoGetter: {
    get: onOuterProtoGetter,
  },
  // outer proto indexed
  0: {
    value: 'onOuterProtoIndexed',
    writable: false,
    enumerable: false,
    configurable: true,
  },
  // both proto indexed
  3: {
    value: 'onOuterProtoIndexed',
    writable: false,
    enumerable: false,
    configurable: true,
  },
});

// Creating a new intermediate proto to mimic the
// window -> Window.prototype -> EventTarget.prototype chain in JSDom.
const sandboxProto = {
  __proto__: outerProto,
};

const sandbox = {
  __proto__: sandboxProto,
  onSelf: 'onSelf',
};

function onSelfGetter() {
  return 'onSelfGetter';
}
Object.defineProperties(sandbox, {
  onSelfGetter: {
    get: onSelfGetter,
  },
  1: {
    value: 'onSelfIndexed',
    writable: false,
    enumerable: false,
    configurable: true,
  }
});

const ctx = vm.createContext(sandbox);

const result = vm.runInContext(`
Object.prototype.onInnerProto = 'onInnerProto';
Object.defineProperties(Object.prototype, {
  onInnerProtoGetter: {
    get() {
      return 'onInnerProtoGetter';
    },
  },
  2: {
    value: 'onInnerProtoIndexed',
    writable: false,
    enumerable: false,
    configurable: true,
  },
});

// Override outer proto properties
Object.prototype.bothProto = 'onInnerProto';
Object.defineProperties(Object.prototype, {
  bothProtoGetter: {
    get() {
      return 'onInnerProtoGetter';
    },
  },
  // outer proto indexed
  3: {
    value: 'onInnerProtoIndexed',
    writable: false,
    enumerable: false,
    configurable: true,
  },
});

const resultHasOwn = {
  onSelf: Object.hasOwn(this, 'onSelf'),
  onSelfGetter: Object.hasOwn(this, 'onSelfGetter'),
  onSelfIndexed: Object.hasOwn(this, 1),
  onOuterProto: Object.hasOwn(this, 'onOuterProto'),
  onOuterProtoGetter: Object.hasOwn(this, 'onOuterProtoGetter'),
  onOuterProtoIndexed: Object.hasOwn(this, 0),
  onInnerProto: Object.hasOwn(this, 'onInnerProto'),
  onInnerProtoGetter: Object.hasOwn(this, 'onInnerProtoGetter'),
  onInnerProtoIndexed: Object.hasOwn(this, 2),
  bothProto: Object.hasOwn(this, 'bothProto'),
  bothProtoGetter: Object.hasOwn(this, 'bothProtoGetter'),
  bothProtoIndexed: Object.hasOwn(this, 3),
};

const getDesc = (prop) => Object.getOwnPropertyDescriptor(this, prop);
const resultDesc = {
  onSelf: getDesc('onSelf'),
  onSelfGetter: getDesc('onSelfGetter'),
  onSelfIndexed: getDesc(1),
  onOuterProto: getDesc('onOuterProto'),
  onOuterProtoGetter: getDesc('onOuterProtoGetter'),
  onOuterProtoIndexed: getDesc(0),
  onInnerProto: getDesc('onInnerProto'),
  onInnerProtoGetter: getDesc('onInnerProtoGetter'),
  onInnerProtoIndexed: getDesc(2),
  bothProto: getDesc('bothProto'),
  bothProtoGetter: getDesc('bothProtoGetter'),
  bothProtoIndexed: getDesc(3),
};
const resultIn = {
  onSelf: 'onSelf' in this,
  onSelfGetter: 'onSelfGetter' in this,
  onSelfIndexed: 1 in this,
  onOuterProto: 'onOuterProto' in this,
  onOuterProtoGetter: 'onOuterProtoGetter' in this,
  onOuterProtoIndexed: 0 in this,
  onInnerProto: 'onInnerProto' in this,
  onInnerProtoGetter: 'onInnerProtoGetter' in this,
  onInnerProtoIndexed: 2 in this,
  bothProto: 'bothProto' in this,
  bothProtoGetter: 'bothProtoGetter' in this,
  bothProtoIndexed: 3 in this,
};
const resultValue = {
  onSelf: this.onSelf,
  onSelfGetter: this.onSelfGetter,
  onSelfIndexed: this[1],
  onOuterProto: this.onOuterProto,
  onOuterProtoGetter: this.onOuterProtoGetter,
  onOuterProtoIndexed: this[0],
  onInnerProto: this.onInnerProto,
  onInnerProtoGetter: this.onInnerProtoGetter,
  onInnerProtoIndexed: this[2],
  bothProto: this.bothProto,
  bothProtoGetter: this.bothProtoGetter,
  bothProtoIndexed: this[3],
};
({
  resultHasOwn,
  resultDesc,
  resultIn,
  resultValue,
});
`, ctx);

// eslint-disable-next-line no-restricted-properties
assert.deepEqual(result, {
  resultHasOwn: {
    onSelf: true,
    onSelfGetter: true,
    onSelfIndexed: true,

    // All prototype properties are not own properties.
    onOuterProto: false,
    onOuterProtoGetter: false,
    onOuterProtoIndexed: false,
    onInnerProto: false,
    onInnerProtoGetter: false,
    onInnerProtoIndexed: false,
    bothProto: false,
    bothProtoGetter: false,
    bothProtoIndexed: false,
  },
  resultDesc: {
    onSelf: { value: 'onSelf', writable: true, enumerable: true, configurable: true },
    onSelfGetter: { get: onSelfGetter, set: undefined, enumerable: false, configurable: false },
    onSelfIndexed: { value: 'onSelfIndexed', writable: false, enumerable: false, configurable: true },

    // All prototype properties are not own properties.
    onOuterProto: undefined,
    onOuterProtoGetter: undefined,
    onOuterProtoIndexed: undefined,
    onInnerProto: undefined,
    onInnerProtoGetter: undefined,
    onInnerProtoIndexed: undefined,
    bothProto: undefined,
    bothProtoGetter: undefined,
    bothProtoIndexed: undefined,
  },
  resultIn: {
    onSelf: true,
    onSelfGetter: true,
    onSelfIndexed: true,

    // Only properties exist on inner prototype chain will be looked up
    // on `in` operator. In the VM Context, the prototype chain will be like:
    // ```
    // Object
    // ^
    // | prototype
    // InnerPrototype
    // ^
    // | prototype
    // globalThis
    // ```
    // Outer prototype is not in the inner global object prototype chain and it
    // will not be looked up on `in` operator.
    onOuterProto: false,
    onOuterProtoGetter: false,
    onOuterProtoIndexed: false,
    onInnerProto: true,
    onInnerProtoGetter: true,
    onInnerProtoIndexed: true,
    bothProto: true,
    bothProtoGetter: true,
    bothProtoIndexed: true,
  },
  resultValue: {
    onSelf: 'onSelf',
    onSelfGetter: 'onSelfGetter',
    onSelfIndexed: 'onSelfIndexed',

    // FIXME(legendecas): The outer prototype is not observable from the inner
    // vm. Allowing property getter on the outer prototype can be confusing
    // comparing to the normal JavaScript objects.
    // Additionally, this may expose unexpected properties on the outer
    // prototype chain, like polyfills, to the vm context.
    onOuterProto: 'onOuterProto',
    onOuterProtoGetter: 'onOuterProtoGetter',
    onOuterProtoIndexed: 'onOuterProtoIndexed',
    onInnerProto: 'onInnerProto',
    onInnerProtoGetter: 'onInnerProtoGetter',
    onInnerProtoIndexed: 'onInnerProtoIndexed',
    bothProto: 'onOuterProto',
    bothProtoGetter: 'onOuterProtoGetter',
    bothProtoIndexed: 'onOuterProtoIndexed',
  },
});
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-global-setter.js                                                  0000664 0000000 0000000 00000011705 14746647661 0022033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const vm = require('vm');

const getSetSymbolReceivingFunction = Symbol('sym-1');
const getSetSymbolReceivingNumber = Symbol('sym-2');
const symbolReceivingNumber = Symbol('sym-3');
const unknownSymbolReceivingNumber = Symbol('sym-4');

const window = createWindow();

const descriptor1 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  'getSetPropReceivingFunction'
);
assert.strictEqual(typeof descriptor1.get, 'function');
assert.strictEqual(typeof descriptor1.set, 'function');
assert.strictEqual(descriptor1.configurable, true);

const descriptor2 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  'getSetPropReceivingNumber'
);
assert.strictEqual(typeof descriptor2.get, 'function');
assert.strictEqual(typeof descriptor2.set, 'function');
assert.strictEqual(descriptor2.configurable, true);

const descriptor3 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  'propReceivingNumber'
);
assert.strictEqual(descriptor3.value, 44);

const descriptor4 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  'unknownPropReceivingNumber'
);
assert.strictEqual(descriptor4, undefined);

const descriptor5 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  getSetSymbolReceivingFunction
);
assert.strictEqual(typeof descriptor5.get, 'function');
assert.strictEqual(typeof descriptor5.set, 'function');
assert.strictEqual(descriptor5.configurable, true);

const descriptor6 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  getSetSymbolReceivingNumber
);
assert.strictEqual(typeof descriptor6.get, 'function');
assert.strictEqual(typeof descriptor6.set, 'function');
assert.strictEqual(descriptor6.configurable, true);

const descriptor7 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  symbolReceivingNumber
);
assert.strictEqual(descriptor7.value, 48);

const descriptor8 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  unknownSymbolReceivingNumber
);
assert.strictEqual(descriptor8, undefined);

const descriptor9 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  'getSetPropThrowing'
);
assert.strictEqual(typeof descriptor9.get, 'function');
assert.strictEqual(typeof descriptor9.set, 'function');
assert.strictEqual(descriptor9.configurable, true);

const descriptor10 = Object.getOwnPropertyDescriptor(
  window.globalProxy,
  'nonWritableProp'
);
assert.strictEqual(descriptor10.value, 51);
assert.strictEqual(descriptor10.writable, false);

// Regression test for GH-42962. This assignment should not throw.
window.globalProxy.getSetPropReceivingFunction = () => {};
assert.strictEqual(window.globalProxy.getSetPropReceivingFunction, 42);

window.globalProxy.getSetPropReceivingNumber = 143;
assert.strictEqual(window.globalProxy.getSetPropReceivingNumber, 43);

window.globalProxy.propReceivingNumber = 144;
assert.strictEqual(window.globalProxy.propReceivingNumber, 144);

window.globalProxy.unknownPropReceivingNumber = 145;
assert.strictEqual(window.globalProxy.unknownPropReceivingNumber, 145);

window.globalProxy[getSetSymbolReceivingFunction] = () => {};
assert.strictEqual(window.globalProxy[getSetSymbolReceivingFunction], 46);

window.globalProxy[getSetSymbolReceivingNumber] = 147;
assert.strictEqual(window.globalProxy[getSetSymbolReceivingNumber], 47);

window.globalProxy[symbolReceivingNumber] = 148;
assert.strictEqual(window.globalProxy[symbolReceivingNumber], 148);

window.globalProxy[unknownSymbolReceivingNumber] = 149;
assert.strictEqual(window.globalProxy[unknownSymbolReceivingNumber], 149);

assert.throws(
  () => (window.globalProxy.getSetPropThrowing = 150),
  new Error('setter called')
);
assert.strictEqual(window.globalProxy.getSetPropThrowing, 50);

assert.throws(
  () => (window.globalProxy.nonWritableProp = 151),
  new TypeError('Cannot redefine property: nonWritableProp')
);
assert.strictEqual(window.globalProxy.nonWritableProp, 51);

function createWindow() {
  const obj = {};
  vm.createContext(obj);
  Object.defineProperty(obj, 'getSetPropReceivingFunction', {
    get: common.mustCall(() => 42),
    set: common.mustCall(),
    configurable: true,
  });
  Object.defineProperty(obj, 'getSetPropReceivingNumber', {
    get: common.mustCall(() => 43),
    set: common.mustCall(),
    configurable: true,
  });
  obj.propReceivingNumber = 44;
  Object.defineProperty(obj, getSetSymbolReceivingFunction, {
    get: common.mustCall(() => 46),
    set: common.mustCall(),
    configurable: true,
  });
  Object.defineProperty(obj, getSetSymbolReceivingNumber, {
    get: common.mustCall(() => 47),
    set: common.mustCall(),
    configurable: true,
  });
  obj[symbolReceivingNumber] = 48;
  Object.defineProperty(obj, 'getSetPropThrowing', {
    get: common.mustCall(() => 50),
    set: common.mustCall(() => {
      throw new Error('setter called');
    }),
    configurable: true,
  });
  Object.defineProperty(obj, 'nonWritableProp', {
    value: 51,
    writable: false,
  });

  obj.globalProxy = vm.runInContext('this', obj);

  return obj;
}
                                                           node-23.7.0/test/parallel/test-vm-harmony-symbols.js                                                0000664 0000000 0000000 00000003242 14746647661 0022427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

// The sandbox should have its own Symbol constructor.
let sandbox = {};
vm.runInNewContext('this.Symbol = Symbol', sandbox);
assert.strictEqual(typeof sandbox.Symbol, 'function');
assert.notStrictEqual(sandbox.Symbol, Symbol);

// Unless we copy the Symbol constructor explicitly, of course.
sandbox = { Symbol };
vm.runInNewContext('this.Symbol = Symbol', sandbox);
assert.strictEqual(typeof sandbox.Symbol, 'function');
assert.strictEqual(sandbox.Symbol, Symbol);
                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-vm-indexed-properties.js                                             0000664 0000000 0000000 00000000500 14746647661 0023070 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const vm = require('vm');

const code = `Object.defineProperty(this, 99, {
      value: 20,
      enumerable: true
 });`;


const sandbox = {};
const ctx = vm.createContext(sandbox);
vm.runInContext(code, ctx);

assert.strictEqual(sandbox[99], 20);
                                                                                                                                                                                                node-23.7.0/test/parallel/test-vm-inherited_properties.js                                           0000664 0000000 0000000 00000001441 14746647661 0023512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const vm = require('vm');
const assert = require('assert');

let base = {
  propBase: 1
};

let sandbox = Object.create(base, {
  propSandbox: { value: 3 }
});

const context = vm.createContext(sandbox);

let result = vm.runInContext('Object.hasOwnProperty(this, "propBase");',
                             context);

assert.strictEqual(result, false);

// Ref: https://github.com/nodejs/node/issues/5350
base = { __proto__: null };
base.x = 1;
base.y = 2;

sandbox = { __proto__: base };
sandbox.z = 3;

assert.deepStrictEqual(Object.keys(sandbox), ['z']);

const code = 'x = 0; z = 4;';
result = vm.runInNewContext(code, sandbox);
assert.strictEqual(result, 4);

// Check that y is not an own property.
assert.deepStrictEqual(Object.keys(sandbox), ['z', 'x']);
                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-vm-is-context.js                                                     0000664 0000000 0000000 00000003344 14746647661 0021364 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

for (const valToTest of [
  'string', null, undefined, 8.9, Symbol('sym'), true,
]) {
  assert.throws(() => {
    vm.isContext(valToTest);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
}

assert.strictEqual(vm.isContext({}), false);
assert.strictEqual(vm.isContext([]), false);

assert.strictEqual(vm.isContext(vm.createContext()), true);
assert.strictEqual(vm.isContext(vm.createContext([])), true);

const sandbox = { foo: 'bar' };
vm.createContext(sandbox);
assert.strictEqual(vm.isContext(sandbox), true);
                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-vm-low-stack-space.js                                                0000664 0000000 0000000 00000000775 14746647661 0022271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

function a() {
  try {
    return a();
  } catch {
    // Throw an exception as near to the recursion-based RangeError as possible.
    return vm.runInThisContext('() => 42')();
  }
}

assert.strictEqual(a(), 42);

function b() {
  try {
    return b();
  } catch {
    // This writes a lot of noise to stderr, but it still works.
    return vm.runInNewContext('() => 42')();
  }
}

assert.strictEqual(b(), 42);
   node-23.7.0/test/parallel/test-vm-measure-memory-lazy.js                                            0000664 0000000 0000000 00000001353 14746647661 0023211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-gc

'use strict';
const common = require('../common');
const {
  assertSummaryShape,
  expectExperimentalWarning
} = require('../common/measure-memory');
const vm = require('vm');

expectExperimentalWarning();

// Test lazy memory measurement - we will need to globalThis.gc()
// or otherwise these may not resolve.
{
  vm.measureMemory()
    .then(common.mustCall(assertSummaryShape));
  globalThis.gc();
}

{
  vm.measureMemory({})
    .then(common.mustCall(assertSummaryShape));
  globalThis.gc();
}

{
  vm.measureMemory({ mode: 'summary' })
    .then(common.mustCall(assertSummaryShape));
  globalThis.gc();
}

{
  vm.measureMemory({ mode: 'detailed' })
    .then(common.mustCall(assertSummaryShape));
  globalThis.gc();
}
                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-vm-measure-memory-multi-context.js                                   0000664 0000000 0000000 00000001466 14746647661 0025053 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const {
  assertDetailedShape,
  expectExperimentalWarning
} = require('../common/measure-memory');
const vm = require('vm');
const assert = require('assert');

expectExperimentalWarning();
{
  const arr = [];
  const count = 10;
  for (let i = 0; i < count; ++i) {
    const context = vm.createContext({
      test: new Array(100).fill('foo')
    });
    arr.push(context);
  }
  // Check that one more context shows up in the result
  vm.measureMemory({ mode: 'detailed', execution: 'eager' })
    .then(common.mustCall((result) => {
      // We must hold on to the contexts here so that they
      // don't get GC'ed until the measurement is complete
      assert.strictEqual(arr.length, count);
      assertDetailedShape(result, count + common.isWindows);
    }));
}
                                                                                                                                                                                                          node-23.7.0/test/parallel/test-vm-measure-memory.js                                                 0000664 0000000 0000000 00000002030 14746647661 0022225 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const {
  assertSummaryShape,
  assertSingleDetailedShape,
  expectExperimentalWarning
} = require('../common/measure-memory');
const assert = require('assert');
const vm = require('vm');

expectExperimentalWarning();

// Test eager memory measurement
{
  vm.measureMemory({ execution: 'eager' })
    .then(common.mustCall(assertSummaryShape));

  if (!common.isWindows) {
    vm.measureMemory({ mode: 'detailed', execution: 'eager' })
      .then(common.mustCall(assertSingleDetailedShape));
  }

  vm.measureMemory({ mode: 'summary', execution: 'eager' })
    .then(common.mustCall(assertSummaryShape));

  assert.throws(() => vm.measureMemory(null), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => vm.measureMemory('summary'), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => vm.measureMemory({ mode: 'random' }), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
  assert.throws(() => vm.measureMemory({ execution: 'random' }), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-vm-module-basic.js                                                   0000664 0000000 0000000 00000011506 14746647661 0021632 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');
const assert = require('assert');
const {
  Module,
  SourceTextModule,
  SyntheticModule,
  createContext,
  compileFunction,
} = require('vm');
const util = require('util');

(async function test1() {
  const context = createContext({
    foo: 'bar',
    baz: undefined,
    typeofProcess: undefined,
  });
  const m = new SourceTextModule(
    'baz = foo; typeofProcess = typeof process; typeof Object;',
    { context }
  );
  assert.strictEqual(m.status, 'unlinked');
  await m.link(common.mustNotCall());
  assert.strictEqual(m.status, 'linked');
  assert.strictEqual(await m.evaluate(), undefined);
  assert.strictEqual(m.status, 'evaluated');
  assert.deepStrictEqual(context, {
    foo: 'bar',
    baz: 'bar',
    typeofProcess: 'undefined'
  });
}().then(common.mustCall()));

(async () => {
  const m = new SourceTextModule(`
    globalThis.vmResultFoo = "foo";
    globalThis.vmResultTypeofProcess = Object.prototype.toString.call(process);
  `);
  await m.link(common.mustNotCall());
  await m.evaluate();
  assert.strictEqual(globalThis.vmResultFoo, 'foo');
  assert.strictEqual(globalThis.vmResultTypeofProcess, '[object process]');
  delete globalThis.vmResultFoo;
  delete globalThis.vmResultTypeofProcess;
})().then(common.mustCall());

(async () => {
  const m = new SourceTextModule('while (true) {}');
  await m.link(common.mustNotCall());
  await m.evaluate({ timeout: 500 })
    .then(() => assert(false), () => {});
})().then(common.mustCall());

// Check the generated identifier for each module
(async () => {
  const context1 = createContext({ });
  const context2 = createContext({ });

  const m1 = new SourceTextModule('1', { context: context1 });
  assert.strictEqual(m1.identifier, 'vm:module(0)');
  const m2 = new SourceTextModule('2', { context: context1 });
  assert.strictEqual(m2.identifier, 'vm:module(1)');
  const m3 = new SourceTextModule('3', { context: context2 });
  assert.strictEqual(m3.identifier, 'vm:module(0)');
})().then(common.mustCall());

// Check inspection of the instance
{
  const context = createContext({ foo: 'bar' });
  const m = new SourceTextModule('1', { context });

  assert.strictEqual(
    util.inspect(m),
    `SourceTextModule {
  status: 'unlinked',
  identifier: 'vm:module(0)',
  context: { foo: 'bar' }
}`
  );

  assert.strictEqual(util.inspect(m, { depth: -1 }), '[SourceTextModule]');

  for (const value of [null, { __proto__: null }, SourceTextModule.prototype]) {
    assert.throws(
      () => m[util.inspect.custom].call(value),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "this" argument must be an instance of Module/,
      },
    );
  }
}

{
  const context = createContext({ foo: 'bar' });
  const m = new SyntheticModule([], () => {}, { context });

  assert.strictEqual(
    util.inspect(m),
    `SyntheticModule {
  status: 'unlinked',
  identifier: 'vm:module(0)',
  context: { foo: 'bar' }
}`
  );

  assert.strictEqual(util.inspect(m, { depth: -1 }), '[SyntheticModule]');
}

// Check dependencies getter returns same object every time
{
  const m = new SourceTextModule('');
  const dep = m.dependencySpecifiers;
  assert.notStrictEqual(dep, undefined);
  assert.strictEqual(dep, m.dependencySpecifiers);
}

// Check the impossibility of creating an abstract instance of the Module.
{
  assert.throws(() => new Module(), {
    message: 'Module is not a constructor',
    name: 'TypeError'
  });
}

// Check to throws invalid exportNames
{
  assert.throws(() => new SyntheticModule(undefined, () => {}, {}), {
    message: 'The "exportNames" argument must be an ' +
        'Array of unique strings.' +
        ' Received undefined',
    name: 'TypeError'
  });
}

// Check to throws duplicated exportNames
// https://github.com/nodejs/node/issues/32806
{
  assert.throws(() => new SyntheticModule(['x', 'x'], () => {}, {}), {
    message: 'The property \'exportNames.x\' is duplicated. Received \'x\'',
    name: 'TypeError',
  });
}

// Check to throws invalid evaluateCallback
{
  assert.throws(() => new SyntheticModule([], undefined, {}), {
    message: 'The "evaluateCallback" argument must be of type function.' +
      ' Received undefined',
    name: 'TypeError'
  });
}

// Check to throws invalid options
{
  assert.throws(() => new SyntheticModule([], () => {}, null), {
    message: 'The "options" argument must be of type object.' +
      ' Received null',
    name: 'TypeError'
  });
}

// Test compileFunction importModuleDynamically
{
  const module = new SyntheticModule([], () => {});
  module.link(() => {});
  const f = compileFunction('return import("x")', [], {
    importModuleDynamically(specifier, referrer) {
      assert.strictEqual(specifier, 'x');
      assert.strictEqual(referrer, f);
      return module;
    },
  });
  f().then((ns) => {
    assert.strictEqual(ns, module.namespace);
  });
}
                                                                                                                                                                                          node-23.7.0/test/parallel/test-vm-module-cached-data.js                                             0000664 0000000 0000000 00000001271 14746647661 0022665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');

const assert = require('assert');
const { SourceTextModule } = require('vm');

{
  const m = new SourceTextModule('const a = 1');
  const cachedData = m.createCachedData();

  new SourceTextModule('const a = 1', { cachedData });

  assert.throws(() => {
    new SourceTextModule('differentSource', { cachedData });
  }, {
    code: 'ERR_VM_MODULE_CACHED_DATA_REJECTED',
  });
}

assert.rejects(async () => {
  const m = new SourceTextModule('const a = 1');
  await m.link(() => {});
  m.evaluate();
  m.createCachedData();
}, {
  code: 'ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA',
}).then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-vm-module-dynamic-import.js                                          0000664 0000000 0000000 00000006103 14746647661 0023502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');

const assert = require('assert');
const { Script, SourceTextModule } = require('vm');

async function testNoCallback() {
  const m = new SourceTextModule(`
    globalThis.importResult = import("foo");
    globalThis.importResult.catch(() => {});
  `);
  await m.link(common.mustNotCall());
  await m.evaluate();
  let threw = false;
  try {
    await globalThis.importResult;
  } catch (err) {
    threw = true;
    assert.strictEqual(err.code, 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING');
  }
  delete globalThis.importResult;
  assert(threw);
}

async function test() {
  const foo = new SourceTextModule('export const a = 1;');
  await foo.link(common.mustNotCall());
  await foo.evaluate();

  {
    const s = new Script('import("foo")', {
      importModuleDynamically: common.mustCall((specifier, wrap) => {
        assert.strictEqual(specifier, 'foo');
        assert.strictEqual(wrap, s);
        return foo;
      }),
    });

    const result = s.runInThisContext();
    assert.strictEqual(await result, foo.namespace);
  }

  {
    const m = new SourceTextModule('globalThis.fooResult = import("foo")', {
      importModuleDynamically: common.mustCall((specifier, wrap) => {
        assert.strictEqual(specifier, 'foo');
        assert.strictEqual(wrap, m);
        return foo;
      }),
    });
    await m.link(common.mustNotCall());
    await m.evaluate();
    assert.strictEqual(await globalThis.fooResult, foo.namespace);
    delete globalThis.fooResult;
  }

  {
    const s = new Script('import("foo", { with: { key: "value" } })', {
      importModuleDynamically: common.mustCall((specifier, wrap, attributes) => {
        assert.strictEqual(specifier, 'foo');
        assert.strictEqual(wrap, s);
        assert.deepStrictEqual(attributes, { __proto__: null, key: 'value' });
        return foo;
      }),
    });

    const result = s.runInThisContext();
    assert.strictEqual(await result, foo.namespace);
  }
}

async function testInvalid() {
  const m = new SourceTextModule('globalThis.fooResult = import("foo")', {
    importModuleDynamically: common.mustCall((specifier, wrap) => {
      return 5;
    }),
  });
  await m.link(common.mustNotCall());
  await m.evaluate();
  await globalThis.fooResult.catch(common.mustCall((e) => {
    assert.strictEqual(e.code, 'ERR_VM_MODULE_NOT_MODULE');
  }));
  delete globalThis.fooResult;

  const s = new Script('import("bar")', {
    importModuleDynamically: common.mustCall((specifier, wrap) => {
      return undefined;
    }),
  });
  let threw = false;
  try {
    await s.runInThisContext();
  } catch (e) {
    threw = true;
    assert.strictEqual(e.code, 'ERR_VM_MODULE_NOT_MODULE');
  }
  assert(threw);
}

async function testInvalidimportModuleDynamically() {
  assert.throws(
    () => new Script(
      'import("foo")',
      { importModuleDynamically: false }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}

(async function() {
  await testNoCallback();
  await test();
  await testInvalid();
  await testInvalidimportModuleDynamically();
}()).then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-vm-module-dynamic-namespace.js                                       0000664 0000000 0000000 00000001306 14746647661 0024124 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');

const assert = require('assert');

const { types } = require('util');
const { SourceTextModule } = require('vm');

(async () => {
  const m = new SourceTextModule('globalThis.importResult = import("");', {
    importModuleDynamically: common.mustCall(async (specifier, wrap) => {
      const m = new SourceTextModule('');
      await m.link(() => 0);
      await m.evaluate();
      return m.namespace;
    }),
  });
  await m.link(() => 0);
  await m.evaluate();
  const ns = await globalThis.importResult;
  delete globalThis.importResult;
  assert.ok(types.isModuleNamespaceObject(ns));
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-vm-module-errors.js                                                  0000664 0000000 0000000 00000017157 14746647661 0022075 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');

const assert = require('assert');

const { SourceTextModule, createContext, Module } = require('vm');

async function createEmptyLinkedModule() {
  const m = new SourceTextModule('');
  await m.link(common.mustNotCall());
  return m;
}

async function checkArgType() {
  assert.throws(() => {
    new SourceTextModule();
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

  for (const invalidOptions of [
    0, 1, null, true, 'str', () => {}, { identifier: 0 }, Symbol.iterator,
    { context: null }, { context: 'hucairz' }, { context: {} },
  ]) {
    assert.throws(() => {
      new SourceTextModule('', invalidOptions);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  }

  for (const invalidLinker of [
    0, 1, undefined, null, true, 'str', {}, Symbol.iterator,
  ]) {
    await assert.rejects(async () => {
      const m = new SourceTextModule('');
      await m.link(invalidLinker);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  }
}

// Check methods/properties can only be used under a specific state.
async function checkModuleState() {
  await assert.rejects(async () => {
    const m = new SourceTextModule('');
    await m.link(common.mustNotCall());
    assert.strictEqual(m.status, 'linked');
    await m.link(common.mustNotCall());
  }, {
    code: 'ERR_VM_MODULE_ALREADY_LINKED'
  });

  await assert.rejects(async () => {
    const m = new SourceTextModule('');
    m.link(common.mustNotCall());
    assert.strictEqual(m.status, 'linking');
    await m.link(common.mustNotCall());
  }, {
    code: 'ERR_VM_MODULE_STATUS'
  });

  await assert.rejects(async () => {
    const m = new SourceTextModule('');
    await m.evaluate();
  }, {
    code: 'ERR_VM_MODULE_STATUS',
    message: 'Module status must be one of linked, evaluated, or errored'
  });

  await assert.rejects(async () => {
    const m = new SourceTextModule('');
    await m.evaluate(false);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The "options" argument must be of type object. ' +
             'Received type boolean (false)'
  });

  assert.throws(() => {
    const m = new SourceTextModule('');
    m.error; // eslint-disable-line no-unused-expressions
  }, {
    code: 'ERR_VM_MODULE_STATUS',
    message: 'Module status must be errored'
  });

  await assert.rejects(async () => {
    const m = await createEmptyLinkedModule();
    await m.evaluate();
    m.error; // eslint-disable-line no-unused-expressions
  }, {
    code: 'ERR_VM_MODULE_STATUS',
    message: 'Module status must be errored'
  });

  assert.throws(() => {
    const m = new SourceTextModule('');
    m.namespace; // eslint-disable-line no-unused-expressions
  }, {
    code: 'ERR_VM_MODULE_STATUS',
    message: 'Module status must not be unlinked or linking'
  });
}

// Check link() fails when the returned module is not valid.
async function checkLinking() {
  await assert.rejects(async () => {
    const m = new SourceTextModule('import "foo";');
    try {
      await m.link(common.mustCall(() => ({})));
    } catch (err) {
      assert.strictEqual(m.status, 'errored');
      throw err;
    }
  }, {
    code: 'ERR_VM_MODULE_NOT_MODULE'
  });

  await assert.rejects(async () => {
    const c = createContext({ a: 1 });
    const foo = new SourceTextModule('', { context: c });
    await foo.link(common.mustNotCall());
    const bar = new SourceTextModule('import "foo";');
    try {
      await bar.link(common.mustCall(() => foo));
    } catch (err) {
      assert.strictEqual(bar.status, 'errored');
      throw err;
    }
  }, {
    code: 'ERR_VM_MODULE_DIFFERENT_CONTEXT'
  });

  const error = new Error();
  await assert.rejects(async () => {
    globalThis.error = error;
    const erroredModule = new SourceTextModule('throw error;');
    await erroredModule.link(common.mustNotCall());
    try {
      await erroredModule.evaluate();
    } catch {
      // ignored
    }
    delete globalThis.error;

    assert.strictEqual(erroredModule.status, 'errored');

    const rootModule = new SourceTextModule('import "errored";');
    await rootModule.link(common.mustCall(() => erroredModule));
  }, {
    code: 'ERR_VM_MODULE_LINK_FAILURE',
    cause: error,
  });
}

assert.throws(() => {
  new SourceTextModule('', {
    importModuleDynamically: 'hucairz'
  });
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: 'The "options.importModuleDynamically" property must be of type ' +
    "function. Received type string ('hucairz')"
});

// Check the JavaScript engine deals with exceptions correctly
async function checkExecution() {
  await (async () => {
    const m = new SourceTextModule('import { nonexistent } from "module";');

    // There is no code for this exception since it is thrown by the JavaScript
    // engine.
    await assert.rejects(() => {
      return m.link(common.mustCall(() => new SourceTextModule('')));
    }, SyntaxError);
  })();

  await (async () => {
    const m = new SourceTextModule('throw new Error();');
    await m.link(common.mustNotCall());
    try {
      await m.evaluate();
    } catch (err) {
      assert.strictEqual(m.error, err);
      assert.strictEqual(m.status, 'errored');
      return;
    }
    assert.fail('Missing expected exception');
  })();
}

// Check for error thrown when breakOnSigint is not a boolean for evaluate()
async function checkInvalidOptionForEvaluate() {
  await assert.rejects(async () => {
    const m = new SourceTextModule('export const a = 1; export let b = 2');
    await m.evaluate({ breakOnSigint: 'a-string' });
  }, {
    name: 'TypeError',
    message:
      'The "options.breakOnSigint" property must be of type boolean. ' +
      "Received type string ('a-string')",
    code: 'ERR_INVALID_ARG_TYPE'
  });

  {
    ['link', 'evaluate'].forEach(async (method) => {
      await assert.rejects(async () => {
        await Module.prototype[method]();
      }, {
        code: 'ERR_INVALID_ARG_TYPE',
        message: /The "this" argument must be an instance of Module/
      });
    });
  }
}

function checkInvalidCachedData() {
  [true, false, 'foo', {}, Array, function() {}].forEach((invalidArg) => {
    const message = 'The "options.cachedData" property must be an ' +
                    'instance of Buffer, TypedArray, or DataView.' +
                    common.invalidArgTypeHelper(invalidArg);
    assert.throws(
      () => new SourceTextModule('import "foo";', { cachedData: invalidArg }),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message,
      }
    );
  });
}

function checkGettersErrors() {
  const expectedError = {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The "this" argument must be an instance of (?:Module|SourceTextModule)/,
  };
  const getters = ['identifier', 'context', 'namespace', 'status', 'error'];
  getters.forEach((getter) => {
    assert.throws(() => {
      // eslint-disable-next-line no-unused-expressions
      Module.prototype[getter];
    }, expectedError);
    assert.throws(() => {
      // eslint-disable-next-line no-unused-expressions
      SourceTextModule.prototype[getter];
    }, expectedError);
  });
  // `dependencySpecifiers` getter is just part of SourceTextModule
  assert.throws(() => {
    // eslint-disable-next-line no-unused-expressions
    SourceTextModule.prototype.dependencySpecifiers;
  }, expectedError);
}

const finished = common.mustCall();

(async function main() {
  await checkArgType();
  await checkModuleState();
  await checkLinking();
  await checkExecution();
  await checkInvalidOptionForEvaluate();
  checkInvalidCachedData();
  checkGettersErrors();
  finished();
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-vm-module-import-meta.js                                             0000664 0000000 0000000 00000002204 14746647661 0023002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');
const assert = require('assert');
const { SourceTextModule } = require('vm');

async function testBasic() {
  const m = new SourceTextModule('globalThis.importMeta = import.meta;', {
    initializeImportMeta: common.mustCall((meta, module) => {
      assert.strictEqual(module, m);
      meta.prop = 42;
    })
  });
  await m.link(common.mustNotCall());
  await m.evaluate();
  const result = globalThis.importMeta;
  delete globalThis.importMeta;
  assert.strictEqual(typeof result, 'object');
  assert.strictEqual(Object.getPrototypeOf(result), null);
  assert.strictEqual(result.prop, 42);
  assert.deepStrictEqual(Reflect.ownKeys(result), ['prop']);
}

async function testInvalid() {
  for (const invalidValue of [
    null, {}, 0, Symbol.iterator, [], 'string', false,
  ]) {
    assert.throws(() => {
      new SourceTextModule('', {
        initializeImportMeta: invalidValue
      });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  }
}

(async () => {
  await testBasic();
  await testInvalid();
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-vm-module-link.js                                                    0000664 0000000 0000000 00000010257 14746647661 0021510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules --harmony-import-attributes

const common = require('../common');

const assert = require('assert');

const { SourceTextModule } = require('vm');

async function simple() {
  const foo = new SourceTextModule('export default 5;');
  await foo.link(common.mustNotCall());

  globalThis.fiveResult = undefined;
  const bar = new SourceTextModule('import five from "foo"; fiveResult = five');

  assert.deepStrictEqual(bar.dependencySpecifiers, ['foo']);

  await bar.link(common.mustCall((specifier, module) => {
    assert.strictEqual(module, bar);
    assert.strictEqual(specifier, 'foo');
    return foo;
  }));

  await bar.evaluate();
  assert.strictEqual(globalThis.fiveResult, 5);
  delete globalThis.fiveResult;
}

async function invalidLinkValue() {
  const invalidValues = [
    undefined,
    null,
    {},
    SourceTextModule.prototype,
  ];

  for (const value of invalidValues) {
    const module = new SourceTextModule('import "foo"');
    await assert.rejects(module.link(() => value), {
      code: 'ERR_VM_MODULE_NOT_MODULE',
    });
  }
}

async function depth() {
  const foo = new SourceTextModule('export default 5');
  await foo.link(common.mustNotCall());

  async function getProxy(parentName, parentModule) {
    const mod = new SourceTextModule(`
      import ${parentName} from '${parentName}';
      export default ${parentName};
    `);
    await mod.link(common.mustCall((specifier, module) => {
      assert.strictEqual(module, mod);
      assert.strictEqual(specifier, parentName);
      return parentModule;
    }));
    return mod;
  }

  const bar = await getProxy('foo', foo);
  const baz = await getProxy('bar', bar);
  const barz = await getProxy('baz', baz);

  await barz.evaluate();

  assert.strictEqual(barz.namespace.default, 5);
}

async function circular() {
  const foo = new SourceTextModule(`
    import getFoo from 'bar';
    export let foo = 42;
    export default getFoo();
  `);
  const bar = new SourceTextModule(`
    import { foo } from 'foo';
    export default function getFoo() {
      return foo;
    }
  `);
  await foo.link(common.mustCall(async (specifier, module) => {
    if (specifier === 'bar') {
      assert.strictEqual(module, foo);
      return bar;
    }
    assert.strictEqual(specifier, 'foo');
    assert.strictEqual(module, bar);
    assert.strictEqual(foo.status, 'linking');
    return foo;
  }, 2));

  assert.strictEqual(bar.status, 'linked');

  await foo.evaluate();
  assert.strictEqual(foo.namespace.default, 42);
}

async function circular2() {
  const sourceMap = {
    'root': `
      import * as a from './a.mjs';
      import * as b from './b.mjs';
      if (!('fromA' in a))
        throw new Error();
      if (!('fromB' in a))
        throw new Error();
      if (!('fromA' in b))
        throw new Error();
      if (!('fromB' in b))
        throw new Error();
    `,
    './a.mjs': `
      export * from './b.mjs';
      export let fromA;
    `,
    './b.mjs': `
      export * from './a.mjs';
      export let fromB;
    `
  };
  const moduleMap = new Map();
  const rootModule = new SourceTextModule(sourceMap.root, {
    identifier: 'vm:root',
  });
  async function link(specifier, referencingModule) {
    if (moduleMap.has(specifier)) {
      return moduleMap.get(specifier);
    }
    const mod = new SourceTextModule(sourceMap[specifier], {
      identifier: new URL(specifier, 'file:///').href,
    });
    moduleMap.set(specifier, mod);
    return mod;
  }
  await rootModule.link(link);
  await rootModule.evaluate();
}

async function asserts() {
  const m = new SourceTextModule(`
  import "foo" with { n1: 'v1', n2: 'v2' };
  `, { identifier: 'm' });
  await m.link((s, r, p) => {
    assert.strictEqual(s, 'foo');
    assert.strictEqual(r.identifier, 'm');
    assert.strictEqual(p.attributes.n1, 'v1');
    assert.strictEqual(p.assert.n1, 'v1');
    assert.strictEqual(p.attributes.n2, 'v2');
    assert.strictEqual(p.assert.n2, 'v2');
    return new SourceTextModule('');
  });
}

const finished = common.mustCall();

(async function main() {
  await simple();
  await invalidLinkValue();
  await depth();
  await circular();
  await circular2();
  await asserts();
  finished();
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-vm-module-reevaluate.js                                              0000664 0000000 0000000 00000002203 14746647661 0022700 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');

const assert = require('assert');

const { SourceTextModule } = require('vm');

const finished = common.mustCall();

(async function main() {
  {
    globalThis.count = 0;
    const m = new SourceTextModule('count += 1;');
    await m.link(common.mustNotCall());
    assert.strictEqual(await m.evaluate(), undefined);
    assert.strictEqual(globalThis.count, 1);
    assert.strictEqual(await m.evaluate(), undefined);
    assert.strictEqual(globalThis.count, 1);
    assert.strictEqual(await m.evaluate(), undefined);
    assert.strictEqual(globalThis.count, 1);
    delete globalThis.count;
  }

  {
    const m = new SourceTextModule('throw new Error()');
    await m.link(common.mustNotCall());

    let threw = false;
    try {
      await m.evaluate();
    } catch (err) {
      assert(err instanceof Error);
      threw = true;
    }
    assert(threw);

    threw = false;
    try {
      await m.evaluate();
    } catch (err) {
      assert(err instanceof Error);
      threw = true;
    }
    assert(threw);
  }

  finished();
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-vm-module-referrer-realm.mjs                                         0000664 0000000 0000000 00000003651 14746647661 0023642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-vm-modules
import * as common from '../common/index.mjs';
import assert from 'node:assert';
import { Script, SourceTextModule, createContext } from 'node:vm';

async function test() {
  const foo = new SourceTextModule('export const a = 1;');
  await foo.link(common.mustNotCall());
  await foo.evaluate();

  const ctx = createContext({}, {
    importModuleDynamically: common.mustCall((specifier, wrap) => {
      assert.strictEqual(specifier, 'foo');
      assert.strictEqual(wrap, ctx);
      return foo;
    }, 2),
  });
  {
    const s = new Script('Promise.resolve("import(\'foo\')").then(eval)', {
      importModuleDynamically: common.mustNotCall(),
    });

    const result = s.runInContext(ctx);
    assert.strictEqual(await result, foo.namespace);
  }

  {
    const m = new SourceTextModule('globalThis.fooResult = Promise.resolve("import(\'foo\')").then(eval)', {
      context: ctx,
      importModuleDynamically: common.mustNotCall(),
    });
    await m.link(common.mustNotCall());
    await m.evaluate();
    assert.strictEqual(await ctx.fooResult, foo.namespace);
    delete ctx.fooResult;
  }
}

async function testMissing() {
  const ctx = createContext({});
  {
    const s = new Script('Promise.resolve("import(\'foo\')").then(eval)', {
      importModuleDynamically: common.mustNotCall(),
    });

    const result = s.runInContext(ctx);
    await assert.rejects(result, {
      code: 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING',
    });
  }

  {
    const m = new SourceTextModule('globalThis.fooResult = Promise.resolve("import(\'foo\')").then(eval)', {
      context: ctx,
      importModuleDynamically: common.mustNotCall(),
    });
    await m.link(common.mustNotCall());
    await m.evaluate();

    await assert.rejects(ctx.fooResult, {
      code: 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING',
    });
    delete ctx.fooResult;
  }
}

await Promise.all([
  test(),
  testMissing(),
]).then(common.mustCall());
                                                                                       node-23.7.0/test/parallel/test-vm-module-synthetic.js                                               0000664 0000000 0000000 00000003350 14746647661 0022561 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --experimental-vm-modules

const common = require('../common');
const { SyntheticModule, SourceTextModule } = require('vm');
const assert = require('assert');

(async () => {
  {
    const s = new SyntheticModule(['x'], () => {
      s.setExport('x', 1);
    });

    const m = new SourceTextModule(`
    import { x } from 'synthetic';

    export const getX = () => x;
    `);

    await m.link(() => s);
    await m.evaluate();

    assert.strictEqual(m.namespace.getX(), 1);
    s.setExport('x', 42);
    assert.strictEqual(m.namespace.getX(), 42);
  }

  {
    const s = new SyntheticModule([], () => {
      const p = Promise.reject();
      p.catch(() => {});
      return p;
    });

    await s.link(common.mustNotCall());
    assert.strictEqual(await s.evaluate(), undefined);
  }

  for (const invalidName of [1, Symbol.iterator, {}, [], null, true, 0]) {
    const s = new SyntheticModule([], () => {});
    await s.link(() => {});
    assert.throws(() => {
      s.setExport(invalidName, undefined);
    }, {
      name: 'TypeError',
    });
  }

  {
    const s = new SyntheticModule([], () => {});
    await s.link(() => {});
    assert.throws(() => {
      s.setExport('does not exist');
    }, {
      name: 'ReferenceError',
    });
  }

  {
    const s = new SyntheticModule([], () => {});
    assert.throws(() => {
      s.setExport('name', 'value');
    }, {
      code: 'ERR_VM_MODULE_STATUS',
    });
  }

  for (const value of [null, {}, SyntheticModule.prototype]) {
    assert.throws(() => {
      SyntheticModule.prototype.setExport.call(value, 'foo');
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /The "this" argument must be an instance of SyntheticModule/
    });
  }

})().then(common.mustCall());
                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-vm-new-script-new-context.js                                         0000664 0000000 0000000 00000006103 14746647661 0023627 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');

const assert = require('assert');

const Script = require('vm').Script;

{
  const script = new Script('\'passed\';');
  const result1 = script.runInNewContext();
  const result2 = script.runInNewContext();
  assert.strictEqual(result1, 'passed');
  assert.strictEqual(result2, 'passed');
}

{
  const script = new Script('throw new Error(\'test\');');
  assert.throws(() => {
    script.runInNewContext();
  }, /^Error: test$/);
}

{
  const script = new Script('foo.bar = 5;');
  assert.throws(() => {
    script.runInNewContext();
  }, /^ReferenceError: foo is not defined$/);
}

{
  globalThis.hello = 5;
  const script = new Script('hello = 2');
  script.runInNewContext();
  assert.strictEqual(globalThis.hello, 5);

  // Cleanup
  delete globalThis.hello;
}

{
  globalThis.code = 'foo = 1;' +
                'bar = 2;' +
                'if (baz !== 3) throw new Error(\'test fail\');';
  globalThis.foo = 2;
  globalThis.obj = { foo: 0, baz: 3 };
  const script = new Script(globalThis.code);
  /* eslint-disable no-unused-vars */
  const baz = script.runInNewContext(globalThis.obj);
  /* eslint-enable no-unused-vars */
  assert.strictEqual(globalThis.obj.foo, 1);
  assert.strictEqual(globalThis.obj.bar, 2);
  assert.strictEqual(globalThis.foo, 2);

  // cleanup
  delete globalThis.code;
  delete globalThis.foo;
  delete globalThis.obj;
}

{
  const script = new Script('f()');
  function changeFoo() { globalThis.foo = 100; }
  script.runInNewContext({ f: changeFoo });
  assert.strictEqual(globalThis.foo, 100);

  // cleanup
  delete globalThis.foo;
}

{
  const script = new Script('f.a = 2');
  const f = { a: 1 };
  script.runInNewContext({ f });
  assert.strictEqual(f.a, 2);

  assert.throws(() => {
    script.runInNewContext();
  }, /^ReferenceError: f is not defined$/);
}

{
  const script = new Script('');
  assert.throws(() => {
    script.runInNewContext.call('\'hello\';');
  }, /^TypeError: this\.runInContext is not a function$/);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-vm-new-script-this-context.js                                        0000664 0000000 0000000 00000004501 14746647661 0024005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
const assert = require('assert');
const Script = require('vm').Script;

// Run a string
let script = new Script('\'passed\';');
const result = script.runInThisContext(script);
assert.strictEqual(result, 'passed');

// Thrown error
script = new Script('throw new Error(\'test\');');
assert.throws(() => {
  script.runInThisContext(script);
}, /^Error: test$/);

globalThis.hello = 5;
script = new Script('hello = 2');
script.runInThisContext(script);
assert.strictEqual(globalThis.hello, 2);


// Pass values
globalThis.code = 'foo = 1;' +
              'bar = 2;' +
              'if (typeof baz !== "undefined") throw new Error("test fail");';
globalThis.foo = 2;
globalThis.obj = { foo: 0, baz: 3 };
script = new Script(globalThis.code);
script.runInThisContext(script);
assert.strictEqual(globalThis.obj.foo, 0);
assert.strictEqual(globalThis.bar, 2);
assert.strictEqual(globalThis.foo, 1);

// Call a function
globalThis.f = function() { globalThis.foo = 100; };
script = new Script('f()');
script.runInThisContext(script);
assert.strictEqual(globalThis.foo, 100);

common.allowGlobals(
  globalThis.hello,
  globalThis.code,
  globalThis.foo,
  globalThis.obj,
  globalThis.f
);
                                                                                                                                                                                               node-23.7.0/test/parallel/test-vm-no-dynamic-import-callback.js                                     0000664 0000000 0000000 00000001045 14746647661 0024363 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Script, compileFunction } = require('vm');
const assert = require('assert');

assert.rejects(async () => {
  const script = new Script('import("fs")');
  const imported = script.runInThisContext();
  await imported;
}, {
  code: 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'
}).then(common.mustCall());

assert.rejects(async () => {
  const imported = compileFunction('return import("fs")')();
  await imported;
}, {
  code: 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'
}).then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-vm-not-strict.js                                                     0000664 0000000 0000000 00000002112 14746647661 0021365 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* eslint-disable strict, no-var, no-delete-var, no-undef, node-core/required-modules, node-core/require-common-first */
// Importing common would break the execution. Indeed running `vm.runInThisContext` alters the global context
// when declaring new variables with `var`. The other rules (strict, no-var, no-delete-var) have been disabled
// in order to be able to test this specific not-strict case playing with `var` and `delete`.
// Related to bug report: https://github.com/nodejs/node/issues/43129
var assert = require('assert');
var vm = require('vm');

var data = [];
var a = 'direct';
delete a;
data.push(a);

var item2 = vm.runInThisContext(`
var unusedB = 1;
var data = [];
var b = "this";
delete b;
data.push(b);
data[0]
`);
data.push(item2);

vm.runInContext(
  `
var unusedC = 1;
var c = "new";
delete c;
data.push(c);
`,
  vm.createContext({ data: data })
);

assert.deepStrictEqual(data, ['direct', 'this', 'new']);

assert.strictEqual(typeof unusedB, 'number'); // Declared within runInThisContext
assert.strictEqual(typeof unusedC, 'undefined'); // Declared within runInContext
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-vm-options-validation.js                                             0000664 0000000 0000000 00000004257 14746647661 0023116 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const vm = require('vm');

const invalidArgType = {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE'
};

const outOfRange = {
  name: 'RangeError',
  code: 'ERR_OUT_OF_RANGE'
};

assert.throws(() => {
  new vm.Script('void 0', 42);
}, invalidArgType);

[null, {}, [1], 'bad', true].forEach((value) => {
  assert.throws(() => {
    new vm.Script('void 0', { lineOffset: value });
  }, invalidArgType);

  assert.throws(() => {
    new vm.Script('void 0', { columnOffset: value });
  }, invalidArgType);
});

[0.1, 2 ** 32].forEach((value) => {
  assert.throws(() => {
    new vm.Script('void 0', { lineOffset: value });
  }, outOfRange);

  assert.throws(() => {
    new vm.Script('void 0', { columnOffset: value });
  }, outOfRange);
});

assert.throws(() => {
  new vm.Script('void 0', { lineOffset: Number.MAX_SAFE_INTEGER });
}, outOfRange);

assert.throws(() => {
  new vm.Script('void 0', { columnOffset: Number.MAX_SAFE_INTEGER });
}, outOfRange);

assert.throws(() => {
  new vm.Script('void 0', { filename: 123 });
}, invalidArgType);

assert.throws(() => {
  new vm.Script('void 0', { produceCachedData: 1 });
}, invalidArgType);

[[0], {}, true, 'bad', 42].forEach((value) => {
  assert.throws(() => {
    new vm.Script('void 0', { cachedData: value });
  }, invalidArgType);
});

{
  const script = new vm.Script('void 0');
  const sandbox = vm.createContext();

  function assertErrors(options, errCheck) {
    assert.throws(() => {
      script.runInThisContext(options);
    }, errCheck);

    assert.throws(() => {
      script.runInContext(sandbox, options);
    }, errCheck);

    assert.throws(() => {
      script.runInNewContext({}, options);
    }, errCheck);
  }

  [null, 'bad', 42].forEach((value) => {
    assertErrors(value, invalidArgType);
  });
  [{}, [1], 'bad', null].forEach((value) => {
    assertErrors({ timeout: value }, invalidArgType);
  });
  [-1, 0, NaN].forEach((value) => {
    assertErrors({ timeout: value }, outOfRange);
  });
  [{}, [1], 'bad', 1, null].forEach((value) => {
    assertErrors({ displayErrors: value }, invalidArgType);
    assertErrors({ breakOnSigint: value }, invalidArgType);
  });
}
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-vm-ownkeys.js                                                        0000664 0000000 0000000 00000001541 14746647661 0020763 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const vm = require('vm');
const assert = require('assert');

const sym1 = Symbol('1');
const sym2 = Symbol('2');
const sandbox = {
  a: true,
  [sym1]: true,
};
Object.defineProperty(sandbox, 'b', { value: true });
Object.defineProperty(sandbox, sym2, { value: true });

const ctx = vm.createContext(sandbox);

assert.deepStrictEqual(Reflect.ownKeys(sandbox), ['a', 'b', sym1, sym2]);
assert.deepStrictEqual(Object.getOwnPropertyNames(sandbox), ['a', 'b']);
assert.deepStrictEqual(Object.getOwnPropertySymbols(sandbox), [sym1, sym2]);

const nativeKeys = vm.runInNewContext('Reflect.ownKeys(this);');
const ownKeys = vm.runInContext('Reflect.ownKeys(this);', ctx);
const restKeys = ownKeys.filter((key) => !nativeKeys.includes(key));
// This should not fail
assert.deepStrictEqual(Array.from(restKeys), ['a', 'b', sym1, sym2]);
                                                                                                                                                               node-23.7.0/test/parallel/test-vm-ownpropertynames.js                                               0000664 0000000 0000000 00000001563 14746647661 0022724 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const vm = require('vm');
const assert = require('assert');

const sym1 = Symbol('1');
const sym2 = Symbol('2');
const sandbox = {
  a: true,
  [sym1]: true,
};
Object.defineProperty(sandbox, 'b', { value: true });
Object.defineProperty(sandbox, sym2, { value: true });

const ctx = vm.createContext(sandbox);

assert.deepStrictEqual(Reflect.ownKeys(sandbox), ['a', 'b', sym1, sym2]);
assert.deepStrictEqual(Object.getOwnPropertyNames(sandbox), ['a', 'b']);
assert.deepStrictEqual(Object.getOwnPropertySymbols(sandbox), [sym1, sym2]);

const nativeNames = vm.runInNewContext('Object.getOwnPropertyNames(this);');
const ownNames = vm.runInContext('Object.getOwnPropertyNames(this);', ctx);
const restNames = ownNames.filter((name) => !nativeNames.includes(name));
// This should not fail
assert.deepStrictEqual(Array.from(restNames), ['a', 'b']);
                                                                                                                                             node-23.7.0/test/parallel/test-vm-ownpropertysymbols.js                                             0000664 0000000 0000000 00000001553 14746647661 0023310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const vm = require('vm');
const assert = require('assert');

const sym1 = Symbol('1');
const sym2 = Symbol('2');
const sandbox = {
  a: true,
  [sym1]: true,
};
Object.defineProperty(sandbox, 'b', { value: true });
Object.defineProperty(sandbox, sym2, { value: true });

const ctx = vm.createContext(sandbox);

assert.deepStrictEqual(Reflect.ownKeys(sandbox), ['a', 'b', sym1, sym2]);
assert.deepStrictEqual(Object.getOwnPropertyNames(sandbox), ['a', 'b']);
assert.deepStrictEqual(Object.getOwnPropertySymbols(sandbox), [sym1, sym2]);

const nativeSym = vm.runInNewContext('Object.getOwnPropertySymbols(this);');
const ownSym = vm.runInContext('Object.getOwnPropertySymbols(this);', ctx);
const restSym = ownSym.filter((sym) => !nativeSym.includes(sym));
// This should not fail
assert.deepStrictEqual(Array.from(restSym), [sym1, sym2]);
                                                                                                                                                     node-23.7.0/test/parallel/test-vm-parse-abort-on-uncaught-exception.js                              0000664 0000000 0000000 00000000561 14746647661 0025726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --abort-on-uncaught-exception
'use strict';
require('../common');
const vm = require('vm');

// Regression test for https://github.com/nodejs/node/issues/13258

try {
  new vm.Script({ toString() { throw new Error('foo'); } }, {});
} catch {
  // Continue regardless of error.
}

try {
  new vm.Script('[', {});
} catch {
  // Continue regardless of error.
}
                                                                                                                                               node-23.7.0/test/parallel/test-vm-preserves-property.js                                             0000664 0000000 0000000 00000001121 14746647661 0023156 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

const vm = require('vm');

const x = {};
Object.defineProperty(x, 'prop', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: 'val'
});
const o = vm.createContext(x);

const code = 'Object.getOwnPropertyDescriptor(this, "prop")';
const res = vm.runInContext(code, o, 'test');

assert(res);
assert.strictEqual(typeof res, 'object');
assert.strictEqual(res.value, 'val');
assert.strictEqual(res.configurable, false);
assert.strictEqual(res.enumerable, false);
assert.strictEqual(res.writable, false);
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-vm-property-not-on-sandbox.js                                        0000664 0000000 0000000 00000002655 14746647661 0024023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

// This, admittedly contrived, example tests an edge cases of the vm module.
//
// The GetterCallback explicitly checks the global_proxy() if a property is
// not found on the sandbox. In the following test, the explicit check
// inside the callback yields different results than deferring the
// check until after the callback. The check is deferred if the
// callback does not intercept, i.e., if args.GetReturnValue().Set() is
// not called.

// Check that the GetterCallback explicitly calls GetRealNamedProperty()
// on the global proxy if the property is not found on the sandbox.
//
// foo is not defined on the sandbox until we call CopyProperties().
// In the GetterCallback, we do not find the property on the sandbox and
// get the property from the global proxy. Since the return value is
// the sandbox, we replace it by
// the global_proxy to keep the correct identities.
//
// This test case is partially inspired by
// https://github.com/nodejs/node/issues/855
const sandbox = { console };
sandbox.document = { defaultView: sandbox };
vm.createContext(sandbox);
const code = `Object.defineProperty(
               this,
               'foo',
               { get: function() {return document.defaultView} }
             );
             var result = foo === this;`;

vm.runInContext(code, sandbox);
assert.strictEqual(sandbox.result, true);
                                                                                   node-23.7.0/test/parallel/test-vm-proxies.js                                                        0000664 0000000 0000000 00000001177 14746647661 0020762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const vm = require('vm');

// src/node_contextify.cc filters out the Proxy object from the parent
// context.  Make sure that the new context has a Proxy object of its own.
let sandbox = {};
vm.runInNewContext('this.Proxy = Proxy', sandbox);
assert.strictEqual(typeof sandbox.Proxy, 'function');
assert.notStrictEqual(sandbox.Proxy, Proxy);

// Unless we copy the Proxy object explicitly, of course.
sandbox = { Proxy };
vm.runInNewContext('this.Proxy = Proxy', sandbox);
assert.strictEqual(typeof sandbox.Proxy, 'function');
assert.strictEqual(sandbox.Proxy, Proxy);
                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-vm-proxy-failure-CP.js                                               0000664 0000000 0000000 00000000622 14746647661 0022371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const vm = require('vm');

// Check that we do not accidentally query attributes.
// Issue: https://github.com/nodejs/node/issues/11902
const handler = {
  getOwnPropertyDescriptor: (target, prop) => {
    throw new Error('whoops');
  }
};
const sandbox = new Proxy({ foo: 'bar' }, handler);
const context = vm.createContext(sandbox);

vm.runInContext('', context);
                                                                                                              node-23.7.0/test/parallel/test-vm-run-in-new-context.js                                             0000664 0000000 0000000 00000006440 14746647661 0022750 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Flags: --expose-gc

const common = require('../common');
const assert = require('assert');
const vm = require('vm');

if (typeof globalThis.gc !== 'function')
  assert.fail('Run this test with --expose-gc');

// Run a string
const result = vm.runInNewContext('\'passed\';');
assert.strictEqual(result, 'passed');

// Thrown error
assert.throws(() => {
  vm.runInNewContext('throw new Error(\'test\');');
}, /^Error: test$/);

globalThis.hello = 5;
vm.runInNewContext('hello = 2');
assert.strictEqual(globalThis.hello, 5);


// Pass values in and out
globalThis.code = 'foo = 1;' +
              'bar = 2;' +
              'if (baz !== 3) throw new Error(\'test fail\');';
globalThis.foo = 2;
globalThis.obj = { foo: 0, baz: 3 };
/* eslint-disable no-unused-vars */
const baz = vm.runInNewContext(globalThis.code, globalThis.obj);
/* eslint-enable no-unused-vars */
assert.strictEqual(globalThis.obj.foo, 1);
assert.strictEqual(globalThis.obj.bar, 2);
assert.strictEqual(globalThis.foo, 2);

// Call a function by reference
function changeFoo() { globalThis.foo = 100; }
vm.runInNewContext('f()', { f: changeFoo });
assert.strictEqual(globalThis.foo, 100);

// Modify an object by reference
const f = { a: 1 };
vm.runInNewContext('f.a = 2', { f });
assert.strictEqual(f.a, 2);

// Use function in context without referencing context
const fn = vm.runInNewContext('(function() { obj.p = {}; })', { obj: {} });
globalThis.gc();
fn();
// Should not crash

const filename = 'test_file.vm';
for (const arg of [filename, { filename }]) {
  // Verify that providing a custom filename works.
  const code = 'throw new Error("foo");';

  assert.throws(() => {
    vm.runInNewContext(code, {}, arg);
  }, (err) => {
    const lines = err.stack.split('\n');

    assert.strictEqual(lines[0].trim(), `${filename}:1`);
    assert.strictEqual(lines[1].trim(), code);
    // Skip lines[2] and lines[3]. They're just a ^ and blank line.
    assert.strictEqual(lines[4].trim(), 'Error: foo');
    assert.strictEqual(lines[5].trim(), `at ${filename}:1:7`);
    // The rest of the stack is uninteresting.
    return true;
  });
}

common.allowGlobals(
  globalThis.hello,
  globalThis.code,
  globalThis.foo,
  globalThis.obj
);
                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-vm-script-throw-in-tostring.js                                       0000664 0000000 0000000 00000000314 14746647661 0024201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

const vm = require('vm');

assert.throws(() => {
  new vm.Script({
    toString() {
      throw new Error();
    }
  });
}, Error);
                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-set-property-proxy.js                                             0000664 0000000 0000000 00000000642 14746647661 0023121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const vm = require('vm');

// Regression test for https://github.com/nodejs/node/issues/34606

const handler = {
  getOwnPropertyDescriptor: common.mustCallAtLeast(() => {
    return {};
  })
};

const proxy = new Proxy({}, handler);
assert.throws(() => vm.runInNewContext('p = 6', proxy),
              /getOwnPropertyDescriptor/);
                                                                                              node-23.7.0/test/parallel/test-vm-set-proto-null-on-globalthis.js                                   0000664 0000000 0000000 00000000607 14746647661 0024732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');

// Setting __proto__ on vm context's globalThis should not cause a crash
// Regression test for https://github.com/nodejs/node/issues/47798

const vm = require('vm');
const context = vm.createContext();

const contextGlobalThis = vm.runInContext('this', context);

// Should not crash.
contextGlobalThis.__proto__ = null; // eslint-disable-line no-proto
                                                                                                                         node-23.7.0/test/parallel/test-vm-sigint-existing-handler.js                                        0000664 0000000 0000000 00000004614 14746647661 0024030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
if (common.isWindows) {
  // No way to send CTRL_C_EVENT to processes from JS right now.
  common.skip('platform not supported');
}

const assert = require('assert');
const vm = require('vm');
const spawn = require('child_process').spawn;

const methods = [
  'runInThisContext',
  'runInContext',
];

if (process.argv[2] === 'child') {
  const method = process.argv[3];
  assert.ok(method);

  let firstHandlerCalled = 0;
  process.on('SIGINT', common.mustCall(() => {
    firstHandlerCalled++;
    // Handler attached _before_ execution.
  }, 2));

  let onceHandlerCalled = 0;
  process.once('SIGINT', common.mustCall(() => {
    onceHandlerCalled++;
    // Handler attached _before_ execution.
  }));

  const script = `process.send('${method}'); while(true) {}`;
  const args = method === 'runInContext' ?
    [vm.createContext({ process })] :
    [];
  const options = { breakOnSigint: true };

  assert.throws(
    () => { vm[method](script, ...args, options); },
    {
      code: 'ERR_SCRIPT_EXECUTION_INTERRUPTED',
      message: 'Script execution was interrupted by `SIGINT`'
    });
  assert.strictEqual(firstHandlerCalled, 0);
  assert.strictEqual(onceHandlerCalled, 0);

  // Keep the process alive for a while so that the second SIGINT can be caught.
  const timeout = setTimeout(() => {}, 1000);

  let afterHandlerCalled = 0;

  process.on('SIGINT', common.mustCall(() => {
    // Handler attached _after_ execution.
    if (afterHandlerCalled++ === 0) {
      // The first time it just bounces back to check that the `once()`
      // handler is not called the second time.
      assert.strictEqual(firstHandlerCalled, 1);
      assert.strictEqual(onceHandlerCalled, 1);
      process.send(method);
      return;
    }

    assert.strictEqual(onceHandlerCalled, 1);
    assert.strictEqual(firstHandlerCalled, 2);
    timeout.unref();
  }, 2));

  process.send(method);

  return;
}

for (const method of methods) {
  const child = spawn(process.execPath, [__filename, 'child', method], {
    stdio: [null, 'inherit', 'inherit', 'ipc']
  });

  child.on('message', common.mustCall(() => {
    // First kill() breaks the while(true) loop, second one invokes the real
    // signal handlers.
    process.kill(child.pid, 'SIGINT');
  }, 3));

  child.on('close', common.mustCall((code, signal) => {
    assert.strictEqual(signal, null);
    assert.strictEqual(code, 0);
  }));
}
                                                                                                                    node-23.7.0/test/parallel/test-vm-sigint.js                                                         0000664 0000000 0000000 00000002666 14746647661 0020572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
if (common.isWindows) {
  // No way to send CTRL_C_EVENT to processes from JS right now.
  common.skip('platform not supported');
}

const assert = require('assert');
const vm = require('vm');
const spawn = require('child_process').spawn;

if (process.argv[2] === 'child') {
  const method = process.argv[3];
  const listeners = +process.argv[4];
  assert.ok(method);
  assert.ok(Number.isInteger(listeners));

  const script = `process.send('${method}'); while(true) {}`;
  const args = method === 'runInContext' ?
    [vm.createContext({ process })] :
    [];
  const options = { breakOnSigint: true };

  for (let i = 0; i < listeners; i++)
    process.on('SIGINT', common.mustNotCall());

  assert.throws(
    () => { vm[method](script, ...args, options); },
    {
      code: 'ERR_SCRIPT_EXECUTION_INTERRUPTED',
      message: 'Script execution was interrupted by `SIGINT`'
    });
  return;
}

for (const method of ['runInThisContext', 'runInContext']) {
  for (const listeners of [0, 1, 2]) {
    const args = [__filename, 'child', method, listeners];
    const child = spawn(process.execPath, args, {
      stdio: [null, 'pipe', 'inherit', 'ipc']
    });

    child.on('message', common.mustCall(() => {
      process.kill(child.pid, 'SIGINT');
    }));

    child.on('close', common.mustCall((code, signal) => {
      assert.strictEqual(signal, null);
      assert.strictEqual(code, 0);
    }));
  }
}
                                                                          node-23.7.0/test/parallel/test-vm-source-map-url.js                                                 0000664 0000000 0000000 00000001112 14746647661 0022131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const vm = require('vm');

function checkSourceMapUrl(source, expectedSourceMapURL) {
  const script = new vm.Script(source);
  assert.strictEqual(script.sourceMapURL, expectedSourceMapURL);
}

// No magic comment
checkSourceMapUrl(`
function myFunc() {}
`, undefined);

// Malformed magic comment
checkSourceMapUrl(`
function myFunc() {}
// sourceMappingURL=sourcemap.json
`, undefined);

// Expected magic comment
checkSourceMapUrl(`
function myFunc() {}
//# sourceMappingURL=sourcemap.json
`, 'sourcemap.json');
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-vm-static-this.js                                                    0000664 0000000 0000000 00000004332 14746647661 0021521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/* eslint-disable strict */
const common = require('../common');
const assert = require('assert');
const vm = require('vm');

// Run a string
const result = vm.runInThisContext('\'passed\';');
assert.strictEqual(result, 'passed');

// thrown error
assert.throws(function() {
  vm.runInThisContext('throw new Error(\'test\');');
}, /test/);

globalThis.hello = 5;
vm.runInThisContext('hello = 2');
assert.strictEqual(globalThis.hello, 2);


// pass values
const code = 'foo = 1;' +
             'bar = 2;' +
             'if (typeof baz !== \'undefined\')' +
             'throw new Error(\'test fail\');';
globalThis.foo = 2;
globalThis.obj = { foo: 0, baz: 3 };
/* eslint-disable no-unused-vars */
const baz = vm.runInThisContext(code);
/* eslint-enable no-unused-vars */
assert.strictEqual(globalThis.obj.foo, 0);
assert.strictEqual(globalThis.bar, 2);
assert.strictEqual(globalThis.foo, 1);

// call a function
globalThis.f = function() { globalThis.foo = 100; };
vm.runInThisContext('f()');
assert.strictEqual(globalThis.foo, 100);

common.allowGlobals(
  globalThis.hello,
  globalThis.foo,
  globalThis.obj,
  globalThis.f
);
                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-vm-strict-assign.js                                                  0000664 0000000 0000000 00000001276 14746647661 0022063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

const vm = require('vm');

// https://github.com/nodejs/node/issues/10223
const ctx = vm.createContext();

// Define x with writable = false.
vm.runInContext('Object.defineProperty(this, "x", { value: 42 })', ctx);
assert.strictEqual(ctx.x, 42);
assert.strictEqual(vm.runInContext('x', ctx), 42);

vm.runInContext('x = 0', ctx);                      // Does not throw but x...
assert.strictEqual(vm.runInContext('x', ctx), 42);  // ...should be unaltered.

assert.throws(() => vm.runInContext('"use strict"; x = 0', ctx),
              /Cannot assign to read only property 'x'/);
assert.strictEqual(vm.runInContext('x', ctx), 42);
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-vm-strict-mode.js                                                    0000664 0000000 0000000 00000000601 14746647661 0021512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// https://github.com/nodejs/node/issues/12300

require('../common');
const assert = require('assert');
const vm = require('vm');

const ctx = vm.createContext({ x: 42 });

// This might look as if x has not been declared, but x is defined on the
// sandbox and the assignment should not throw.
vm.runInContext('"use strict"; x = 1', ctx);

assert.strictEqual(ctx.x, 1);
                                                                                                                               node-23.7.0/test/parallel/test-vm-symbols.js                                                        0000664 0000000 0000000 00000000672 14746647661 0020760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

const vm = require('vm');

const symbol = Symbol();

function Document() {
  this[symbol] = 'foo';
}

Document.prototype.getSymbolValue = function() {
  return this[symbol];
};

const context = new Document();
vm.createContext(context);

assert.strictEqual(context.getSymbolValue(), 'foo');

assert.strictEqual(vm.runInContext('this.getSymbolValue()', context), 'foo');
                                                                      node-23.7.0/test/parallel/test-vm-syntax-error-message.js                                           0000664 0000000 0000000 00000001134 14746647661 0023361 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const child_process = require('child_process');

const p = child_process.spawn(process.execPath, [
  '-e',
  'vm = require("vm");' +
      'context = vm.createContext({});' +
      'try { vm.runInContext("throw new Error(\'boo\')", context); } ' +
      'catch (e) { console.log(e.message); }',
]);

p.stderr.on('data', common.mustNotCall());

let output = '';

p.stdout.on('data', (data) => output += data);

p.stdout.on('end', common.mustCall(() => {
  assert.strictEqual(output.replace(/[\r\n]+/g, ''), 'boo');
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-syntax-error-stderr.js                                            0000664 0000000 0000000 00000001226 14746647661 0023242 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const child_process = require('child_process');
const fixtures = require('../common/fixtures');

const wrong_script = fixtures.path('keys/rsa_cert.crt');

const p = child_process.spawn(process.execPath, [
  '-e',
  'require(process.argv[1]);',
  wrong_script,
]);

p.stdout.on('data', common.mustNotCall());

let output = '';

p.stderr.on('data', (data) => output += data);

p.stderr.on('end', common.mustCall(() => {
  assert.match(output, /BEGIN CERT/);
  assert.match(output, /^\s+\^/m);
  assert.match(output, /Invalid left-hand side expression in prefix operation/);
}));
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-vm-timeout-escape-promise-2.js                                       0000664 0000000 0000000 00000001537 14746647661 0024030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// https://github.com/nodejs/node/issues/3020
// Promises used to allow code to escape the timeout
// set for runInContext, runInNewContext, and runInThisContext.

require('../common');
const assert = require('assert');
const vm = require('vm');

const NS_PER_MS = 1000000n;

const hrtime = process.hrtime.bigint;

function loop() {
  const start = hrtime();
  while (1) {
    const current = hrtime();
    const span = (current - start) / NS_PER_MS;
    if (span >= 2000n) {
      throw new Error(
        `escaped timeout at ${span} milliseconds!`);
    }
  }
}

assert.throws(() => {
  vm.runInNewContext(
    'Promise.resolve().then(() => loop());',
    {
      hrtime,
      loop
    },
    { timeout: 10, microtaskMode: 'afterEvaluate' }
  );
}, {
  code: 'ERR_SCRIPT_EXECUTION_TIMEOUT',
  message: 'Script execution timed out after 10ms'
});
                                                                                                                                                                 node-23.7.0/test/parallel/test-vm-timeout-escape-promise-module.js                                  0000664 0000000 0000000 00000002074 14746647661 0025151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-vm-modules
'use strict';

// https://github.com/nodejs/node/issues/3020
// Promises used to allow code to escape the timeout
// set for runInContext, runInNewContext, and runInThisContext.

const common = require('../common');
const assert = require('assert');
const vm = require('vm');

const NS_PER_MS = 1000000n;

const hrtime = process.hrtime.bigint;

function loop() {
  const start = hrtime();
  while (1) {
    const current = hrtime();
    const span = (current - start) / NS_PER_MS;
    if (span >= 2000n) {
      throw new Error(
        `escaped timeout at ${span} milliseconds!`);
    }
  }
}

assert.rejects(async () => {
  const module = new vm.SourceTextModule(
    'Promise.resolve().then(() => loop()); loop();',
    {
      context: vm.createContext({
        hrtime,
        loop
      }, { microtaskMode: 'afterEvaluate' })
    });
  await module.link(common.mustNotCall());
  await module.evaluate({ timeout: 5 });
}, {
  code: 'ERR_SCRIPT_EXECUTION_TIMEOUT',
  message: 'Script execution timed out after 5ms'
}).then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-vm-timeout-escape-promise.js                                         0000664 0000000 0000000 00000001546 14746647661 0023671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// https://github.com/nodejs/node/issues/3020
// Promises used to allow code to escape the timeout
// set for runInContext, runInNewContext, and runInThisContext.

require('../common');
const assert = require('assert');
const vm = require('vm');

const NS_PER_MS = 1000000n;

const hrtime = process.hrtime.bigint;

function loop() {
  const start = hrtime();
  while (1) {
    const current = hrtime();
    const span = (current - start) / NS_PER_MS;
    if (span >= 2000n) {
      throw new Error(
        `escaped timeout at ${span} milliseconds!`);
    }
  }
}

assert.throws(() => {
  vm.runInNewContext(
    'Promise.resolve().then(() => loop()); loop();',
    {
      hrtime,
      loop
    },
    { timeout: 5, microtaskMode: 'afterEvaluate' }
  );
}, {
  code: 'ERR_SCRIPT_EXECUTION_TIMEOUT',
  message: 'Script execution timed out after 5ms'
});
                                                                                                                                                          node-23.7.0/test/parallel/test-vm-timeout.js                                                        0000664 0000000 0000000 00000005346 14746647661 0020761 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
require('../common');
const assert = require('assert');
const vm = require('vm');

// Timeout of 100ms executing endless loop
assert.throws(
  function() {
    vm.runInThisContext('while(true) {}', { timeout: 100 });
  },
  {
    code: 'ERR_SCRIPT_EXECUTION_TIMEOUT',
    message: 'Script execution timed out after 100ms'
  });

// Timeout of 1000ms, script finishes first
vm.runInThisContext('', { timeout: 1000 });

// Nested vm timeouts, inner timeout propagates out
assert.throws(
  function() {
    const context = {
      log: console.log,
      runInVM: function(timeout) {
        vm.runInNewContext('while(true) {}', context, { timeout });
      }
    };
    vm.runInNewContext('runInVM(10)', context, { timeout: 10000 });
    throw new Error('Test 5 failed');
  },
  {
    code: 'ERR_SCRIPT_EXECUTION_TIMEOUT',
    message: 'Script execution timed out after 10ms'
  });

// Nested vm timeouts, outer timeout is shorter and fires first.
assert.throws(
  function() {
    const context = {
      runInVM: function(timeout) {
        vm.runInNewContext('while(true) {}', context, { timeout });
      }
    };
    vm.runInNewContext('runInVM(10000)', context, { timeout: 100 });
    throw new Error('Test 6 failed');
  },
  {
    code: 'ERR_SCRIPT_EXECUTION_TIMEOUT',
    message: 'Script execution timed out after 100ms'
  });

// Nested vm timeouts, inner script throws an error.
assert.throws(function() {
  const context = {
    runInVM: function(timeout) {
      vm.runInNewContext('throw new Error(\'foobar\')', context, { timeout });
    }
  };
  vm.runInNewContext('runInVM(10000)', context, { timeout: 100000 });
}, /foobar/);
                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-warn-multipleResolves.mjs                                            0000664 0000000 0000000 00000000423 14746647661 0023342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import { expectWarning, mustCall } from '../common/index.mjs';

expectWarning(
  'DeprecationWarning',
  'The multipleResolves event has been deprecated.',
  'DEP0160',
);

process.on('multipleResolves', mustCall());

new Promise((resolve) => {
  resolve();
  resolve();
});
                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-warn-sigprof.js                                                      0000664 0000000 0000000 00000001106 14746647661 0021257 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --inspect=0
'use strict';
const common = require('../common');

// The inspector attempts to start when Node starts. Once started, the inspector
// warns on the use of a SIGPROF listener.

common.skipIfInspectorDisabled();

if (common.isWindows) {
  common.skip('test does not apply to Windows');
}

const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('This test only works on a main thread');
}

common.expectWarning('Warning',
                     'process.on(SIGPROF) is reserved while debugging');

process.on('SIGPROF', () => {});
                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-warn-stream-wrap.js                                                  0000664 0000000 0000000 00000000345 14746647661 0022054 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

// _stream_wrap is deprecated.

common.expectWarning('DeprecationWarning',
                     'The _stream_wrap module is deprecated.', 'DEP0125');

require('_stream_wrap');
                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-watch-file-shared-dependency.mjs                                     0000664 0000000 0000000 00000004513 14746647661 0024426 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
import * as common from '../common/index.mjs';
import { describe, it } from 'node:test';
import assert from 'node:assert';
import tmpdir from '../common/tmpdir.js';
import watcher from 'internal/watch_mode/files_watcher';
import { writeFileSync } from 'node:fs';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

if (common.isAIX)
  common.skip('folder watch capability is limited in AIX.');

const { FilesWatcher } = watcher;

tmpdir.refresh();

// Set up test files and dependencies
const fixtureContent = {
  'dependency.js': 'module.exports = {};',
  'test.js': 'require(\'./dependency.js\');',
  'test-2.js': 'require(\'./dependency.js\');',
};

const fixturePaths = Object.fromEntries(Object.keys(fixtureContent)
  .map((file) => [file, tmpdir.resolve(file)]));

Object.entries(fixtureContent)
  .forEach(([file, content]) => writeFileSync(fixturePaths[file], content));

describe('watch file with shared dependency', () => {
  it('should not remove shared dependencies when unfiltering an owner', (t, done) => {
    const controller = new AbortController();
    const watcher = new FilesWatcher({ signal: controller.signal });

    watcher.on('changed', ({ owners }) => {
      if (owners.size !== 2) return;

      // If this code is never reached the test times out.
      assert.ok(owners.has(fixturePaths['test.js']));
      assert.ok(owners.has(fixturePaths['test-2.js']));
      controller.abort();
      done();
    });
    watcher.filterFile(fixturePaths['test.js']);
    watcher.filterFile(fixturePaths['test-2.js']);
    watcher.filterFile(fixturePaths['dependency.js'], fixturePaths['test.js']);
    watcher.filterFile(fixturePaths['dependency.js'], fixturePaths['test-2.js']);
    watcher.unfilterFilesOwnedBy([fixturePaths['test.js']]);
    watcher.filterFile(fixturePaths['test.js']);
    watcher.filterFile(fixturePaths['dependency.js'], fixturePaths['test.js']);

    if (common.isMacOS) {
      // Do the write with a delay to ensure that the OS is ready to notify us.
      setTimeout(() => {
        writeFileSync(
          fixturePaths['dependency.js'],
          'module.exports = { modified: true };'
        );
      }, common.platformTimeout(200));
    } else {
      writeFileSync(
        fixturePaths['dependency.js'],
        'module.exports = { modified: true };'
      );
    }
  });
});
                                                                                                                                                                                     node-23.7.0/test/parallel/test-watch-mode-files_watcher.mjs                                         0000664 0000000 0000000 00000015000 14746647661 0023661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
import * as common from '../common/index.mjs';
import * as fixtures from '../common/fixtures.mjs';
import tmpdir from '../common/tmpdir.js';
import path from 'node:path';
import assert from 'node:assert';
import process from 'node:process';
import { describe, it, beforeEach, afterEach } from 'node:test';
import { writeFileSync, mkdirSync } from 'node:fs';
import { setTimeout } from 'node:timers/promises';
import { once } from 'node:events';
import { spawn } from 'node:child_process';
import watcher from 'internal/watch_mode/files_watcher';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

const supportsRecursiveWatching = common.isMacOS || common.isWindows;

const { FilesWatcher } = watcher;
tmpdir.refresh();

describe('watch mode file watcher', () => {
  let watcher;
  let changesCount;

  beforeEach(() => {
    changesCount = 0;
    watcher = new FilesWatcher({ debounce: 100 });
    watcher.on('changed', () => changesCount++);
  });

  afterEach(() => watcher.clear());

  let counter = 0;
  function writeAndWaitForChanges(watcher, file) {
    return new Promise((resolve) => {
      const interval = setInterval(() => writeFileSync(file, `write ${counter++}`), 100);
      watcher.once('changed', () => {
        clearInterval(interval);
        resolve();
      });
    });
  }

  it('should watch changed files', async () => {
    const file = tmpdir.resolve('file1');
    writeFileSync(file, 'written');
    watcher.filterFile(file);
    await writeAndWaitForChanges(watcher, file);
    assert.strictEqual(changesCount, 1);
  });

  it('should debounce changes', async () => {
    const file = tmpdir.resolve('file2');
    writeFileSync(file, 'written');
    watcher.filterFile(file);
    await writeAndWaitForChanges(watcher, file);

    writeFileSync(file, '1');
    writeFileSync(file, '2');
    writeFileSync(file, '3');
    writeFileSync(file, '4');
    await setTimeout(200); // debounce * 2
    writeFileSync(file, '5');
    const changed = once(watcher, 'changed');
    writeFileSync(file, 'after');
    await changed;
    // Unfortunately testing that changesCount === 2 is flaky
    assert.ok(changesCount < 5);
  });

  it('should debounce changes on multiple files', async () => {
    const files = [];
    for (let i = 0; i < 10; i++) {
      const file = tmpdir.resolve(`file-debounced-${i}`);
      writeFileSync(file, 'written');
      watcher.filterFile(file);
      files.push(file);
    }

    files.forEach((file) => writeFileSync(file, '1'));
    files.forEach((file) => writeFileSync(file, '2'));
    files.forEach((file) => writeFileSync(file, '3'));
    files.forEach((file) => writeFileSync(file, '4'));

    await setTimeout(200); // debounce * 2
    files.forEach((file) => writeFileSync(file, '5'));
    const changed = once(watcher, 'changed');
    files.forEach((file) => writeFileSync(file, 'after'));
    await changed;
    // Unfortunately testing that changesCount === 2 is flaky
    assert.ok(changesCount < 5);
  });

  it('should ignore files in watched directory if they are not filtered',
     { skip: !supportsRecursiveWatching }, async () => {
       watcher.on('changed', common.mustNotCall());
       watcher.watchPath(tmpdir.path);
       writeFileSync(tmpdir.resolve('file3'), '1');
       // Wait for this long to make sure changes are not triggered
       await setTimeout(1000);
     });

  it('should allow clearing filters', async () => {
    const file = tmpdir.resolve('file4');
    writeFileSync(file, 'written');
    watcher.filterFile(file);
    await writeAndWaitForChanges(watcher, file);

    writeFileSync(file, '1');
    assert.strictEqual(changesCount, 1);

    watcher.clearFileFilters();
    writeFileSync(file, '2');
    // Wait for this long to make sure changes are triggered only once
    await setTimeout(1000);
    assert.strictEqual(changesCount, 1);
  });

  it('should watch all files in watched path when in "all" mode',
     { skip: !supportsRecursiveWatching }, async () => {
       watcher = new FilesWatcher({ debounce: 100, mode: 'all' });
       watcher.on('changed', () => changesCount++);

       const file = tmpdir.resolve('file5');
       watcher.watchPath(tmpdir.path);

       const changed = once(watcher, 'changed');
       await setTimeout(common.platformTimeout(100)); // avoid throttling
       writeFileSync(file, 'changed');
       await changed;
       assert.strictEqual(changesCount, 1);
     });

  it('should ruse existing watcher if it exists',
     { skip: !supportsRecursiveWatching }, () => {
       assert.deepStrictEqual(watcher.watchedPaths, []);
       watcher.watchPath(tmpdir.path);
       assert.deepStrictEqual(watcher.watchedPaths, [tmpdir.path]);
       watcher.watchPath(tmpdir.path);
       assert.deepStrictEqual(watcher.watchedPaths, [tmpdir.path]);
     });

  it('should ruse existing watcher of a parent directory',
     { skip: !supportsRecursiveWatching }, () => {
       assert.deepStrictEqual(watcher.watchedPaths, []);
       watcher.watchPath(tmpdir.path);
       assert.deepStrictEqual(watcher.watchedPaths, [tmpdir.path]);
       watcher.watchPath(tmpdir.resolve('subdirectory'));
       assert.deepStrictEqual(watcher.watchedPaths, [tmpdir.path]);
     });

  it('should remove existing watcher if adding a parent directory watcher',
     { skip: !supportsRecursiveWatching }, () => {
       assert.deepStrictEqual(watcher.watchedPaths, []);
       const subdirectory = tmpdir.resolve('subdirectory');
       mkdirSync(subdirectory);
       watcher.watchPath(subdirectory);
       assert.deepStrictEqual(watcher.watchedPaths, [subdirectory]);
       watcher.watchPath(tmpdir.path);
       assert.deepStrictEqual(watcher.watchedPaths, [tmpdir.path]);
     });

  it('should clear all watchers when calling clear',
     { skip: !supportsRecursiveWatching }, () => {
       assert.deepStrictEqual(watcher.watchedPaths, []);
       watcher.watchPath(tmpdir.path);
       assert.deepStrictEqual(watcher.watchedPaths, [tmpdir.path]);
       watcher.clear();
       assert.deepStrictEqual(watcher.watchedPaths, []);
     });

  it('should watch files from subprocess IPC events', async () => {
    const file = fixtures.path('watch-mode/ipc.js');
    const child = spawn(process.execPath, [file], { stdio: ['pipe', 'pipe', 'pipe', 'ipc'], encoding: 'utf8' });
    watcher.watchChildProcessModules(child);
    await once(child, 'exit');
    let expected = [file, tmpdir.resolve('file')];
    if (supportsRecursiveWatching) {
      expected = expected.map((file) => path.dirname(file));
    }
    assert.deepStrictEqual(watcher.watchedPaths, expected);
  });
});
node-23.7.0/test/parallel/test-weakref.js                                                           0000664 0000000 0000000 00000000341 14746647661 0020265 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --expose-gc

require('../common');
const assert = require('assert');

const w = new globalThis.WeakRef({});

setTimeout(() => {
  globalThis.gc();
  assert.strictEqual(w.deref(), undefined);
}, 200);
                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-webcrypto-constructors.js                                            0000664 0000000 0000000 00000007341 14746647661 0023434 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

// Test CryptoKey constructor
{
  assert.throws(() => new CryptoKey(), {
    name: 'TypeError', message: 'Illegal constructor', code: 'ERR_ILLEGAL_CONSTRUCTOR'
  });
}

// Test SubtleCrypto constructor
{
  assert.throws(() => new SubtleCrypto(), {
    name: 'TypeError', message: 'Illegal constructor', code: 'ERR_ILLEGAL_CONSTRUCTOR'
  });
}

// Test Crypto constructor
{
  assert.throws(() => new Crypto(), {
    name: 'TypeError', message: 'Illegal constructor', code: 'ERR_ILLEGAL_CONSTRUCTOR'
  });
}

const notCrypto = Reflect.construct(function() {}, [], Crypto);
const notSubtle = Reflect.construct(function() {}, [], SubtleCrypto);

// Test Crypto.prototype.subtle
{
  assert.throws(() => notCrypto.subtle, {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  });
}

// Test Crypto.prototype.randomUUID
{
  assert.throws(() => notCrypto.randomUUID(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  });
}

// Test Crypto.prototype.getRandomValues
{
  assert.throws(() => notCrypto.getRandomValues(new Uint8Array(12)), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  });
}

// Test SubtleCrypto.prototype.encrypt
{
  assert.rejects(() => notSubtle.encrypt(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.decrypt
{
  assert.rejects(() => notSubtle.decrypt(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.sign
{
  assert.rejects(() => notSubtle.sign(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.verify
{
  assert.rejects(() => notSubtle.verify(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.digest
{
  assert.rejects(() => notSubtle.digest(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.generateKey
{
  assert.rejects(() => notSubtle.generateKey(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.deriveKey
{
  assert.rejects(() => notSubtle.deriveKey(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.deriveBits
{
  assert.rejects(() => notSubtle.deriveBits(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.importKey
{
  assert.rejects(() => notSubtle.importKey(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.exportKey
{
  assert.rejects(() => notSubtle.exportKey(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.wrapKey
{
  assert.rejects(() => notSubtle.wrapKey(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

// Test SubtleCrypto.prototype.unwrapKey
{
  assert.rejects(() => notSubtle.unwrapKey(), {
    name: 'TypeError', code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
}

{
  subtle.importKey(
    'raw',
    globalThis.crypto.getRandomValues(new Uint8Array(4)),
    'PBKDF2',
    false,
    ['deriveKey'],
  ).then((key) => {
    subtle.importKey = common.mustNotCall();
    return subtle.deriveKey({
      name: 'PBKDF2',
      hash: 'SHA-512',
      salt: globalThis.crypto.getRandomValues(new Uint8Array()),
      iterations: 5,
    }, key, {
      name: 'AES-GCM',
      length: 256
    }, true, ['encrypt', 'decrypt']);
  }).then(common.mustCall());
}
                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-webcrypto-cryptokey-workers.js                                       0000664 0000000 0000000 00000002527 14746647661 0024410 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This test ensures that CryptoKey instances can be correctly
// sent to a Worker via postMessage.

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;
const { once } = require('events');

const {
  Worker,
  parentPort,
} = require('worker_threads');

const keyData =
  Buffer.from(
    '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f', 'hex');

const sig = '13691a79fb55a0417e4d6699a32f91ad29283fa2c1439865cc0632931f4f48dc';

async function doSig(key) {
  const signature = await subtle.sign({
    name: 'HMAC'
  }, key, Buffer.from('some data'));
  assert.strictEqual(Buffer.from(signature).toString('hex'), sig);
}

if (process.env.HAS_STARTED_WORKER) {
  return parentPort.once('message', (key) => {
    assert.strictEqual(key.algorithm.name, 'HMAC');
    doSig(key).then(common.mustCall());
  });
}

// Don't use isMainThread to allow running this test inside a worker.
process.env.HAS_STARTED_WORKER = 1;

(async function() {
  const worker = new Worker(__filename);

  await once(worker, 'online');

  const key = await subtle.importKey(
    'raw',
    keyData,
    { name: 'HMAC', hash: 'SHA-256' },
    true, ['sign', 'verify']);

  worker.postMessage(key);

  await doSig(key);
})().then(common.mustCall());
                                                                                                                                                                         node-23.7.0/test/parallel/test-webcrypto-derivebits-cfrg.js                                         0000664 0000000 0000000 00000012752 14746647661 0023745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const kTests = [
  {
    name: 'X25519',
    size: 32,
    pkcs8: '302e020100300506032b656e04220420c8838e76d057dfb7d8c95a69e138160ad' +
           'd6373fd71a4d276bb56e3a81b64ff61',
    spki: '302a300506032b656e0321001cf2b1e6022ec537371ed7f53e54fa1154d83e98eb' +
          '64ea51fae5b3307cfe9706',
    result: '2768409dfab99ec23b8c89b93ff5880295f76176088f89e43dfebe7ea1950008'
  },
  {
    name: 'X448',
    size: 56,
    pkcs8: '3046020100300506032b656f043a043858c7d29a3eb519b29d00cfb191bb64fc6' +
           'd8a42d8f17176272b89f2272d1819295c6525c0829671b052ef0727530f188e31' +
           'd0cc53bf26929e',
    spki: '3042300506032b656f033900b604a1d1a5cd1d9426d561ef630a9eb16cbe69d5b9' +
          'ca615edc53633efb52ea31e6e6a0a1dbacc6e76cbce6482d7e4ba3d55d9e802765' +
          'ce6f',
    result: 'f0f6c5f17f94f4291eab7178866d37ec8906dd6c514143dc85be7cf28deff39b' +
            '726e0f6dcf810eb594dca97b4882bd44c43ea7dc67f49a4e',
  },
];

async function prepareKeys() {
  const keys = {};
  await Promise.all(
    kTests.map(async ({ name, size, pkcs8, spki, result }) => {
      const [
        privateKey,
        publicKey,
      ] = await Promise.all([
        subtle.importKey(
          'pkcs8',
          Buffer.from(pkcs8, 'hex'),
          { name },
          true,
          ['deriveKey', 'deriveBits']),
        subtle.importKey(
          'spki',
          Buffer.from(spki, 'hex'),
          { name },
          true,
          []),
      ]);
      keys[name] = {
        privateKey,
        publicKey,
        size,
        result,
      };
    }));
  return keys;
}

(async function() {
  const keys = await prepareKeys();

  await Promise.all(
    Object.keys(keys).map(async (name) => {
      const { size, result, privateKey, publicKey } = keys[name];

      {
        // Good parameters
        const bits = await subtle.deriveBits({
          name,
          public: publicKey
        }, privateKey, 8 * size);

        assert(bits instanceof ArrayBuffer);
        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Case insensitivity
        const bits = await subtle.deriveBits({
          name: name.toLowerCase(),
          public: publicKey
        }, privateKey, 8 * size);

        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Null length
        const bits = await subtle.deriveBits({
          name,
          public: publicKey
        }, privateKey, null);

        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Default length
        const bits = await subtle.deriveBits({
          name,
          public: publicKey
        }, privateKey);

        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Short Result
        const bits = await subtle.deriveBits({
          name,
          public: publicKey
        }, privateKey, 8 * size - 32);

        assert.strictEqual(
          Buffer.from(bits).toString('hex'),
          result.slice(0, -8));
      }

      {
        // Too long result
        await assert.rejects(subtle.deriveBits({
          name,
          public: publicKey
        }, privateKey, 8 * size + 8), {
          message: /derived bit length is too small/
        });
      }

      {
        // Non-multiple of 8
        const bits = await subtle.deriveBits({
          name,
          public: publicKey
        }, privateKey, 8 * size - 11);

        const expected = Buffer.from(result.slice(0, -2), 'hex');
        expected[size - 2] = expected[size - 2] & 0b11111000;
        assert.deepStrictEqual(
          Buffer.from(bits),
          expected);
      }
    }));

  // Error tests
  {
    // Missing public property
    await assert.rejects(
      subtle.deriveBits(
        { name: 'X448' },
        keys.X448.privateKey,
        8 * keys.X448.size),
      { code: 'ERR_MISSING_OPTION' });
  }

  {
    // The public property is not a CryptoKey
    await assert.rejects(
      subtle.deriveBits(
        {
          name: 'X448',
          public: { message: 'Not a CryptoKey' }
        },
        keys.X448.privateKey,
        8 * keys.X448.size),
      { code: 'ERR_INVALID_ARG_TYPE' });
  }

  {
    // Mismatched types
    await assert.rejects(
      subtle.deriveBits(
        {
          name: 'X448',
          public: keys.X25519.publicKey
        },
        keys.X448.privateKey,
        8 * keys.X448.size),
      { message: 'The public and private keys must be of the same type' });
  }

  {
    // Base key is not a private key
    await assert.rejects(subtle.deriveBits({
      name: 'X448',
      public: keys.X448.publicKey
    }, keys.X448.publicKey, null), {
      name: 'InvalidAccessError'
    });
  }

  {
    // Base key is not a private key
    await assert.rejects(subtle.deriveBits({
      name: 'X448',
      public: keys.X448.privateKey
    }, keys.X448.publicKey, null), {
      name: 'InvalidAccessError'
    });
  }

  {
    // Public is a secret key
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    const key = await subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-CBC', length: 256 },
      false, ['encrypt']);

    await assert.rejects(subtle.deriveBits({
      name: 'X448',
      public: key
    }, keys.X448.publicKey, null), {
      name: 'InvalidAccessError'
    });
  }
})().then(common.mustCall());
                      node-23.7.0/test/parallel/test-webcrypto-derivebits-ecdh.js                                         0000664 0000000 0000000 00000017315 14746647661 0023727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const kTests = [
  {
    namedCurve: 'P-521',
    size: 66,
    pkcs8: '3081ee020100301006072a8648ce3d020106052b810400230481d63081d302010' +
           '1044201a67ed321915a64aa359b7d648ddc2618fa8e8d1867e8f71830b10d25ed' +
           '2891faf12f3c7e75421a2ea264f9a915320d274fe1470742b984e96b98912081f' +
           'acd478da18189038186000400209d483f28666881c6641f3a126f400f51e46511' +
           '70fe678c75e85712e2868adc850824997bebf0bc82b43028a6d2ec1777ca45279' +
           'f7206a3ea8b5cd2073f493e45000cb54c3a5acaa268c56710428878d98b8afbf6' +
           '8a612153632846d807e92672698f1b9c611de7d38e34cd6c73889092c56e52d68' +
           '0f1dfd092b87ac8ef9ff3c8fb48',
    spki: '30819b301006072a8648ce3d020106052b81040023038186000400ee69f94715d7' +
          '01e9e2011333d4f4f96cba7d91f88b112baf75cf09cc1f8aca97618da9389822d2' +
          '9b6fe9996a61203ef752b771e8958fc4677bb3778565ab60d6ed00deab6761895b' +
          '935e3ad325fb8549e56f13786aa73f88a2ecfe40933473d8aef240c4dfd7d506f2' +
          '2cdd0e55558f3fbf05ebf7efef7a72d78f46469b8448f26e2712',
    result: '009c2bce57be80adab3b07385b8e5990eb7d6fdebdb01bf35371a4f6075e9d28' +
            '8ac12a6dfe03aa5743bc81709d49a822940219b64b768acd520fa1368ea0af8d' +
            '475d',
  },
  {
    namedCurve: 'P-384',
    size: 48,
    pkcs8: '3081b6020100301006072a8648ce3d020106052b8104002204819e30819b02010' +
           '10430f871a5666589c14a5747263ef85b319cc023db6e35676c3d781eef8b055f' +
           'cfbe86fa0d06d056b5195fb1323af8de25b3a16403620004f11965df7dd4594d0' +
           '419c5086482a3b826b9797f9be0bd0d109c9e1e9989c1b9a92b8f269f98e17ad1' +
           '84ba73c1f79762af45af8141602642da271a6bb0ffeb0cb4478fcf707e661aa6d' +
           '6cdf51549c88c3f130be9e8201f6f6a09f4185aaf95c4',
    spki: '3076301006072a8648ce3d020106052b810400220362000491822dc2af59c18f5b' +
          '67f80df61a2603c2a8f0b3c0af822d63c279701a824560404401dde9a56ee52757' +
          'ea8bc748d4c82b5337b48d7b65583a3d572438880036bac6730f42ca5278966bd5' +
          'f21e86e21d30c5a6d0463ec513dd509ffcdcaf1ff5',
    result: 'e0bd6bce0aef8ca48838a6e2fcc57e67b9c5e8860c5f0be9dabec53e454e18a0' +
            'a174c48888a26488115b2dc9f1dfa52d',
  },
];

async function prepareKeys() {
  const keys = {};
  await Promise.all(
    kTests.map(async ({ namedCurve, size, pkcs8, spki, result }) => {
      const [
        privateKey,
        publicKey,
      ] = await Promise.all([
        subtle.importKey(
          'pkcs8',
          Buffer.from(pkcs8, 'hex'),
          {
            name: 'ECDH',
            namedCurve
          },
          true,
          ['deriveKey', 'deriveBits']),
        subtle.importKey(
          'spki',
          Buffer.from(spki, 'hex'),
          {
            name: 'ECDH',
            namedCurve
          },
          true,
          []),
      ]);
      keys[namedCurve] = {
        privateKey,
        publicKey,
        size,
        result,
      };
    }));
  return keys;
}

(async function() {
  const keys = await prepareKeys();

  await Promise.all(
    Object.keys(keys).map(async (namedCurve) => {
      const { size, result, privateKey, publicKey } = keys[namedCurve];

      {
        // Good parameters
        const bits = await subtle.deriveBits({
          name: 'ECDH',
          public: publicKey
        }, privateKey, 8 * size);

        assert(bits instanceof ArrayBuffer);
        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Case insensitivity
        const bits = await subtle.deriveBits({
          name: 'eCdH',
          public: publicKey
        }, privateKey, 8 * size);

        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Null length
        const bits = await subtle.deriveBits({
          name: 'ECDH',
          public: publicKey
        }, privateKey, null);

        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Default length
        const bits = await subtle.deriveBits({
          name: 'ECDH',
          public: publicKey
        }, privateKey);

        assert.strictEqual(Buffer.from(bits).toString('hex'), result);
      }

      {
        // Short Result
        const bits = await subtle.deriveBits({
          name: 'ECDH',
          public: publicKey
        }, privateKey, 8 * size - 32);

        assert.strictEqual(
          Buffer.from(bits).toString('hex'),
          result.slice(0, -8));
      }

      {
        // Too long result
        await assert.rejects(subtle.deriveBits({
          name: 'ECDH',
          public: publicKey
        }, privateKey, 8 * size + 8), {
          message: /derived bit length is too small/
        });
      }

      {
        // Non-multiple of 8
        const bits = await subtle.deriveBits({
          name: 'ECDH',
          public: publicKey
        }, privateKey, 8 * size - 11);

        const expected = Buffer.from(result.slice(0, -2), 'hex');
        expected[size - 2] = expected[size - 2] & 0b11111000;
        assert.deepStrictEqual(
          Buffer.from(bits),
          expected);
      }
    }));

  // Error tests
  {
    // Missing public property
    await assert.rejects(
      subtle.deriveBits(
        { name: 'ECDH' },
        keys['P-384'].privateKey,
        8 * keys['P-384'].size),
      { code: 'ERR_MISSING_OPTION' });
  }

  {
    // The public property is not a CryptoKey
    await assert.rejects(
      subtle.deriveBits(
        {
          name: 'ECDH',
          public: { message: 'Not a CryptoKey' }
        },
        keys['P-384'].privateKey,
        8 * keys['P-384'].size),
      { code: 'ERR_INVALID_ARG_TYPE' });
  }

  {
    // Mismatched named curves
    await assert.rejects(
      subtle.deriveBits(
        {
          name: 'ECDH',
          public: keys['P-384'].publicKey
        },
        keys['P-521'].privateKey,
        8 * keys['P-521'].size),
      { message: /Named curve mismatch/ });
  }

  {
    // Incorrect public key algorithm
    const { publicKey } = await subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-521'
      }, false, ['sign', 'verify']);

    await assert.rejects(subtle.deriveBits({
      name: 'ECDH',
      public: publicKey
    }, keys['P-521'].privateKey, null), {
      message: /Keys must be ECDH, X25519, or X448 keys/
    });
  }

  {
    // Private key does not have correct usages
    const privateKey = await subtle.importKey(
      'pkcs8',
      Buffer.from(kTests[0].pkcs8, 'hex'),
      {
        name: 'ECDH',
        namedCurve: 'P-521'
      }, false, ['deriveKey']);

    await assert.rejects(subtle.deriveBits({
      name: 'ECDH',
      public: keys['P-521'].publicKey,
    }, privateKey, null), {
      message: /baseKey does not have deriveBits usage/
    });
  }

  {
    // Base key is not a private key
    await assert.rejects(subtle.deriveBits({
      name: 'ECDH',
      public: keys['P-521'].publicKey
    }, keys['P-521'].publicKey, null), {
      name: 'InvalidAccessError'
    });
  }

  {
    // Public is not a public key
    await assert.rejects(subtle.deriveBits({
      name: 'ECDH',
      public: keys['P-521'].privateKey
    }, keys['P-521'].privateKey, null), {
      name: 'InvalidAccessError'
    });
  }

  {
    // Public is a secret key
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    const key = await subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-CBC', length: 256 },
      false, ['encrypt']);

    await assert.rejects(subtle.deriveBits({
      name: 'ECDH',
      public: key
    }, keys['P-521'].publicKey, null), {
      name: 'InvalidAccessError'
    });
  }
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-webcrypto-derivebits-hkdf.js                                         0000664 0000000 0000000 00000034516 14746647661 0023742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

function getDeriveKeyInfo(name, length, hash, ...usages) {
  return [{ name, length, hash }, usages];
}

const kDerivedKeyTypes = [
  ['AES-CBC', 128, undefined, 'encrypt', 'decrypt'],
  ['AES-CBC', 256, undefined, 'encrypt', 'decrypt'],
  ['AES-CTR', 128, undefined, 'encrypt', 'decrypt'],
  ['AES-CTR', 256, undefined, 'encrypt', 'decrypt'],
  ['AES-GCM', 128, undefined, 'encrypt', 'decrypt'],
  ['AES-GCM', 256, undefined, 'encrypt', 'decrypt'],
  ['AES-KW', 128, undefined, 'wrapKey', 'unwrapKey'],
  ['AES-KW', 256, undefined, 'wrapKey', 'unwrapKey'],
  ['HMAC', 256, 'SHA-1', 'sign', 'verify'],
  ['HMAC', 256, 'SHA-256', 'sign', 'verify'],
  ['HMAC', 256, 'SHA-384', 'sign', 'verify'],
  ['HMAC', 256, 'SHA-512', 'sign', 'verify'],
];

const kDerivedKeys = {
  short: '5040737377307264',
  long: '55736572732073686f756c64207069636b206c6f6e6720706173737068726' +
          '173657320286e6f74207573652073686f72742070617373776f7264732921',
  empty: ''
};

const kSalts = {
  normal: '536f6469756d2043686c6f7269646520636f6d706f756e64',
  empty: ''
};

const kInfos = {
  normal: '484b444620657874726120696e666f',
  empty: ''
};

const kDerivations = {
  short: {
    normal: {
      'SHA-384': {
        normal: '19ba74368e6b993390f27fe9a7d02bc3' +
                '38173f72be71a19fc744fcdb3fd4b84b',
        empty: '97601f4e0c53a5d3f3a2810099bc6820' +
               'ec50083434769b59fc24a417a9543734'
      },
      'SHA-512': {
        normal: '4bbd6db2435fb696157f6089c977c3c7' +
                '3f3eac5ef3dd6baae604cb53bfbb153e',
        empty: '2f3157e7fe0c10b01298c8f0886a90ed' +
               'cf80abdef5dbc1df2b1482532b52b934'
      },
      'SHA-1': {
        normal: '05ad22ed2138c9600e4d9e2725ded301' +
                'f5d287fbfb5702f999bc6536d3edef98',
        empty: 'd51b6fb7e599ca30c5ee264593e4b85f' +
               '2220c7c3ab003157bff8cb4f369c7560'
      },
      'SHA-256': {
        normal: '2af5901e28849c28443857386aa1ac3b' +
                'b127e92631c1c051482d6690941772b4',
        empty: '9e4b719033742101e90f1ad61e2ff3b4' +
               '256863667296d74389f1f02af2c4e6a6'
      }
    },
    empty: {
      'SHA-384': {
        normal: 'fb482ff22c4f8d466c4dfe6e29f2cc2e' +
                'cdabf5884328fbf08a738fd945f166cb',
        empty: '1e023c17b340533ceaef39230cb8b3bb' +
               'dbf663a13d6075d0dd326c049478fba5'
      },
      'SHA-512': {
        normal: 'f17b5bdcd8d7d3d4601036a19436317d' +
                '1644f9a4e0956efc0e372b83acdacfdb',
        empty: 'c7b474942f31f83faf5d14731802b1bd' +
               '49478549cb3a8f3dbfedc4d3209cf5b6'
      },
      'SHA-1': {
        normal: 'c126f1e6f25a9de42cf7d427059a52ed' +
                '9601f29a5815cbfbc64bc7f668c6a341',
        empty: '3215c3f08de70549b051b7033745a818' +
               '4f8cbaa6b1735330d2bcb6b16f4642ef'
      },
      'SHA-256': {
        normal: '733c8b6bcfac875c7f08982a6e3ffb56' +
                '0acea6f165476eb83460b9353ed41dfe',
        empty: 'c8e12774135305c9147f2cc4766e5ead' +
               '25d8f457b9a1953d52677361ced558fb'
      }
    }
  },
  long: {
    normal: {
      'SHA-384': {
        normal: 'f91571b521f7eef13e573aa46378659e' +
                'f3b7f36ffdd1bb055db2cd77d260c467',
        empty: '68af1c2cf6b9370d2054344798bdbb18' +
               '47ccf407b7652b793dd136d4640e0348'
      },
      'SHA-512': {
        normal: '710aae2fdf889e45fe0fb995b2c26b33' +
                'eb988650ec0faef167028a7a6ccb3638',
        empty: 'e5de568081c71e562750829871c34275' +
               '8104765ed6f306f0613c9d4bb336f2aa'
      },
      'SHA-1': {
        normal: '7f957edcbce3cb0b70566e1eb60efd1e' +
                '405a13304c661d3663778109bf06899c',
        empty: '3062f3cf1a730b9cef51f02c1dfac85e' +
               'd91e4b0065eb50ca9fd8b0107e728733'
      },
      'SHA-256': {
        normal: '31b7d68530a863e717c081ca6917b686' +
                '50b3dd9a29f30606e2cad199bec14d13',
        empty: 'e579d1f9e7f08e6f990ffcfcce1ed201' +
               'c5e37e62cdf606f0ba4aca80427fbc44'
      }
    },
    empty: {
      'SHA-384': {
        normal: '619eb6f9287395bbd5ed6a67c968465a' +
                'd82b6c559f3c38b604bbb08f58320b03',
        empty: 'ff447b423d83fe76836c32337228b56b' +
               '5bd9bf68d58e7dca4b7cca842a45e11a'
      },
      'SHA-512': {
        normal: '133e8a7f7ff433690cc88432c2a338c2' +
                '77e5c13756ff878f46753fe6a564e3e5',
        empty: 'de54f7eec80c9cc66d349fc987f80d46' +
               '1db2ef4ff4e18505d28bd80cb42c7d76'
      },
      'SHA-1': {
        normal: 'adb93cdbce79b7d51159b6c0131a2b62' +
                'f23828d26acd685e34c06535e6f77496',
        empty: '47710d2a7507e05a1ddcc87a7c2f9061' +
               '77a266efb9e622510cccb3713cd08d58'
      },
      'SHA-256': {
        normal: 'a401d7c9158a29e5c7193ab9730f0748' +
                '851cc5baadb42cad024b6290fe213436',
        empty: 'b4f7e7557674d501cbfbc0148ad800c0' +
               '750189fe295a2aca5e1bf4122c85edf9'
      }
    }
  },
};

async function setupBaseKeys() {
  const promises = [];

  const baseKeys = {};
  const noBits = {};
  const noKey = {};
  let wrongKey = null;

  Object.keys(kDerivedKeys).forEach((size) => {
    const keyData = Buffer.from(kDerivedKeys[size], 'hex');
    promises.push(
      subtle.importKey(
        'raw',
        keyData,
        { name: 'HKDF' },
        false,
        ['deriveKey', 'deriveBits'])
        .then(
          (baseKey) => baseKeys[size] = baseKey,
          (err) => assert.ifError(err)));

    promises.push(
      subtle.importKey(
        'raw',
        keyData,
        { name: 'HKDF' },
        false, ['deriveBits'])
        .then(
          (baseKey) => noKey[size] = baseKey,
          (err) => assert.ifError(err)));

    promises.push(
      subtle.importKey(
        'raw',
        keyData,
        { name: 'HKDF' },
        false, ['deriveKey'])
        .then(
          (baseKey) => noBits[size] = baseKey,
          (err) => assert.ifError(err)));
  });

  promises.push(
    subtle.generateKey(
      {
        name: 'ECDH',
        namedCurve: 'P-521'
      },
      false,
      ['deriveKey', 'deriveBits'])
      .then(
        (baseKey) => wrongKey = baseKey.privateKey,
        (err) => assert.ifError(err)));

  await Promise.all(promises);

  return {
    baseKeys,
    noBits,
    noKey,
    wrongKey
  };
}

async function testDeriveBits(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  const bits = await subtle.deriveBits(
    algorithm,
    baseKeys[size],
    256);

  assert(bits instanceof ArrayBuffer);
  assert.strictEqual(
    Buffer.from(bits).toString('hex'),
    kDerivations[size][saltSize][hash][infoSize]);
}

async function testDeriveBitsBadLengths(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  return Promise.all([
    assert.rejects(
      subtle.deriveBits(algorithm, baseKeys[size], undefined), {
        name: 'OperationError',
      }),
    assert.rejects(
      subtle.deriveBits(algorithm, baseKeys[size], null), {
        message: 'length cannot be null',
        name: 'OperationError',
      }),
    assert.rejects(
      subtle.deriveBits(algorithm, baseKeys[size]), {
        message: 'length cannot be null',
        name: 'OperationError',
      }),
    assert.rejects(
      subtle.deriveBits(algorithm, baseKeys[size], 15), {
        message: /length must be a multiple of 8/,
        name: 'OperationError',
      }),
  ]);
}

async function testDeriveBitsBadHash(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize) {
  const salt = Buffer.from(kSalts[saltSize], 'hex');
  const info = Buffer.from(kInfos[infoSize], 'hex');
  const algorithm = { name: 'HKDF', salt, info };

  return Promise.all([
    assert.rejects(
      subtle.deriveBits(
        {
          ...algorithm,
          hash: hash.substring(0, 3) + hash.substring(4)
        }, baseKeys[size], 256), {
        message: /Unrecognized algorithm name/,
        name: 'NotSupportedError',
      }),
    assert.rejects(
      subtle.deriveBits(
        {
          ...algorithm,
          hash: 'PBKDF2'
        },
        baseKeys[size], 256), {
        message: /Unrecognized algorithm name/,
        name: 'NotSupportedError',
      }),
  ]);
}

async function testDeriveBitsBadUsage(
  noBits,
  size,
  saltSize,
  hash,
  infoSize) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  return assert.rejects(
    subtle.deriveBits(algorithm, noBits[size], 256), {
      message: /baseKey does not have deriveBits usage/
    });
}

async function testDeriveBitsMissingSalt(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize) {
  const algorithm = {
    name: 'HKDF',
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  return assert.rejects(
    subtle.deriveBits(algorithm, baseKeys[size], 0), {
      code: 'ERR_MISSING_OPTION'
    });
}

async function testDeriveBitsMissingInfo(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[infoSize], 'hex'),
    hash
  };

  return assert.rejects(
    subtle.deriveBits(algorithm, baseKeys[size], 0), {
      code: 'ERR_MISSING_OPTION'
    });
}

async function testBitsWrongKeyType(
  wrongKey,
  saltSize,
  hash,
  infoSize) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  return assert.rejects(
    subtle.deriveBits(algorithm, wrongKey, 256), {
      message: /Key algorithm mismatch/
    });
}

async function testDeriveKey(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize,
  keyType,
  usages) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  const key = await subtle.deriveKey(
    algorithm,
    baseKeys[size],
    keyType,
    true,
    usages);

  const bits = await subtle.exportKey('raw', key);

  assert.strictEqual(
    Buffer.from(bits).toString('hex'),
    kDerivations[size][saltSize][hash][infoSize].slice(0, keyType.length / 4));
}

async function testDeriveKeyBadHash(
  baseKeys,
  size,
  saltSize,
  hash,
  infoSize,
  keyType,
  usages) {
  const salt = Buffer.from(kSalts[saltSize], 'hex');
  const info = Buffer.from(kInfos[infoSize], 'hex');
  const algorithm = { name: 'HKDF', salt, info };

  return Promise.all([
    assert.rejects(
      subtle.deriveKey(
        {
          ...algorithm,
          hash: hash.substring(0, 3) + hash.substring(4)
        },
        baseKeys[size],
        keyType,
        true,
        usages),
      {
        message: /Unrecognized algorithm name/,
        name: 'NotSupportedError',
      }),
    assert.rejects(
      subtle.deriveKey(
        {
          ...algorithm,
          hash: 'PBKDF2'
        },
        baseKeys[size],
        keyType,
        true,
        usages),
      {
        message: /Unrecognized algorithm name/,
        name: 'NotSupportedError',
      }),
  ]);
}

async function testDeriveKeyBadUsage(
  noKey,
  size,
  saltSize,
  hash,
  infoSize,
  keyType,
  usages) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  return assert.rejects(
    subtle.deriveKey(algorithm, noKey[size], keyType, true, usages), {
      message: /baseKey does not have deriveKey usage/
    });
}

async function testWrongKeyType(
  wrongKey,
  saltSize,
  hash,
  infoSize,
  keyType,
  usages
) {
  const algorithm = {
    name: 'HKDF',
    salt: Buffer.from(kSalts[saltSize], 'hex'),
    info: Buffer.from(kInfos[infoSize], 'hex'),
    hash
  };

  return assert.rejects(
    subtle.deriveKey(algorithm, wrongKey, keyType, true, usages), {
      message: /Key algorithm mismatch/
    });
}

(async function() {
  const {
    baseKeys,
    noBits,
    noKey,
    wrongKey,
  } = await setupBaseKeys();

  const variations = [];

  Object.keys(kDerivations).forEach((size) => {
    Object.keys(kDerivations[size]).forEach((saltSize) => {
      Object.keys(kDerivations[size][saltSize]).forEach((hash) => {
        Object.keys(kDerivations[size][saltSize][hash]).forEach(
          async (infoSize) => {
            const args = [baseKeys, size, saltSize, hash, infoSize];
            variations.push(testDeriveBits(...args));
            variations.push(testDeriveBitsBadLengths(...args));
            variations.push(testDeriveBitsMissingSalt(...args));
            variations.push(testDeriveBitsMissingInfo(...args));
            variations.push(testDeriveBitsBadHash(...args));
            variations.push(
              testDeriveBitsBadUsage(
                noBits,
                size,
                saltSize,
                hash,
                infoSize));
            variations.push(
              testBitsWrongKeyType(
                wrongKey,
                saltSize,
                hash,
                infoSize));

            kDerivedKeyTypes.forEach((keyType) => {
              const keyArgs = getDeriveKeyInfo(...keyType);
              variations.push(testDeriveKey(...args, ...keyArgs));
              variations.push(testDeriveKeyBadHash(...args, ...keyArgs));
              variations.push(testDeriveKeyBadUsage(
                noKey, size, saltSize, hash, infoSize, ...keyArgs));
              variations.push(
                testWrongKeyType(
                  wrongKey,
                  saltSize,
                  hash,
                  infoSize,
                  ...keyArgs));
            });
          });
      });
    });
  });

  await Promise.all(variations);

})().then(common.mustCall());

// https://github.com/w3c/webcrypto/pull/380
{
  crypto.subtle.importKey('raw', new Uint8Array(0), 'HKDF', false, ['deriveBits']).then((key) => {
    return crypto.subtle.deriveBits({
      name: 'HKDF',
      hash: { name: 'SHA-256' },
      info: new Uint8Array(0),
      salt: new Uint8Array(0),
    }, key, 0);
  }).then((bits) => {
    assert.deepStrictEqual(bits, new ArrayBuffer(0));
  })
  .then(common.mustCall());
}
                                                                                                                                                                                  node-23.7.0/test/parallel/test-webcrypto-derivebits.js                                              0000664 0000000 0000000 00000007063 14746647661 0023025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

// This is only a partial test. The WebCrypto Web Platform Tests
// will provide much greater coverage.

// Test ECDH bit derivation
{
  async function test(namedCurve) {
    const [alice, bob] = await Promise.all([
      subtle.generateKey({ name: 'ECDH', namedCurve }, true, ['deriveBits']),
      subtle.generateKey({ name: 'ECDH', namedCurve }, true, ['deriveBits']),
    ]);

    const [secret1, secret2] = await Promise.all([
      subtle.deriveBits({
        name: 'ECDH', namedCurve, public: alice.publicKey
      }, bob.privateKey, 128),
      subtle.deriveBits({
        name: 'ECDH', namedCurve, public: bob.publicKey
      }, alice.privateKey, 128),
    ]);

    assert(secret1 instanceof ArrayBuffer);
    assert(secret2 instanceof ArrayBuffer);
    assert.deepStrictEqual(secret1, secret2);
  }

  test('P-521').then(common.mustCall());
}

// Test HKDF bit derivation
{
  async function test(pass, info, salt, hash, length, expected) {
    const ec = new TextEncoder();
    const key = await subtle.importKey(
      'raw',
      ec.encode(pass),
      { name: 'HKDF', hash },
      false, ['deriveBits']);
    const secret = await subtle.deriveBits({
      name: 'HKDF',
      hash,
      salt: ec.encode(salt),
      info: ec.encode(info)
    }, key, length);
    assert.strictEqual(Buffer.from(secret).toString('hex'), expected);
  }

  const kTests = [
    ['hello', 'there', 'my friend', 'SHA-256', 512,
     '14d93b0ccd99d4f2cbd9fbfe9c830b5b8a43e3e45e329' +
     '41ef21bdeb0fa87b6b6bfa5c54466aa5bf76cdc2685fb' +
     'a4408ea5b94c049fe035649b46f92fdc519374'],
    ['hello', 'there', 'my friend', 'SHA-384', 128,
     'e36cf2cf943d8f3a88adb80f478745c3'],
  ];

  const tests = Promise.all(kTests.map((args) => test(...args)));

  tests.then(common.mustCall());
}

// Test PBKDF2 bit derivation
{
  async function test(pass, salt, iterations, hash, length, expected) {
    const ec = new TextEncoder();
    const key = await subtle.importKey(
      'raw',
      ec.encode(pass),
      { name: 'PBKDF2', hash },
      false, ['deriveBits']);
    const secret = await subtle.deriveBits({
      name: 'PBKDF2',
      hash,
      salt: ec.encode(salt),
      iterations,
    }, key, length);
    assert.strictEqual(Buffer.from(secret).toString('hex'), expected);
  }

  const kTests = [
    ['hello', 'there', 10, 'SHA-256', 512,
     'f72d1cf4853fffbd16a42751765d11f8dc7939498ee7b7' +
     'ce7678b4cb16fad88098110a83e71f4483ce73203f7a64' +
     '719d293280f780f9fafdcf46925c5c0588b3'],
    ['hello', 'there', 5, 'SHA-384', 128,
     '201509b012c9cd2fbe7ea938f0c509b3'],
  ];

  const tests = Promise.all(kTests.map((args) => test(...args)));

  tests.then(common.mustCall());
}

// Test X25519 and X448 bit derivation
{
  async function test(name) {
    const [alice, bob] = await Promise.all([
      subtle.generateKey({ name }, true, ['deriveBits']),
      subtle.generateKey({ name }, true, ['deriveBits']),
    ]);

    const [secret1, secret2] = await Promise.all([
      subtle.deriveBits({
        name, public: alice.publicKey
      }, bob.privateKey, 128),
      subtle.deriveBits({
        name, public: bob.publicKey
      }, alice.privateKey, 128),
    ]);

    assert(secret1 instanceof ArrayBuffer);
    assert(secret2 instanceof ArrayBuffer);
    assert.deepStrictEqual(secret1, secret2);
  }

  test('X25519').then(common.mustCall());
  test('X448').then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-webcrypto-derivekey-cfrg.js                                          0000664 0000000 0000000 00000010734 14746647661 0023572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const kTests = [
  {
    name: 'X25519',
    size: 32,
    pkcs8: '302e020100300506032b656e04220420c8838e76d057dfb7d8c95a69e138160ad' +
           'd6373fd71a4d276bb56e3a81b64ff61',
    spki: '302a300506032b656e0321001cf2b1e6022ec537371ed7f53e54fa1154d83e98eb' +
          '64ea51fae5b3307cfe9706',
    result: '2768409dfab99ec23b8c89b93ff5880295f76176088f89e43dfebe7ea1950008'
  },
  {
    name: 'X448',
    size: 56,
    pkcs8: '3046020100300506032b656f043a043858c7d29a3eb519b29d00cfb191bb64fc6' +
           'd8a42d8f17176272b89f2272d1819295c6525c0829671b052ef0727530f188e31' +
           'd0cc53bf26929e',
    spki: '3042300506032b656f033900b604a1d1a5cd1d9426d561ef630a9eb16cbe69d5b9' +
          'ca615edc53633efb52ea31e6e6a0a1dbacc6e76cbce6482d7e4ba3d55d9e802765' +
          'ce6f',
    result: 'f0f6c5f17f94f4291eab7178866d37ec8906dd6c514143dc85be7cf28deff39b'
  },
];

async function prepareKeys() {
  const keys = {};
  await Promise.all(
    kTests.map(async ({ name, size, pkcs8, spki, result }) => {
      const [
        privateKey,
        publicKey,
      ] = await Promise.all([
        subtle.importKey(
          'pkcs8',
          Buffer.from(pkcs8, 'hex'),
          { name },
          true,
          ['deriveKey', 'deriveBits']),
        subtle.importKey(
          'spki',
          Buffer.from(spki, 'hex'),
          { name },
          true,
          []),
      ]);
      keys[name] = {
        privateKey,
        publicKey,
        size,
        result,
      };
    }));
  return keys;
}

(async function() {
  const keys = await prepareKeys();
  const otherArgs = [
    { name: 'HMAC', hash: 'SHA-256', length: 256 },
    true,
    ['sign', 'verify']];

  await Promise.all(
    Object.keys(keys).map(async (name) => {
      const { result, privateKey, publicKey } = keys[name];

      {
        // Good parameters
        const key = await subtle.deriveKey({
          name,
          public: publicKey
        }, privateKey, ...otherArgs);

        const raw = await subtle.exportKey('raw', key);

        assert.strictEqual(Buffer.from(raw).toString('hex'), result);
      }

      {
        // Case insensitivity
        const key = await subtle.deriveKey({
          name: name.toLowerCase(),
          public: publicKey
        }, privateKey, {
          name: 'HmAc',
          hash: 'SHA-256',
          length: 256
        }, true, ['sign', 'verify']);

        const raw = await subtle.exportKey('raw', key);

        assert.strictEqual(Buffer.from(raw).toString('hex'), result);
      }
    }));

  // Error tests
  {
    // Missing public property
    await assert.rejects(
      subtle.deriveKey(
        { name: 'X448' },
        keys.X448.privateKey,
        ...otherArgs),
      { code: 'ERR_MISSING_OPTION' });
  }

  {
    // The public property is not a CryptoKey
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'X448',
          public: { message: 'Not a CryptoKey' }
        },
        keys.X448.privateKey,
        ...otherArgs),
      { code: 'ERR_INVALID_ARG_TYPE' });
  }

  {
    // Mismatched named curves
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'X448',
          public: keys.X25519.publicKey
        },
        keys.X448.privateKey,
        ...otherArgs),
      { message: 'The public and private keys must be of the same type' });
  }

  {
    // Base key is not a private key
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'X448',
          public: keys.X448.publicKey
        },
        keys.X448.publicKey,
        ...otherArgs),
      { name: 'InvalidAccessError' });
  }

  {
    // Public is not a public key
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'X448',
          public: keys.X448.privateKey
        },
        keys.X448.privateKey,
        ...otherArgs),
      { name: 'InvalidAccessError' });
  }

  {
    // Public is a secret key
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    const key = await subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-CBC', length: 256 },
      false, ['encrypt']);

    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'X448',
          public: key
        },
        keys.X448.publicKey,
        ...otherArgs),
      { name: 'InvalidAccessError' });
  }
})().then(common.mustCall());
                                    node-23.7.0/test/parallel/test-webcrypto-derivekey-ecdh.js                                          0000664 0000000 0000000 00000015201 14746647661 0023546 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const kTests = [
  {
    namedCurve: 'P-521',
    pkcs8: '3081ee020100301006072a8648ce3d020106052b810400230481d63081d302010' +
           '1044201a67ed321915a64aa359b7d648ddc2618fa8e8d1867e8f71830b10d25ed' +
           '2891faf12f3c7e75421a2ea264f9a915320d274fe1470742b984e96b98912081f' +
           'acd478da18189038186000400209d483f28666881c6641f3a126f400f51e46511' +
           '70fe678c75e85712e2868adc850824997bebf0bc82b43028a6d2ec1777ca45279' +
           'f7206a3ea8b5cd2073f493e45000cb54c3a5acaa268c56710428878d98b8afbf6' +
           '8a612153632846d807e92672698f1b9c611de7d38e34cd6c73889092c56e52d68' +
           '0f1dfd092b87ac8ef9ff3c8fb48',
    spki: '30819b301006072a8648ce3d020106052b81040023038186000400ee69f94715d7' +
          '01e9e2011333d4f4f96cba7d91f88b112baf75cf09cc1f8aca97618da9389822d2' +
          '9b6fe9996a61203ef752b771e8958fc4677bb3778565ab60d6ed00deab6761895b' +
          '935e3ad325fb8549e56f13786aa73f88a2ecfe40933473d8aef240c4dfd7d506f2' +
          '2cdd0e55558f3fbf05ebf7efef7a72d78f46469b8448f26e2712',
    result: '009c2bce57be80adab3b07385b8e5990eb7d6fdebdb01bf35371a4f6075e9d28',
  },
  {
    namedCurve: 'P-384',
    pkcs8: '3081b6020100301006072a8648ce3d020106052b8104002204819e30819b02010' +
           '10430f871a5666589c14a5747263ef85b319cc023db6e35676c3d781eef8b055f' +
           'cfbe86fa0d06d056b5195fb1323af8de25b3a16403620004f11965df7dd4594d0' +
           '419c5086482a3b826b9797f9be0bd0d109c9e1e9989c1b9a92b8f269f98e17ad1' +
           '84ba73c1f79762af45af8141602642da271a6bb0ffeb0cb4478fcf707e661aa6d' +
           '6cdf51549c88c3f130be9e8201f6f6a09f4185aaf95c4',
    spki: '3076301006072a8648ce3d020106052b810400220362000491822dc2af59c18f5b' +
          '67f80df61a2603c2a8f0b3c0af822d63c279701a824560404401dde9a56ee52757' +
          'ea8bc748d4c82b5337b48d7b65583a3d572438880036bac6730f42ca5278966bd5' +
          'f21e86e21d30c5a6d0463ec513dd509ffcdcaf1ff5',
    result: 'e0bd6bce0aef8ca48838a6e2fcc57e67b9c5e8860c5f0be9dabec53e454e18a0',
  },
];

async function prepareKeys() {
  const keys = {};
  await Promise.all(
    kTests.map(async ({ namedCurve, size, pkcs8, spki, result }) => {
      const [
        privateKey,
        publicKey,
      ] = await Promise.all([
        subtle.importKey(
          'pkcs8',
          Buffer.from(pkcs8, 'hex'),
          {
            name: 'ECDH',
            namedCurve
          },
          true,
          ['deriveKey', 'deriveBits']),
        subtle.importKey(
          'spki',
          Buffer.from(spki, 'hex'),
          {
            name: 'ECDH',
            namedCurve
          },
          true,
          []),
      ]);
      keys[namedCurve] = {
        privateKey,
        publicKey,
        size,
        result,
      };
    }));
  return keys;
}

(async function() {
  const keys = await prepareKeys();
  const otherArgs = [
    { name: 'HMAC', hash: 'SHA-256', length: 256 },
    true,
    ['sign', 'verify']];

  await Promise.all(
    Object.keys(keys).map(async (namedCurve) => {
      const { result, privateKey, publicKey } = keys[namedCurve];

      {
        // Good parameters
        const key = await subtle.deriveKey({
          name: 'ECDH',
          public: publicKey
        }, privateKey, ...otherArgs);

        const raw = await subtle.exportKey('raw', key);

        assert.strictEqual(Buffer.from(raw).toString('hex'), result);
      }

      {
        // Case insensitivity
        const key = await subtle.deriveKey({
          name: 'eCdH',
          public: publicKey
        }, privateKey, {
          name: 'HmAc',
          hash: 'SHA-256',
          length: 256
        }, true, ['sign', 'verify']);

        const raw = await subtle.exportKey('raw', key);

        assert.strictEqual(Buffer.from(raw).toString('hex'), result);
      }
    }));

  // Error tests
  {
    // Missing public property
    await assert.rejects(
      subtle.deriveKey(
        { name: 'ECDH' },
        keys['P-384'].privateKey,
        ...otherArgs),
      { code: 'ERR_MISSING_OPTION' });
  }

  {
    // The public property is not a CryptoKey
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: { message: 'Not a CryptoKey' }
        },
        keys['P-384'].privateKey,
        ...otherArgs),
      { code: 'ERR_INVALID_ARG_TYPE' });
  }

  {
    // Mismatched named curves
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: keys['P-384'].publicKey
        },
        keys['P-521'].privateKey,
        ...otherArgs),
      { message: /Named curve mismatch/ });
  }

  {
    // Incorrect public key algorithm
    const { publicKey } = await subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-521'
      },
      false,
      ['sign', 'verify']);

    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: publicKey
        },
        keys['P-521'].privateKey,
        ...otherArgs),
      { message: /Keys must be ECDH, X25519, or X448 keys/ });
  }

  {
    // Private key does not have correct usages
    const privateKey = await subtle.importKey(
      'pkcs8',
      Buffer.from(kTests[0].pkcs8, 'hex'),
      {
        name: 'ECDH',
        namedCurve: 'P-521'
      }, false, ['deriveBits']);

    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: keys['P-521'].publicKey,
        },
        privateKey,
        ...otherArgs),
      { message: /baseKey does not have deriveKey usage/ });
  }

  {
    // Base key is not a private key
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: keys['P-521'].publicKey
        },
        keys['P-521'].publicKey,
        ...otherArgs),
      { name: 'InvalidAccessError' });
  }

  {
    // Base key is not a private key
    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: keys['P-521'].privateKey
        },
        keys['P-521'].publicKey,
        ...otherArgs),
      { name: 'InvalidAccessError' });
  }

  {
    // Public is a secret key
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    const key = await subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-CBC', length: 256 },
      false, ['encrypt']);

    await assert.rejects(
      subtle.deriveKey(
        {
          name: 'ECDH',
          public: key
        },
        keys['P-521'].publicKey,
        ...otherArgs),
      { name: 'InvalidAccessError' });
  }
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-webcrypto-derivekey.js                                               0000664 0000000 0000000 00000013540 14746647661 0022651 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;
const { KeyObject } = require('crypto');

// This is only a partial test. The WebCrypto Web Platform Tests
// will provide much greater coverage.

// Test ECDH key derivation
{
  async function test(namedCurve) {
    const [alice, bob] = await Promise.all([
      subtle.generateKey({ name: 'ECDH', namedCurve }, true, ['deriveKey']),
      subtle.generateKey({ name: 'ECDH', namedCurve }, true, ['deriveKey']),
    ]);

    const [secret1, secret2] = await Promise.all([
      subtle.deriveKey({
        name: 'ECDH', namedCurve, public: alice.publicKey
      }, bob.privateKey, {
        name: 'AES-CBC',
        length: 256
      }, true, ['encrypt']),
      subtle.deriveKey({
        name: 'ECDH', namedCurve, public: bob.publicKey
      }, alice.privateKey, {
        name: 'AES-CBC',
        length: 256
      }, true, ['encrypt']),
    ]);

    const [raw1, raw2] = await Promise.all([
      subtle.exportKey('raw', secret1),
      subtle.exportKey('raw', secret2),
    ]);

    assert.deepStrictEqual(raw1, raw2);
  }

  test('P-521').then(common.mustCall());
}

// Test HKDF key derivation
{
  async function test(pass, info, salt, hash, expected) {
    const ec = new TextEncoder();
    const key = await subtle.importKey(
      'raw',
      ec.encode(pass),
      { name: 'HKDF', hash },
      false, ['deriveKey']);

    const secret = await subtle.deriveKey({
      name: 'HKDF',
      hash,
      salt: ec.encode(salt),
      info: ec.encode(info)
    }, key, {
      name: 'AES-CTR',
      length: 256
    }, true, ['encrypt']);

    const raw = await subtle.exportKey('raw', secret);

    assert.strictEqual(Buffer.from(raw).toString('hex'), expected);
  }

  const kTests = [
    ['hello', 'there', 'my friend', 'SHA-256',
     '14d93b0ccd99d4f2cbd9fbfe9c830b5b8a43e3e45e32941ef21bdeb0fa87b6b6'],
    ['hello', 'there', 'my friend', 'SHA-384',
     'e36cf2cf943d8f3a88adb80f478745c336ac811b1a86d03a7d10eb0b6b52295c'],
  ];

  const tests = Promise.all(kTests.map((args) => test(...args)));

  tests.then(common.mustCall());
}

// Test PBKDF2 key derivation
{
  async function test(pass, salt, iterations, hash, expected) {
    const ec = new TextEncoder();
    const key = await subtle.importKey(
      'raw',
      ec.encode(pass),
      { name: 'PBKDF2', hash },
      false, ['deriveKey']);
    const secret = await subtle.deriveKey({
      name: 'PBKDF2',
      hash,
      salt: ec.encode(salt),
      iterations,
    }, key, {
      name: 'AES-CTR',
      length: 256
    }, true, ['encrypt']);

    const raw = await subtle.exportKey('raw', secret);

    assert.strictEqual(Buffer.from(raw).toString('hex'), expected);
  }

  const kTests = [
    ['hello', 'there', 10, 'SHA-256',
     'f72d1cf4853fffbd16a42751765d11f8dc7939498ee7b7ce7678b4cb16fad880'],
    ['hello', 'there', 5, 'SHA-384',
     '201509b012c9cd2fbe7ea938f0c509b36ecb140f38bf9130e96923f55f46756d'],
  ];

  const tests = Promise.all(kTests.map((args) => test(...args)));

  tests.then(common.mustCall());
}

// Test default key lengths
{
  const vectors = [
    ['PBKDF2', 'deriveKey', 528],
    ['HKDF', 'deriveKey', 528],
    [{ name: 'HMAC', hash: 'SHA-1' }, 'sign', 512],
    [{ name: 'HMAC', hash: 'SHA-256' }, 'sign', 512],
    // Not long enough secret generated by ECDH
    // [{ name: 'HMAC', hash: 'SHA-384' }, 'sign', 1024],
    // [{ name: 'HMAC', hash: 'SHA-512' }, 'sign', 1024],
  ];

  (async () => {
    const keyPair = await subtle.generateKey({ name: 'ECDH', namedCurve: 'P-521' }, false, ['deriveKey']);
    for (const [derivedKeyAlgorithm, usage, expected] of vectors) {
      const derived = await subtle.deriveKey(
        { name: 'ECDH', public: keyPair.publicKey },
        keyPair.privateKey,
        derivedKeyAlgorithm,
        false,
        [usage]);

      if (derived.algorithm.name === 'HMAC') {
        assert.strictEqual(derived.algorithm.length, expected);
      } else {
        // KDFs cannot be exportable and do not indicate their length
        const secretKey = KeyObject.from(derived);
        assert.strictEqual(secretKey.symmetricKeySize, expected / 8);
      }
    }
  })().then(common.mustCall());
}

{
  const vectors = [
    [{ name: 'HMAC', hash: 'SHA-1' }, 'sign', 512],
    [{ name: 'HMAC', hash: 'SHA-256' }, 'sign', 512],
    [{ name: 'HMAC', hash: 'SHA-384' }, 'sign', 1024],
    [{ name: 'HMAC', hash: 'SHA-512' }, 'sign', 1024],
  ];

  (async () => {
    for (const [derivedKeyAlgorithm, usage, expected] of vectors) {
      const derived = await subtle.deriveKey(
        { name: 'PBKDF2', salt: new Uint8Array([]), hash: 'SHA-256', iterations: 20 },
        await subtle.importKey('raw', new Uint8Array([]), { name: 'PBKDF2' }, false, ['deriveKey']),
        derivedKeyAlgorithm,
        false,
        [usage]);

      assert.strictEqual(derived.algorithm.length, expected);
    }
  })().then(common.mustCall());
}

// Test X25519 and X448 key derivation
{
  async function test(name) {
    const [alice, bob] = await Promise.all([
      subtle.generateKey({ name }, true, ['deriveKey']),
      subtle.generateKey({ name }, true, ['deriveKey']),
    ]);

    const [secret1, secret2] = await Promise.all([
      subtle.deriveKey({
        name, public: alice.publicKey
      }, bob.privateKey, {
        name: 'AES-CBC',
        length: 256
      }, true, ['encrypt']),
      subtle.deriveKey({
        name, public: bob.publicKey
      }, alice.privateKey, {
        name: 'AES-CBC',
        length: 256
      }, true, ['encrypt']),
    ]);

    const [raw1, raw2] = await Promise.all([
      subtle.exportKey('raw', secret1),
      subtle.exportKey('raw', secret2),
    ]);

    assert.deepStrictEqual(raw1, raw2);
  }

  test('X25519').then(common.mustCall());
  test('X448').then(common.mustCall());
}
                                                                                                                                                                node-23.7.0/test/parallel/test-webcrypto-digest.js                                                  0000664 0000000 0000000 00000013366 14746647661 0022147 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { Buffer } = require('buffer');
const { subtle } = globalThis.crypto;
const { createHash } = require('crypto');

const kTests = [
  ['SHA-1', 'sha1', 160],
  ['SHA-256', 'sha256', 256],
  ['SHA-384', 'sha384', 384],
  ['SHA-512', 'sha512', 512],
];

// Empty hash just works, not checking result
subtle.digest('SHA-512', Buffer.alloc(0))
  .then(common.mustCall());

// TODO(@jasnell): Need to move this particular test to pummel
// // Careful, this is an expensive operation because of both the memory
// // allocation and the cost of performing the hash on such a large
// // input.
// subtle.digest('SHA-512', new ArrayBuffer(2 ** 31 - 1))
//   .then(common.mustCall());

// TODO(@jasnell): Change max to 2 ** 31 - 1
// assert.rejects(subtle.digest('SHA-512', new ArrayBuffer(kMaxLength + 1)), {
//   code: 'ERR_OUT_OF_RANGE'
// });

const kData = (new TextEncoder()).encode('hello');
(async function() {
  await Promise.all(kTests.map(async (test) => {
    // Get the digest using the legacy crypto API
    const checkValue =
      createHash(test[1]).update(kData).digest().toString('hex');

    // Get the digest using the SubtleCrypto API
    const values = Promise.all([
      subtle.digest({ name: test[0] }, kData),
      subtle.digest({ name: test[0], length: test[2] }, kData),
      subtle.digest(test[0], kData),
      subtle.digest(test[0], kData.buffer),
      subtle.digest(test[0], new DataView(kData.buffer)),
      subtle.digest(test[0], Buffer.from(kData)),
    ]);

    // subtle.digest copies the input data, so changing it
    // while we're waiting on the Promises should never
    // cause the test to fail.
    kData[0] = 0x1;
    kData[2] = 0x2;
    kData[4] = 0x3;

    // Compare that the legacy crypto API and SubtleCrypto API
    // produce the same results
    (await values).forEach((v) => {
      assert(v instanceof ArrayBuffer);
      assert.strictEqual(checkValue, Buffer.from(v).toString('hex'));
    });
  }));
})().then(common.mustCall());

Promise.all([1, null, undefined].map((i) =>
  assert.rejects(subtle.digest(i, Buffer.alloc(0)), {
    message: /Unrecognized algorithm name/,
    name: 'NotSupportedError',
  })
)).then(common.mustCall());

assert.rejects(subtle.digest('', Buffer.alloc(0)), {
  message: /Unrecognized algorithm name/,
  name: 'NotSupportedError',
}).then(common.mustCall());

Promise.all([1, [], {}, null, undefined].map((i) =>
  assert.rejects(subtle.digest('SHA-256', i), {
    code: 'ERR_INVALID_ARG_TYPE'
  })
)).then(common.mustCall());

const kSourceData = {
  empty: '',
  short: '156eea7cc14c56cb94db030a4a9d95ff',
  medium: 'b6c8f9df648cd088b70f38e74197b18cb81e1e435' +
          '0d50bccb8fb5a7379c87bb2e3d6ed5461ed1e9f36' +
          'f340a3962a446b815b794b4bd43a4403502077b22' +
          '56cc807837f3aacd118eb4b9c2baeb897068625ab' +
          'aca193',
  long: null
};

kSourceData.long = kSourceData.medium.repeat(1024);

const kDigestedData = {
  'sha-1': {
    empty: 'da39a3ee5e6b4b0d3255bfef95601890afd80709',
    short: 'c91318cdf2396a015e3f4e6a86a0ba65b8635944',
    medium: 'e541060870eb16bf33b68e51f513526893986729',
    long: '3098b50037ecd02ebd657653b2bfa01eee27a2ea'
  },
  'sha-256': {
    empty: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',
    short: 'a2831186984792c7d32d59c89740687f19addc1b959e71a1cc538a3b7ed843f2',
    medium: '535367877ef014d7fc717e5cb7843e59b61aee62c7029cec7ec6c12fd924e0e4',
    long: '14cdea9dc75f5a6274d9fc1e64009912f1dcd306b48fe8e9cf122de671571781'
  },
  'sha-384': {
    empty: '38b060a751ac96384cd9327eb1b1e36a21fdb71114b' +
           'e07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2' +
           'f14898b95b',
    short: '6bf5ea6524d1cddc43f7cf3b56ee059227404a2f538' +
           'f022a3db7447a782c06c1ed05e8ab4f5edc17f37114' +
           '40dfe97731',
    medium: 'cbc2c588fe5b25f916da28b4e47a484ae6fc1fe490' +
            '2dd5c9939a6bfd034ab3b48b39087436011f6a9987' +
            '9d279540e977',
    long: '49f4fdb3981968f97d57370f85345067cd5296a97dd1' +
          'a18e06911e756e9608492529870e1ad130998d57cbfb' +
          'b7c1d09e'
  },
  'sha-512': {
    empty: 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5' +
           '715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318' +
           'd2877eec2f63b931bd47417a81a538327af927da3e',
    short: '375248be5ff34be74cab4ff1c3bc8dc68bd5f8dff40' +
           '23e98f87b865cff2c724292df189443a64ff4134a65' +
           'cd4635b9d4f5dc0d3fb67528002a63acf26c9da575',
    medium: 'b9109f839e8ea43c890f293ce11dc6e2798d1e2431' +
            'f1e4b919e3b20c4f36303ba39c916db306c45a3b65' +
            '761ff5be85328eeaf42c3830f1d95e7a41165b7d2d36',
    long: '4b02caf650276030ea5617e597c5d53fd9daa68b78bfe' +
          '60b22aab8d36a4c2a3affdb71234f49276737c575ddf7' +
          '4d14054cbd6fdb98fd0ddcbcb46f91ad76b6ee'
  }
};

async function testDigest(size, name) {
  const digest = await subtle.digest(
    name,
    Buffer.from(kSourceData[size], 'hex'));

  assert.strictEqual(
    Buffer.from(digest).toString('hex'),
    kDigestedData[name.toLowerCase()][size]);
}

(async function() {
  const variations = [];
  Object.keys(kSourceData).forEach((size) => {
    Object.keys(kDigestedData).forEach((alg) => {
      const upCase = alg.toUpperCase();
      const downCase = alg.toLowerCase();
      const mixedCase = upCase.slice(0, 1) + downCase.slice(1);

      variations.push(testDigest(size, upCase));
      variations.push(testDigest(size, downCase));
      variations.push(testDigest(size, mixedCase));
    });
  });

  await Promise.all(variations);
})().then(common.mustCall());

(async () => {
  await assert.rejects(subtle.digest('RSA-OAEP', Buffer.alloc(1)), {
    name: 'NotSupportedError',
  });
})().then(common.mustCall());
                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-webcrypto-encrypt-decrypt-aes.js                                     0000664 0000000 0000000 00000013756 14746647661 0024575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

async function testEncrypt({ keyBuffer, algorithm, plaintext, result }) {
  // Using a copy of plaintext to prevent tampering of the original
  plaintext = Buffer.from(plaintext);

  const key = await subtle.importKey(
    'raw',
    keyBuffer,
    { name: algorithm.name },
    false,
    ['encrypt', 'decrypt']);

  const output = await subtle.encrypt(algorithm, key, plaintext);
  plaintext[0] = 255 - plaintext[0];

  assert.strictEqual(
    Buffer.from(output).toString('hex'),
    Buffer.from(result).toString('hex'));

  // Converting the returned ArrayBuffer into a Buffer right away,
  // so that the next line works
  const check = Buffer.from(await subtle.decrypt(algorithm, key, output));
  check[0] = 255 - check[0];

  assert.strictEqual(
    Buffer.from(check).toString('hex'),
    Buffer.from(plaintext).toString('hex'));
}

async function testEncryptNoEncrypt({ keyBuffer, algorithm, plaintext }) {
  const key = await subtle.importKey(
    'raw',
    keyBuffer,
    { name: algorithm.name },
    false,
    ['decrypt']);

  return assert.rejects(subtle.encrypt(algorithm, key, plaintext), {
    message: /The requested operation is not valid for the provided key/
  });
}

async function testEncryptNoDecrypt({ keyBuffer, algorithm, plaintext }) {
  const key = await subtle.importKey(
    'raw',
    keyBuffer,
    { name: algorithm.name },
    false,
    ['encrypt']);

  const output = await subtle.encrypt(algorithm, key, plaintext);

  return assert.rejects(subtle.decrypt(algorithm, key, output), {
    message: /The requested operation is not valid for the provided key/
  });
}

async function testEncryptWrongAlg({ keyBuffer, algorithm, plaintext }, alg) {
  assert.notStrictEqual(algorithm.name, alg);
  const key = await subtle.importKey(
    'raw',
    keyBuffer,
    { name: alg },
    false,
    ['encrypt']);

  return assert.rejects(subtle.encrypt(algorithm, key, plaintext), {
    message: /The requested operation is not valid for the provided key/
  });
}

async function testDecrypt({ keyBuffer, algorithm, result }) {
  const key = await subtle.importKey(
    'raw',
    keyBuffer,
    { name: algorithm.name },
    false,
    ['encrypt', 'decrypt']);

  await subtle.decrypt(algorithm, key, result);
}

// Test aes-cbc vectors
{
  const {
    passing,
    failing,
    decryptionFailing
  } = require('../fixtures/crypto/aes_cbc')();

  (async function() {
    const variations = [];

    passing.forEach((vector) => {
      variations.push(testEncrypt(vector));
      variations.push(testEncryptNoEncrypt(vector));
      variations.push(testEncryptNoDecrypt(vector));
      variations.push(testEncryptWrongAlg(vector, 'AES-CTR'));
    });

    failing.forEach((vector) => {
      variations.push(assert.rejects(testEncrypt(vector), {
        message: /algorithm\.iv must contain exactly 16 bytes/
      }));
      variations.push(assert.rejects(testDecrypt(vector), {
        message: /algorithm\.iv must contain exactly 16 bytes/
      }));
    });

    decryptionFailing.forEach((vector) => {
      variations.push(assert.rejects(testDecrypt(vector), {
        name: 'OperationError'
      }));
    });

    await Promise.all(variations);
  })().then(common.mustCall());
}

// Test aes-ctr vectors
{
  const {
    passing,
    failing,
    decryptionFailing
  } = require('../fixtures/crypto/aes_ctr')();

  (async function() {
    const variations = [];

    passing.forEach((vector) => {
      variations.push(testEncrypt(vector));
      variations.push(testEncryptNoEncrypt(vector));
      variations.push(testEncryptNoDecrypt(vector));
      variations.push(testEncryptWrongAlg(vector, 'AES-CBC'));
    });

    // TODO(@jasnell): These fail for different reasons. Need to
    // make them consistent
    failing.forEach((vector) => {
      variations.push(assert.rejects(testEncrypt(vector), {
        message: /.*/
      }));
      variations.push(assert.rejects(testDecrypt(vector), {
        message: /.*/
      }));
    });

    decryptionFailing.forEach((vector) => {
      variations.push(assert.rejects(testDecrypt(vector), {
        name: 'OperationError'
      }));
    });

    await Promise.all(variations);
  })().then(common.mustCall());
}

// Test aes-gcm vectors
{
  const {
    passing,
    failing,
    decryptionFailing
  } = require('../fixtures/crypto/aes_gcm')();

  (async function() {
    const variations = [];

    passing.forEach((vector) => {
      variations.push(testEncrypt(vector));
      variations.push(testEncryptNoEncrypt(vector));
      variations.push(testEncryptNoDecrypt(vector));
      variations.push(testEncryptWrongAlg(vector, 'AES-CBC'));
    });

    failing.forEach((vector) => {
      variations.push(assert.rejects(testEncrypt(vector), {
        message: /is not a valid AES-GCM tag length/
      }));
      variations.push(assert.rejects(testDecrypt(vector), {
        message: /is not a valid AES-GCM tag length/
      }));
    });

    decryptionFailing.forEach((vector) => {
      variations.push(assert.rejects(testDecrypt(vector), {
        name: 'OperationError'
      }));
    });

    await Promise.all(variations);
  })().then(common.mustCall());
}

{
  (async function() {
    const secretKey = await subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256,
      },
      false,
      ['encrypt', 'decrypt'],
    );

    const iv = globalThis.crypto.getRandomValues(new Uint8Array(12));
    const aad = globalThis.crypto.getRandomValues(new Uint8Array(32));

    const encrypted = await subtle.encrypt(
      {
        name: 'AES-GCM',
        iv,
        additionalData: aad,
        tagLength: 128
      },
      secretKey,
      globalThis.crypto.getRandomValues(new Uint8Array(32))
    );

    await subtle.decrypt(
      {
        name: 'AES-GCM',
        iv,
        additionalData: aad,
        tagLength: 128,
      },
      secretKey,
      new Uint8Array(encrypted),
    );
  })().then(common.mustCall());
}
                  node-23.7.0/test/parallel/test-webcrypto-encrypt-decrypt-rsa.js                                     0000664 0000000 0000000 00000014121 14746647661 0024575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const {
  passing
} = require('../fixtures/crypto/rsa')();

async function importVectorKey(
  publicKeyBuffer,
  privateKeyBuffer,
  name,
  hash,
  publicUsages,
  privateUsages) {
  const [publicKey, privateKey] = await Promise.all([
    subtle.importKey(
      'spki', publicKeyBuffer, { name, hash }, false, publicUsages),
    subtle.importKey(
      'pkcs8', privateKeyBuffer, { name, hash }, false, privateUsages),
  ]);

  return { publicKey, privateKey };
}

async function testDecryption({ ciphertext,
                                algorithm,
                                plaintext,
                                hash,
                                publicKeyBuffer,
                                privateKeyBuffer }) {
  if (ciphertext === undefined)
    return;

  const {
    privateKey
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['encrypt'],
    ['decrypt']);

  const encodedPlaintext = Buffer.from(plaintext).toString('hex');
  const result = await subtle.decrypt(algorithm, privateKey, ciphertext);

  assert.strictEqual(
    Buffer.from(result).toString('hex'),
    encodedPlaintext);

  const ciphercopy = Buffer.from(ciphertext);

  // Modifying the ciphercopy after calling decrypt should just work
  const result2 = await subtle.decrypt(algorithm, privateKey, ciphercopy);
  ciphercopy[0] = 255 - ciphercopy[0];

  assert.strictEqual(
    Buffer.from(result2).toString('hex'),
    encodedPlaintext);
}

async function testEncryption(
  {
    ciphertext,
    algorithm,
    plaintext,
    hash,
    publicKeyBuffer,
    privateKeyBuffer
  },
  modify = false) {
  const {
    publicKey,
    privateKey
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['encrypt'],
    ['decrypt']);

  if (modify)
    plaintext = Buffer.from(plaintext);  // make a copy

  const encodedPlaintext = Buffer.from(plaintext).toString('hex');

  const result = await subtle.encrypt(algorithm, publicKey, plaintext);
  if (modify)
    plaintext[0] = 255 - plaintext[0];

  assert.strictEqual(
    result.byteLength * 8,
    privateKey.algorithm.modulusLength);

  const out = await subtle.decrypt(algorithm, privateKey, result);

  assert.strictEqual(
    Buffer.from(out).toString('hex'),
    encodedPlaintext);
}

async function testEncryptionLongPlaintext({ algorithm,
                                             plaintext,
                                             hash,
                                             publicKeyBuffer,
                                             privateKeyBuffer }) {
  const {
    publicKey,
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['encrypt'],
    ['decrypt']);
  const newplaintext = new Uint8Array(plaintext.byteLength + 1);
  newplaintext.set(plaintext, 0);
  newplaintext[plaintext.byteLength] = 32;

  return assert.rejects(
    subtle.encrypt(algorithm, publicKey, newplaintext), {
      name: 'OperationError'
    });
}

async function testEncryptionWrongKey({ algorithm,
                                        plaintext,
                                        hash,
                                        publicKeyBuffer,
                                        privateKeyBuffer }) {
  const {
    privateKey,
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['encrypt'],
    ['decrypt']);
  return assert.rejects(
    subtle.encrypt(algorithm, privateKey, plaintext), {
      message: /The requested operation is not valid/
    });
}

async function testEncryptionBadUsage({ algorithm,
                                        plaintext,
                                        hash,
                                        publicKeyBuffer,
                                        privateKeyBuffer }) {
  const {
    publicKey,
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['wrapKey'],
    ['decrypt']);
  return assert.rejects(
    subtle.encrypt(algorithm, publicKey, plaintext), {
      message: /The requested operation is not valid/
    });
}

async function testDecryptionWrongKey({ ciphertext,
                                        algorithm,
                                        hash,
                                        publicKeyBuffer,
                                        privateKeyBuffer }) {
  if (ciphertext === undefined)
    return;

  const {
    publicKey
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['encrypt'],
    ['decrypt']);

  return assert.rejects(
    subtle.decrypt(algorithm, publicKey, ciphertext), {
      message: /The requested operation is not valid/
    });
}

async function testDecryptionBadUsage({ ciphertext,
                                        algorithm,
                                        hash,
                                        publicKeyBuffer,
                                        privateKeyBuffer }) {
  if (ciphertext === undefined)
    return;

  const {
    publicKey
  } = await importVectorKey(
    publicKeyBuffer,
    privateKeyBuffer,
    algorithm.name,
    hash,
    ['encrypt'],
    ['unwrapKey']);

  return assert.rejects(
    subtle.decrypt(algorithm, publicKey, ciphertext), {
      message: /The requested operation is not valid/
    });
}

(async function() {
  const variations = [];

  // Test decryption
  passing.forEach(async (vector) => {
    variations.push(testDecryption(vector));
    variations.push(testDecryptionWrongKey(vector));
    variations.push(testDecryptionBadUsage(vector));
    variations.push(testEncryption(vector));
    variations.push(testEncryption(vector, true));
    variations.push(testEncryptionLongPlaintext(vector));
    variations.push(testEncryptionWrongKey(vector));
    variations.push(testEncryptionBadUsage(vector));
  });

  await Promise.all(variations);
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-webcrypto-encrypt-decrypt.js                                         0000664 0000000 0000000 00000006104 14746647661 0024014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

// This is only a partial test. The WebCrypto Web Platform Tests
// will provide much greater coverage.

// Test Encrypt/Decrypt RSA-OAEP
{
  const buf = globalThis.crypto.getRandomValues(new Uint8Array(50));

  async function test() {
    const ec = new TextEncoder();
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'RSA-OAEP',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-384',
    }, true, ['encrypt', 'decrypt']);

    const ciphertext = await subtle.encrypt({
      name: 'RSA-OAEP',
      label: ec.encode('a label')
    }, publicKey, buf);

    const plaintext = await subtle.decrypt({
      name: 'RSA-OAEP',
      label: ec.encode('a label')
    }, privateKey, ciphertext);

    assert.strictEqual(
      Buffer.from(plaintext).toString('hex'),
      Buffer.from(buf).toString('hex'));
  }

  test().then(common.mustCall());
}

// Test Encrypt/Decrypt AES-CTR
{
  const buf = globalThis.crypto.getRandomValues(new Uint8Array(50));
  const counter = globalThis.crypto.getRandomValues(new Uint8Array(16));

  async function test() {
    const key = await subtle.generateKey({
      name: 'AES-CTR',
      length: 256
    }, true, ['encrypt', 'decrypt']);

    const ciphertext = await subtle.encrypt(
      { name: 'AES-CTR', counter, length: 64 }, key, buf,
    );

    const plaintext = await subtle.decrypt(
      { name: 'AES-CTR', counter, length: 64 }, key, ciphertext,
    );

    assert.strictEqual(
      Buffer.from(plaintext).toString('hex'),
      Buffer.from(buf).toString('hex'));
  }

  test().then(common.mustCall());
}

// Test Encrypt/Decrypt AES-CBC
{
  const buf = globalThis.crypto.getRandomValues(new Uint8Array(50));
  const iv = globalThis.crypto.getRandomValues(new Uint8Array(16));

  async function test() {
    const key = await subtle.generateKey({
      name: 'AES-CBC',
      length: 256
    }, true, ['encrypt', 'decrypt']);

    const ciphertext = await subtle.encrypt(
      { name: 'AES-CBC', iv }, key, buf,
    );

    const plaintext = await subtle.decrypt(
      { name: 'AES-CBC', iv }, key, ciphertext,
    );

    assert.strictEqual(
      Buffer.from(plaintext).toString('hex'),
      Buffer.from(buf).toString('hex'));
  }

  test().then(common.mustCall());
}

// Test Encrypt/Decrypt AES-GCM
{
  const buf = globalThis.crypto.getRandomValues(new Uint8Array(50));
  const iv = globalThis.crypto.getRandomValues(new Uint8Array(12));

  async function test() {
    const key = await subtle.generateKey({
      name: 'AES-GCM',
      length: 256
    }, true, ['encrypt', 'decrypt']);

    const ciphertext = await subtle.encrypt(
      { name: 'AES-GCM', iv }, key, buf,
    );

    const plaintext = await subtle.decrypt(
      { name: 'AES-GCM', iv }, key, ciphertext,
    );

    assert.strictEqual(
      Buffer.from(plaintext).toString('hex'),
      Buffer.from(buf).toString('hex'));
  }

  test().then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-webcrypto-export-import-cfrg.js                                      0000664 0000000 0000000 00000025643 14746647661 0024441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fixtures = require('../common/fixtures');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { subtle } = globalThis.crypto;

const keyData = {
  'Ed25519': {
    jwsAlg: 'EdDSA',
    spki: Buffer.from(
      '302a300506032b6570032100a054b618c12b26c8d43595a5c38dd2b0140b944a' +
      '151f75003278c2b6c58ec08f', 'hex'),
    pkcs8: Buffer.from(
      '302e020100300506032b657004220420d53150bdcd17b4d4b21ae756d4965639' +
      'd75b28f56ff9111b1f88326913e445bc', 'hex'),
    jwk: {
      kty: 'OKP',
      crv: 'Ed25519',
      x: 'oFS2GMErJsjUNZWlw43SsBQLlEoVH3UAMnjCtsWOwI8',
      d: '1TFQvc0XtNSyGudW1JZWOddbKPVv-REbH4gyaRPkRbw'
    }
  },
  'Ed448': {
    jwsAlg: 'EdDSA',
    spki: Buffer.from(
      '3043300506032b6571033a0008cc38160c85bca5656ac4924af7ea97a9161b20' +
      '2528273dcb84afd2eeb99ac912a401b34ef15ef4d9486406a6eecc31e5909219' +
      'bd54866800', 'hex'),
    pkcs8: Buffer.from(
      '3047020100300506032b6571043b0439afd05b2fbb153b47c18dfa66baaed0de' +
      'fb4e88c651487cdee0fafc40fa3d048fe1cd145a44143243c0468166b5bc161a' +
      '82e3b904f3e2fcaaf9', 'hex'),
    jwk: {
      kty: 'OKP',
      crv: 'Ed448',
      x: 'CMw4FgyFvKVlasSSSvfql6kWGyAlKCc9y4Sv0u65mskSpAGzTvFe9NlIZAam7' +
         'swx5ZCSGb1UhmgA',
      d: 'r9BbL7sVO0fBjfpmuq7Q3vtOiMZRSHze4Pr8QPo9BI_hzRRaRBQyQ8BGgWa1v' +
         'BYaguO5BPPi_Kr5'
    }
  },
  'X25519': {
    jwsAlg: 'ECDH-ES',
    spki: Buffer.from(
      '302a300506032b656e032100f38d9f4e621a44e0428176a4c8a534b34f07f8db' +
      '30152f9ca0167aabf598fe65', 'hex'),
    pkcs8: Buffer.from(
      '302e020100300506032b656e04220420a8327850317b4b03a5a8b4e923413b1d' +
      'a4a642e0d6f7a72cf4d16a549e628a5f', 'hex'),
    jwk: {
      kty: 'OKP',
      crv: 'X25519',
      x: '842fTmIaROBCgXakyKU0s08H-NswFS-coBZ6q_WY_mU',
      d: 'qDJ4UDF7SwOlqLTpI0E7HaSmQuDW96cs9NFqVJ5iil8'
    }
  },
  'X448': {
    jwsAlg: 'ECDH-ES',
    spki: Buffer.from(
      '3042300506032b656f0339001d451c8c0c369a42eadfc2875cd44953caeb46c4' +
      '66dc86568280bfdbbb01f4709a1b0b1e0dd66cf7b11c84119ddc98890db72891' +
      '29e30da4', 'hex'),
    pkcs8: Buffer.from(
      '3046020100300506032b656f043a0438fc818f6546a81f963c27765dc1c05bfd' +
      'b169667e5e0cf45318ed1cb93872217ab0d9004e0c7dd0dcb00192f72039cc1a' +
      '1dff750ec31c8afb', 'hex'),
    jwk: {
      kty: 'OKP',
      crv: 'X448',
      x: 'HUUcjAw2mkLq38KHXNRJU8rrRsRm3IZWgoC_27sB9HCaGwseDdZs97EchBGd3' +
         'JiJDbcokSnjDaQ',
      d: '_IGPZUaoH5Y8J3ZdwcBb_bFpZn5eDPRTGO0cuThyIXqw2QBODH3Q3LABkvcgO' +
         'cwaHf91DsMcivs'
    }
  }
};

const testVectors = [
  {
    name: 'Ed25519',
    privateUsages: ['sign'],
    publicUsages: ['verify']
  },
  {
    name: 'Ed448',
    privateUsages: ['sign'],
    publicUsages: ['verify']
  },
  {
    name: 'X25519',
    privateUsages: ['deriveKey', 'deriveBits'],
    publicUsages: []
  },
  {
    name: 'X448',
    privateUsages: ['deriveKey', 'deriveBits'],
    publicUsages: []
  },
];

async function testImportSpki({ name, publicUsages }, extractable) {
  const key = await subtle.importKey(
    'spki',
    keyData[name].spki,
    { name },
    extractable,
    publicUsages);
  assert.strictEqual(key.type, 'public');
  assert.strictEqual(key.extractable, extractable);
  assert.deepStrictEqual(key.usages, publicUsages);
  assert.deepStrictEqual(key.algorithm.name, name);
  assert.strictEqual(key.algorithm, key.algorithm);
  assert.strictEqual(key.usages, key.usages);

  if (extractable) {
    // Test the roundtrip
    const spki = await subtle.exportKey('spki', key);
    assert.strictEqual(
      Buffer.from(spki).toString('hex'),
      keyData[name].spki.toString('hex'));
  } else {
    await assert.rejects(
      subtle.exportKey('spki', key), {
        message: /key is not extractable/
      });
  }

  // Bad usage
  await assert.rejects(
    subtle.importKey(
      'spki',
      keyData[name].spki,
      { name },
      extractable,
      ['wrapKey']),
    { message: /Unsupported key usage/ });
}

async function testImportPkcs8({ name, privateUsages }, extractable) {
  const key = await subtle.importKey(
    'pkcs8',
    keyData[name].pkcs8,
    { name },
    extractable,
    privateUsages);
  assert.strictEqual(key.type, 'private');
  assert.strictEqual(key.extractable, extractable);
  assert.deepStrictEqual(key.usages, privateUsages);
  assert.deepStrictEqual(key.algorithm.name, name);
  assert.strictEqual(key.algorithm, key.algorithm);
  assert.strictEqual(key.usages, key.usages);

  if (extractable) {
    // Test the roundtrip
    const pkcs8 = await subtle.exportKey('pkcs8', key);
    assert.strictEqual(
      Buffer.from(pkcs8).toString('hex'),
      keyData[name].pkcs8.toString('hex'));
  } else {
    await assert.rejects(
      subtle.exportKey('pkcs8', key), {
        message: /key is not extractable/
      });
  }

  await assert.rejects(
    subtle.importKey(
      'pkcs8',
      keyData[name].pkcs8,
      { name },
      extractable,
      [/* empty usages */]),
    { name: 'SyntaxError', message: 'Usages cannot be empty when importing a private key.' });
}

async function testImportJwk({ name, publicUsages, privateUsages }, extractable) {

  const jwk = keyData[name].jwk;

  const [
    publicKey,
    privateKey,
  ] = await Promise.all([
    subtle.importKey(
      'jwk',
      {
        kty: jwk.kty,
        crv: jwk.crv,
        x: jwk.x,
      },
      { name },
      extractable, publicUsages),
    subtle.importKey(
      'jwk',
      jwk,
      { name },
      extractable,
      privateUsages),
    subtle.importKey(
      'jwk',
      {
        alg: keyData[name].jwsAlg,
        kty: jwk.kty,
        crv: jwk.crv,
        x: jwk.x,
      },
      { name },
      extractable, publicUsages),
    subtle.importKey(
      'jwk',
      {
        ...jwk,
        alg: keyData[name].jwsAlg,
      },
      { name },
      extractable,
      privateUsages),
  ]);

  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(publicKey.extractable, extractable);
  assert.strictEqual(privateKey.extractable, extractable);
  assert.deepStrictEqual(publicKey.usages, publicUsages);
  assert.deepStrictEqual(privateKey.usages, privateUsages);
  assert.strictEqual(publicKey.algorithm.name, name);
  assert.strictEqual(privateKey.algorithm.name, name);
  assert.strictEqual(privateKey.algorithm, privateKey.algorithm);
  assert.strictEqual(privateKey.usages, privateKey.usages);
  assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
  assert.strictEqual(publicKey.usages, publicKey.usages);

  if (extractable) {
    // Test the round trip
    const [
      pubJwk,
      pvtJwk,
    ] = await Promise.all([
      subtle.exportKey('jwk', publicKey),
      subtle.exportKey('jwk', privateKey),
    ]);

    assert.deepStrictEqual(pubJwk.key_ops, publicUsages);
    assert.strictEqual(pubJwk.ext, true);
    assert.strictEqual(pubJwk.kty, 'OKP');
    assert.strictEqual(pubJwk.x, jwk.x);
    assert.strictEqual(pubJwk.crv, jwk.crv);

    assert.deepStrictEqual(pvtJwk.key_ops, privateUsages);
    assert.strictEqual(pvtJwk.ext, true);
    assert.strictEqual(pvtJwk.kty, 'OKP');
    assert.strictEqual(pvtJwk.x, jwk.x);
    assert.strictEqual(pvtJwk.crv, jwk.crv);
    assert.strictEqual(pvtJwk.d, jwk.d);

    assert.strictEqual(pubJwk.alg, undefined);
    assert.strictEqual(pvtJwk.alg, undefined);
  } else {
    await assert.rejects(
      subtle.exportKey('jwk', publicKey), {
        message: /key is not extractable/
      });
    await assert.rejects(
      subtle.exportKey('jwk', privateKey), {
        message: /key is not extractable/
      });
  }

  {
    const invalidUse = name.startsWith('X') ? 'sig' : 'enc';
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, use: invalidUse },
        { name },
        extractable,
        privateUsages),
      { message: 'Invalid JWK "use" Parameter' });
  }

  // The JWK alg member is ignored
  // https://github.com/WICG/webcrypto-secure-curves/pull/24
  if (name.startsWith('Ed')) {
    await subtle.importKey(
      'jwk',
      { kty: jwk.kty, x: jwk.x, crv: jwk.crv, alg: 'foo' },
      { name },
      extractable,
      publicUsages);

    await subtle.importKey(
      'jwk',
      { ...jwk, alg: 'foo' },
      { name },
      extractable,
      privateUsages);
  }

  for (const crv of [undefined, name === 'Ed25519' ? 'Ed448' : 'Ed25519']) {
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { kty: jwk.kty, x: jwk.x, y: jwk.y, crv },
        { name },
        extractable,
        publicUsages),
      { message: 'JWK "crv" Parameter and algorithm name mismatch' });

    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, crv },
        { name },
        extractable,
        privateUsages),
      { message: 'JWK "crv" Parameter and algorithm name mismatch' });
  }

  await assert.rejects(
    subtle.importKey(
      'jwk',
      { ...jwk },
      { name },
      extractable,
      [/* empty usages */]),
    { name: 'SyntaxError', message: 'Usages cannot be empty when importing a private key.' });

  await assert.rejects(
    subtle.importKey(
      'jwk',
      { kty: jwk.kty, /* missing x */ crv: jwk.crv },
      { name },
      extractable,
      publicUsages),
    { name: 'DataError', message: 'Invalid keyData' });
}

async function testImportRaw({ name, publicUsages }) {
  const jwk = keyData[name].jwk;

  const publicKey = await subtle.importKey(
    'raw',
    Buffer.from(jwk.x, 'base64url'),
    { name },
    true, publicUsages);

  assert.strictEqual(publicKey.type, 'public');
  assert.deepStrictEqual(publicKey.usages, publicUsages);
  assert.strictEqual(publicKey.algorithm.name, name);
  assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
  assert.strictEqual(publicKey.usages, publicKey.usages);
}

(async function() {
  const tests = [];
  for (const vector of testVectors) {
    for (const extractable of [true, false]) {
      tests.push(testImportSpki(vector, extractable));
      tests.push(testImportPkcs8(vector, extractable));
      tests.push(testImportJwk(vector, extractable));
    }
    tests.push(testImportRaw(vector));
  }
  await Promise.all(tests);
})().then(common.mustCall());

{
  const rsaPublic = crypto.createPublicKey(
    fixtures.readKey('rsa_public_2048.pem'));
  const rsaPrivate = crypto.createPrivateKey(
    fixtures.readKey('rsa_private_2048.pem'));

  for (const [name, publicUsages, privateUsages] of [
    ['Ed25519', ['verify'], ['sign']],
    ['X448', [], ['deriveBits']],
  ]) {
    assert.rejects(subtle.importKey(
      'spki',
      rsaPublic.export({ format: 'der', type: 'spki' }),
      { name },
      true, publicUsages), { message: /Invalid key type/ }).then(common.mustCall());
    assert.rejects(subtle.importKey(
      'pkcs8',
      rsaPrivate.export({ format: 'der', type: 'pkcs8' }),
      { name },
      true, privateUsages), { message: /Invalid key type/ }).then(common.mustCall());
  }
}
                                                                                             node-23.7.0/test/parallel/test-webcrypto-export-import-ec.js                                        0000664 0000000 0000000 00000041363 14746647661 0024104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fixtures = require('../common/fixtures');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { subtle } = globalThis.crypto;

const curves = ['P-256', 'P-384', 'P-521'];

const keyData = {
  'P-521': {
    jwsAlg: 'ES512',
    spki: Buffer.from(
      '30819b301006072a8648ce3d020106052b8104002303818600040156f479f8df' +
      '1e20a7ffc04ce420c3e154ae251996bee42f034b84d41b743f34e45f311b813a' +
      '9cdec8cda59bbbbd31d460b3292521e7c1b722e5667c03db2fae753f01501736' +
      'cfe247394320d8e4afc2fd39b5a9331061b81e2241282b9e17891822b5b79e05' +
      '2f4597b59643fd39379c51bd5125c4f48bc3f025ce3cd36953286ccb38fb',
      'hex'),
    pkcs8: Buffer.from(
      '3081ee020100301006072a8648ce3d020106052b810400230481d63081d3020' +
      '101044200f408758368ba930f30f76ae054fe5cd2ce7fda2c9f76a6d436cf75' +
      'd66c440bfe6331c7c172a12478193c8251487bc91263fa50217f85ff636f59c' +
      'd546e3ab483b4a1818903818600040156f479f8df1e20a7ffc04ce420c3e154' +
      'ae251996bee42f034b84d41b743f34e45f311b813a9cdec8cda59bbbbd31d46' +
      '0b3292521e7c1b722e5667c03db2fae753f01501736cfe247394320d8e4afc2' +
      'fd39b5a9331061b81e2241282b9e17891822b5b79e052f4597b59643fd39379' +
      'c51bd5125c4f48bc3f025ce3cd36953286ccb38fb', 'hex'),
    jwk: {
      kty: 'EC',
      crv: 'P-521',
      x: 'AVb0efjfHiCn_8BM5CDD4VSuJRmWvuQvA0uE1Bt0PzTkXzEbgTqc3sjN' +
          'pZu7vTHUYLMpJSHnwbci5WZ8A9svrnU_',
      y: 'AVAXNs_iRzlDINjkr8L9ObWpMxBhuB4iQSgrnheJGCK1t54FL0W' +
          'XtZZD_Tk3nFG9USXE9IvD8CXOPNNpUyhsyzj7',
      d: 'APQIdYNoupMPMPdq4FT-XNLOf9osn3am1DbPddZsRAv-YzHHw' +
          'XKhJHgZPIJRSHvJEmP6UCF_hf9jb1nNVG46tIO0'
    }
  },
  'P-384': {
    jwsAlg: 'ES384',
    spki: Buffer.from(
      '3076301006072a8648ce3d020106052b8104002203620004219c14d66617b36e' +
      'c6d8856b385b73a74d344fd8ae75ef046435dda54e3b44bd5fbdebd1d08dd69e' +
      '2d7dc1dc218cb435bd28138cc778337a842f6bd61b240e74249f24667c2a5810' +
      'a76bfc28e0335f88a6501dec01976da85afb00869cb6ace8', 'hex'),
    pkcs8: Buffer.from(
      '3081b6020100301006072a8648ce3d020106052b8104002204819e30819b0201' +
      '0104304537b5990784d3c2d22e96a8f92fa1aa492ee873e576a41582e144183c' +
      '9888d10e6b9eb4ced4b2cc4012e4ac5ea84073a16403620004219c14d66617b3' +
      '6ec6d8856b385b73a74d344fd8ae75ef046435dda54e3b44bd5fbdebd1d08dd6' +
      '9e2d7dc1dc218cb435bd28138cc778337a842f6bd61b240e74249f24667c2a58' +
      '10a76bfc28e0335f88a6501dec01976da85afb00869cb6ace8', 'hex'),
    jwk: {
      kty: 'EC',
      crv: 'P-384',
      x: 'IZwU1mYXs27G2IVrOFtzp000T9iude8EZDXdpU47RL1fvevR0I3Wni19wdwhjLQ1',
      y: 'vSgTjMd4M3qEL2vWGyQOdCSfJGZ8KlgQp2v8KOAzX4imUB3sAZdtqFr7AIactqzo',
      d: 'RTe1mQeE08LSLpao-S-hqkku6HPldqQVguFEGDyYiNEOa560ztSyzEAS5KxeqEBz'
    }
  },
  'P-256': {
    jwsAlg: 'ES256',
    spki: Buffer.from(
      '3059301306072a8648ce3d020106082a8648ce3d03010703420004d6e8328a95' +
      'fe29afcdc30977b9251efbb219022807f6b14bb34695b6b4bdb93ee6684548a4' +
      'ad13c49d00433c45315e8274f3540f58f5d79ef7a1b184f4c21d17', 'hex'),
    pkcs8: Buffer.from(
      '308187020100301306072a8648ce3d020106082a8648ce3d030107046d306b02' +
      '010104202bc2eda265e46866efa8f8f99da993175b6c85c246e15dceaed7e307' +
      '0f13fbf8a14403420004d6e8328a95fe29afcdc30977b9251efbb219022807f6' +
      'b14bb34695b6b4bdb93ee6684548a4ad13c49d00433c45315e8274f3540f58f5' +
      'd79ef7a1b184f4c21d17', 'hex'),
    jwk: {
      kty: 'EC',
      crv: 'P-256',
      x: '1ugyipX-Ka_Nwwl3uSUe-7IZAigH9rFLs0aVtrS9uT4',
      y: '5mhFSKStE8SdAEM8RTFegnTzVA9Y9dee96GxhPTCHRc',
      d: 'K8LtomXkaGbvqPj5namTF1tshcJG4V3OrtfjBw8T-_g'
    }
  },
};

const testVectors = [
  {
    name: 'ECDSA',
    privateUsages: ['sign'],
    publicUsages: ['verify']
  },
  {
    name: 'ECDH',
    privateUsages: ['deriveKey', 'deriveBits'],
    publicUsages: []
  },
];

async function testImportSpki({ name, publicUsages }, namedCurve, extractable) {
  const key = await subtle.importKey(
    'spki',
    keyData[namedCurve].spki,
    { name, namedCurve },
    extractable,
    publicUsages);
  assert.strictEqual(key.type, 'public');
  assert.strictEqual(key.extractable, extractable);
  assert.deepStrictEqual(key.usages, publicUsages);
  assert.deepStrictEqual(key.algorithm.name, name);
  assert.deepStrictEqual(key.algorithm.namedCurve, namedCurve);
  assert.strictEqual(key.algorithm, key.algorithm);
  assert.strictEqual(key.usages, key.usages);

  if (extractable) {
    // Test the roundtrip
    const spki = await subtle.exportKey('spki', key);
    assert.strictEqual(
      Buffer.from(spki).toString('hex'),
      keyData[namedCurve].spki.toString('hex'));
  } else {
    await assert.rejects(
      subtle.exportKey('spki', key), {
        message: /key is not extractable/
      });
  }

  // Bad usage
  await assert.rejects(
    subtle.importKey(
      'spki',
      keyData[namedCurve].spki,
      { name, namedCurve },
      extractable,
      ['wrapKey']),
    { message: /Unsupported key usage/ });
}

async function testImportPkcs8(
  { name, privateUsages },
  namedCurve,
  extractable) {
  const key = await subtle.importKey(
    'pkcs8',
    keyData[namedCurve].pkcs8,
    { name, namedCurve },
    extractable,
    privateUsages);
  assert.strictEqual(key.type, 'private');
  assert.strictEqual(key.extractable, extractable);
  assert.deepStrictEqual(key.usages, privateUsages);
  assert.deepStrictEqual(key.algorithm.name, name);
  assert.deepStrictEqual(key.algorithm.namedCurve, namedCurve);
  assert.strictEqual(key.algorithm, key.algorithm);
  assert.strictEqual(key.usages, key.usages);

  if (extractable) {
    // Test the roundtrip
    const pkcs8 = await subtle.exportKey('pkcs8', key);
    assert.strictEqual(
      Buffer.from(pkcs8).toString('hex'),
      keyData[namedCurve].pkcs8.toString('hex'));
  } else {
    await assert.rejects(
      subtle.exportKey('pkcs8', key), {
        message: /key is not extractable/
      });
  }

  await assert.rejects(
    subtle.importKey(
      'pkcs8',
      keyData[namedCurve].pkcs8,
      { name, namedCurve },
      extractable,
      [/* empty usages */]),
    { name: 'SyntaxError', message: 'Usages cannot be empty when importing a private key.' });
}

async function testImportJwk(
  { name, publicUsages, privateUsages },
  namedCurve,
  extractable) {

  const jwk = keyData[namedCurve].jwk;

  const [
    publicKey,
    privateKey,
  ] = await Promise.all([
    subtle.importKey(
      'jwk',
      {
        kty: jwk.kty,
        crv: jwk.crv,
        x: jwk.x,
        y: jwk.y,
      },
      { name, namedCurve },
      extractable, publicUsages),
    subtle.importKey(
      'jwk',
      jwk,
      { name, namedCurve },
      extractable,
      privateUsages),
    subtle.importKey(
      'jwk',
      {
        alg: name === 'ECDSA' ? keyData[namedCurve].jwsAlg : 'ECDH-ES',
        kty: jwk.kty,
        crv: jwk.crv,
        x: jwk.x,
        y: jwk.y,
      },
      { name, namedCurve },
      extractable, publicUsages),
    subtle.importKey(
      'jwk',
      {
        ...jwk,
        alg: name === 'ECDSA' ? keyData[namedCurve].jwsAlg : 'ECDH-ES',
      },
      { name, namedCurve },
      extractable,
      privateUsages),
  ]);

  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(publicKey.extractable, extractable);
  assert.strictEqual(privateKey.extractable, extractable);
  assert.deepStrictEqual(publicKey.usages, publicUsages);
  assert.deepStrictEqual(privateKey.usages, privateUsages);
  assert.strictEqual(publicKey.algorithm.name, name);
  assert.strictEqual(privateKey.algorithm.name, name);
  assert.strictEqual(publicKey.algorithm.namedCurve, namedCurve);
  assert.strictEqual(privateKey.algorithm.namedCurve, namedCurve);
  assert.strictEqual(privateKey.algorithm, privateKey.algorithm);
  assert.strictEqual(privateKey.usages, privateKey.usages);
  assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
  assert.strictEqual(publicKey.usages, publicKey.usages);

  if (extractable) {
    // Test the round trip
    const [
      pubJwk,
      pvtJwk,
    ] = await Promise.all([
      subtle.exportKey('jwk', publicKey),
      subtle.exportKey('jwk', privateKey),
    ]);

    assert.deepStrictEqual(pubJwk.key_ops, publicUsages);
    assert.strictEqual(pubJwk.ext, true);
    assert.strictEqual(pubJwk.kty, 'EC');
    assert.strictEqual(pubJwk.x, jwk.x);
    assert.strictEqual(pubJwk.y, jwk.y);
    assert.strictEqual(pubJwk.crv, jwk.crv);

    assert.deepStrictEqual(pvtJwk.key_ops, privateUsages);
    assert.strictEqual(pvtJwk.ext, true);
    assert.strictEqual(pvtJwk.kty, 'EC');
    assert.strictEqual(pvtJwk.x, jwk.x);
    assert.strictEqual(pvtJwk.y, jwk.y);
    assert.strictEqual(pvtJwk.crv, jwk.crv);
    assert.strictEqual(pvtJwk.d, jwk.d);
  } else {
    await assert.rejects(
      subtle.exportKey('jwk', publicKey), {
        message: /key is not extractable/
      });
    await assert.rejects(
      subtle.exportKey('jwk', privateKey), {
        message: /key is not extractable/
      });
  }

  {
    const invalidUse = name === 'ECDH' ? 'sig' : 'enc';
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, use: invalidUse },
        { name, namedCurve },
        extractable,
        privateUsages),
      { message: 'Invalid JWK "use" Parameter' });
  }

  if (name === 'ECDSA') {
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { kty: jwk.kty, x: jwk.x, y: jwk.y, crv: jwk.crv, alg: jwk.crv === 'P-256' ? 'ES384' : 'ES256' },
        { name, namedCurve },
        extractable,
        publicUsages),
      { message: 'JWK "alg" does not match the requested algorithm' });

    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, alg: jwk.crv === 'P-256' ? 'ES384' : 'ES256' },
        { name, namedCurve },
        extractable,
        privateUsages),
      { message: 'JWK "alg" does not match the requested algorithm' });
  }

  for (const crv of [undefined, namedCurve === 'P-256' ? 'P-384' : 'P-256']) {
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { kty: jwk.kty, x: jwk.x, y: jwk.y, crv },
        { name, namedCurve },
        extractable,
        publicUsages),
      { message: 'JWK "crv" does not match the requested algorithm' });

    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, crv },
        { name, namedCurve },
        extractable,
        privateUsages),
      { message: 'JWK "crv" does not match the requested algorithm' });
  }

  await assert.rejects(
    subtle.importKey(
      'jwk',
      { ...jwk },
      { name, namedCurve },
      extractable,
      [/* empty usages */]),
    { name: 'SyntaxError', message: 'Usages cannot be empty when importing a private key.' });

  await assert.rejects(
    subtle.importKey(
      'jwk',
      { kty: jwk.kty, /* missing x */ y: jwk.y, crv: jwk.crv },
      { name, namedCurve },
      extractable,
      publicUsages),
    { name: 'DataError', message: 'Invalid keyData' });
}

async function testImportRaw({ name, publicUsages }, namedCurve) {
  const jwk = keyData[namedCurve].jwk;

  const [publicKey] = await Promise.all([
    subtle.importKey(
      'raw',
      Buffer.concat([
        Buffer.alloc(1, 0x04),
        Buffer.from(jwk.x, 'base64url'),
        Buffer.from(jwk.y, 'base64url'),
      ]),
      { name, namedCurve },
      true, publicUsages),
    subtle.importKey(
      'raw',
      Buffer.concat([
        Buffer.alloc(1, 0x03),
        Buffer.from(jwk.x, 'base64url'),
      ]),
      { name, namedCurve },
      true, publicUsages),
  ]);

  assert.strictEqual(publicKey.type, 'public');
  assert.deepStrictEqual(publicKey.usages, publicUsages);
  assert.strictEqual(publicKey.algorithm.name, name);
  assert.strictEqual(publicKey.algorithm.namedCurve, namedCurve);
  assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
  assert.strictEqual(publicKey.usages, publicKey.usages);
}

(async function() {
  const tests = [];
  for (const vector of testVectors) {
    for (const namedCurve of curves) {
      for (const extractable of [true, false]) {
        tests.push(testImportSpki(vector, namedCurve, extractable));
        tests.push(testImportPkcs8(vector, namedCurve, extractable));
        tests.push(testImportJwk(vector, namedCurve, extractable));
      }
      tests.push(testImportRaw(vector, namedCurve));
    }
  }

  await Promise.all(tests);
})().then(common.mustCall());


// https://github.com/nodejs/node/issues/45859
(async function() {
  const compressed = Buffer.from([48, 57, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 34, 0, 2, 210, 16, 176, 166, 249, 217, 240, 18, 134, 128, 88, 180, 63, 164, 244, 113, 1, 133, 67, 187, 160, 12, 146, 80, 223, 146, 87, 194, 172, 174, 93, 209]);  // eslint-disable-line @stylistic/js/max-len
  const uncompressed = Buffer.from([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66, 0, 4, 210, 16, 176, 166, 249, 217, 240, 18, 134, 128, 88, 180, 63, 164, 244, 113, 1, 133, 67, 187, 160, 12, 146, 80, 223, 146, 87, 194, 172, 174, 93, 209, 206, 3, 117, 82, 212, 129, 69, 12, 227, 155, 77, 16, 149, 112, 27, 23, 91, 250, 179, 75, 142, 108, 9, 158, 24, 241, 193, 152, 53, 131, 97, 232]);  // eslint-disable-line @stylistic/js/max-len
  for (const name of ['ECDH', 'ECDSA']) {
    const options = { name, namedCurve: 'P-256' };
    const key = await subtle.importKey('spki', compressed, options, true, []);
    const spki = await subtle.exportKey('spki', key);
    assert.deepStrictEqual(uncompressed, Buffer.from(spki));
  }
})().then(common.mustCall());

{
  const rsaPublic = crypto.createPublicKey(
    fixtures.readKey('rsa_public_2048.pem'));
  const rsaPrivate = crypto.createPrivateKey(
    fixtures.readKey('rsa_private_2048.pem'));

  for (const [name, publicUsages, privateUsages] of [
    ['ECDSA', ['verify'], ['sign']],
    ['ECDH', [], ['deriveBits', 'deriveBits']],
  ]) {
    assert.rejects(
      subtle.importKey(
        'spki',
        rsaPublic.export({ format: 'der', type: 'spki' }),
        { name, hash: 'SHA-256', namedCurve: 'P-256' },
        true, publicUsages), { message: /Invalid key type/ },
    ).then(common.mustCall());
    assert.rejects(
      subtle.importKey(
        'pkcs8',
        rsaPrivate.export({ format: 'der', type: 'pkcs8' }),
        { name, hash: 'SHA-256', namedCurve: 'P-256' },
        true, privateUsages), { message: /Invalid key type/ },
    ).then(common.mustCall());
  }
}

// Bad private keys
{
  for (const { namedCurve, key: pkcs8 } of [
    // The private key is exactly equal to the order, and the public key is
    // private key * order.
    {
      namedCurve: 'P-256',
      key: Buffer.from(
        '3066020100301306072a8648ce3d020106082a8648ce3d030107044c304a0201' +
        '010420ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc' +
        '632551a12303210000ffffff00000000ffffffffffffffffbce6faada7179e84' +
        'f3b9cac2fc632551', 'hex'),
    },
    // The private key is exactly equal to the order, and the public key is
    // omitted.
    {
      namedCurve: 'P-256',
      key: Buffer.from(
        '3041020100301306072a8648ce3d020106082a8648ce3d030107042730250201' +
        '010420ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc' +
        '632551', 'hex'),
    },
    // The private key is exactly equal to the order + 11, and the public key is
    // private key * order.
    {
      namedCurve: 'P-521',
      key: Buffer.from(
        '3081ee020100301006072a8648ce3d020106052b810400230481d63081d30201' +
        '01044201ffffffffffffffffffffffffffffffffffffffffffffffffffffffff' +
        'fffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb7' +
        '1e91386414a181890381860004008a75841259fdedff546f1a39573b4315cfed' +
        '5dc7ed7c17849543ef2c54f2991652f3dbc5332663da1bd19b1aebe319108501' +
        '5c024fa4c9a902ecc0e02dda0cdb9a0096fb303fcbba2129849d0ca877054fb2' +
        '293add566210bd0493ed2e95d4e0b9b82b1bc8a90e8b42a4ab3892331914a953' +
        '36dcac80e3f4819b5d58874f92ce48c808', 'hex'),
    },
    // The private key is exactly equal to the order + 11, and the public key is
    // omitted.
    {
      namedCurve: 'P-521',
      key: Buffer.from(
        '3060020100301006072a8648ce3d020106052b81040023044930470201010442' +
        '01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff' +
        'fffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e9138' +
        '6414', 'hex'),
    },
  ]) {
    for (const [name, privateUsages] of [
      ['ECDSA', ['sign']],
      ['ECDH', ['deriveBits', 'deriveBits']],
    ]) {
      assert.rejects(
        subtle.importKey(
          'pkcs8',
          pkcs8,
          { name, hash: 'SHA-256', namedCurve },
          true, privateUsages), { name: 'DataError', message: /Invalid keyData/ },
      ).then(common.mustCall());
    }
  }
}
                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-webcrypto-export-import-rsa.js                                       0000664 0000000 0000000 00000067303 14746647661 0024304 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fixtures = require('../common/fixtures');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { subtle } = globalThis.crypto;

const sizes = [1024, 2048, 4096];

const hashes = [
  'SHA-1',
  'SHA-256',
  'SHA-384',
  'SHA-512',
];

const keyData = {
  1024: {
    spki: Buffer.from(
      '30819f300d06092a864886f70d010101050003818d0030818902818100cd99f8b111' +
      '9f8d0a2ce7ac8bfd0cb547d348f931cc9c5ca79fde20e51c40eb01ab261e01253df1' +
      'e88f71d086e94b7abe77839103a476bee0cc87c743151afd4431fa5d8fa051271cf5' +
      '4e49cf7500d8a9957ec09b9d43ef70098c57f10d03bfd31748af563b881687720d3c' +
      '7b10a1cd553ac71d296b6edeeca5b99c8afb36dd970203010001', 'hex'),
    pkcs8: Buffer.from(
      '30820278020100300d06092a864886f70d0101010500048202623082025e02010002' +
      '818100cd99f8b1119f8d0a2ce7ac8bfd0cb547d348f931cc9c5ca79fde20e51c40eb' +
      '01ab261e01253df1e88f71d086e94b7abe77839103a476bee0cc87c743151afd4431' +
      'fa5d8fa051271cf54e49cf7500d8a9957ec09b9d43ef70098c57f10d03bfd31748af' +
      '563b881687720d3c7b10a1cd553ac71d296b6edeeca5b99c8afb36dd970203010001' +
      '02818062a20afc6747f3917e19665d81f826bf5e4d13bf2039a2f9876838bfb0de33' +
      'df890bb0393c748b28d627f3b1c519c0b8befd0f048051b72080fe62497c468658e4' +
      '5508e5d206958d7a9318a62a39da7df0e6e8f951912c0676ed65cd04b5685517602e' +
      'a9aed56e22ab59c414120108f15d201390f8b72060f065eff7def97501024100f41a' +
      'c08392f5cdfa863ee5890ee0c2057f939ad65dace23762ce1968dfb230f9538f0592' +
      '10f3b4aa77e3119730d958171e024999b55ca3a4f172424298462a79024100d79ee3' +
      '0c9d586b99e642f4cf6e12803c078c5a88310b26904e406ba77d2910a77a986481df' +
      'ce61aabe01224f2cddfecc757a4cf944a9699814a13e28ff65448f024100a9d77f41' +
      '4cdc681fba8e42a8d5483ed712880200cb16c22325451f5adfe21cbf2d8b62a5d9d3' +
      'a74dc0b2a6079b3e6e534f56ea1cdf9a80660074ae73a57d948902410084d45fc0e4' +
      'a994d7e12efc4b50dedadaa037c989bed4c4b3ff50d640feecae52ce46551c60f86d' +
      'd85666b2711e0dc02aca70463d051c6c6d80bff8601f3d8e67024100cdba49400862' +
      '9ebc526d52b1050d846461540f67b75825db009458a64f07550e40039d8e84a4e270' +
      'ec9eda11079eb82914acc2f22ce74ec086dc5324bf0723e1', 'hex'),
    jwk: {
      kty: 'RSA',
      n: 'zZn4sRGfjQos56yL_Qy1R9NI-THMnFynn94g5RxA6wGrJh4BJT3x6I9x0IbpS3q-d' +
         '4ORA6R2vuDMh8dDFRr9RDH6XY-gUScc9U5Jz3UA2KmVfsCbnUPvcAmMV_ENA7_TF0' +
         'ivVjuIFodyDTx7EKHNVTrHHSlrbt7spbmcivs23Zc',
      e: 'AQAB',
      d: 'YqIK_GdH85F-GWZdgfgmv15NE78gOaL5h2g4v7DeM9-JC7A5PHSLKNYn87HFGcC4v' +
         'v0PBIBRtyCA_mJJfEaGWORVCOXSBpWNepMYpio52n3w5uj5UZEsBnbtZc0EtWhVF2' +
         'Auqa7VbiKrWcQUEgEI8V0gE5D4tyBg8GXv9975dQE',
      p: '9BrAg5L1zfqGPuWJDuDCBX-TmtZdrOI3Ys4ZaN-yMPlTjwWSEPO0qnfjEZcw2VgXH' +
         'gJJmbVco6TxckJCmEYqeQ',
      q: '157jDJ1Ya5nmQvTPbhKAPAeMWogxCyaQTkBrp30pEKd6mGSB385hqr4BIk8s3f7Md' +
         'XpM-USpaZgUoT4o_2VEjw',
      dp: 'qdd_QUzcaB-6jkKo1Ug-1xKIAgDLFsIjJUUfWt_iHL8ti2Kl2dOnTcCypgebPm5T' +
          'T1bqHN-agGYAdK5zpX2UiQ',
      dq: 'hNRfwOSplNfhLvxLUN7a2qA3yYm-1MSz_1DWQP7srlLORlUcYPht2FZmsnEeDcAq' +
          'ynBGPQUcbG2Av_hgHz2OZw',
      qi: 'zbpJQAhinrxSbVKxBQ2EZGFUD2e3WCXbAJRYpk8HVQ5AA52OhKTicOye2hEHnrgp' +
          'FKzC8iznTsCG3FMkvwcj4Q'
    }
  },

  2048: {
    spki: Buffer.from(
      '30820122300d06092a864886f70d01010105000382010f003082010a0282010100d9' +
      '8580eb2d1772f4a476bc5404bee60d9a3c2acbbcf24a74754d9f5a6812388f9e3f26' +
      '0ad81687ddb366f8da559462b397f1c097896d0df6e6de31c04f8d47cd15600d11be' +
      '4ec4e6309e200416257fabba8bbed33ab0c165da3c9b1fcec2c4e9e52aca6359a7cf' +
      '54d5275b4486bf01a2b45f04fae20b717d01a794570728815297b2b7f22be00ef302' +
      '3813ca87b7e0be8343335cfaf0769e366cf9256cf44239458bb47ebd6b32f0168980' +
      '67009273f79d45b85b9f33f57318dfc5af981aa2964834e7f5b33012d369646a6738' +
      'b22bca55e59066f1e69f6a69f1eedecce881b7423fd44dfc7a7c989c426741d8813c' +
      '3fcdc024b53d84290a3beda3c83872cafd0203010001', 'hex'),
    pkcs8: Buffer.from(
      '308204be020100300d06092a864886f70d0101010500048204a8308204a402010002' +
      '82010100d98580eb2d1772f4a476bc5404bee60d9a3c2acbbcf24a74754d9f5a6812' +
      '388f9e3f260ad81687ddb366f8da559462b397f1c097896d0df6e6de31c04f8d47cd' +
      '15600d11be4ec4e6309e200416257fabba8bbed33ab0c165da3c9b1fcec2c4e9e52a' +
      'ca6359a7cf54d5275b4486bf01a2b45f04fae20b717d01a794570728815297b2b7f2' +
      '2be00ef3023813ca87b7e0be8343335cfaf0769e366cf9256cf44239458bb47ebd6b' +
      '32f016898067009273f79d45b85b9f33f57318dfc5af981aa2964834e7f5b33012d3' +
      '69646a6738b22bca55e59066f1e69f6a69f1eedecce881b7423fd44dfc7a7c989c42' +
      '6741d8813c3fcdc024b53d84290a3beda3c83872cafd0203010001028201005ad2a7' +
      '758aaa53d15a2a49903b3b0a0b7beecb5fae50ec4d9bfd01205a7be129f6451fb93f' +
      '6888ea44d225ede3f5c5107fcced41589c344c7731274cc8ea90a44cdc82187a81a1' +
      '2d0bf7ba1e7ab0c5920a9df6db739201ee69250d1046e0841fb5141cd546c60e87b9' +
      '48698f3f43d986fa11029f4e6ac0c41540c76b5f0dc690d445ffe2bf792e1e67996f' +
      'aba68958e5568e42ee881848f81b2b7465d76327f6d46ff184a907fc1368ace90828' +
      'e3ac2a2f248622d661e4b3d7c104de81a5013bd8ab32116444c7e272af31065f817a' +
      'bdc6981171467968334b12d21bed5d57683140707ac6223dd107067916bf5f97f87c' +
      '07578f2d7b168099c582c4f4a4e1f102818100fcdf6d12d3df7c92438ad38e9c9966' +
      'c0c0ec81150e9e1ce40cb845efa5c3d109ecf0583b8f68c7c57c53a8c9a6f99e9c43' +
      '9e0f749be053ac70bb01e17ffeafafd6d6246fda556d21e49dc03dc3cf19889af486' +
      '451267e1ac8310a846031e0562a22f58bf63f17f5d24044861e307463c8d19964daa' +
      'c956811d603c29e7bec86b02818100dc36288ccc4f0795f128e5ed0d0376ac4c3d89' +
      '08fd48df77bd1357c7033dc52d6f123ae079be902e8fe107810a9a188c60f6d4e0e8' +
      '90436206bca711e0d7a0b6f984aef9154e8a3bbab8ef0a47922ebdcea5393226f1e6' +
      '39a94d4ce5352db85716c25e3044f6abff49c519400d843878f164c5f3ab54f62056' +
      '3737d8794034370281806dddbd0c2315c48fdfdc9f5224e3d96b01e73fa62075bde3' +
      'af4b18c7a863cd9cdc5f0856c8562405bfa0b182fb9314c09bf83e8ad176c3a3f64e' +
      'a9e089b5e42b27d25e7e62841f284ca5e5727072b88b4b97d606889aadc84021aa9a' +
      'd09be88714243210e5a1754ec8693bf19babfb6e2f77e07fda2623f97103f0dfdc1a' +
      '5e05028181009571bbbb31bc406da5a817c1f41ef19ea46eee5cc76779208d945ef1' +
      '94658b36f635ecf702282d392c338f2027cdc3f320aae2756fded79be2ee8c83398f' +
      '9c661097d716fb3abddd232ef62a87bfd130c6d8a2244301cf383a8957320610ed15' +
      '4d40c32306ea507783dcdaf1f93a4e08e5e979dd8fdcacdbed26b42398c5d5a90281' +
      '81009d221bcb65a15be795dfffbab2afa85dc2a3ab65ba5f6e26fa172612d5572129' +
      'bb120015ca4446ec3fdb9ec980a661d2aad23850511898f07c148716095cd1bd60d6' +
      '31464ac89b524660bd465952d2e57d8740b7c3f3db79492b16b87a5cd1767e13526e' +
      'f66d79c691e2c7f2528b69652c29ba210a5e679d23b21a680cbf0d07', 'hex'),
    jwk: {
      kty: 'RSA',
      n: '2YWA6y0XcvSkdrxUBL7mDZo8Ksu88kp0dU2fWmgSOI-ePyYK2BaH3bNm-NpVlGKzl' +
         '_HAl4ltDfbm3jHAT41HzRVgDRG-TsTmMJ4gBBYlf6u6i77TOrDBZdo8mx_OwsTp5S' +
         'rKY1mnz1TVJ1tEhr8BorRfBPriC3F9AaeUVwcogVKXsrfyK-AO8wI4E8qHt-C-g0M' +
         'zXPrwdp42bPklbPRCOUWLtH69azLwFomAZwCSc_edRbhbnzP1cxjfxa-YGqKWSDTn' +
         '9bMwEtNpZGpnOLIrylXlkGbx5p9qafHu3szogbdCP9RN_Hp8mJxCZ0HYgTw_zcAkt' +
         'T2EKQo77aPIOHLK_Q',
      e: 'AQAB',
      d: 'WtKndYqqU9FaKkmQOzsKC3vuy1-uUOxNm_0BIFp74Sn2RR-5P2iI6kTSJe3j9cUQf' +
         '8ztQVicNEx3MSdMyOqQpEzcghh6gaEtC_e6HnqwxZIKnfbbc5IB7mklDRBG4IQftR' +
         'Qc1UbGDoe5SGmPP0PZhvoRAp9OasDEFUDHa18NxpDURf_iv3kuHmeZb6umiVjlVo5' +
         'C7ogYSPgbK3Rl12Mn9tRv8YSpB_wTaKzpCCjjrCovJIYi1mHks9fBBN6BpQE72Ksy' +
         'EWREx-JyrzEGX4F6vcaYEXFGeWgzSxLSG-1dV2gxQHB6xiI90QcGeRa_X5f4fAdXj' +
         'y17FoCZxYLE9KTh8Q',
      p: '_N9tEtPffJJDitOOnJlmwMDsgRUOnhzkDLhF76XD0Qns8Fg7j2jHxXxTqMmm-Z6cQ' +
         '54PdJvgU6xwuwHhf_6vr9bWJG_aVW0h5J3APcPPGYia9IZFEmfhrIMQqEYDHgVioi' +
         '9Yv2Pxf10kBEhh4wdGPI0Zlk2qyVaBHWA8Kee-yGs',
      q: '3DYojMxPB5XxKOXtDQN2rEw9iQj9SN93vRNXxwM9xS1vEjrgeb6QLo_hB4EKmhiMY' +
         'PbU4OiQQ2IGvKcR4NegtvmErvkVToo7urjvCkeSLr3OpTkyJvHmOalNTOU1LbhXFs' +
         'JeMET2q_9JxRlADYQ4ePFkxfOrVPYgVjc32HlANDc',
      dp: 'bd29DCMVxI_f3J9SJOPZawHnP6Ygdb3jr0sYx6hjzZzcXwhWyFYkBb-gsYL7kxTA' +
          'm_g-itF2w6P2TqngibXkKyfSXn5ihB8oTKXlcnByuItLl9YGiJqtyEAhqprQm-iH' +
          'FCQyEOWhdU7IaTvxm6v7bi934H_aJiP5cQPw39waXgU',
      dq: 'lXG7uzG8QG2lqBfB9B7xnqRu7lzHZ3kgjZRe8ZRlizb2Nez3AigtOSwzjyAnzcPz' +
          'IKridW_e15vi7oyDOY-cZhCX1xb7Or3dIy72Koe_0TDG2KIkQwHPODqJVzIGEO0V' +
          'TUDDIwbqUHeD3Nrx-TpOCOXped2P3Kzb7Sa0I5jF1ak',
      qi: 'nSIby2WhW-eV3_-6sq-oXcKjq2W6X24m-hcmEtVXISm7EgAVykRG7D_bnsmApmHS' +
          'qtI4UFEYmPB8FIcWCVzRvWDWMUZKyJtSRmC9RllS0uV9h0C3w_PbeUkrFrh6XNF2' +
          'fhNSbvZtecaR4sfyUotpZSwpuiEKXmedI7IaaAy_DQc'
    }
  },

  4096: {
    spki: Buffer.from(
      '30820222300d06092a864886f70d01010105000382020f003082020a0282020100da' +
      'aaf64cbd9cd8999bb0dd0e2c846768007f64a6f5f8687d1f4a9be25ac1b836aa916f' +
      'de14fc13f8922cbe7349bc34fb04b279eed4cc223e7a64cb6fe9e7d249359293d30e' +
      'a16d89d4afe212b7ad67671e801fda457eea4158e7a05b33f54d3604a7c02144f4a3' +
      'f2bb6fd1b4f1dd6bac0528862fd255087039ba1d83b05d74c6ca526cfbd103484b8f' +
      '3b2cde385945679fd3a013d6ad4d850044dba44f40ee41bdc9f8adb492c4ee56e8d7' +
      '6d27a5a210e62e86ea946a22e6c63fe78f10b3d06d1664369c6b841cd076cdd959e4' +
      '4bc4a9b505559d906e81ba8d7768a2ceaa73076052f0218f51f3d7436089cfd116a2' +
      'fb6cd0e820eccda7aea1740df9bb16f0b9aca0675ea2931a0f8fb79362e77586b932' +
      '40281e1b0d9884288a204e9ea2cfd4e5d2fb587443e5a4a4933b205ed9c5f295664a' +
      'db2e7f441c740a02f9e7827b1d2d493811c3d02d193cfc62bd6d1900fd97fe7cd330' +
      '179c4ea39abc11450ebc10403bbe8846a2fded9c6f291b283fcdcc5e0032ed3e57d3' +
      '735b44c26877486ae2a030a58a86028a99b526f93078480ff5e30fa440bc4a0454d5' +
      '53434957b5485e2e36c1fcbc0ecf1c529f83a8eea8911ce61b7e975d0560447e42ae' +
      '9b657b14da835c7c4e522c378b4d69b18879b12b4d0cf0004c14857981490fa0c896' +
      '725f3b3ba5f0cc0d9c86c204469ed56fe567d8ef8410b897cefee53e173a7d3190d0' +
      'd70203010001', 'hex'),
    pkcs8: Buffer.from(
      '30820944020100300d06092a864886f70d01010105000482092e3082092a02010002' +
      '82020100daaaf64cbd9cd8999bb0dd0e2c846768007f64a6f5f8687d1f4a9be25ac1' +
      'b836aa916fde14fc13f8922cbe7349bc34fb04b279eed4cc223e7a64cb6fe9e7d249' +
      '359293d30ea16d89d4afe212b7ad67671e801fda457eea4158e7a05b33f54d3604a7' +
      'c02144f4a3f2bb6fd1b4f1dd6bac0528862fd255087039ba1d83b05d74c6ca526cfb' +
      'd103484b8f3b2cde385945679fd3a013d6ad4d850044dba44f40ee41bdc9f8adb492' +
      'c4ee56e8d76d27a5a210e62e86ea946a22e6c63fe78f10b3d06d1664369c6b841cd0' +
      '76cdd959e44bc4a9b505559d906e81ba8d7768a2ceaa73076052f0218f51f3d74360' +
      '89cfd116a2fb6cd0e820eccda7aea1740df9bb16f0b9aca0675ea2931a0f8fb79362' +
      'e77586b93240281e1b0d9884288a204e9ea2cfd4e5d2fb587443e5a4a4933b205ed9' +
      'c5f295664adb2e7f441c740a02f9e7827b1d2d493811c3d02d193cfc62bd6d1900fd' +
      '97fe7cd330179c4ea39abc11450ebc10403bbe8846a2fded9c6f291b283fcdcc5e00' +
      '32ed3e57d3735b44c26877486ae2a030a58a86028a99b526f93078480ff5e30fa440' +
      'bc4a0454d553434957b5485e2e36c1fcbc0ecf1c529f83a8eea8911ce61b7e975d05' +
      '60447e42ae9b657b14da835c7c4e522c378b4d69b18879b12b4d0cf0004c14857981' +
      '490fa0c896725f3b3ba5f0cc0d9c86c204469ed56fe567d8ef8410b897cefee53e17' +
      '3a7d3190d0d702030100010282020100b973d15c185c139f8359a6c144a42e871814' +
      'f32a5ee604c849679f7983fb53de991eabbfb010726798a1760c94f69800646571e0' +
      '4a7dae754a9c7da536bdb3acff50872ab2f7d9ccd1a3319b2a4858b02e3fffc3c0b8' +
      'f8b7df4ce2c536f5ce3c080ab57a01df71c4858f3a4db9eb4e4c203bd4426ea24b7b' +
      'd299b43a61b3813caf8ee47b5532f17793cc5e2b41a304a7f3f7298669c5a53f2d91' +
      '38aecbc087d11dc353b30eb883689830f5b3cfb23c17150154cf527c0989ab8dbb37' +
      'acb4b40a30b9614f9c27f9c01b624dfa5d129d8248d2736024847465e160ea4f59f3' +
      '598761fc35486122e229292d90f3bda2f32b45888fb68cdf865d26f5247d2e5d305e' +
      'd7279c39565dcfcc486a70d7cbe6501489e0f22192216cbcb9fe75bdf052403cbaf7' +
      'be8aaa9f934b319465ae8215b1d379069990e6a6b59b5ee8020477ec2385fddf0e1e' +
      'c739d71ffb5aa713e79a36e1554411ea9e3532f3b695c1d63cbc062602c8a1e8c11e' +
      '99e7dd398c374523159922eeaf41fdd2777d7874997f43cc0942d2c8a5d4d8023e13' +
      '0fab4db7f77fe08a29d0aae3249eb06f80ac4649f194ac32ae7e50b1eb5d5966544c' +
      'dd1ed8317d8e232d60e03ca13f30558f144cb66f0f9c8b379b71e2f8ef82fcf1c5f7' +
      '7c3d27c5aa774c88c3b4a96af0ea6572cf0ba0aa8bc2bb3016725440971ed463d5b0' +
      '6a4fe87fc599850838d253436a7ce76002910282010100f4dad7c2ae2463d90104ec' +
      '0ba0565541ce24248fcd6ca6bf5bd14b75075121b32c6591d72775c3511f6f24071a' +
      '691ef95b0202ed7e8de799d5b564eadbc072b3d7e527d46b0937dc88e9ed1c4a6106' +
      '161a2f9653525fba921626b0e7ffa6c7dfd9568e382bc719f7f97a3b8e981431930d' +
      '84f9cbfb9274605851e82d6a64bb634920cb861edf64b3b38051f21955897d6099f0' +
      'e05614ce181ac5e9a49e32de67c5d39065b6cdc93317e77de5823d8bccc3f34526b9' +
      'bb30f98c6b8927ea150d2b18706c6d0f1939377f2898eee360569d72233436268c55' +
      '2a7735632385d0f041ab0847fff3f8b0a611b25c3ecb389e1fa9df7b0776d8a68453' +
      '3e70a063f4841d0282010100e49ef9f3f35e2abd573d988bc57a216104278742dbe1' +
      '0b46675c730a08e10502dc201793386fed6230ae7acf6d98bb7ddcba497f2a5227e4' +
      'a30cbc24476b34ebdfc8072606a71c9e1ad57eba5a98852c359c3d825ca3031b23b9' +
      '8d70ecf6d26b4bf5217e86d72901f4dc245d16e8323e448d99763e01a7c5ca71bbc4' +
      'bafba18042d391678545cf9b75414cfb7d2be069ab061dfe1f6f90059ea6b48fa3cd' +
      'd497070b32ea52258f4b687c6145dcf6ca2d1928dc175c747072ccc68c306fbf351c' +
      '0986ea5aa8f36c4bc563a2ad1fc261e0b84ce3aac76a810e4deae726c0c5e9ae96f0' +
      '37fcf11b61a931317309da41fd0efdd95b8d2c4420f7dbc71f2dd4442e8302820101' +
      '00e18ec7bb9b580272e1317b90aa3f5d82a5373e470a61d0a9ef173a7fb021d8fd89' +
      '2477d8cf8cf8443ec4cf578bc8d2b3ba567c03f3d51d48e549989191a61304011a24' +
      '3ad5ef43fa7055ae0ba5a9034651110d55ec482b42700d6c620b6bc42c3db6328524' +
      '2ee18941d48c10ab9fce9b3c9506d81603b01920c33332c313d05b81fe27fe816a21' +
      '06399137ebe1d29e395547fa516e7af3efd89a00c598c61b835505b3bb3f4f0acd7a' +
      '73d1d21ecc3b8081f213fdbc92e866ba2845ccf32239633dbc32e5b446f4225f8d32' +
      '74be18fd3144f7911d611d5d47255194e6205b7d37c12a7bc919223af880cce19526' +
      'f81d11e616eceacf5c7ce8e116600220921b310282010100813e223db7f21f2544c1' +
      '6c906f85f882b8ef83b6d748a4b01b549730300ecd5f6d83b2f0263298372f20240b' +
      '4980d35576c7d52ecf84fc4a73a68a61d402163bd619657928bfa61cf73c8454e34c' +
      '5fd4bb45e53be214c177c13d6f694c7cc83da20624f63b523d3b7eea48a05b87ce87' +
      '8707a99ebfb4fddc81f2c3dc967c1433c713859ac92bcb0eae3dc9404ee5d40ac885' +
      '3fc55e8e1a14233948cfff2128326ce7f6d3a2b6db081d3c5b5d3c6a43a73516f53d' +
      '3ba613bfc265e7f0a5eba9217d7d48d511b7f31beeadc1d42f251b6207ae67f22ea3' +
      'd5eb793ef787dfe8c28f5182e193dbd5c7e2f70d6664467f9188bd16f87b996fb657' +
      '88664c09037bbbf30282010024799529bd73c16e62451e9109e7b16278767e663edc' +
      '3acf49d33c0f186bd05f1d6b28beb6546a11d9c6d21be9e399fc80b52c91659c07d1' +
      '1795424e6d918a0df1aec6031ade0ff178b036be6150d763313ecc87e2208d66fb20' +
      '986c71ed3b8e1eb9c3879101567338fdd7baddcac424e376b1823c3b38bec69d8e12' +
      '602bdac7962aae2cc641678ba7b12e1a9bf8d1389bd1cc2a59e0d44b50876acb0451' +
      'b55580f749862930b7397f1cea1af4b19f715af97820f8864f637b9badc9b9d8a620' +
      '98b5069a7612b5f56a1925927610d71e5360239a5d000d05ce9c81937657f89b3187' +
      '07279de2ab6010707aad3a9113065a0bdd6dd010fbbc12786aaa8f954fc0', 'hex'),
    jwk: {
      kty: 'RSA',
      n: '2qr2TL2c2JmbsN0OLIRnaAB_ZKb1-Gh9H0qb4lrBuDaqkW_eFPwT-JIsvnNJvDT7B' +
         'LJ57tTMIj56ZMtv6efSSTWSk9MOoW2J1K_iEretZ2cegB_aRX7qQVjnoFsz9U02BK' +
         'fAIUT0o_K7b9G08d1rrAUohi_SVQhwObodg7BddMbKUmz70QNIS487LN44WUVnn9O' +
         'gE9atTYUARNukT0DuQb3J-K20ksTuVujXbSelohDmLobqlGoi5sY_548Qs9BtFmQ2' +
         'nGuEHNB2zdlZ5EvEqbUFVZ2QboG6jXdoos6qcwdgUvAhj1Hz10Ngic_RFqL7bNDoI' +
         'OzNp66hdA35uxbwuaygZ16ikxoPj7eTYud1hrkyQCgeGw2YhCiKIE6eos_U5dL7WH' +
         'RD5aSkkzsgXtnF8pVmStsuf0QcdAoC-eeCex0tSTgRw9AtGTz8Yr1tGQD9l_580zA' +
         'XnE6jmrwRRQ68EEA7vohGov3tnG8pGyg_zcxeADLtPlfTc1tEwmh3SGrioDClioYC' +
         'ipm1JvkweEgP9eMPpEC8SgRU1VNDSVe1SF4uNsH8vA7PHFKfg6juqJEc5ht-l10FY' +
         'ER-Qq6bZXsU2oNcfE5SLDeLTWmxiHmxK00M8ABMFIV5gUkPoMiWcl87O6XwzA2chs' +
         'IERp7Vb-Vn2O-EELiXzv7lPhc6fTGQ0Nc',
      e: 'AQAB',
      d: 'uXPRXBhcE5-DWabBRKQuhxgU8ype5gTISWefeYP7U96ZHqu_sBByZ5ihdgyU9pgAZ' +
         'GVx4Ep9rnVKnH2lNr2zrP9Qhyqy99nM0aMxmypIWLAuP__DwLj4t99M4sU29c48CA' +
         'q1egHfccSFjzpNuetOTCA71EJuokt70pm0OmGzgTyvjuR7VTLxd5PMXitBowSn8_c' +
         'phmnFpT8tkTiuy8CH0R3DU7MOuINomDD1s8-yPBcVAVTPUnwJiauNuzestLQKMLlh' +
         'T5wn-cAbYk36XRKdgkjSc2AkhHRl4WDqT1nzWYdh_DVIYSLiKSktkPO9ovMrRYiPt' +
         'ozfhl0m9SR9Ll0wXtcnnDlWXc_MSGpw18vmUBSJ4PIhkiFsvLn-db3wUkA8uve-iq' +
         'qfk0sxlGWughWx03kGmZDmprWbXugCBHfsI4X93w4exznXH_tapxPnmjbhVUQR6p4' +
         '1MvO2lcHWPLwGJgLIoejBHpnn3TmMN0UjFZki7q9B_dJ3fXh0mX9DzAlC0sil1NgC' +
         'PhMPq02393_giinQquMknrBvgKxGSfGUrDKuflCx611ZZlRM3R7YMX2OIy1g4DyhP' +
         'zBVjxRMtm8PnIs3m3Hi-O-C_PHF93w9J8Wqd0yIw7SpavDqZXLPC6Cqi8K7MBZyVE' +
         'CXHtRj1bBqT-h_xZmFCDjSU0NqfOdgApE',
      p: '9NrXwq4kY9kBBOwLoFZVQc4kJI_NbKa_W9FLdQdRIbMsZZHXJ3XDUR9vJAcaaR75W' +
         'wIC7X6N55nVtWTq28Bys9flJ9RrCTfciOntHEphBhYaL5ZTUl-6khYmsOf_psff2V' +
         'aOOCvHGff5ejuOmBQxkw2E-cv7knRgWFHoLWpku2NJIMuGHt9ks7OAUfIZVYl9YJn' +
         'w4FYUzhgaxemknjLeZ8XTkGW2zckzF-d95YI9i8zD80Umubsw-YxriSfqFQ0rGHBs' +
         'bQ8ZOTd_KJju42BWnXIjNDYmjFUqdzVjI4XQ8EGrCEf_8_iwphGyXD7LOJ4fqd97B' +
         '3bYpoRTPnCgY_SEHQ',
      q: '5J758_NeKr1XPZiLxXohYQQnh0Lb4QtGZ1xzCgjhBQLcIBeTOG_tYjCues9tmLt93' +
         'LpJfypSJ-SjDLwkR2s069_IByYGpxyeGtV-ulqYhSw1nD2CXKMDGyO5jXDs9tJrS_' +
         'UhfobXKQH03CRdFugyPkSNmXY-AafFynG7xLr7oYBC05FnhUXPm3VBTPt9K-BpqwY' +
         'd_h9vkAWeprSPo83UlwcLMupSJY9LaHxhRdz2yi0ZKNwXXHRwcszGjDBvvzUcCYbq' +
         'WqjzbEvFY6KtH8Jh4LhM46rHaoEOTernJsDF6a6W8Df88RthqTExcwnaQf0O_dlbj' +
         'SxEIPfbxx8t1EQugw',
      dp: '4Y7Hu5tYAnLhMXuQqj9dgqU3PkcKYdCp7xc6f7Ah2P2JJHfYz4z4RD7Ez1eLyNKz' +
          'ulZ8A_PVHUjlSZiRkaYTBAEaJDrV70P6cFWuC6WpA0ZREQ1V7EgrQnANbGILa8Qs' +
          'PbYyhSQu4YlB1IwQq5_OmzyVBtgWA7AZIMMzMsMT0FuB_if-gWohBjmRN-vh0p45' +
          'VUf6UW568-_YmgDFmMYbg1UFs7s_TwrNenPR0h7MO4CB8hP9vJLoZrooRczzIjlj' +
          'Pbwy5bRG9CJfjTJ0vhj9MUT3kR1hHV1HJVGU5iBbfTfBKnvJGSI6-IDM4ZUm-B0R' +
          '5hbs6s9cfOjhFmACIJIbMQ',
      dq: 'gT4iPbfyHyVEwWyQb4X4grjvg7bXSKSwG1SXMDAOzV9tg7LwJjKYNy8gJAtJgNNV' +
          'dsfVLs-E_Epzpoph1AIWO9YZZXkov6Yc9zyEVONMX9S7ReU74hTBd8E9b2lMfMg9' +
          'ogYk9jtSPTt-6kigW4fOh4cHqZ6_tP3cgfLD3JZ8FDPHE4WaySvLDq49yUBO5dQK' +
          'yIU_xV6OGhQjOUjP_yEoMmzn9tOittsIHTxbXTxqQ6c1FvU9O6YTv8Jl5_Cl66kh' +
          'fX1I1RG38xvurcHULyUbYgeuZ_Iuo9XreT73h9_owo9RguGT29XH4vcNZmRGf5GI' +
          'vRb4e5lvtleIZkwJA3u78w',
      qi: 'JHmVKb1zwW5iRR6RCeexYnh2fmY-3DrPSdM8Dxhr0F8dayi-tlRqEdnG0hvp45n8' +
          'gLUskWWcB9EXlUJObZGKDfGuxgMa3g_xeLA2vmFQ12MxPsyH4iCNZvsgmGxx7TuO' +
          'HrnDh5EBVnM4_de63crEJON2sYI8Ozi-xp2OEmAr2seWKq4sxkFni6exLhqb-NE4' +
          'm9HMKlng1EtQh2rLBFG1VYD3SYYpMLc5fxzqGvSxn3Fa-Xgg-IZPY3ubrcm52KYg' +
          'mLUGmnYStfVqGSWSdhDXHlNgI5pdAA0FzpyBk3ZX-JsxhwcnneKrYBBweq06kRMG' +
          'WgvdbdAQ-7wSeGqqj5VPwA'
    }
  },
};

async function testImportSpki({ name, publicUsages }, size, hash, extractable) {
  const key = await subtle.importKey(
    'spki',
    keyData[size].spki,
    { name, hash },
    extractable,
    publicUsages);

  assert.strictEqual(key.type, 'public');
  assert.strictEqual(key.extractable, extractable);
  assert.deepStrictEqual(key.usages, publicUsages);
  assert.strictEqual(key.algorithm.name, name);
  assert.strictEqual(key.algorithm.modulusLength, size);
  assert.deepStrictEqual(key.algorithm.publicExponent,
                         new Uint8Array([1, 0, 1]));
  assert.strictEqual(key.algorithm.hash.name, hash);
  assert.strictEqual(key.algorithm, key.algorithm);
  assert.strictEqual(key.usages, key.usages);

  if (extractable) {
    const spki = await subtle.exportKey('spki', key);
    assert.strictEqual(
      Buffer.from(spki).toString('hex'),
      keyData[size].spki.toString('hex'));
  } else {
    await assert.rejects(
      subtle.exportKey('spki', key), {
        message: /key is not extractable/
      });
  }
}

async function testImportPkcs8(
  { name, privateUsages },
  size,
  hash,
  extractable) {
  const key = await subtle.importKey(
    'pkcs8',
    keyData[size].pkcs8,
    { name, hash },
    extractable,
    privateUsages);

  assert.strictEqual(key.type, 'private');
  assert.strictEqual(key.extractable, extractable);
  assert.deepStrictEqual(key.usages, privateUsages);
  assert.strictEqual(key.algorithm.name, name);
  assert.strictEqual(key.algorithm.modulusLength, size);
  assert.deepStrictEqual(key.algorithm.publicExponent,
                         new Uint8Array([1, 0, 1]));
  assert.strictEqual(key.algorithm.hash.name, hash);
  assert.strictEqual(key.algorithm, key.algorithm);
  assert.strictEqual(key.usages, key.usages);

  if (extractable) {
    const pkcs8 = await subtle.exportKey('pkcs8', key);
    assert.strictEqual(
      Buffer.from(pkcs8).toString('hex'),
      keyData[size].pkcs8.toString('hex'));
  } else {
    await assert.rejects(
      subtle.exportKey('pkcs8', key), {
        message: /key is not extractable/
      });
  }

  await assert.rejects(
    subtle.importKey(
      'pkcs8',
      keyData[size].pkcs8,
      { name, hash },
      extractable,
      [/* empty usages */]),
    { name: 'SyntaxError', message: 'Usages cannot be empty when importing a private key.' });
}

async function testImportJwk(
  { name, publicUsages, privateUsages },
  size,
  hash,
  extractable) {

  const jwk = keyData[size].jwk;

  const [
    publicKey,
    privateKey,
  ] = await Promise.all([
    subtle.importKey(
      'jwk',
      {
        kty: jwk.kty,
        n: jwk.n,
        e: jwk.e,
        alg: `PS${hash.substring(4)}`
      },
      { name, hash },
      extractable,
      publicUsages),
    subtle.importKey(
      'jwk',
      { ...jwk, alg: `PS${hash.substring(4)}` },
      { name, hash },
      extractable,
      privateUsages),
  ]);

  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(publicKey.extractable, extractable);
  assert.strictEqual(privateKey.extractable, extractable);
  assert.strictEqual(publicKey.algorithm.name, name);
  assert.strictEqual(privateKey.algorithm.name, name);
  assert.strictEqual(publicKey.algorithm.modulusLength, size);
  assert.strictEqual(privateKey.algorithm.modulusLength, size);
  assert.deepStrictEqual(publicKey.algorithm.publicExponent,
                         new Uint8Array([1, 0, 1]));
  assert.deepStrictEqual(publicKey.algorithm.publicExponent,
                         privateKey.algorithm.publicExponent);
  assert.strictEqual(privateKey.algorithm, privateKey.algorithm);
  assert.strictEqual(privateKey.usages, privateKey.usages);
  assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
  assert.strictEqual(publicKey.usages, publicKey.usages);

  if (extractable) {
    const [
      pubJwk,
      pvtJwk,
    ] = await Promise.all([
      subtle.exportKey('jwk', publicKey),
      subtle.exportKey('jwk', privateKey),
    ]);

    assert.strictEqual(pubJwk.kty, 'RSA');
    assert.strictEqual(pvtJwk.kty, 'RSA');
    assert.strictEqual(pubJwk.n, jwk.n);
    assert.strictEqual(pvtJwk.n, jwk.n);
    assert.strictEqual(pubJwk.e, jwk.e);
    assert.strictEqual(pvtJwk.e, jwk.e);
    assert.strictEqual(pvtJwk.d, jwk.d);
    assert.strictEqual(pvtJwk.p, jwk.p);
    assert.strictEqual(pvtJwk.q, jwk.q);
    assert.strictEqual(pvtJwk.dp, jwk.dp);
    assert.strictEqual(pvtJwk.dq, jwk.dq);
    assert.strictEqual(pvtJwk.qi, jwk.qi);
    assert.strictEqual(pubJwk.d, undefined);
    assert.strictEqual(pubJwk.p, undefined);
    assert.strictEqual(pubJwk.q, undefined);
    assert.strictEqual(pubJwk.dp, undefined);
    assert.strictEqual(pubJwk.dq, undefined);
    assert.strictEqual(pubJwk.qi, undefined);
  } else {
    await assert.rejects(
      subtle.exportKey('jwk', publicKey), {
        message: /key is not extractable/
      });
    await assert.rejects(
      subtle.exportKey('jwk', privateKey), {
        message: /key is not extractable/
      });
  }

  {
    const invalidUse = name === 'RSA-OAEP' ? 'sig' : 'enc';
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { kty: jwk.kty, n: jwk.n, e: jwk.e, use: invalidUse },
        { name, hash },
        extractable,
        publicUsages),
      { message: 'Invalid JWK "use" Parameter' });
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, use: invalidUse },
        { name, hash },
        extractable,
        privateUsages),
      { message: 'Invalid JWK "use" Parameter' });
  }

  {
    let invalidAlg = name === 'RSA-OAEP' ? name : name === 'RSA-PSS' ? 'PS' : 'RS';
    switch (name) {
      case 'RSA-OAEP':
        if (hash === 'SHA-1')
          invalidAlg += '-256';
        break;
      default:
        if (hash === 'SHA-256')
          invalidAlg += '384';
        else
          invalidAlg += '256';
    }
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { kty: jwk.kty, n: jwk.n, e: jwk.e, alg: invalidAlg },
        { name, hash },
        extractable,
        publicUsages),
      { message: 'JWK "alg" does not match the requested algorithm' });
    await assert.rejects(
      subtle.importKey(
        'jwk',
        { ...jwk, alg: invalidAlg },
        { name, hash },
        extractable,
        privateUsages),
      { message: 'JWK "alg" does not match the requested algorithm' });
  }

  await assert.rejects(
    subtle.importKey(
      'jwk',
      { ...jwk },
      { name, hash },
      extractable,
      [/* empty usages */]),
    { name: 'SyntaxError', message: 'Usages cannot be empty when importing a private key.' });

  await assert.rejects(
    subtle.importKey(
      'jwk',
      { kty: jwk.kty, /* missing e */ n: jwk.n },
      { name, hash },
      extractable,
      publicUsages),
    { name: 'DataError', message: 'Invalid keyData' });
}

// combinations to test
const testVectors = [
  {
    name: 'RSA-OAEP',
    privateUsages: ['decrypt', 'unwrapKey'],
    publicUsages: ['encrypt', 'wrapKey']
  },
  {
    name: 'RSA-PSS',
    privateUsages: ['sign'],
    publicUsages: ['verify']
  },
  {
    name: 'RSASSA-PKCS1-v1_5',
    privateUsages: ['sign'],
    publicUsages: ['verify']
  },
];

(async function() {
  const variations = [];
  sizes.forEach((size) => {
    hashes.forEach((hash) => {
      [true, false].forEach((extractable) => {
        testVectors.forEach((vector) => {
          variations.push(testImportSpki(vector, size, hash, extractable));
          variations.push(testImportPkcs8(vector, size, hash, extractable));
          variations.push(testImportJwk(vector, size, hash, extractable));
        });
      });
    });
  });
  await Promise.all(variations);
})().then(common.mustCall());

{
  const ecPublic = crypto.createPublicKey(
    fixtures.readKey('ec_p256_public.pem'));
  const ecPrivate = crypto.createPrivateKey(
    fixtures.readKey('ec_p256_private.pem'));

  for (const [name, [publicUsage, privateUsage]] of Object.entries({
    'RSA-PSS': ['verify', 'sign'],
    'RSASSA-PKCS1-v1_5': ['verify', 'sign'],
    'RSA-OAEP': ['encrypt', 'decrypt'],
  })) {
    assert.rejects(subtle.importKey(
      'spki',
      ecPublic.export({ format: 'der', type: 'spki' }),
      { name, hash: 'SHA-256' },
      true, [publicUsage]), { message: /Invalid key type/ }).then(common.mustCall());
    assert.rejects(subtle.importKey(
      'pkcs8',
      ecPrivate.export({ format: 'der', type: 'pkcs8' }),
      { name, hash: 'SHA-256' },
      true, [privateUsage]), { message: /Invalid key type/ }).then(common.mustCall());
  }
}
                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-webcrypto-export-import.js                                           0000664 0000000 0000000 00000016436 14746647661 0023522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

{
  async function test() {
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    await Promise.all([1, null, undefined, {}, []].map((format) =>
      assert.rejects(
        subtle.importKey(format, keyData, {}, false, ['wrapKey']), {
          code: 'ERR_INVALID_ARG_VALUE'
        })
    ));
    await assert.rejects(
      subtle.importKey('not valid', keyData, {}, false, ['wrapKey']), {
        code: 'ERR_INVALID_ARG_VALUE'
      });
    await assert.rejects(
      subtle.importKey('KeyObject', keyData, {}, false, ['wrapKey']), {
        message: /'KeyObject' is not a valid enum value of type KeyFormat/,
        code: 'ERR_INVALID_ARG_VALUE'
      });
    await assert.rejects(
      subtle.importKey('raw', 1, {}, false, ['deriveBits']), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    await assert.rejects(
      subtle.importKey('raw', keyData, {
        name: 'HMAC'
      }, false, ['sign', 'verify']), {
        code: 'ERR_MISSING_OPTION'
      });
    await assert.rejects(
      subtle.importKey('raw', keyData, {
        name: 'HMAC',
        hash: 'SHA-256'
      }, false, ['deriveBits']), {
        name: 'SyntaxError',
        message: 'Unsupported key usage for an HMAC key'
      });
    await assert.rejects(
      subtle.importKey('raw', keyData, {
        name: 'HMAC',
        hash: 'SHA-256',
        length: 0
      }, false, ['sign', 'verify']), {
        name: 'DataError',
        message: 'Zero-length key is not supported'
      });
    await assert.rejects(
      subtle.importKey('raw', keyData, {
        name: 'HMAC',
        hash: 'SHA-256',
        length: 1
      }, false, ['sign', 'verify']), {
        name: 'DataError',
        message: 'Invalid key length'
      });
    await assert.rejects(
      subtle.importKey('jwk', null, {
        name: 'HMAC',
        hash: 'SHA-256',
      }, false, ['sign', 'verify']), {
        name: 'DataError',
        message: 'Invalid keyData'
      });
  }

  test().then(common.mustCall());
}

// Import/Export HMAC Secret Key
{
  async function test() {
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    const key = await subtle.importKey(
      'raw',
      keyData, {
        name: 'HMAC',
        hash: 'SHA-256'
      }, true, ['sign', 'verify']);


    assert.strictEqual(key.algorithm, key.algorithm);
    assert.strictEqual(key.usages, key.usages);

    const raw = await subtle.exportKey('raw', key);

    assert.deepStrictEqual(
      Buffer.from(keyData).toString('hex'),
      Buffer.from(raw).toString('hex'));

    const jwk = await subtle.exportKey('jwk', key);
    assert.deepStrictEqual(jwk.key_ops, ['sign', 'verify']);
    assert(jwk.ext);
    assert.strictEqual(jwk.kty, 'oct');

    assert.deepStrictEqual(
      Buffer.from(jwk.k, 'base64').toString('hex'),
      Buffer.from(raw).toString('hex'));

    await assert.rejects(
      subtle.importKey(
        'raw',
        keyData,
        {
          name: 'HMAC',
          hash: 'SHA-256'
        },
        true,
        [/* empty usages */]),
      { name: 'SyntaxError', message: 'Usages cannot be empty when importing a secret key.' });
  }

  test().then(common.mustCall());
}

// Import/Export AES Secret Key
{
  async function test() {
    const keyData = globalThis.crypto.getRandomValues(new Uint8Array(32));
    const key = await subtle.importKey(
      'raw',
      keyData, {
        name: 'AES-CTR',
        length: 256,
      }, true, ['encrypt', 'decrypt']);
    assert.strictEqual(key.algorithm, key.algorithm);
    assert.strictEqual(key.usages, key.usages);

    const raw = await subtle.exportKey('raw', key);

    assert.deepStrictEqual(
      Buffer.from(keyData).toString('hex'),
      Buffer.from(raw).toString('hex'));

    const jwk = await subtle.exportKey('jwk', key);
    assert.deepStrictEqual(jwk.key_ops, ['encrypt', 'decrypt']);
    assert(jwk.ext);
    assert.strictEqual(jwk.kty, 'oct');

    assert.deepStrictEqual(
      Buffer.from(jwk.k, 'base64').toString('hex'),
      Buffer.from(raw).toString('hex'));

    await assert.rejects(
      subtle.importKey(
        'raw',
        keyData,
        {
          name: 'AES-CTR',
          length: 256,
        },
        true,
        [/* empty usages */]),
      { name: 'SyntaxError', message: 'Usages cannot be empty when importing a secret key.' });
  }

  test().then(common.mustCall());
}

// Import/Export RSA Key Pairs
{
  async function test() {
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'RSA-PSS',
      modulusLength: 1024,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-384'
    }, true, ['sign', 'verify']);

    const [
      spki,
      pkcs8,
      publicJwk,
      privateJwk,
    ] = await Promise.all([
      subtle.exportKey('spki', publicKey),
      subtle.exportKey('pkcs8', privateKey),
      subtle.exportKey('jwk', publicKey),
      subtle.exportKey('jwk', privateKey),
    ]);

    assert(spki);
    assert(pkcs8);
    assert(publicJwk);
    assert(privateJwk);

    const [
      importedSpkiPublicKey,
      importedPkcs8PrivateKey,
      importedJwkPublicKey,
      importedJwkPrivateKey,
    ] = await Promise.all([
      subtle.importKey('spki', spki, {
        name: 'RSA-PSS',
        hash: 'SHA-384',
      }, true, ['verify']),
      subtle.importKey('pkcs8', pkcs8, {
        name: 'RSA-PSS',
        hash: 'SHA-384',
      }, true, ['sign']),
      subtle.importKey('jwk', publicJwk, {
        name: 'RSA-PSS',
        hash: 'SHA-384',
      }, true, ['verify']),
      subtle.importKey('jwk', privateJwk, {
        name: 'RSA-PSS',
        hash: 'SHA-384',
      }, true, ['sign']),
    ]);

    assert(importedSpkiPublicKey);
    assert(importedPkcs8PrivateKey);
    assert(importedJwkPublicKey);
    assert(importedJwkPrivateKey);
  }

  test().then(common.mustCall());
}

// Import/Export EC Key Pairs
{
  async function test() {
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'ECDSA',
      namedCurve: 'P-384'
    }, true, ['sign', 'verify']);

    const [
      spki,
      pkcs8,
      publicJwk,
      privateJwk,
    ] = await Promise.all([
      subtle.exportKey('spki', publicKey),
      subtle.exportKey('pkcs8', privateKey),
      subtle.exportKey('jwk', publicKey),
      subtle.exportKey('jwk', privateKey),
    ]);

    assert(spki);
    assert(pkcs8);
    assert(publicJwk);
    assert(privateJwk);

    const [
      importedSpkiPublicKey,
      importedPkcs8PrivateKey,
      importedJwkPublicKey,
      importedJwkPrivateKey,
    ] = await Promise.all([
      subtle.importKey('spki', spki, {
        name: 'ECDSA',
        namedCurve: 'P-384'
      }, true, ['verify']),
      subtle.importKey('pkcs8', pkcs8, {
        name: 'ECDSA',
        namedCurve: 'P-384'
      }, true, ['sign']),
      subtle.importKey('jwk', publicJwk, {
        name: 'ECDSA',
        namedCurve: 'P-384'
      }, true, ['verify']),
      subtle.importKey('jwk', privateJwk, {
        name: 'ECDSA',
        namedCurve: 'P-384'
      }, true, ['sign']),
    ]);

    assert(importedSpkiPublicKey);
    assert(importedPkcs8PrivateKey);
    assert(importedJwkPublicKey);
    assert(importedJwkPrivateKey);
  }

  test().then(common.mustCall());
}
                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-webcrypto-getRandomValues.js                                         0000664 0000000 0000000 00000000426 14746647661 0023761 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { getRandomValues } = globalThis.crypto;

assert.throws(() => getRandomValues(new Uint8Array()), { code: 'ERR_INVALID_THIS' });
                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-webcrypto-keygen.js                                                  0000664 0000000 0000000 00000041601 14746647661 0022143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { types: { isCryptoKey } } = require('util');
const {
  createSecretKey,
  KeyObject,
} = require('crypto');
const { subtle } = globalThis.crypto;

const { bigIntArrayToUnsignedBigInt } = require('internal/crypto/util');

const allUsages = [
  'encrypt',
  'decrypt',
  'sign',
  'verify',
  'deriveBits',
  'deriveKey',
  'wrapKey',
  'unwrapKey',
];
const vectors = {
  'AES-CTR': {
    algorithm: { length: 256 },
    result: 'CryptoKey',
    usages: [
      'encrypt',
      'decrypt',
      'wrapKey',
      'unwrapKey',
    ],
  },
  'AES-CBC': {
    algorithm: { length: 256 },
    result: 'CryptoKey',
    usages: [
      'encrypt',
      'decrypt',
      'wrapKey',
      'unwrapKey',
    ],
  },
  'AES-GCM': {
    algorithm: { length: 256 },
    result: 'CryptoKey',
    usages: [
      'encrypt',
      'decrypt',
      'wrapKey',
      'unwrapKey',
    ],
  },
  'AES-KW': {
    algorithm: { length: 256 },
    result: 'CryptoKey',
    usages: [
      'wrapKey',
      'unwrapKey',
    ],
  },
  'HMAC': {
    algorithm: { length: 256, hash: 'SHA-256' },
    result: 'CryptoKey',
    usages: [
      'sign',
      'verify',
    ],
  },
  'RSASSA-PKCS1-v1_5': {
    algorithm: {
      modulusLength: 1024,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    },
    result: 'CryptoKeyPair',
    usages: [
      'sign',
      'verify',
    ],
  },
  'RSA-PSS': {
    algorithm: {
      modulusLength: 1024,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    },
    result: 'CryptoKeyPair',
    usages: [
      'sign',
      'verify',
    ],
  },
  'RSA-OAEP': {
    algorithm: {
      modulusLength: 1024,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    },
    result: 'CryptoKeyPair',
    usages: [
      'encrypt',
      'decrypt',
      'wrapKey',
      'unwrapKey',
    ],
  },
  'ECDSA': {
    algorithm: { namedCurve: 'P-521' },
    result: 'CryptoKeyPair',
    usages: [
      'sign',
      'verify',
    ],
  },
  'ECDH': {
    algorithm: { namedCurve: 'P-521' },
    result: 'CryptoKeyPair',
    usages: [
      'deriveKey',
      'deriveBits',
    ],
  },
  'Ed25519': {
    result: 'CryptoKeyPair',
    usages: [
      'sign',
      'verify',
    ],
  },
  'Ed448': {
    result: 'CryptoKeyPair',
    usages: [
      'sign',
      'verify',
    ],
  },
  'X25519': {
    result: 'CryptoKeyPair',
    usages: [
      'deriveKey',
      'deriveBits',
    ],
  },
  'X448': {
    result: 'CryptoKeyPair',
    usages: [
      'deriveKey',
      'deriveBits',
    ],
  },
};

// Test invalid algorithms
{
  async function test(algorithm) {
    return assert.rejects(
      // The extractable and usages values are invalid here also,
      // but the unrecognized algorithm name should be caught first.
      subtle.generateKey(algorithm, 7, []), {
        message: /Unrecognized algorithm name/,
        name: 'NotSupportedError',
      });
  }

  const tests = [
    'AES',
    { name: 'AES' },
    { name: 'AES-CMAC' },
    { name: 'AES-CFB' },
    { name: 'HMAC', hash: 'MD5' },
    {
      name: 'RSA',
      hash: 'SHA-256',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1])
    },
    {
      name: 'RSA-PSS',
      hash: 'SHA',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1])
    },
    {
      name: 'EC',
      namedCurve: 'P521'
    },
  ].map(async (algorithm) => test(algorithm));

  Promise.all(tests).then(common.mustCall());
}

// Test bad usages
{
  async function test(name) {
    await assert.rejects(
      subtle.generateKey(
        {
          name, ...vectors[name].algorithm
        },
        true,
        []),
      { message: /Usages cannot be empty/ });

    // For CryptoKeyPair results the private key
    // usages must not be empty.
    // - ECDH(-like) algorithm key pairs only have private key usages
    // - Signing algorithm key pairs may pass a non-empty array but
    //   with only a public key usage
    if (
      vectors[name].result === 'CryptoKeyPair' &&
      vectors[name].usages.includes('verify')
    ) {
      await assert.rejects(
        subtle.generateKey(
          {
            name, ...vectors[name].algorithm
          },
          true,
          ['verify']),
        { message: /Usages cannot be empty/ });
    }

    const invalidUsages = [];
    allUsages.forEach((usage) => {
      if (!vectors[name].usages.includes(usage))
        invalidUsages.push(usage);
    });
    for (const invalidUsage of invalidUsages) {
      await assert.rejects(
        subtle.generateKey(
          {
            name, ...vectors[name].algorithm
          },
          true,
          [...vectors[name].usages, invalidUsage]),
        { message: /Unsupported key usage/ });
    }
  }

  const tests = Object.keys(vectors).map(test);

  Promise.all(tests).then(common.mustCall());
}

// Test RSA key generation
{
  async function test(
    name,
    modulusLength,
    publicExponent,
    hash,
    privateUsages,
    publicUsages = privateUsages) {
    let usages = privateUsages;
    if (publicUsages !== privateUsages)
      usages = usages.concat(publicUsages);
    const { publicKey, privateKey } = await subtle.generateKey({
      name,
      modulusLength,
      publicExponent,
      hash
    }, true, usages);

    assert(publicKey);
    assert(privateKey);
    assert(isCryptoKey(publicKey));
    assert(isCryptoKey(privateKey));

    assert(publicKey instanceof CryptoKey);
    assert(privateKey instanceof CryptoKey);

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(publicKey.toString(), '[object CryptoKey]');
    assert.strictEqual(privateKey.toString(), '[object CryptoKey]');
    assert.strictEqual(publicKey.extractable, true);
    assert.strictEqual(privateKey.extractable, true);
    assert.deepStrictEqual(publicKey.usages, publicUsages);
    assert.deepStrictEqual(privateKey.usages, privateUsages);
    assert.strictEqual(publicKey.algorithm.name, name);
    assert.strictEqual(publicKey.algorithm.modulusLength, modulusLength);
    assert.deepStrictEqual(publicKey.algorithm.publicExponent, publicExponent);
    assert.strictEqual(
      KeyObject.from(publicKey).asymmetricKeyDetails.publicExponent,
      bigIntArrayToUnsignedBigInt(publicExponent));
    assert.strictEqual(publicKey.algorithm.hash.name, hash);
    assert.strictEqual(privateKey.algorithm.name, name);
    assert.strictEqual(privateKey.algorithm.modulusLength, modulusLength);
    assert.deepStrictEqual(privateKey.algorithm.publicExponent, publicExponent);
    assert.strictEqual(
      KeyObject.from(privateKey).asymmetricKeyDetails.publicExponent,
      bigIntArrayToUnsignedBigInt(publicExponent));
    assert.strictEqual(privateKey.algorithm.hash.name, hash);
    assert.strictEqual(privateKey.algorithm, privateKey.algorithm);
    assert.strictEqual(privateKey.usages, privateKey.usages);
    assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
    assert.strictEqual(publicKey.usages, publicKey.usages);

    // Missing parameters
    await assert.rejects(
      subtle.generateKey({ name, publicExponent, hash }, true, usages), {
        code: 'ERR_MISSING_OPTION'
      });

    await assert.rejects(
      subtle.generateKey({ name, modulusLength, hash }, true, usages), {
        code: 'ERR_MISSING_OPTION'
      });

    await assert.rejects(
      subtle.generateKey({ name, modulusLength }, true, usages), {
        code: 'ERR_MISSING_OPTION'
      });

    await Promise.all([{}].map((modulusLength) => {
      return assert.rejects(subtle.generateKey({
        name,
        modulusLength,
        publicExponent,
        hash
      }, true, usages), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    }));

    await Promise.all(
      [
        '',
        true,
        {},
        1,
        [],
        new Uint32Array(2),
      ].map((publicExponent) => {
        return assert.rejects(
          subtle.generateKey(
            { name, modulusLength, publicExponent, hash }, true, usages),
          { code: 'ERR_INVALID_ARG_TYPE' });
      }));

    await Promise.all([true, 1].map((hash) => {
      return assert.rejects(subtle.generateKey({
        name,
        modulusLength,
        publicExponent,
        hash
      }, true, usages), {
        message: /Unrecognized algorithm name/,
        name: 'NotSupportedError',
      });
    }));

    await Promise.all(['', {}, 1, false].map((usages) => {
      return assert.rejects(subtle.generateKey({
        name,
        modulusLength,
        publicExponent,
        hash
      }, true, usages), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    }));

    await Promise.all([[1], [1, 0, 0]].map((publicExponent) => {
      return assert.rejects(subtle.generateKey({
        name,
        modulusLength,
        publicExponent: new Uint8Array(publicExponent),
        hash
      }, true, usages), {
        name: 'OperationError',
      });
    }));
  }

  const kTests = [
    [
      'RSASSA-PKCS1-v1_5',
      1024,
      Buffer.from([1, 0, 1]),
      'SHA-256',
      ['sign'],
      ['verify'],
    ],
    [
      'RSA-PSS',
      2048,
      Buffer.from([1, 0, 1]),
      'SHA-512',
      ['sign'],
      ['verify'],
    ],
    [
      'RSA-OAEP',
      1024,
      Buffer.from([3]),
      'SHA-384',
      ['decrypt', 'unwrapKey'],
      ['encrypt', 'wrapKey'],
    ],
  ];

  const tests = kTests.map((args) => test(...args));

  Promise.all(tests).then(common.mustCall());
}

// Test EC Key Generation
{
  async function test(
    name,
    namedCurve,
    privateUsages,
    publicUsages = privateUsages) {

    let usages = privateUsages;
    if (publicUsages !== privateUsages)
      usages = usages.concat(publicUsages);

    const { publicKey, privateKey } = await subtle.generateKey({
      name,
      namedCurve
    }, true, usages);

    assert(publicKey);
    assert(privateKey);
    assert(isCryptoKey(publicKey));
    assert(isCryptoKey(privateKey));

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(publicKey.toString(), '[object CryptoKey]');
    assert.strictEqual(privateKey.toString(), '[object CryptoKey]');
    assert.strictEqual(publicKey.extractable, true);
    assert.strictEqual(privateKey.extractable, true);
    assert.deepStrictEqual(publicKey.usages, publicUsages);
    assert.deepStrictEqual(privateKey.usages, privateUsages);
    assert.strictEqual(publicKey.algorithm.name, name);
    assert.strictEqual(privateKey.algorithm.name, name);
    assert.strictEqual(publicKey.algorithm.namedCurve, namedCurve);
    assert.strictEqual(privateKey.algorithm.namedCurve, namedCurve);
    assert.strictEqual(privateKey.algorithm, privateKey.algorithm);
    assert.strictEqual(privateKey.usages, privateKey.usages);
    assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
    assert.strictEqual(publicKey.usages, publicKey.usages);

    // Invalid parameters
    [1, true, {}, [], null].forEach(async (namedCurve) => {
      await assert.rejects(
        subtle.generateKey({ name, namedCurve }, true, privateUsages), {
          name: 'NotSupportedError'
        });
    });
    await assert.rejects(
      subtle.generateKey({ name, namedCurve: undefined }, true, privateUsages), {
        name: 'TypeError',
        code: 'ERR_MISSING_OPTION'
      });
  }

  const kTests = [
    [
      'ECDSA',
      'P-384',
      ['sign'],
      ['verify'],
    ],
    [
      'ECDSA',
      'P-521',
      ['sign'],
      ['verify'],
    ],
    [
      'ECDH',
      'P-384',
      ['deriveKey', 'deriveBits'],
      [],
    ],
    [
      'ECDH',
      'P-521',
      ['deriveKey', 'deriveBits'],
      [],
    ],
  ];

  const tests = kTests.map((args) => test(...args));

  // Test bad parameters

  Promise.all(tests).then(common.mustCall());
}

// Test AES Key Generation
{
  async function test(name, length, usages) {
    const key = await subtle.generateKey({
      name,
      length
    }, true, usages);

    assert(key);
    assert(isCryptoKey(key));

    assert.strictEqual(key.type, 'secret');
    assert.strictEqual(key.toString(), '[object CryptoKey]');
    assert.strictEqual(key.extractable, true);
    assert.deepStrictEqual(key.usages, usages);
    assert.strictEqual(key.algorithm.name, name);
    assert.strictEqual(key.algorithm.length, length);
    assert.strictEqual(key.algorithm, key.algorithm);
    assert.strictEqual(key.usages, key.usages);

    // Invalid parameters
    [1, 100, 257, '', false, null].forEach(async (length) => {
      await assert.rejects(
        subtle.generateKey({ name, length }, true, usages), {
          name: 'OperationError'
        });
    });

    await assert.rejects(
      subtle.generateKey({ name, length: undefined }, true, usages), {
        name: 'TypeError',
        code: 'ERR_MISSING_OPTION'
      });
  }

  const kTests = [
    [ 'AES-CTR', 128, ['encrypt', 'decrypt', 'wrapKey']],
    [ 'AES-CTR', 256, ['encrypt', 'decrypt', 'unwrapKey']],
    [ 'AES-CBC', 128, ['encrypt', 'decrypt']],
    [ 'AES-CBC', 256, ['encrypt', 'decrypt']],
    [ 'AES-GCM', 128, ['encrypt', 'decrypt']],
    [ 'AES-GCM', 256, ['encrypt', 'decrypt']],
    [ 'AES-KW', 128, ['wrapKey', 'unwrapKey']],
    [ 'AES-KW', 256, ['wrapKey', 'unwrapKey']],
  ];

  const tests = Promise.all(kTests.map((args) => test(...args)));

  tests.then(common.mustCall());
}

// Test HMAC Key Generation
{
  async function test(length, hash, usages) {
    const key = await subtle.generateKey({
      name: 'HMAC',
      length,
      hash
    }, true, usages);

    if (length === undefined) {
      switch (hash) {
        case 'SHA-1': length = 512; break;
        case 'SHA-256': length = 512; break;
        case 'SHA-384': length = 1024; break;
        case 'SHA-512': length = 1024; break;
      }
    }

    assert(key);
    assert(isCryptoKey(key));

    assert.strictEqual(key.type, 'secret');
    assert.strictEqual(key.toString(), '[object CryptoKey]');
    assert.strictEqual(key.extractable, true);
    assert.deepStrictEqual(key.usages, usages);
    assert.strictEqual(key.algorithm.name, 'HMAC');
    assert.strictEqual(key.algorithm.length, length);
    assert.strictEqual(key.algorithm.hash.name, hash);
    assert.strictEqual(key.algorithm, key.algorithm);
    assert.strictEqual(key.usages, key.usages);

    [1, false, null].forEach(async (hash) => {
      await assert.rejects(
        subtle.generateKey({ name: 'HMAC', length, hash }, true, usages), {
          message: /Unrecognized algorithm name/,
          name: 'NotSupportedError',
        });
    });
  }

  const kTests = [
    [ undefined, 'SHA-1', ['sign', 'verify']],
    [ undefined, 'SHA-256', ['sign', 'verify']],
    [ undefined, 'SHA-384', ['sign', 'verify']],
    [ undefined, 'SHA-512', ['sign', 'verify']],
    [ 128, 'SHA-256', ['sign', 'verify']],
    [ 1024, 'SHA-512', ['sign', 'verify']],
  ];

  const tests = Promise.all(kTests.map((args) => test(...args)));

  tests.then(common.mustCall());
}

// End user code cannot create CryptoKey directly
assert.throws(() => new CryptoKey(), { code: 'ERR_ILLEGAL_CONSTRUCTOR' });

{
  const buffer = Buffer.from('Hello World');
  const keyObject = createSecretKey(buffer);
  assert(!isCryptoKey(buffer));
  assert(!isCryptoKey(keyObject));
}

// Test OKP Key Generation
{
  async function test(
    name,
    privateUsages,
    publicUsages = privateUsages) {

    let usages = privateUsages;
    if (publicUsages !== privateUsages)
      usages = usages.concat(publicUsages);

    const { publicKey, privateKey } = await subtle.generateKey({
      name,
    }, true, usages);

    assert(publicKey);
    assert(privateKey);
    assert(isCryptoKey(publicKey));
    assert(isCryptoKey(privateKey));

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(publicKey.toString(), '[object CryptoKey]');
    assert.strictEqual(privateKey.toString(), '[object CryptoKey]');
    assert.strictEqual(publicKey.extractable, true);
    assert.strictEqual(privateKey.extractable, true);
    assert.deepStrictEqual(publicKey.usages, publicUsages);
    assert.deepStrictEqual(privateKey.usages, privateUsages);
    assert.strictEqual(publicKey.algorithm.name, name);
    assert.strictEqual(privateKey.algorithm.name, name);
    assert.strictEqual(privateKey.algorithm, privateKey.algorithm);
    assert.strictEqual(privateKey.usages, privateKey.usages);
    assert.strictEqual(publicKey.algorithm, publicKey.algorithm);
    assert.strictEqual(publicKey.usages, publicKey.usages);
  }

  const kTests = [
    [
      'Ed25519',
      ['sign'],
      ['verify'],
    ],
    [
      'Ed448',
      ['sign'],
      ['verify'],
    ],
    [
      'X25519',
      ['deriveKey', 'deriveBits'],
      [],
    ],
    [
      'X448',
      ['deriveKey', 'deriveBits'],
      [],
    ],
  ];

  const tests = kTests.map((args) => test(...args));

  // Test bad parameters

  Promise.all(tests).then(common.mustCall());
}
                                                                                                                               node-23.7.0/test/parallel/test-webcrypto-random.js                                                  0000664 0000000 0000000 00000002762 14746647661 0022146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const { Buffer } = require('buffer');
const assert = require('assert');
const { crypto } = globalThis;

[
  undefined, null, '', 1, {}, [],
  new Float32Array(1),
  new Float64Array(1),
  new DataView(new ArrayBuffer(1)),
].forEach((i) => {
  assert.throws(
    () => crypto.getRandomValues(i),
    { name: 'TypeMismatchError', code: 17 },
  );
});

{
  const buf = new Uint8Array(0);
  crypto.getRandomValues(buf);
}

const intTypedConstructors = [
  Int8Array,
  Int16Array,
  Int32Array,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Uint8ClampedArray,
  BigInt64Array,
  BigUint64Array,
];

for (const ctor of intTypedConstructors) {
  const buf = new ctor(10);
  const before = Buffer.from(buf.buffer).toString('hex');
  crypto.getRandomValues(buf);
  const after = Buffer.from(buf.buffer).toString('hex');
  assert.notStrictEqual(before, after);
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.getRandomValues(buf);
  const after = buf.toString('hex');
  assert.notStrictEqual(before, after);
}

{
  let kData;
  try {
    kData = Buffer.alloc(65536 + 1);
  } catch {
    // Ignore if error here.
  }

  if (kData !== undefined) {
    assert.throws(
      () => crypto.getRandomValues(kData),
      { name: 'QuotaExceededError', code: 22 },
    );
  }
}

{
  const typedArray = new Uint8Array(32);
  assert.strictEqual(crypto.getRandomValues(typedArray), typedArray);
}
              node-23.7.0/test/parallel/test-webcrypto-sign-verify-ecdsa.js                                       0000664 0000000 0000000 00000013554 14746647661 0024206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const vectors = require('../fixtures/crypto/ecdsa')();

async function testVerify({ name,
                            hash,
                            namedCurve,
                            publicKeyBuffer,
                            privateKeyBuffer,
                            signature,
                            plaintext }) {
  const [
    publicKey,
    noVerifyPublicKey,
    privateKey,
    hmacKey,
    rsaKeys,
    okpKeys,
  ] = await Promise.all([
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name, namedCurve },
      false,
      ['verify']),
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name, namedCurve },
      false,
      [ /* No usages */ ]),
    subtle.importKey(
      'pkcs8',
      privateKeyBuffer,
      { name, namedCurve },
      false,
      ['sign']),
    subtle.generateKey(
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'Ed25519',
      },
      false,
      ['sign']),
  ]);

  assert(await subtle.verify({ name, hash }, publicKey, signature, plaintext));

  // Test verification with altered buffers
  const copy = Buffer.from(plaintext);
  const sigcopy = Buffer.from(signature);
  const p = subtle.verify({ name, hash }, publicKey, sigcopy, copy);
  copy[0] = 255 - copy[0];
  sigcopy[0] = 255 - sigcopy[0];
  assert(await p);

  // Test failure when using wrong key
  await assert.rejects(
    subtle.verify({ name, hash }, privateKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify({ name, hash }, noVerifyPublicKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.verify({ name, hash }, hmacKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify({ name, hash }, rsaKeys.publicKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify({ name, hash }, okpKeys.publicKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  // Test failure when signature is altered
  {
    const copy = Buffer.from(signature);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify(
      { name, hash },
      publicKey,
      copy,
      plaintext)));
    assert(!(await subtle.verify(
      { name, hash },
      publicKey,
      copy.slice(1),
      plaintext)));
  }

  // Test failure when data is altered
  {
    const copy = Buffer.from(plaintext);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify({ name, hash }, publicKey, signature, copy)));
  }

  // Test failure when wrong hash is used
  {
    const otherhash = hash === 'SHA-1' ? 'SHA-256' : 'SHA-1';
    assert(!(await subtle.verify({
      name,
      hash: otherhash
    }, publicKey, signature, copy)));
  }

  await assert.rejects(
    subtle.verify({ name, hash: 'sha256' }, publicKey, signature, copy), {
      message: /Unrecognized algorithm name/,
      name: 'NotSupportedError',
    });
}

async function testSign({ name,
                          hash,
                          namedCurve,
                          publicKeyBuffer,
                          privateKeyBuffer,
                          signature,
                          plaintext }) {
  const [
    publicKey,
    privateKey,
    hmacKey,
    rsaKeys,
    okpKeys,
  ] = await Promise.all([
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name, namedCurve },
      false,
      ['verify']),
    subtle.importKey(
      'pkcs8',
      privateKeyBuffer,
      { name, namedCurve },
      false,
      ['sign']),
    subtle.generateKey(
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'Ed25519',
      },
      false,
      ['sign']),
  ]);

  {
    const sig = await subtle.sign({ name, hash }, privateKey, plaintext);
    assert.strictEqual(sig.byteLength, signature.byteLength);
    assert(await subtle.verify({ name, hash }, publicKey, sig, plaintext));
  }

  {
    const copy = Buffer.from(plaintext);
    const p = subtle.sign({ name, hash }, privateKey, copy);
    copy[0] = 255 - copy[0];
    const sig = await p;
    assert(await subtle.verify({ name, hash }, publicKey, sig, plaintext));
  }

  // Test failure when using wrong key
  await assert.rejects(
    subtle.sign({ name, hash }, publicKey, plaintext), {
      message: /Unable to use this key to sign/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.sign({ name, hash }, hmacKey, plaintext), {
      message: /Unable to use this key to sign/
    });

  await assert.rejects(
    subtle.sign({ name, hash }, rsaKeys.privateKey, plaintext), {
      message: /Unable to use this key to sign/
    });

  await assert.rejects(
    subtle.sign({ name, hash }, okpKeys.privateKey, plaintext), {
      message: /Unable to use this key to sign/
    });
}

(async function() {
  const variations = [];

  for (let i = 0; i < vectors.length; ++i) {
    const vector = vectors[i];
    variations.push(testVerify(vector));
    variations.push(testSign(vector));
  }

  await Promise.all(variations);
})().then(common.mustCall());
                                                                                                                                                    node-23.7.0/test/parallel/test-webcrypto-sign-verify-eddsa.js                                       0000664 0000000 0000000 00000014203 14746647661 0024177 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const vectors = require('../fixtures/crypto/eddsa')();

async function testVerify({ name,
                            publicKeyBuffer,
                            privateKeyBuffer,
                            signature,
                            data }) {
  const [
    publicKey,
    noVerifyPublicKey,
    privateKey,
    hmacKey,
    rsaKeys,
    ecKeys,
  ] = await Promise.all([
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name },
      false,
      ['verify']),
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name },
      false,
      [ /* No usages */ ]),
    subtle.importKey(
      'pkcs8',
      privateKeyBuffer,
      { name },
      false,
      ['sign']),
    subtle.generateKey(
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-256'
      },
      false,
      ['sign']),
  ]);

  assert(await subtle.verify({ name }, publicKey, signature, data));

  // Test verification with altered buffers
  const copy = Buffer.from(data);
  const sigcopy = Buffer.from(signature);
  const p = subtle.verify({ name }, publicKey, sigcopy, copy);
  copy[0] = 255 - copy[0];
  sigcopy[0] = 255 - sigcopy[0];
  assert(await p);

  // Test failure when using wrong key
  await assert.rejects(
    subtle.verify({ name }, privateKey, signature, data), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify({ name }, noVerifyPublicKey, signature, data), {
      message: /Unable to use this key to verify/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.verify({ name }, hmacKey, signature, data), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify({ name }, rsaKeys.publicKey, signature, data), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify({ name }, ecKeys.publicKey, signature, data), {
      message: /Unable to use this key to verify/
    });

  // Test failure when signature is altered
  {
    const copy = Buffer.from(signature);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify(
      { name },
      publicKey,
      copy,
      data)));
    assert(!(await subtle.verify(
      { name },
      publicKey,
      copy.slice(1),
      data)));
  }

  // Test failure when data is altered
  {
    const copy = Buffer.from(data);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify({ name }, publicKey, signature, copy)));
  }
}

async function testSign({ name,
                          publicKeyBuffer,
                          privateKeyBuffer,
                          signature,
                          data }) {
  const [
    publicKey,
    privateKey,
    hmacKey,
    rsaKeys,
    ecKeys,
  ] = await Promise.all([
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name },
      false,
      ['verify']),
    subtle.importKey(
      'pkcs8',
      privateKeyBuffer,
      { name },
      false,
      ['sign']),
    subtle.generateKey(
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-256'
      },
      false,
      ['sign']),
  ]);

  {
    const sig = await subtle.sign({ name }, privateKey, data);
    assert.strictEqual(sig.byteLength, signature.byteLength);
    assert(await subtle.verify({ name }, publicKey, sig, data));
  }

  {
    const copy = Buffer.from(data);
    const p = subtle.sign({ name }, privateKey, copy);
    copy[0] = 255 - copy[0];
    const sig = await p;
    assert(await subtle.verify({ name }, publicKey, sig, data));
  }

  // Test failure when using wrong key
  await assert.rejects(
    subtle.sign({ name }, publicKey, data), {
      message: /Unable to use this key to sign/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.sign({ name }, hmacKey, data), {
      message: /Unable to use this key to sign/
    });

  await assert.rejects(
    subtle.sign({ name }, rsaKeys.privateKey, data), {
      message: /Unable to use this key to sign/
    });

  await assert.rejects(
    subtle.sign({ name }, ecKeys.privateKey, data), {
      message: /Unable to use this key to sign/
    });
}

(async function() {
  const variations = [];

  vectors.forEach((vector) => {
    variations.push(testVerify(vector));
    variations.push(testSign(vector));
  });

  await Promise.all(variations);
})().then(common.mustCall());

// Ed448 context
{
  const vector = vectors.find(({ name }) => name === 'Ed448');
  Promise.all([
    subtle.importKey(
      'pkcs8',
      vector.privateKeyBuffer,
      { name: 'Ed448' },
      false,
      ['sign']),
    subtle.importKey(
      'spki',
      vector.publicKeyBuffer,
      { name: 'Ed448' },
      false,
      ['verify']),
  ]).then(async ([privateKey, publicKey]) => {
    const sig = await subtle.sign({ name: 'Ed448', context: Buffer.alloc(0) }, privateKey, vector.data);
    assert.deepStrictEqual(Buffer.from(sig), vector.signature);
    assert.strictEqual(
      await subtle.verify({ name: 'Ed448', context: Buffer.alloc(0) }, publicKey, sig, vector.data), true);

    await assert.rejects(subtle.sign({ name: 'Ed448', context: Buffer.alloc(1) }, privateKey, vector.data), {
      message: /Non zero-length context is not yet supported/
    });
    await assert.rejects(subtle.verify({ name: 'Ed448', context: Buffer.alloc(1) }, publicKey, sig, vector.data), {
      message: /Non zero-length context is not yet supported/
    });
  }).then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-webcrypto-sign-verify-hmac.js                                        0000664 0000000 0000000 00000010516 14746647661 0024032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const vectors = require('../fixtures/crypto/hmac')();

async function testVerify({ hash,
                            keyBuffer,
                            signature,
                            plaintext }) {
  const name = 'HMAC';
  const [
    key,
    noVerifyKey,
    rsaKeys,
  ] = await Promise.all([
    subtle.importKey(
      'raw',
      keyBuffer,
      { name, hash },
      false,
      ['verify']),
    subtle.importKey(
      'raw',
      keyBuffer,
      { name, hash },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      false,
      ['sign']),
  ]);

  assert(await subtle.verify({ name, hash }, key, signature, plaintext));

  // Test verification with altered buffers
  const copy = Buffer.from(plaintext);
  const sigcopy = Buffer.from(signature);
  const p = subtle.verify({ name, hash }, key, sigcopy, copy);
  copy[0] = 255 - copy[0];
  sigcopy[0] = 255 - sigcopy[0];
  assert(await p);

  // Test failure when using wrong key
  await assert.rejects(
    subtle.verify({ name, hash }, noVerifyKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.verify({ name, hash }, rsaKeys.publicKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  // Test failure when signature is altered
  {
    const copy = Buffer.from(signature);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify(
      { name, hash },
      key,
      copy,
      plaintext)));
    assert(!(await subtle.verify(
      { name, hash },
      key,
      copy.slice(1),
      plaintext)));
  }

  // Test failure when data is altered
  {
    const copy = Buffer.from(plaintext);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify({ name, hash }, key, signature, copy)));
  }

  // Test failure when wrong hash is used
  {
    const otherhash = hash === 'SHA-1' ? 'SHA-256' : 'SHA-1';
    const keyWithOtherHash = await subtle.importKey(
      'raw',
      keyBuffer,
      { name, hash: otherhash },
      false,
      ['verify']);
    assert(!(await subtle.verify({ name }, keyWithOtherHash, signature, plaintext)));
  }
}

async function testSign({ hash,
                          keyBuffer,
                          signature,
                          plaintext }) {
  const name = 'HMAC';
  const [
    key,
    noSignKey,
    rsaKeys,
  ] = await Promise.all([
    subtle.importKey(
      'raw',
      keyBuffer,
      { name, hash },
      false,
      ['verify', 'sign']),
    subtle.importKey(
      'raw',
      keyBuffer,
      { name, hash },
      false,
      [ 'verify' ]),
    subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      false,
      ['sign']),
  ]);

  {
    const sig = await subtle.sign({ name, hash }, key, plaintext);
    assert.strictEqual(
      Buffer.from(sig).toString('hex'),
      signature.toString('hex'));
    assert(await subtle.verify({ name, hash }, key, sig, plaintext));
  }

  {
    const copy = Buffer.from(plaintext);
    const p = subtle.sign({ name, hash }, key, copy);
    copy[0] = 255 - copy[0];
    const sig = await p;
    assert(await subtle.verify({ name, hash }, key, sig, plaintext));
  }

  await assert.rejects(
    subtle.generateKey({ name }, false, ['sign', 'verify']), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
    });

  // Test failure when no sign usage
  await assert.rejects(
    subtle.sign({ name, hash }, noSignKey, plaintext), {
      message: /Unable to use this key to sign/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.sign({ name, hash }, rsaKeys.privateKey, plaintext), {
      message: /Unable to use this key to sign/
    });
}

(async function() {
  const variations = [];

  for (const vector of vectors) {
    variations.push(testVerify(vector));
    variations.push(testSign(vector));
  }

  await Promise.all(variations);
})().then(common.mustCall());
                                                                                                                                                                                  node-23.7.0/test/parallel/test-webcrypto-sign-verify-rsa.js                                         0000664 0000000 0000000 00000015034 14746647661 0023707 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const rsa_pkcs = require('../fixtures/crypto/rsa_pkcs');
const rsa_pss = require('../fixtures/crypto/rsa_pss');

async function testVerify({
  algorithm,
  hash,
  publicKeyBuffer,
  privateKeyBuffer,
  signature,
  plaintext,
}) {
  const [
    publicKey,
    noVerifyPublicKey,
    privateKey,
    hmacKey,
    ecdsaKeys,
  ] = await Promise.all([
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name: algorithm.name, hash },
      false,
      ['verify']),
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name: algorithm.name, hash },
      false,
      [ /* No usages */ ]),
    subtle.importKey(
      'pkcs8',
      privateKeyBuffer,
      { name: algorithm.name, hash },
      false,
      ['sign']),
    subtle.generateKey(
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-521',
        hash: 'SHA-256',
      },
      false,
      ['sign']),
  ]);

  assert(await subtle.verify(algorithm, publicKey, signature, plaintext));

  // Test verification with altered buffers
  const copy = Buffer.from(plaintext);
  const sigcopy = Buffer.from(signature);
  const p = subtle.verify(algorithm, publicKey, sigcopy, copy);
  copy[0] = 255 - copy[0];
  sigcopy[0] = 255 - sigcopy[0];
  assert(await p);

  // Test failure when using wrong key
  await assert.rejects(
    subtle.verify(algorithm, privateKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify(algorithm, noVerifyPublicKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.verify(algorithm, hmacKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  await assert.rejects(
    subtle.verify(algorithm, ecdsaKeys.publicKey, signature, plaintext), {
      message: /Unable to use this key to verify/
    });

  // Test failure when signature is altered
  {
    const copy = Buffer.from(signature);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify(algorithm, publicKey, copy, plaintext)));
    assert(!(await subtle.verify(
      algorithm,
      publicKey,
      copy.slice(1),
      plaintext)));
  }

  // Test failure when data is altered
  {
    const copy = Buffer.from(plaintext);
    copy[0] = 255 - copy[0];
    assert(!(await subtle.verify(algorithm, publicKey, signature, copy)));
  }

  // Test failure when wrong hash is used
  {
    const otherhash = hash === 'SHA-1' ? 'SHA-256' : 'SHA-1';
    const keyWithOtherHash = await subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name: algorithm.name, hash: otherhash },
      false,
      ['verify']);
    assert(!(await subtle.verify(algorithm, keyWithOtherHash, signature, plaintext)));
  }
}

async function testSign({
  algorithm,
  hash,
  publicKeyBuffer,
  privateKeyBuffer,
  signature,
  plaintext,
}) {
  const [
    publicKey,
    privateKey,
    hmacKey,
    ecdsaKeys,
  ] = await Promise.all([
    subtle.importKey(
      'spki',
      publicKeyBuffer,
      { name: algorithm.name, hash },
      false,
      ['verify']),
    subtle.importKey(
      'pkcs8',
      privateKeyBuffer,
      { name: algorithm.name, hash },
      false,
      ['sign']),
    subtle.generateKey(
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']),
    subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-521',
        hash: 'SHA-256',
      },
      false,
      ['sign']),
  ]);

  {
    const sig = await subtle.sign(algorithm, privateKey, plaintext);
    assert.strictEqual(sig.byteLength, signature.byteLength);
    assert(await subtle.verify(algorithm, publicKey, sig, plaintext));
  }

  {
    const copy = Buffer.from(plaintext);
    const p = subtle.sign(algorithm, privateKey, copy);
    copy[0] = 255 - copy[0];
    const sig = await p;
    assert(await subtle.verify(algorithm, publicKey, sig, plaintext));
  }

  // Test failure when using wrong key
  await assert.rejects(
    subtle.sign(algorithm, publicKey, plaintext), {
      message: /Unable to use this key to sign/
    });

  // Test failure when using the wrong algorithms
  await assert.rejects(
    subtle.sign(algorithm, hmacKey, plaintext), {
      message: /Unable to use this key to sign/
    });

  await assert.rejects(
    subtle.sign(algorithm, ecdsaKeys.privateKey, plaintext), {
      message: /Unable to use this key to sign/
    });
}

async function testSaltLength(keyLength, hash, hLen) {
  const { publicKey, privateKey } = await subtle.generateKey({
    name: 'RSA-PSS',
    modulusLength: keyLength,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash,
  }, false, ['sign', 'verify']);

  const data = Buffer.from('Hello, world!');
  const max = keyLength / 8 - hLen - 2;

  const signature = await subtle.sign({ name: 'RSA-PSS', saltLength: max }, privateKey, data);
  await assert.rejects(
    subtle.sign({ name: 'RSA-PSS', saltLength: max + 1 }, privateKey, data), (err) => {
      assert.strictEqual(err.name, 'OperationError');
      assert.strictEqual(err.cause?.code, 'ERR_OUT_OF_RANGE');
      assert.strictEqual(err.cause?.message, `The value of "algorithm.saltLength" is out of range. It must be >= 0 && <= ${max}. Received ${max + 1}`);
      return true;
    });
  await subtle.verify({ name: 'RSA-PSS', saltLength: max }, publicKey, signature, data);
  await assert.rejects(
    subtle.verify({ name: 'RSA-PSS', saltLength: max + 1 }, publicKey, signature, data), (err) => {
      assert.strictEqual(err.name, 'OperationError');
      assert.strictEqual(err.cause?.code, 'ERR_OUT_OF_RANGE');
      assert.strictEqual(err.cause?.message, `The value of "algorithm.saltLength" is out of range. It must be >= 0 && <= ${max}. Received ${max + 1}`);
      return true;
    });
}

(async function() {
  const variations = [];

  rsa_pkcs().forEach((vector) => {
    variations.push(testVerify(vector));
    variations.push(testSign(vector));
  });
  rsa_pss().forEach((vector) => {
    variations.push(testVerify(vector));
    variations.push(testSign(vector));
  });

  for (const keyLength of [1024, 2048]) {
    for (const [hash, hLen] of [['SHA-1', 20], ['SHA-256', 32], ['SHA-384', 48], ['SHA-512', 64]]) {
      variations.push(testSaltLength(keyLength, hash, hLen));
    }
  }

  await Promise.all(variations);
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-webcrypto-sign-verify.js                                             0000664 0000000 0000000 00000006645 14746647661 0023134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

// This is only a partial test. The WebCrypto Web Platform Tests
// will provide much greater coverage.

// Test Sign/Verify RSASSA-PKCS1-v1_5
{
  async function test(data) {
    const ec = new TextEncoder();
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'RSASSA-PKCS1-v1_5',
      modulusLength: 1024,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    }, true, ['sign', 'verify']);

    const signature = await subtle.sign({
      name: 'RSASSA-PKCS1-v1_5'
    }, privateKey, ec.encode(data));

    assert(await subtle.verify({
      name: 'RSASSA-PKCS1-v1_5'
    }, publicKey, signature, ec.encode(data)));
  }

  test('hello world').then(common.mustCall());
}

// Test Sign/Verify RSA-PSS
{
  async function test(data) {
    const ec = new TextEncoder();
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'RSA-PSS',
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    }, true, ['sign', 'verify']);

    const signature = await subtle.sign({
      name: 'RSA-PSS',
      saltLength: 256,
    }, privateKey, ec.encode(data));

    assert(await subtle.verify({
      name: 'RSA-PSS',
      saltLength: 256,
    }, publicKey, signature, ec.encode(data)));
  }

  test('hello world').then(common.mustCall());
}

// Test Sign/Verify ECDSA
{
  async function test(data) {
    const ec = new TextEncoder();
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'ECDSA',
      namedCurve: 'P-384',
    }, true, ['sign', 'verify']);

    const signature = await subtle.sign({
      name: 'ECDSA',
      hash: 'SHA-384',
    }, privateKey, ec.encode(data));

    assert(await subtle.verify({
      name: 'ECDSA',
      hash: 'SHA-384',
    }, publicKey, signature, ec.encode(data)));
  }

  test('hello world').then(common.mustCall());
}

// Test Sign/Verify HMAC
{
  async function test(data) {
    const ec = new TextEncoder();

    const key = await subtle.generateKey({
      name: 'HMAC',
      length: 256,
      hash: 'SHA-256'
    }, true, ['sign', 'verify']);

    const signature = await subtle.sign({
      name: 'HMAC',
    }, key, ec.encode(data));

    assert(await subtle.verify({
      name: 'HMAC',
    }, key, signature, ec.encode(data)));
  }

  test('hello world').then(common.mustCall());
}

// Test Sign/Verify Ed25519
{
  async function test(data) {
    const ec = new TextEncoder();
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'Ed25519',
    }, true, ['sign', 'verify']);

    const signature = await subtle.sign({
      name: 'Ed25519',
    }, privateKey, ec.encode(data));

    assert(await subtle.verify({
      name: 'Ed25519',
    }, publicKey, signature, ec.encode(data)));
  }

  test('hello world').then(common.mustCall());
}

// Test Sign/Verify Ed448
{
  async function test(data) {
    const ec = new TextEncoder();
    const { publicKey, privateKey } = await subtle.generateKey({
      name: 'Ed448',
    }, true, ['sign', 'verify']);

    const signature = await subtle.sign({
      name: 'Ed448',
    }, privateKey, ec.encode(data));

    assert(await subtle.verify({
      name: 'Ed448',
    }, publicKey, signature, ec.encode(data)));
  }

  test('hello world').then(common.mustCall());
}
                                                                                           node-23.7.0/test/parallel/test-webcrypto-util.js                                                    0000664 0000000 0000000 00000001011 14746647661 0021625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const {
  normalizeAlgorithm,
} = require('internal/crypto/util');

{
  // Check that normalizeAlgorithm does not mutate object inputs.
  const algorithm = { name: 'ECDSA', hash: 'SHA-256' };
  assert.strictEqual(normalizeAlgorithm(algorithm, 'sign') !== algorithm, true);
  assert.deepStrictEqual(algorithm, { name: 'ECDSA', hash: 'SHA-256' });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-webcrypto-webidl.js                                                  0000664 0000000 0000000 00000041721 14746647661 0022132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const webidl = require('internal/crypto/webidl');
const { subtle } = globalThis.crypto;
const { generateKeySync } = require('crypto');

const { converters } = webidl;
const prefix = "Failed to execute 'fn' on 'interface'";
const context = '1st argument';
const opts = { prefix, context };

// Required arguments.length
{
  assert.throws(() => webidl.requiredArguments(0, 3, { prefix }), {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: `${prefix}: 3 arguments required, but only 0 present.`
  });

  assert.throws(() => webidl.requiredArguments(0, 1, { prefix }), {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: `${prefix}: 1 argument required, but only 0 present.`
  });

  // Does not throw when extra are added
  webidl.requiredArguments(4, 3, { prefix });
}

// boolean
{
  assert.strictEqual(converters.boolean(0), false);
  assert.strictEqual(converters.boolean(NaN), false);
  assert.strictEqual(converters.boolean(undefined), false);
  assert.strictEqual(converters.boolean(null), false);
  assert.strictEqual(converters.boolean(false), false);
  assert.strictEqual(converters.boolean(''), false);

  assert.strictEqual(converters.boolean(1), true);
  assert.strictEqual(converters.boolean(Number.POSITIVE_INFINITY), true);
  assert.strictEqual(converters.boolean(Number.NEGATIVE_INFINITY), true);
  assert.strictEqual(converters.boolean('1'), true);
  assert.strictEqual(converters.boolean('0'), true);
  assert.strictEqual(converters.boolean('false'), true);
  assert.strictEqual(converters.boolean(function() {}), true);
  assert.strictEqual(converters.boolean(Symbol()), true);
  assert.strictEqual(converters.boolean([]), true);
  assert.strictEqual(converters.boolean({}), true);
}

// int conversion
// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
{
  for (const [converter, max] of [
    [converters.octet, Math.pow(2, 8) - 1],
    [converters['unsigned short'], Math.pow(2, 16) - 1],
    [converters['unsigned long'], Math.pow(2, 32) - 1],
  ]) {
    assert.strictEqual(converter(0), 0);
    assert.strictEqual(converter(max), max);
    assert.strictEqual(converter('' + 0), 0);
    assert.strictEqual(converter('' + max), max);
    assert.strictEqual(converter(3), 3);
    assert.strictEqual(converter('' + 3), 3);
    assert.strictEqual(converter(3.1), 3);
    assert.strictEqual(converter(3.7), 3);

    assert.strictEqual(converter(max + 1), 0);
    assert.strictEqual(converter(max + 2), 1);
    assert.throws(() => converter(max + 1, { ...opts, enforceRange: true }), {
      name: 'TypeError',
      code: 'ERR_OUT_OF_RANGE',
      message: `${prefix}: ${context} is outside the expected range of 0 to ${max}.`,
    });

    assert.strictEqual(converter({}), 0);
    assert.strictEqual(converter(NaN), 0);
    assert.strictEqual(converter(false), 0);
    assert.strictEqual(converter(true), 1);
    assert.strictEqual(converter('1'), 1);
    assert.strictEqual(converter('0'), 0);
    assert.strictEqual(converter('{}'), 0);
    assert.strictEqual(converter({}), 0);
    assert.strictEqual(converter([]), 0);
    assert.strictEqual(converter(function() {}), 0);

    assert.throws(() => converter(Symbol(), opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: `${prefix}: ${context} is a Symbol and cannot be converted to a number.`
    });
    assert.throws(() => converter(0n, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: `${prefix}: ${context} is a BigInt and cannot be converted to a number.`
    });
  }
}

// DOMString
{
  assert.strictEqual(converters.DOMString(1), '1');
  assert.strictEqual(converters.DOMString(1n), '1');
  assert.strictEqual(converters.DOMString(false), 'false');
  assert.strictEqual(converters.DOMString(true), 'true');
  assert.strictEqual(converters.DOMString(undefined), 'undefined');
  assert.strictEqual(converters.DOMString(NaN), 'NaN');
  assert.strictEqual(converters.DOMString({}), '[object Object]');
  assert.strictEqual(converters.DOMString({ foo: 'bar' }), '[object Object]');
  assert.strictEqual(converters.DOMString([]), '');
  assert.strictEqual(converters.DOMString([1, 2]), '1,2');

  assert.throws(() => converters.DOMString(Symbol(), opts), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: `${prefix}: ${context} is a Symbol and cannot be converted to a string.`
  });
}

// object
{
  for (const good of [{}, [], new Array(), function() {}]) {
    assert.deepStrictEqual(converters.object(good), good);
  }

  for (const bad of [undefined, null, NaN, false, true, 0, 1, '', 'foo', Symbol(), 9n]) {
    assert.throws(() => converters.object(bad, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: `${prefix}: ${context} is not an object.`
    });
  }
}

// Uint8Array
{
  for (const good of [Buffer.alloc(0), new Uint8Array()]) {
    assert.deepStrictEqual(converters.Uint8Array(good), good);
  }

  for (const bad of [new ArrayBuffer(), new SharedArrayBuffer(), [], null, 'foo', undefined, true]) {
    assert.throws(() => converters.Uint8Array(bad, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: `${prefix}: ${context} is not an Uint8Array object.`
    });
  }

  assert.throws(() => converters.Uint8Array(new Uint8Array(new SharedArrayBuffer()), opts), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: `${prefix}: ${context} is a view on a SharedArrayBuffer, which is not allowed.`
  });
}

// BufferSource
{
  for (const good of [
    Buffer.alloc(0),
    new Uint8Array(),
    new ArrayBuffer(),
    new DataView(new ArrayBuffer()),
    new BigInt64Array(),
    new BigUint64Array(),
    new Float32Array(),
    new Float64Array(),
    new Int8Array(),
    new Int16Array(),
    new Int32Array(),
    new Uint8ClampedArray(),
    new Uint16Array(),
    new Uint32Array(),
  ]) {
    assert.deepStrictEqual(converters.BufferSource(good), good);
  }

  for (const bad of [new SharedArrayBuffer(), [], null, 'foo', undefined, true]) {
    assert.throws(() => converters.BufferSource(bad, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: `${prefix}: ${context} is not instance of ArrayBuffer, Buffer, TypedArray, or DataView.`
    });
  }

  assert.throws(() => converters.BufferSource(new Uint8Array(new SharedArrayBuffer()), opts), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: `${prefix}: ${context} is a view on a SharedArrayBuffer, which is not allowed.`
  });
}

// CryptoKey
{

  subtle.generateKey({ name: 'AES-CBC', length: 128 }, false, ['encrypt']).then((key) => {
    assert.deepStrictEqual(converters.CryptoKey(key), key);
  }).then(common.mustCall());

  for (const bad of [
    generateKeySync('aes', { length: 128 }),
    undefined, null, 1, {}, Symbol(), true, false, [],
  ]) {
    assert.throws(() => converters.CryptoKey(bad, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: `${prefix}: ${context} is not of type CryptoKey.`
    });
  }
}

// AlgorithmIdentifier (Union for (object or DOMString))
{
  assert.strictEqual(converters.AlgorithmIdentifier('foo'), 'foo');
  assert.deepStrictEqual(converters.AlgorithmIdentifier({ name: 'foo' }), { name: 'foo' });
}

// JsonWebKey
{
  for (const good of [
    {},
    { use: 'sig' },
    { key_ops: ['sign'] },
    { ext: true },
    { oth: [] },
    { oth: [{ r: '', d: '', t: '' }] },
  ]) {
    assert.deepStrictEqual(converters.JsonWebKey(good), good);
    assert.deepStrictEqual(converters.JsonWebKey({ ...good, filtered: 'out' }), good);
  }
}

// KeyFormat
{
  for (const good of ['jwk', 'spki', 'pkcs8', 'raw']) {
    assert.strictEqual(converters.KeyFormat(good), good);
  }

  for (const bad of ['foo', 1, false]) {
    assert.throws(() => converters.KeyFormat(bad, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: `${prefix}: ${context} value '${bad}' is not a valid enum value of type KeyFormat.`,
    });
  }
}

// KeyUsage
{
  for (const good of [
    'encrypt',
    'decrypt',
    'sign',
    'verify',
    'deriveKey',
    'deriveBits',
    'wrapKey',
    'unwrapKey',
  ]) {
    assert.strictEqual(converters.KeyUsage(good), good);
  }

  for (const bad of ['foo', 1, false]) {
    assert.throws(() => converters.KeyUsage(bad, opts), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: `${prefix}: ${context} value '${bad}' is not a valid enum value of type KeyUsage.`,
    });
  }
}

// Algorithm
{
  const good = { name: 'RSA-PSS' };
  assert.deepStrictEqual(converters.Algorithm({ ...good, filtered: 'out' }, opts), good);

  assert.throws(() => converters.Algorithm({}, opts), {
    name: 'TypeError',
    code: 'ERR_MISSING_OPTION',
    message: `${prefix}: ${context} can not be converted to 'Algorithm' because 'name' is required in 'Algorithm'.`,
  });
}

// RsaHashedKeyGenParams
{
  for (const good of [
    {
      name: 'RSA-OAEP',
      hash: { name: 'SHA-1' },
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
    },
    {
      name: 'RSA-OAEP',
      hash: 'SHA-1',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
    },
  ]) {
    assert.deepStrictEqual(converters.RsaHashedKeyGenParams({ ...good, filtered: 'out' }, opts), good);
    for (const required of ['hash', 'publicExponent', 'modulusLength']) {
      assert.throws(() => converters.RsaHashedKeyGenParams({ ...good, [required]: undefined }, opts), {
        name: 'TypeError',
        code: 'ERR_MISSING_OPTION',
        message: `${prefix}: ${context} can not be converted to 'RsaHashedKeyGenParams' because '${required}' is required in 'RsaHashedKeyGenParams'.`,
      });
    }
  }
}

// RsaHashedImportParams
{
  for (const good of [
    { name: 'RSA-OAEP', hash: { name: 'SHA-1' } },
    { name: 'RSA-OAEP', hash: 'SHA-1' },
  ]) {
    assert.deepStrictEqual(converters.RsaHashedImportParams({ ...good, filtered: 'out' }, opts), good);
    assert.throws(() => converters.RsaHashedImportParams({ ...good, hash: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to 'RsaHashedImportParams' because 'hash' is required in 'RsaHashedImportParams'.`,
    });
  }
}

// RsaPssParams
{
  const good = { name: 'RSA-PSS', saltLength: 20 };
  assert.deepStrictEqual(converters.RsaPssParams({ ...good, filtered: 'out' }, opts), good);

  assert.throws(() => converters.RsaPssParams({ ...good, saltLength: undefined }, opts), {
    name: 'TypeError',
    code: 'ERR_MISSING_OPTION',
    message: `${prefix}: ${context} can not be converted to 'RsaPssParams' because 'saltLength' is required in 'RsaPssParams'.`,
  });
}

// RsaOaepParams
{
  for (const good of [{ name: 'RSA-OAEP' }, { name: 'RSA-OAEP', label: Buffer.alloc(0) }]) {
    assert.deepStrictEqual(converters.RsaOaepParams({ ...good, filtered: 'out' }, opts), good);
  }
}

// EcKeyImportParams, EcKeyGenParams
{
  for (const name of ['EcKeyImportParams', 'EcKeyGenParams']) {
    const { [name]: converter } = converters;

    const good = { name: 'ECDSA', namedCurve: 'P-256' };
    assert.deepStrictEqual(converter({ ...good, filtered: 'out' }, opts), good);

    assert.throws(() => converter({ ...good, namedCurve: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to '${name}' because 'namedCurve' is required in '${name}'.`,
    });
  }
}

// EcdsaParams
{
  for (const good of [
    { name: 'ECDSA', hash: { name: 'SHA-1' } },
    { name: 'ECDSA', hash: 'SHA-1' },
  ]) {
    assert.deepStrictEqual(converters.EcdsaParams({ ...good, filtered: 'out' }, opts), good);
    assert.throws(() => converters.EcdsaParams({ ...good, hash: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to 'EcdsaParams' because 'hash' is required in 'EcdsaParams'.`,
    });
  }
}

// HmacKeyGenParams, HmacImportParams
{
  for (const name of ['HmacKeyGenParams', 'HmacImportParams']) {
    const { [name]: converter } = converters;

    for (const good of [
      { name: 'HMAC', hash: { name: 'SHA-1' } },
      { name: 'HMAC', hash: { name: 'SHA-1' }, length: 20 },
      { name: 'HMAC', hash: 'SHA-1' },
      { name: 'HMAC', hash: 'SHA-1', length: 20 },
    ]) {
      assert.deepStrictEqual(converter({ ...good, filtered: 'out' }, opts), good);
      assert.throws(() => converter({ ...good, hash: undefined }, opts), {
        name: 'TypeError',
        code: 'ERR_MISSING_OPTION',
        message: `${prefix}: ${context} can not be converted to '${name}' because 'hash' is required in '${name}'.`,
      });
    }
  }
}

// AesKeyGenParams, AesDerivedKeyParams
{
  for (const name of ['AesKeyGenParams', 'AesDerivedKeyParams']) {
    const { [name]: converter } = converters;

    const good = { name: 'AES-CBC', length: 128 };
    assert.deepStrictEqual(converter({ ...good, filtered: 'out' }, opts), good);

    assert.throws(() => converter({ ...good, length: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to '${name}' because 'length' is required in '${name}'.`,
    });
  }
}

// HkdfParams
{
  for (const good of [
    { name: 'HKDF', hash: { name: 'SHA-1' }, salt: Buffer.alloc(0), info: Buffer.alloc(0) },
    { name: 'HKDF', hash: 'SHA-1', salt: Buffer.alloc(0), info: Buffer.alloc(0) },
  ]) {
    assert.deepStrictEqual(converters.HkdfParams({ ...good, filtered: 'out' }, opts), good);
    for (const required of ['hash', 'salt', 'info']) {
      assert.throws(() => converters.HkdfParams({ ...good, [required]: undefined }, opts), {
        name: 'TypeError',
        code: 'ERR_MISSING_OPTION',
        message: `${prefix}: ${context} can not be converted to 'HkdfParams' because '${required}' is required in 'HkdfParams'.`,
      });
    }
  }
}

// Pbkdf2Params
{
  for (const good of [
    { name: 'PBKDF2', hash: { name: 'SHA-1' }, iterations: 5, salt: Buffer.alloc(0) },
    { name: 'PBKDF2', hash: 'SHA-1', iterations: 5, salt: Buffer.alloc(0) },
  ]) {
    assert.deepStrictEqual(converters.Pbkdf2Params({ ...good, filtered: 'out' }, opts), good);
    for (const required of ['hash', 'iterations', 'salt']) {
      assert.throws(() => converters.Pbkdf2Params({ ...good, [required]: undefined }, opts), {
        name: 'TypeError',
        code: 'ERR_MISSING_OPTION',
        message: `${prefix}: ${context} can not be converted to 'Pbkdf2Params' because '${required}' is required in 'Pbkdf2Params'.`,
      });
    }
  }
}

// AesCbcParams
{
  const good = { name: 'AES-CBC', iv: Buffer.alloc(0) };
  assert.deepStrictEqual(converters.AesCbcParams({ ...good, filtered: 'out' }, opts), good);

  assert.throws(() => converters.AesCbcParams({ ...good, iv: undefined }, opts), {
    name: 'TypeError',
    code: 'ERR_MISSING_OPTION',
    message: `${prefix}: ${context} can not be converted to 'AesCbcParams' because 'iv' is required in 'AesCbcParams'.`,
  });
}

// AesGcmParams
{
  for (const good of [
    { name: 'AES-GCM', iv: Buffer.alloc(0) },
    { name: 'AES-GCM', iv: Buffer.alloc(0), tagLength: 16 },
    { name: 'AES-GCM', iv: Buffer.alloc(0), tagLength: 16, additionalData: Buffer.alloc(0) },
  ]) {
    assert.deepStrictEqual(converters.AesGcmParams({ ...good, filtered: 'out' }, opts), good);

    assert.throws(() => converters.AesGcmParams({ ...good, iv: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to 'AesGcmParams' because 'iv' is required in 'AesGcmParams'.`,
    });
  }
}

// AesCtrParams
{
  const good = { name: 'AES-CTR', counter: Buffer.alloc(0), length: 20 };
  assert.deepStrictEqual(converters.AesCtrParams({ ...good, filtered: 'out' }, opts), good);

  for (const required of ['counter', 'length']) {
    assert.throws(() => converters.AesCtrParams({ ...good, [required]: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to 'AesCtrParams' because '${required}' is required in 'AesCtrParams'.`,
    });
  }
}

// EcdhKeyDeriveParams
{
  subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, false, ['deriveBits']).then((kp) => {
    const good = { name: 'ECDH', public: kp.publicKey };
    assert.deepStrictEqual(converters.EcdhKeyDeriveParams({ ...good, filtered: 'out' }, opts), good);

    assert.throws(() => converters.EcdhKeyDeriveParams({ ...good, public: undefined }, opts), {
      name: 'TypeError',
      code: 'ERR_MISSING_OPTION',
      message: `${prefix}: ${context} can not be converted to 'EcdhKeyDeriveParams' because 'public' is required in 'EcdhKeyDeriveParams'.`,
    });
  }).then(common.mustCall());
}

// Ed448Params
{
  for (const good of [
    { name: 'Ed448', context: new Uint8Array() },
    { name: 'Ed448' },
  ]) {
    assert.deepStrictEqual(converters.Ed448Params({ ...good, filtered: 'out' }, opts), good);
  }
}
                                               node-23.7.0/test/parallel/test-webcrypto-wrap-unwrap.js                                             0000664 0000000 0000000 00000015423 14746647661 0023147 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { subtle } = globalThis.crypto;

const kWrappingData = {
  'RSA-OAEP': {
    generate: {
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256',
    },
    wrap: { label: new Uint8Array(8) },
    pair: true
  },
  'AES-CTR': {
    generate: { length: 128 },
    wrap: { counter: new Uint8Array(16), length: 64 },
    pair: false
  },
  'AES-CBC': {
    generate: { length: 128 },
    wrap: { iv: new Uint8Array(16) },
    pair: false
  },
  'AES-GCM': {
    generate: { length: 128 },
    wrap: {
      iv: new Uint8Array(16),
      additionalData: new Uint8Array(16),
      tagLength: 64
    },
    pair: false
  },
  'AES-KW': {
    generate: { length: 128 },
    wrap: { },
    pair: false
  }
};

function generateWrappingKeys() {
  return Promise.all(Object.keys(kWrappingData).map(async (name) => {
    const keys = await subtle.generateKey(
      { name, ...kWrappingData[name].generate },
      true,
      ['wrapKey', 'unwrapKey']);
    if (kWrappingData[name].pair) {
      kWrappingData[name].wrappingKey = keys.publicKey;
      kWrappingData[name].unwrappingKey = keys.privateKey;
    } else {
      kWrappingData[name].wrappingKey = keys;
      kWrappingData[name].unwrappingKey = keys;
    }
  }));
}

async function generateKeysToWrap() {
  const parameters = [
    {
      algorithm: {
        name: 'RSASSA-PKCS1-v1_5',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      },
      privateUsages: ['sign'],
      publicUsages: ['verify'],
      pair: true,
    },
    {
      algorithm: {
        name: 'RSA-PSS',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      },
      privateUsages: ['sign'],
      publicUsages: ['verify'],
      pair: true,
    },
    {
      algorithm: {
        name: 'RSA-OAEP',
        modulusLength: 1024,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      },
      privateUsages: ['decrypt'],
      publicUsages: ['encrypt'],
      pair: true,
    },
    {
      algorithm: {
        name: 'ECDSA',
        namedCurve: 'P-384'
      },
      privateUsages: ['sign'],
      publicUsages: ['verify'],
      pair: true,
    },
    {
      algorithm: {
        name: 'ECDH',
        namedCurve: 'P-384'
      },
      privateUsages: ['deriveBits'],
      publicUsages: [],
      pair: true,
    },
    {
      algorithm: {
        name: 'Ed25519',
      },
      privateUsages: ['sign'],
      publicUsages: ['verify'],
      pair: true,
    },
    {
      algorithm: {
        name: 'Ed448',
      },
      privateUsages: ['sign'],
      publicUsages: ['verify'],
      pair: true,
    },
    {
      algorithm: {
        name: 'X25519',
      },
      privateUsages: ['deriveBits'],
      publicUsages: [],
      pair: true,
    },
    {
      algorithm: {
        name: 'X448',
      },
      privateUsages: ['deriveBits'],
      publicUsages: [],
      pair: true,
    },
    {
      algorithm: {
        name: 'AES-CTR',
        length: 128
      },
      usages: ['encrypt', 'decrypt'],
      pair: false,
    },
    {
      algorithm: {
        name: 'AES-CBC',
        length: 128
      },
      usages: ['encrypt', 'decrypt'],
      pair: false,
    },
    {
      algorithm: {
        name: 'AES-GCM', length: 128
      },
      usages: ['encrypt', 'decrypt'],
      pair: false,
    },
    {
      algorithm: {
        name: 'AES-KW',
        length: 128
      },
      usages: ['wrapKey', 'unwrapKey'],
      pair: false,
    },
    {
      algorithm: {
        name: 'HMAC',
        length: 128,
        hash: 'SHA-256'
      },
      usages: ['sign', 'verify'],
      pair: false,
    },
  ];

  const allkeys = await Promise.all(parameters.map(async (params) => {
    const usages = 'usages' in params ?
      params.usages :
      params.publicUsages.concat(params.privateUsages);

    const keys = await subtle.generateKey(params.algorithm, true, usages);

    if (params.pair) {
      return [
        {
          algorithm: params.algorithm,
          usages: params.publicUsages,
          key: keys.publicKey,
        },
        {
          algorithm: params.algorithm,
          usages: params.privateUsages,
          key: keys.privateKey,
        },
      ];
    }

    return [{
      algorithm: params.algorithm,
      usages: params.usages,
      key: keys,
    }];
  }));

  return allkeys.flat();
}

function getFormats(key) {
  switch (key.key.type) {
    case 'secret': return ['raw', 'jwk'];
    case 'public': return ['spki', 'jwk'];
    case 'private': return ['pkcs8', 'jwk'];
  }
}

// If the wrapping algorithm is AES-KW, the exported key
// material length must be a multiple of 8.
// If the wrapping algorithm is RSA-OAEP, the exported key
// material maximum length is a factor of the modulusLength
//
// As per the NOTE in step 13 https://w3c.github.io/webcrypto/#SubtleCrypto-method-wrapKey
// we're padding AES-KW wrapped JWK to make sure it is always a multiple of 8 bytes
// in length
async function wrappingIsPossible(name, exported) {
  if ('byteLength' in exported) {
    switch (name) {
      case 'AES-KW':
        return exported.byteLength % 8 === 0;
      case 'RSA-OAEP':
        return exported.byteLength <= 446;
    }
  } else if ('kty' in exported && name === 'RSA-OAEP') {
    return JSON.stringify(exported).length <= 478;
  }
  return true;
}

async function testWrap(wrappingKey, unwrappingKey, key, wrap, format) {
  const exported = await subtle.exportKey(format, key.key);
  if (!(await wrappingIsPossible(wrappingKey.algorithm.name, exported)))
    return;

  const wrapped =
    await subtle.wrapKey(
      format,
      key.key,
      wrappingKey,
      { name: wrappingKey.algorithm.name, ...wrap });
  const unwrapped =
    await subtle.unwrapKey(
      format,
      wrapped,
      unwrappingKey,
      { name: wrappingKey.algorithm.name, ...wrap },
      key.algorithm,
      true,
      key.usages);
  assert(unwrapped.extractable);

  const exportedAgain = await subtle.exportKey(format, unwrapped);
  assert.deepStrictEqual(exported, exportedAgain);
}

function testWrapping(name, keys) {
  const variations = [];

  const {
    wrappingKey,
    unwrappingKey,
    wrap
  } = kWrappingData[name];

  keys.forEach((key) => {
    getFormats(key).forEach((format) => {
      variations.push(testWrap(wrappingKey, unwrappingKey, key, wrap, format));
    });
  });

  return variations;
}

(async function() {
  await generateWrappingKeys();
  const keys = await generateKeysToWrap();
  const variations = [];
  Object.keys(kWrappingData).forEach((name) => {
    variations.push(...testWrapping(name, keys));
  });
  await Promise.all(variations);
})().then(common.mustCall());
                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-websocket-disabled.js                                                0000664 0000000 0000000 00000000325 14746647661 0022376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-experimental-websocket
'use strict';

require('../common');
const assert = require('assert');

assert.strictEqual(typeof WebSocket, 'undefined');
assert.strictEqual(typeof CloseEvent, 'undefined');
                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-websocket.js                                                         0000664 0000000 0000000 00000000255 14746647661 0020633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

assert.strictEqual(typeof WebSocket, 'function');
assert.strictEqual(typeof CloseEvent, 'function');
                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-webstorage.js                                                        0000664 0000000 0000000 00000011550 14746647661 0021007 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const tmpdir = require('../common/tmpdir');
const assert = require('node:assert');
const { join } = require('node:path');
const { readdir } = require('node:fs/promises');
const { test, describe } = require('node:test');
const { spawnPromisified } = common;
let cnt = 0;

tmpdir.refresh();

function nextLocalStorage() {
  return join(tmpdir.path, `${++cnt}.localstorage`);
}

test('disabled without --experimental-webstorage', async () => {
  for (const api of ['Storage', 'localStorage', 'sessionStorage']) {
    const cp = await spawnPromisified(process.execPath, ['-e', api]);

    assert.strictEqual(cp.code, 1);
    assert.strictEqual(cp.signal, null);
    assert.strictEqual(cp.stdout, '');
    assert(cp.stderr.includes(`ReferenceError: ${api} is not defined`));
  }
});

test('emits a warning when used', async () => {
  for (const api of ['Storage', 'localStorage', 'sessionStorage']) {
    const cp = await spawnPromisified(process.execPath, [
      '--experimental-webstorage',
      '--localstorage-file', nextLocalStorage(),
      '-e', api,
    ]);

    assert.strictEqual(cp.code, 0);
    assert.strictEqual(cp.signal, null);
    assert.strictEqual(cp.stdout, '');
    assert.match(cp.stderr, /ExperimentalWarning: Web Storage/);
  }
});

test('Storage instances cannot be created in userland', async () => {
  const cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage', '-e', 'new globalThis.Storage()',
  ]);

  assert.strictEqual(cp.code, 1);
  assert.strictEqual(cp.signal, null);
  assert.strictEqual(cp.stdout, '');
  assert.match(cp.stderr, /Error: Illegal constructor/);
});

test('sessionStorage is not persisted', async () => {
  let cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage', '-pe', 'sessionStorage.foo = "barbaz"',
  ]);
  assert.strictEqual(cp.code, 0);
  assert.match(cp.stdout, /barbaz/);

  cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage', '-pe', 'sessionStorage.foo',
  ]);
  assert.strictEqual(cp.code, 0);
  assert.match(cp.stdout, /undefined/);
  assert.strictEqual((await readdir(tmpdir.path)).length, 0);
});

test('localStorage throws without --localstorage-file ', async () => {
  const cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage',
    '-pe', 'localStorage === globalThis.localStorage',
  ]);
  assert.strictEqual(cp.code, 1);
  assert.strictEqual(cp.signal, null);
  assert.strictEqual(cp.stdout, '');
  assert.match(cp.stderr, /The argument '--localstorage-file' is an invalid localStorage location/);
});

test('localStorage is not persisted if it is unused', async () => {
  const cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage',
    '--localstorage-file', nextLocalStorage(),
    '-pe', 'localStorage === globalThis.localStorage',
  ]);
  assert.strictEqual(cp.code, 0);
  assert.match(cp.stdout, /true/);
  assert.strictEqual((await readdir(tmpdir.path)).length, 0);
});

test('localStorage is persisted if it is used', async () => {
  const localStorageFile = nextLocalStorage();
  let cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage',
    '--localstorage-file', localStorageFile,
    '-pe', 'localStorage.foo = "barbaz"',
  ]);
  assert.strictEqual(cp.code, 0);
  assert.match(cp.stdout, /barbaz/);
  const entries = await readdir(tmpdir.path);
  assert.strictEqual(entries.length, 1);
  assert.match(entries[0], /\d+\.localstorage/);

  cp = await spawnPromisified(process.execPath, [
    '--experimental-webstorage',
    '--localstorage-file', localStorageFile,
    '-pe', 'localStorage.foo',
  ]);
  assert.strictEqual(cp.code, 0);
  assert.match(cp.stdout, /barbaz/);
});


describe('webstorage quota for localStorage and sessionStorage', () => {
  const MAX_STORAGE_SIZE = 10 * 1024 * 1024;

  test('localStorage can store and retrieve a max of 10 MB quota', async () => {
    const localStorageFile = nextLocalStorage();
    const cp = await spawnPromisified(process.execPath, [
      '--experimental-webstorage',
      '--localstorage-file', localStorageFile,
      // Each character is 2 bytes
      '-pe', `
      localStorage['a'.repeat(${MAX_STORAGE_SIZE} / 2)] = '';
      console.error('filled');
      localStorage.anything = 'should fail';
      `,
    ]);

    assert.match(cp.stderr, /filled/);
    assert.match(cp.stderr, /QuotaExceededError: Setting the value exceeded the quota/);
  });

  test('sessionStorage can store a max of 10 MB quota', async () => {
    const cp = await spawnPromisified(process.execPath, [
      '--experimental-webstorage',
      // Each character is 2 bytes
      '-pe', `sessionStorage['a'.repeat(${MAX_STORAGE_SIZE} / 2)] = '';
      console.error('filled');
      sessionStorage.anything = 'should fail';
      `,
    ]);

    assert.match(cp.stderr, /filled/);
    assert.match(cp.stderr, /QuotaExceededError/);
  });
});
                                                                                                                                                        node-23.7.0/test/parallel/test-webstream-encoding-inspect.js                                        0000664 0000000 0000000 00000002002 14746647661 0024055 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const { TextEncoderStream, TextDecoderStream } = require('stream/web');
const util = require('util');
const assert = require('assert');

const textEncoderStream = new TextEncoderStream();
assert.strictEqual(
  util.inspect(textEncoderStream),
  `TextEncoderStream {
  encoding: 'utf-8',
  readable: ReadableStream { locked: false, state: 'readable', supportsBYOB: false },
  writable: WritableStream { locked: false, state: 'writable' }
}`
);
assert.throws(() => textEncoderStream[util.inspect.custom].call(), {
  code: 'ERR_INVALID_THIS',
});

const textDecoderStream = new TextDecoderStream();
assert.strictEqual(
  util.inspect(textDecoderStream),
  `TextDecoderStream {
  encoding: 'utf-8',
  fatal: false,
  ignoreBOM: false,
  readable: ReadableStream { locked: false, state: 'readable', supportsBYOB: false },
  writable: WritableStream { locked: false, state: 'writable' }
}`
);
assert.throws(() => textDecoderStream[util.inspect.custom].call(), {
  code: 'ERR_INVALID_THIS',
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-webstream-readable-from.js                                           0000664 0000000 0000000 00000000267 14746647661 0023337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('node:assert');

assert.throws(
  () => ReadableStream.from({}),
  { code: 'ERR_ARG_NOT_ITERABLE', name: 'TypeError' },
);
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-webstream-readablestream-pipeto.js                                   0000664 0000000 0000000 00000001331 14746647661 0025101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('node:assert');
const { AbortError } = require('internal/errors');

// Purpose: pass an AbortError instance, which isn't the DOMException, as an
// abort reason.

for (const message of [undefined, 'abc']) {
  const rs = new ReadableStream();
  const ws = new WritableStream();
  const ac = new AbortController();
  const reason = new AbortError(message);
  ac.abort(reason);

  assert.rejects(rs.pipeTo(ws, { signal: ac.signal }), (e) => {
    assert(e instanceof DOMException);
    assert.strictEqual(e.name, 'AbortError');
    assert.strictEqual(e.message, reason.message);
    return true;
  }).then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-webstream-string-tag.js                                              0000664 0000000 0000000 00000001533 14746647661 0022713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const assert = require('assert');

const classesToBeTested = [ WritableStream, WritableStreamDefaultWriter, WritableStreamDefaultController,
                            ReadableStream, ReadableStreamBYOBRequest, ReadableStreamDefaultReader,
                            ReadableStreamBYOBReader, ReadableStreamDefaultController, ReadableByteStreamController,
                            ByteLengthQueuingStrategy, CountQueuingStrategy, TransformStream,
                            TransformStreamDefaultController];


classesToBeTested.forEach((cls) => {
  assert.strictEqual(cls.prototype[Symbol.toStringTag], cls.name);
  assert.deepStrictEqual(Object.getOwnPropertyDescriptor(cls.prototype, Symbol.toStringTag),
                         { configurable: true, enumerable: false, value: cls.name, writable: false });
});
                                                                                                                                                                     node-23.7.0/test/parallel/test-webstream-structured-clone-no-leftovers.mjs                          0000664 0000000 0000000 00000001223 14746647661 0026730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import '../common/index.mjs';
import { test } from 'node:test';
import assert from 'node:assert';

test('do not leak promises', async () => {
  const buf = new Uint8Array(1);
  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(buf);
      controller.close();
    }
  });

  const [out1, out2] = readable.tee();
  const cloned = structuredClone(out2, { transfer: [out2] });

  for await (const chunk of cloned) {
    assert.deepStrictEqual(chunk, buf);
  }

  for await (const chunk of out2) {
    assert.deepStrictEqual(chunk, buf);
  }

  for await (const chunk of out1) {
    assert.deepStrictEqual(chunk, buf);
  }
});
                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-webstreams-abort-controller.js                                       0000664 0000000 0000000 00000010206 14746647661 0024304 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { finished, addAbortSignal } = require('stream');
const { ReadableStream, WritableStream } = require('stream/web');
const assert = require('assert');

function createTestReadableStream() {
  return new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
      controller.enqueue('c');
      controller.close();
    }
  });
}

function createTestWritableStream(values) {
  return new WritableStream({
    write(chunk) {
      values.push(chunk);
    }
  });
}

{
  const rs = createTestReadableStream();

  const reader = rs.getReader();

  const ac = new AbortController();

  addAbortSignal(ac.signal, rs);

  finished(rs, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(reader.read(), /AbortError/).then(common.mustCall());
    assert.rejects(reader.closed, /AbortError/).then(common.mustCall());
  }));

  reader.read().then(common.mustCall((result) => {
    assert.strictEqual(result.value, 'a');
    ac.abort();
  }));
}

{
  const rs = createTestReadableStream();

  const ac = new AbortController();

  addAbortSignal(ac.signal, rs);

  assert.rejects((async () => {
    for await (const chunk of rs) {
      if (chunk === 'b') {
        ac.abort();
      }
    }
  })(), /AbortError/).then(common.mustCall());
}

{
  const rs1 = createTestReadableStream();

  const rs2 = createTestReadableStream();

  const ac = new AbortController();

  addAbortSignal(ac.signal, rs1);
  addAbortSignal(ac.signal, rs2);

  const reader1 = rs1.getReader();
  const reader2 = rs2.getReader();

  finished(rs1, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(reader1.read(), /AbortError/).then(common.mustCall());
    assert.rejects(reader1.closed, /AbortError/).then(common.mustCall());
  }));

  finished(rs2, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(reader2.read(), /AbortError/).then(common.mustCall());
    assert.rejects(reader2.closed, /AbortError/).then(common.mustCall());
  }));

  ac.abort();
}

{
  const rs = createTestReadableStream();

  const { 0: rs1, 1: rs2 } = rs.tee();

  const ac = new AbortController();

  addAbortSignal(ac.signal, rs);

  const reader1 = rs1.getReader();
  const reader2 = rs2.getReader();

  finished(rs1, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(reader1.read(), /AbortError/).then(common.mustCall());
    assert.rejects(reader1.closed, /AbortError/).then(common.mustCall());
  }));

  finished(rs2, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(reader2.read(), /AbortError/).then(common.mustCall());
    assert.rejects(reader2.closed, /AbortError/).then(common.mustCall());
  }));

  ac.abort();
}

{
  const values = [];
  const ws = createTestWritableStream(values);

  const ac = new AbortController();

  addAbortSignal(ac.signal, ws);

  const writer = ws.getWriter();

  finished(ws, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.deepStrictEqual(values, ['a']);
    assert.rejects(writer.write('b'), /AbortError/).then(common.mustCall());
    assert.rejects(writer.closed, /AbortError/).then(common.mustCall());
  }));

  writer.write('a').then(() => {
    ac.abort();
  });
}

{
  const values = [];

  const ws1 = createTestWritableStream(values);
  const ws2 = createTestWritableStream(values);

  const ac = new AbortController();

  addAbortSignal(ac.signal, ws1);
  addAbortSignal(ac.signal, ws2);

  const writer1 = ws1.getWriter();
  const writer2 = ws2.getWriter();

  finished(ws1, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(writer1.write('a'), /AbortError/).then(common.mustCall());
    assert.rejects(writer1.closed, /AbortError/).then(common.mustCall());
  }));

  finished(ws2, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
    assert.rejects(writer2.write('a'), /AbortError/).then(common.mustCall());
    assert.rejects(writer2.closed, /AbortError/).then(common.mustCall());
  }));

  ac.abort();
}
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-webstreams-clone-unref.js                                            0000664 0000000 0000000 00000000727 14746647661 0023240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const { ok } = require('node:assert');

// This test verifies that cloned ReadableStream and WritableStream instances
// do not keep the process alive. The test fails if it timesout (it should just
// exit immediately)

const rs1 = new ReadableStream();
const ws1 = new WritableStream();

const [rs2, ws2] = structuredClone([rs1, ws1], { transfer: [rs1, ws1] });

ok(rs2 instanceof ReadableStream);
ok(ws2 instanceof WritableStream);
                                         node-23.7.0/test/parallel/test-webstreams-compose.js                                                0000664 0000000 0000000 00000023235 14746647661 0022467 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const {
  Transform,
  Readable,
  Writable,
  compose
} = require('stream');

const {
  TransformStream,
  ReadableStream,
  WritableStream,
} = require('stream/web');

{
  let res = '';

  const d = compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk?.toString()?.replace(' ', '_'));
      })
    }),
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk?.toString()?.toUpperCase());
      })
    })
  );

  d.on('data', common.mustCall((chunk) => {
    res += chunk;
  }));

  d.on('end', common.mustCall(() => {
    assert.strictEqual(res, 'HELLO_WORLD');
  }));

  d.end('hello world');
}

{
  let res = '';

  compose(
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk + chunk);
      })
    }),
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      })
    })
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASDASD');
  }));
}

{
  let res = '';

  compose(
    async function*(source) {
      for await (const chunk of source) {
        yield chunk + chunk;
      }
    },
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      }),
    })
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASDASD');
  }));
}

{
  let res = '';

  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      }),
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk + chunk;
      }
    },
    new Transform({
      transform: common.mustCall((chunk, enc, clb) => {
        clb(null, chunk?.toString()?.replaceAll('A', 'B'));
      })
    })
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'BSDBSD');
  }));
}

{
  let res = '';

  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      }),
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk + chunk;
      }
    },
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk?.toString()?.replaceAll('A', 'B'));
      })
    })
  )
  .end('asd')
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'BSDBSD');
  }));
}

{
  let res = '';
  compose(
    new ReadableStream({
      start(controller) {
        controller.enqueue('asd');
        controller.close();
      }
    }),
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk?.toString()?.toUpperCase());
      })
    })
  )
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    new ReadableStream({
      start(controller) {
        controller.enqueue('asd');
        controller.close();
      }
    }),
    new Transform({
      transform: common.mustCall((chunk, enc, clb) => {
        clb(null, chunk?.toString()?.toUpperCase());
      })
    })
  )
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    Readable.from(['asd']),
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk?.toString()?.toUpperCase());
      })
    })
  )
  .on('data', common.mustCall((buf) => {
    res += buf;
  }))
  .on('end', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    new Writable({
      write: common.mustCall((chunk, encoding, callback) => {
        res += chunk;
        callback(null);
      })
    })
  )
    .end('asd')
    .on('finish', common.mustCall(() => {
      assert.strictEqual(res, 'ASD');
    }));
}

{
  let res = '';
  compose(
    new Transform({
      transform: common.mustCall((chunk, encoding, callback) => {
        callback(null, chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    new WritableStream({
      write: common.mustCall((chunk) => {
        res += chunk;
      })
    })
  )
  .end('asd')
  .on('finish', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    new WritableStream({
      write: common.mustCall((chunk) => {
        res += chunk;
      })
    })
  )
  .end('asd')
  .on('finish', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{
  let res = '';
  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    async function(source) {
      for await (const chunk of source) {
        res += chunk;
      }
    }
  )
  .end('asd')
  .on('finish', common.mustCall(() => {
    assert.strictEqual(res, 'ASD');
  }));
}

{

  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.error(new Error('asd'));
      })
    }),
    new TransformStream({
      transform: common.mustNotCall()
    })
  )
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{

  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk);
      })
    }),
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.error(new Error('asd'));
      })
    })
  )
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{

  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk);
      })
    }),
    async function*(source) { // eslint-disable-line require-yield
      let tmp = '';
      for await (const chunk of source) {
        tmp += chunk;
        throw new Error('asd');
      }
      return tmp;
    },
    new TransformStream({
      transform: common.mustNotCall()
    })
  )
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{

  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.error(new Error('asd'));
      })
    }),
    new Transform({
      transform: common.mustNotCall()
    })
  )
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{

  compose(
    new Transform({
      transform: common.mustCall((chunk, enc, clb) => {
        clb(new Error('asd'));
      })
    }),
    new TransformStream({
      transform: common.mustNotCall()
    })
  )
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{
  compose(
    new ReadableStream({
      start(controller) {
        controller.enqueue(new Error('asd'));
      }
    }),
    new TransformStream({
      transform: common.mustNotCall()
    })
  )
  .on('data', common.mustNotCall())
  .on('end', common.mustNotCall())
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{
  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      })
    }),
    new WritableStream({
      write: common.mustCall((chunk, controller) => {
        controller.error(new Error('asd'));
      })
    })
  )
  .on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  })
  .end('xyz');
}

{
  compose(
    new TransformStream({
      transform: common.mustCall((chunk, controller) => {
        controller.enqueue(chunk.toString().toUpperCase());
      })
    }),
    async function*(source) {
      for await (const chunk of source) {
        yield chunk;
      }
    },
    async function(source) {
      throw new Error('asd');
    }
  ).on('error', (err) => {
    assert.strictEqual(err?.message, 'asd');
  }).end('xyz');
}
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-webstreams-finished.js                                               0000664 0000000 0000000 00000014302 14746647661 0022606 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { ReadableStream, WritableStream } = require('stream/web');
const { finished } = require('stream');
const { finished: finishedPromise } = require('stream/promises');

{
  const rs = new ReadableStream({
    start(controller) {
      controller.enqueue('asd');
      controller.close();
    },
  });
  finished(rs, common.mustSucceed());
  async function test() {
    const values = [];
    for await (const chunk of rs) {
      values.push(chunk);
    }
    assert.deepStrictEqual(values, ['asd']);
  }
  test();
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.error(new Error('asd'));
    }
  });

  finished(rs, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));
}

{
  const rs = new ReadableStream({
    async start(controller) {
      throw new Error('asd');
    }
  });

  finished(rs, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.enqueue('asd');
      controller.close();
    }
  });

  async function test() {
    const values = [];
    for await (const chunk of rs) {
      values.push(chunk);
    }
    assert.deepStrictEqual(values, ['asd']);
  }

  finishedPromise(rs).then(common.mustSucceed());

  test();
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.error(new Error('asd'));
    }
  });

  finishedPromise(rs).then(common.mustNotCall()).catch(common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));
}

{
  const rs = new ReadableStream({
    async start(controller) {
      throw new Error('asd');
    }
  });

  finishedPromise(rs).then(common.mustNotCall()).catch(common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.enqueue('asd');
      controller.close();
    }
  });

  const { 0: s1, 1: s2 } = rs.tee();

  finished(s1, common.mustSucceed());
  finished(s2, common.mustSucceed());

  async function test(stream) {
    const values = [];
    for await (const chunk of stream) {
      values.push(chunk);
    }
    assert.deepStrictEqual(values, ['asd']);
  }

  Promise.all([
    test(s1),
    test(s2),
  ]).then(common.mustCall());
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.error(new Error('asd'));
    }
  });

  const { 0: s1, 1: s2 } = rs.tee();

  finished(s1, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));

  finished(s2, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.enqueue('asd');
      controller.close();
    }
  });

  finished(rs, common.mustSucceed());

  rs.cancel();
}

{
  let str = '';
  const ws = new WritableStream({
    write(chunk) {
      str += chunk;
    }
  });

  finished(ws, common.mustSucceed(() => {
    assert.strictEqual(str, 'asd');
  }));

  const writer = ws.getWriter();
  writer.write('asd');
  writer.close();
}

{
  const ws = new WritableStream({
    async write(chunk) {
      throw new Error('asd');
    }
  });

  finished(ws, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));

  const writer = ws.getWriter();
  writer.write('asd').catch((err) => {
    assert.strictEqual(err?.message, 'asd');
  });
}

{
  let str = '';
  const ws = new WritableStream({
    write(chunk) {
      str += chunk;
    }
  });

  finishedPromise(ws).then(common.mustSucceed(() => {
    assert.strictEqual(str, 'asd');
  }));

  const writer = ws.getWriter();
  writer.write('asd');
  writer.close();
}

{
  const ws = new WritableStream({
    write(chunk) { }
  });
  finished(ws, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));

  const writer = ws.getWriter();
  writer.abort(new Error('asd'));
}

{
  const ws = new WritableStream({
    async write(chunk) {
      throw new Error('asd');
    }
  });

  finishedPromise(ws).then(common.mustNotCall()).catch(common.mustCall((err) => {
    assert.strictEqual(err?.message, 'asd');
  }));

  const writer = ws.getWriter();
  writer.write('asd').catch((err) => {
    assert.strictEqual(err?.message, 'asd');
  });
}

{
  // Check pre-cancelled
  const signal = new EventTarget();
  signal.aborted = true;

  const rs = new ReadableStream({
    start() {}
  });
  finished(rs, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
}

{
  // Check cancelled before the stream ends sync.
  const ac = new AbortController();
  const { signal } = ac;

  const rs = new ReadableStream({
    start() {}
  });
  finished(rs, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  ac.abort();
}

{
  // Check cancelled before the stream ends async.
  const ac = new AbortController();
  const { signal } = ac;

  const rs = new ReadableStream({
    start() {}
  });
  setTimeout(() => ac.abort(), 1);
  finished(rs, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
}

{
  // Check cancelled after doesn't throw.
  const ac = new AbortController();
  const { signal } = ac;

  const rs = new ReadableStream({
    start(controller) {
      controller.enqueue('asd');
      controller.close();
    }
  });
  finished(rs, { signal }, common.mustSucceed());

  rs.getReader().read().then(common.mustCall((chunk) => {
    assert.strictEqual(chunk.value, 'asd');
    setImmediate(() => ac.abort());
  }));
}

{
  // Promisified abort works
  async function run() {
    const ac = new AbortController();
    const { signal } = ac;
    const rs = new ReadableStream({
      start() {}
    });
    setImmediate(() => ac.abort());
    await finishedPromise(rs, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}

{
  // Promisified pre-aborted works
  async function run() {
    const signal = new EventTarget();
    signal.aborted = true;
    const rs = new ReadableStream({
      start() {}
    });
    await finishedPromise(rs, { signal });
  }

  assert.rejects(run, { name: 'AbortError' }).then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-webstreams-pipeline.js                                               0000664 0000000 0000000 00000017514 14746647661 0022632 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { Readable, Writable, Transform, pipeline, PassThrough } = require('stream');
const { pipeline: pipelinePromise } = require('stream/promises');
const { ReadableStream, WritableStream, TransformStream } = require('stream/web');
const http = require('http');

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });
  const ws = new WritableStream({
    write(chunk) {
      values.push(chunk);
    }
  });

  pipeline(rs, ws, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['hello', 'world']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ws = new WritableStream({
    write() { }
  });

  pipeline(rs, ws, common.mustCall((err) => {
    assert.strictEqual(err?.message, 'kaboom');
  }));

  c.error(new Error('kaboom'));
}

{
  let c;
  const values = [];
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ts = new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk?.toString().toUpperCase());
    }
  });

  const ws = new WritableStream({
    write(chunk) {
      values.push(chunk?.toString());
    }
  });

  pipeline(rs, ts, ws, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['HELLO', 'WORLD']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  function makeTransformStream() {
    return new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk?.toString());
      }
    });
  }

  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ws = new WritableStream({
    write() { }
  });

  pipeline(rs,
           makeTransformStream(),
           makeTransformStream(),
           makeTransformStream(),
           makeTransformStream(),
           ws,
           common.mustCall((err) => {
             assert.strictEqual(err?.message, 'kaboom');
           }));

  c.error(new Error('kaboom'));
}

{
  const values = [];

  const r = new Readable({
    read() { }
  });

  const ws = new WritableStream({
    write(chunk) {
      values.push(chunk?.toString());
    }
  });

  pipeline(r, ws, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['helloworld']);
  }));

  r.push('hello');
  r.push('world');
  r.push(null);
}

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const w = new Writable({
    write(chunk, encoding, callback) {
      values.push(chunk?.toString());
      callback();
    }
  });

  pipeline(rs, w, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['hello', 'world']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ws = new WritableStream({
    write(chunk) {
      values.push(chunk?.toString());
    }
  });

  const t = new Transform({
    transform(chunk, encoding, callback) {
      callback(null, chunk?.toString().toUpperCase());
    }
  });

  pipeline(rs, t, ws, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['HELLOWORLD']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  const server = http.createServer((req, res) => {
    const rs = new ReadableStream({
      start(controller) {
        controller.enqueue('hello');
        controller.enqueue('world');
        controller.close();
      }
    });
    pipeline(rs, res, common.mustSucceed(() => {}));
  });

  server.listen(0, common.mustCall(() => {
    const req = http.request({
      port: server.address().port
    });
    req.end();
    const values = [];
    req.on('response', (res) => {
      res.on('data', (chunk) => {
        values.push(chunk?.toString());
      });
      res.on('end', common.mustCall(() => {
        assert.deepStrictEqual(values, ['hello', 'world']);
        server.close();
      }));
    });
  }));
}

{
  const values = [];
  const server = http.createServer((req, res) => {
    const ts = new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk?.toString().toUpperCase());
      }
    });
    pipeline(req, ts, res, common.mustSucceed());
  });

  server.listen(0, () => {
    const req = http.request({
      port: server.address().port,
      method: 'POST',
    });


    const rs = new ReadableStream({
      start(controller) {
        controller.enqueue('hello');
        controller.close();
      }
    });

    pipeline(rs, req, common.mustSucceed());

    req.on('response', (res) => {
      res.on('data', (chunk) => {
        values.push(chunk?.toString());
      }
      );
      res.on('end', common.mustCall(() => {
        assert.deepStrictEqual(values, ['HELLO']);
        server.close();
      }));
    });
  });
}

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });
  const ws = new WritableStream({
    write(chunk) {
      values.push(chunk?.toString());
    }
  });

  pipelinePromise(rs, ws).then(common.mustCall(() => {
    assert.deepStrictEqual(values, ['hello', 'world']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ws = new WritableStream({
    write() { }
  });

  pipelinePromise(rs, ws).then(common.mustNotCall()).catch(common.mustCall((err) => {
    assert.strictEqual(err?.message, 'kaboom');
  }));

  c.error(new Error('kaboom'));
}

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  pipeline(rs, async function(source) {
    for await (const chunk of source) {
      values.push(chunk?.toString());
    }
  }, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['hello', 'world']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  const rs = new ReadableStream({
    start() {}
  });

  pipeline(rs, async function(source) {
    throw new Error('kaboom');
  }, (err) => {
    assert.strictEqual(err?.message, 'kaboom');
  });
}

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ts = new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk?.toString().toUpperCase());
    }
  });

  pipeline(rs, ts, async function(source) {
    for await (const chunk of source) {
      values.push(chunk?.toString());
    }
  }, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['HELLO', 'WORLD']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  const values = [];
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ws = new WritableStream({
    write(chunk) {
      values.push(chunk?.toString());
    }
  });

  pipeline(rs, async function* (source) {
    for await (const chunk of source) {
      yield chunk?.toString().toUpperCase();
    }
  }, ws, common.mustSucceed(() => {
    assert.deepStrictEqual(values, ['HELLO', 'WORLD']);
  }));

  c.enqueue('hello');
  c.enqueue('world');
  c.close();
}

{
  let c;
  const rs = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const ws = new WritableStream({
    write(chunk) { }
  }, { highWaterMark: 0 });

  pipeline(rs, ws, common.mustNotCall());

  for (let i = 0; i < 10; i++) {
    c.enqueue(`${i}`);
  }
  c.close();
}

{
  const rs = new ReadableStream({
    start(controller) {
      controller.close();
    }
  });

  pipeline(rs, new PassThrough(), common.mustSucceed());
}
                                                                                                                                                                                    node-23.7.0/test/parallel/test-whatwg-encoding-custom-api-basics.js                                 0000664 0000000 0000000 00000003061 14746647661 0025251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// From: https://github.com/w3c/web-platform-tests/blob/master/encoding/api-basics.html
// This is the part that can be run without ICU

require('../common');

const assert = require('assert');

function testDecodeSample(encoding, string, bytes) {
  assert.strictEqual(
    new TextDecoder(encoding).decode(new Uint8Array(bytes)),
    string);
  assert.strictEqual(
    new TextDecoder(encoding).decode(new Uint8Array(bytes).buffer),
    string);
}

// `z` (ASCII U+007A), cent (Latin-1 U+00A2), CJK water (BMP U+6C34),
// G-Clef (non-BMP U+1D11E), PUA (BMP U+F8FF), PUA (non-BMP U+10FFFD)
// byte-swapped BOM (non-character U+FFFE)
const sample = 'z\xA2\u6C34\uD834\uDD1E\uF8FF\uDBFF\uDFFD\uFFFE';

{
  const encoding = 'utf-8';
  const string = sample;
  const bytes = [
    0x7A, 0xC2, 0xA2, 0xE6, 0xB0, 0xB4,
    0xF0, 0x9D, 0x84, 0x9E, 0xEF, 0xA3,
    0xBF, 0xF4, 0x8F, 0xBF, 0xBD, 0xEF,
    0xBF, 0xBE,
  ];
  const encoded = new TextEncoder().encode(string);
  assert.deepStrictEqual([].slice.call(encoded), bytes);
  assert.strictEqual(
    new TextDecoder(encoding).decode(new Uint8Array(bytes)),
    string);
  assert.strictEqual(
    new TextDecoder(encoding).decode(new Uint8Array(bytes).buffer),
    string);
}

testDecodeSample(
  'utf-16le',
  sample,
  [
    0x7A, 0x00, 0xA2, 0x00, 0x34, 0x6C,
    0x34, 0xD8, 0x1E, 0xDD, 0xFF, 0xF8,
    0xFF, 0xDB, 0xFD, 0xDF, 0xFE, 0xFF,
  ]
);

testDecodeSample(
  'utf-16',
  sample,
  [
    0x7A, 0x00, 0xA2, 0x00, 0x34, 0x6C,
    0x34, 0xD8, 0x1E, 0xDD, 0xFF, 0xF8,
    0xFF, 0xDB, 0xFD, 0xDF, 0xFE, 0xFF,
  ]
);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-whatwg-encoding-custom-fatal-streaming.js                            0000664 0000000 0000000 00000003073 14746647661 0026317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// From: https://github.com/w3c/web-platform-tests/blob/d74324b53c/encoding/textdecoder-fatal-streaming.html
// With the twist that we specifically test for Node.js error codes

const common = require('../common');
const assert = require('assert');

if (!common.hasIntl)
  common.skip('missing Intl');

{
  [
    { encoding: 'utf-8', sequence: [0xC0] },
    { encoding: 'utf-16le', sequence: [0x00] },
    { encoding: 'utf-16be', sequence: [0x00] },
  ].forEach((testCase) => {
    const data = new Uint8Array([testCase.sequence]);
    assert.throws(
      () => {
        const decoder = new TextDecoder(testCase.encoding, { fatal: true });
        decoder.decode(data);
      }, {
        code: 'ERR_ENCODING_INVALID_ENCODED_DATA',
        name: 'TypeError',
        message:
          `The encoded data was not valid for encoding ${testCase.encoding}`
      }
    );
  });
}

{
  const decoder = new TextDecoder('utf-16le', { fatal: true });
  const odd = new Uint8Array([0x00]);
  const even = new Uint8Array([0x00, 0x00]);

  assert.throws(
    () => {
      decoder.decode(even, { stream: true });
      decoder.decode(odd);
    }, {
      code: 'ERR_ENCODING_INVALID_ENCODED_DATA',
      name: 'TypeError',
      message:
        'The encoded data was not valid for encoding utf-16le'
    }
  );

  assert.throws(
    () => {
      decoder.decode(odd, { stream: true });
      decoder.decode(even);
    }, {
      code: 'ERR_ENCODING_INVALID_ENCODED_DATA',
      name: 'TypeError',
      message:
        'The encoded data was not valid for encoding utf-16le'
    }
  );
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-whatwg-encoding-custom-internals.js                                  0000664 0000000 0000000 00000012171 14746647661 0025237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

// This tests internal mapping of the Node.js encoding implementation

require('../common');

const assert = require('assert');
const { getEncodingFromLabel } = require('internal/encoding');

// Test Encoding Mappings
{
  const mappings = {
    'utf-8': [
      'unicode-1-1-utf-8',
      'unicode11utf8',
      'unicode20utf8',
      'utf8',
      'x-unicode20utf8',
    ],
    'utf-16be': [
      'unicodefffe',
    ],
    'utf-16le': [
      'csunicode',
      'iso-10646-ucs-2',
      'ucs-2',
      'unicode',
      'unicodefeff',
      'utf-16',
    ],
    'ibm866': [
      '866',
      'cp866',
      'csibm866',
    ],
    'iso-8859-2': [
      'csisolatin2',
      'iso-ir-101',
      'iso8859-2',
      'iso88592',
      'iso_8859-2',
      'iso_8859-2:1987',
      'l2',
      'latin2',
    ],
    'iso-8859-3': [
      'csisolatin3',
      'iso-ir-109',
      'iso8859-3',
      'iso88593',
      'iso_8859-3',
      'iso_8859-3:1988',
      'l3',
      'latin3',
    ],
    'iso-8859-4': [
      'csisolatin4',
      'iso-ir-110',
      'iso8859-4',
      'iso88594',
      'iso_8859-4',
      'iso_8859-4:1988',
      'l4',
      'latin4',
    ],
    'iso-8859-5': [
      'csisolatincyrillic',
      'cyrillic',
      'iso-ir-144',
      'iso8859-5',
      'iso88595',
      'iso_8859-5',
      'iso_8859-5:1988',
    ],
    'iso-8859-6': [
      'arabic',
      'asmo-708',
      'csiso88596e',
      'csiso88596i',
      'csisolatinarabic',
      'ecma-114',
      'iso-8859-6-e',
      'iso-8859-6-i',
      'iso-ir-127',
      'iso8859-6',
      'iso88596',
      'iso_8859-6',
      'iso_8859-6:1987',
    ],
    'iso-8859-7': [
      'csisolatingreek',
      'ecma-118',
      'elot_928',
      'greek',
      'greek8',
      'iso-ir-126',
      'iso8859-7',
      'iso88597',
      'iso_8859-7',
      'iso_8859-7:1987',
      'sun_eu_greek',
    ],
    'iso-8859-8': [
      'csiso88598e',
      'csisolatinhebrew',
      'hebrew',
      'iso-8859-8-e',
      'iso-ir-138',
      'iso8859-8',
      'iso88598',
      'iso_8859-8',
      'iso_8859-8:1988',
      'visual',
    ],
    'iso-8859-8-i': [
      'csiso88598i',
      'logical',
    ],
    'iso-8859-10': [
      'csisolatin6',
      'iso-ir-157',
      'iso8859-10',
      'iso885910',
      'l6',
      'latin6',
    ],
    'iso-8859-13': [
      'iso8859-13',
      'iso885913',
    ],
    'iso-8859-14': [
      'iso8859-14',
      'iso885914',
    ],
    'iso-8859-15': [
      'csisolatin9',
      'iso8859-15',
      'iso885915',
      'iso_8859-15',
      'l9',
    ],
    'koi8-r': [
      'cskoi8r',
      'koi',
      'koi8',
      'koi8_r',
    ],
    'koi8-u': [
      'koi8-ru',
    ],
    'macintosh': [
      'csmacintosh',
      'mac',
      'x-mac-roman',
    ],
    'windows-874': [
      'dos-874',
      'iso-8859-11',
      'iso8859-11',
      'iso885911',
      'tis-620',
    ],
    'windows-1250': [
      'cp1250',
      'x-cp1250',
    ],
    'windows-1251': [
      'cp1251',
      'x-cp1251',
    ],
    'windows-1252': [
      'ansi_x3.4-1968',
      'ascii',
      'cp1252',
      'cp819',
      'csisolatin1',
      'ibm819',
      'iso-8859-1',
      'iso-ir-100',
      'iso8859-1',
      'iso88591',
      'iso_8859-1',
      'iso_8859-1:1987',
      'l1',
      'latin1',
      'us-ascii',
      'x-cp1252',
    ],
    'windows-1253': [
      'cp1253',
      'x-cp1253',
    ],
    'windows-1254': [
      'cp1254',
      'csisolatin5',
      'iso-8859-9',
      'iso-ir-148',
      'iso8859-9',
      'iso88599',
      'iso_8859-9',
      'iso_8859-9:1989',
      'l5',
      'latin5',
      'x-cp1254',
    ],
    'windows-1255': [
      'cp1255',
      'x-cp1255',
    ],
    'windows-1256': [
      'cp1256',
      'x-cp1256',
    ],
    'windows-1257': [
      'cp1257',
      'x-cp1257',
    ],
    'windows-1258': [
      'cp1258',
      'x-cp1258',
    ],
    'x-mac-cyrillic': [
      'x-mac-ukrainian',
    ],
    'gbk': [
      'chinese',
      'csgb2312',
      'csiso58gb231280',
      'gb2312',
      'gb_2312',
      'gb_2312-80',
      'iso-ir-58',
      'x-gbk',
    ],
    'gb18030': [ ],
    'big5': [
      'big5-hkscs',
      'cn-big5',
      'csbig5',
      'x-x-big5',
    ],
    'euc-jp': [
      'cseucpkdfmtjapanese',
      'x-euc-jp',
    ],
    'iso-2022-jp': [
      'csiso2022jp',
    ],
    'shift_jis': [
      'csshiftjis',
      'ms932',
      'ms_kanji',
      'shift-jis',
      'sjis',
      'windows-31j',
      'x-sjis',
    ],
    'euc-kr': [
      '  euc-kr  \t',
      'EUC-kr  \n',
      'cseuckr',
      'csksc56011987',
      'iso-ir-149',
      'korean',
      'ks_c_5601-1987',
      'ks_c_5601-1989',
      'ksc5601',
      'ksc_5601',
      'windows-949',
    ],
    'replacement': [
      'csiso2022kr',
      'hz-gb-2312',
      'iso-2022-cn',
      'iso-2022-cn-ext',
      'iso-2022-kr',
    ],
    'x-user-defined': []
  };
  Object.entries(mappings).forEach((i) => {
    const enc = i[0];
    const labels = i[1];
    assert.strictEqual(getEncodingFromLabel(enc), enc);
    labels.forEach((l) => assert.strictEqual(getEncodingFromLabel(l), enc));
  });

  assert.strictEqual(getEncodingFromLabel('made-up'), undefined);
}
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-whatwg-encoding-custom-interop.js                                    0000664 0000000 0000000 00000003226 14746647661 0024721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals

// This tests interoperability between TextEncoder and TextDecoder with
// Node.js util.inspect and Buffer APIs

'use strict';

require('../common');

const assert = require('assert');
const { customInspectSymbol: inspect } = require('internal/util');

const encoded = Buffer.from([0xef, 0xbb, 0xbf, 0x74, 0x65,
                             0x73, 0x74, 0xe2, 0x82, 0xac]);

// Make Sure TextEncoder exists
assert(TextEncoder);

// Test TextEncoder
{
  const enc = new TextEncoder();
  assert.strictEqual(enc.encoding, 'utf-8');
  assert(enc);
  const buf = enc.encode('\ufefftest€');
  assert.strictEqual(Buffer.compare(buf, encoded), 0);
}

{
  const enc = new TextEncoder();
  const buf = enc.encode();
  assert.strictEqual(buf.length, 0);
}

{
  const enc = new TextEncoder();
  const buf = enc.encode(undefined);
  assert.strictEqual(buf.length, 0);
}

{
  const inspectFn = TextEncoder.prototype[inspect];
  const encodeFn = TextEncoder.prototype.encode;
  const encodingGetter =
    Object.getOwnPropertyDescriptor(TextEncoder.prototype, 'encoding').get;

  const instance = new TextEncoder();

  const expectedError = {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type TextEncoder'
  };

  inspectFn.call(instance, Infinity, {});
  encodeFn.call(instance);
  encodingGetter.call(instance);

  const invalidThisArgs = [{}, [], true, 1, '', new TextDecoder()];
  for (const i of invalidThisArgs) {
    assert.throws(() => inspectFn.call(i, Infinity, {}), expectedError);
    assert.throws(() => encodeFn.call(i), expectedError);
    assert.throws(() => encodingGetter.call(i), expectedError);
  }
}
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder-api-invalid-label.js              0000664 0000000 0000000 00000002026 14746647661 0031020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// From: https://github.com/w3c/web-platform-tests/blob/master/encoding/api-invalid-label.html
// With the twist that we specifically test for Node.js error codes

require('../common');
const assert = require('assert');

[
  'utf-8',
  'unicode-1-1-utf-8',
  'unicode11utf8',
  'unicode20utf8',
  'x-unicode20utf8',
  'utf8',
  'unicodefffe',
  'utf-16be',
  'csunicode',
  'iso-10646-ucs-2',
  'ucs-2',
  'unicode',
  'unicodefeff',
  'utf-16le',
  'utf-16',
].forEach((i) => {
  ['\u0000', '\u000b', '\u00a0', '\u2028', '\u2029'].forEach((ws) => {
    assert.throws(
      () => new TextDecoder(`${ws}${i}`),
      {
        code: 'ERR_ENCODING_NOT_SUPPORTED',
        name: 'RangeError'
      }
    );

    assert.throws(
      () => new TextDecoder(`${i}${ws}`),
      {
        code: 'ERR_ENCODING_NOT_SUPPORTED',
        name: 'RangeError'
      }
    );

    assert.throws(
      () => new TextDecoder(`${ws}${i}${ws}`),
      {
        code: 'ERR_ENCODING_NOT_SUPPORTED',
        name: 'RangeError'
      }
    );
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder-fatal.js                          0000664 0000000 0000000 00000007307 14746647661 0026644 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// From: https://github.com/w3c/web-platform-tests/blob/39a67e2fff/encoding/textdecoder-fatal.html
// With the twist that we specifically test for Node.js error codes

const common = require('../common');

if (!common.hasIntl)
  common.skip('missing Intl');

const assert = require('assert');

const bad = [
  { encoding: 'utf-8', input: [0xFF], name: 'invalid code' },
  { encoding: 'utf-8', input: [0xC0], name: 'ends early' },
  { encoding: 'utf-8', input: [0xE0], name: 'ends early 2' },
  { encoding: 'utf-8', input: [0xC0, 0x00], name: 'invalid trail' },
  { encoding: 'utf-8', input: [0xC0, 0xC0], name: 'invalid trail 2' },
  { encoding: 'utf-8', input: [0xE0, 0x00], name: 'invalid trail 3' },
  { encoding: 'utf-8', input: [0xE0, 0xC0], name: 'invalid trail 4' },
  { encoding: 'utf-8', input: [0xE0, 0x80, 0x00], name: 'invalid trail 5' },
  { encoding: 'utf-8', input: [0xE0, 0x80, 0xC0], name: 'invalid trail 6' },
  { encoding: 'utf-8', input: [0xFC, 0x80, 0x80, 0x80, 0x80, 0x80],
    name: '> 0x10FFFF' },
  { encoding: 'utf-8', input: [0xFE, 0x80, 0x80, 0x80, 0x80, 0x80],
    name: 'obsolete lead byte' },
  // Overlong encodings
  { encoding: 'utf-8', input: [0xC0, 0x80], name: 'overlong U+0000 - 2 bytes' },
  { encoding: 'utf-8', input: [0xE0, 0x80, 0x80],
    name: 'overlong U+0000 - 3 bytes' },
  { encoding: 'utf-8', input: [0xF0, 0x80, 0x80, 0x80],
    name: 'overlong U+0000 - 4 bytes' },
  { encoding: 'utf-8', input: [0xF8, 0x80, 0x80, 0x80, 0x80],
    name: 'overlong U+0000 - 5 bytes' },
  { encoding: 'utf-8', input: [0xFC, 0x80, 0x80, 0x80, 0x80, 0x80],
    name: 'overlong U+0000 - 6 bytes' },
  { encoding: 'utf-8', input: [0xC1, 0xBF], name: 'overlong U+007F - 2 bytes' },
  { encoding: 'utf-8', input: [0xE0, 0x81, 0xBF],
    name: 'overlong U+007F - 3 bytes' },
  { encoding: 'utf-8', input: [0xF0, 0x80, 0x81, 0xBF],
    name: 'overlong U+007F - 4 bytes' },
  { encoding: 'utf-8', input: [0xF8, 0x80, 0x80, 0x81, 0xBF],
    name: 'overlong U+007F - 5 bytes' },
  { encoding: 'utf-8', input: [0xFC, 0x80, 0x80, 0x80, 0x81, 0xBF],
    name: 'overlong U+007F - 6 bytes' },
  { encoding: 'utf-8', input: [0xE0, 0x9F, 0xBF],
    name: 'overlong U+07FF - 3 bytes' },
  { encoding: 'utf-8', input: [0xF0, 0x80, 0x9F, 0xBF],
    name: 'overlong U+07FF - 4 bytes' },
  { encoding: 'utf-8', input: [0xF8, 0x80, 0x80, 0x9F, 0xBF],
    name: 'overlong U+07FF - 5 bytes' },
  { encoding: 'utf-8', input: [0xFC, 0x80, 0x80, 0x80, 0x9F, 0xBF],
    name: 'overlong U+07FF - 6 bytes' },
  { encoding: 'utf-8', input: [0xF0, 0x8F, 0xBF, 0xBF],
    name: 'overlong U+FFFF - 4 bytes' },
  { encoding: 'utf-8', input: [0xF8, 0x80, 0x8F, 0xBF, 0xBF],
    name: 'overlong U+FFFF - 5 bytes' },
  { encoding: 'utf-8', input: [0xFC, 0x80, 0x80, 0x8F, 0xBF, 0xBF],
    name: 'overlong U+FFFF - 6 bytes' },
  { encoding: 'utf-8', input: [0xF8, 0x84, 0x8F, 0xBF, 0xBF],
    name: 'overlong U+10FFFF - 5 bytes' },
  { encoding: 'utf-8', input: [0xFC, 0x80, 0x84, 0x8F, 0xBF, 0xBF],
    name: 'overlong U+10FFFF - 6 bytes' },
  // UTF-16 surrogates encoded as code points in UTF-8
  { encoding: 'utf-8', input: [0xED, 0xA0, 0x80], name: 'lead surrogate' },
  { encoding: 'utf-8', input: [0xED, 0xB0, 0x80], name: 'trail surrogate' },
  { encoding: 'utf-8', input: [0xED, 0xA0, 0x80, 0xED, 0xB0, 0x80],
    name: 'surrogate pair' },
  { encoding: 'utf-16le', input: [0x00], name: 'truncated code unit' },
  // Mismatched UTF-16 surrogates are exercised in utf16-surrogates.html
  // FIXME: Add legacy encoding cases
];

bad.forEach((t) => {
  assert.throws(
    () => {
      new TextDecoder(t.encoding, { fatal: true })
        .decode(new Uint8Array(t.input));
    }, {
      code: 'ERR_ENCODING_INVALID_ENCODED_DATA',
      name: 'TypeError'
    }
  );
});
                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder-ignorebom.js                      0000664 0000000 0000000 00000001557 14746647661 0027537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// From: https://github.com/w3c/web-platform-tests/blob/7f567fa29c/encoding/textdecoder-ignorebom.html
// This is the part that can be run without ICU

require('../common');

const assert = require('assert');

const cases = [
  {
    encoding: 'utf-8',
    bytes: [0xEF, 0xBB, 0xBF, 0x61, 0x62, 0x63]
  },
  {
    encoding: 'utf-16le',
    bytes: [0xFF, 0xFE, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00]
  },
];

cases.forEach((testCase) => {
  const BOM = '\uFEFF';
  let decoder = new TextDecoder(testCase.encoding, { ignoreBOM: true });
  const bytes = new Uint8Array(testCase.bytes);
  assert.strictEqual(decoder.decode(bytes), `${BOM}abc`);
  decoder = new TextDecoder(testCase.encoding, { ignoreBOM: false });
  assert.strictEqual(decoder.decode(bytes), 'abc');
  decoder = new TextDecoder(testCase.encoding);
  assert.strictEqual(decoder.decode(bytes), 'abc');
});
                                                                                                                                                 node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder-invalid-arg.js                    0000664 0000000 0000000 00000000746 14746647661 0027752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This tests that ERR_INVALID_ARG_TYPE are thrown when
// invalid arguments are passed to TextDecoder.

require('../common');
const assert = require('assert');

{
  const notArrayBufferViewExamples = [false, {}, 1, '', new Error()];
  notArrayBufferViewExamples.forEach((invalidInputType) => {
    assert.throws(() => {
      new TextDecoder(undefined, null).decode(invalidInputType);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}
                          node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder-streaming.js                      0000664 0000000 0000000 00000002420 14746647661 0027535 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// From: https://github.com/w3c/web-platform-tests/blob/fa9436d12c/encoding/textdecoder-streaming.html
// This is the part that can be run without ICU

require('../common');

const assert = require('assert');

const string =
  '\x00123ABCabc\x80\xFF\u0100\u1000\uFFFD\uD800\uDC00\uDBFF\uDFFF';
const octets = {
  'utf-8': [
    0x00, 0x31, 0x32, 0x33, 0x41, 0x42, 0x43, 0x61, 0x62, 0x63, 0xc2, 0x80,
    0xc3, 0xbf, 0xc4, 0x80, 0xe1, 0x80, 0x80, 0xef, 0xbf, 0xbd, 0xf0, 0x90,
    0x80, 0x80, 0xf4, 0x8f, 0xbf, 0xbf],
  'utf-16le': [
    0x00, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x41, 0x00, 0x42, 0x00,
    0x43, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x80, 0x00, 0xFF, 0x00,
    0x00, 0x01, 0x00, 0x10, 0xFD, 0xFF, 0x00, 0xD8, 0x00, 0xDC, 0xFF, 0xDB,
    0xFF, 0xDF]
};

Object.keys(octets).forEach((encoding) => {
  for (let len = 1; len <= 5; ++len) {
    const encoded = octets[encoding];
    const decoder = new TextDecoder(encoding);
    let out = '';
    for (let i = 0; i < encoded.length; i += len) {
      const sub = [];
      for (let j = i; j < encoded.length && j < i + len; ++j)
        sub.push(encoded[j]);
      out += decoder.decode(new Uint8Array(sub), { stream: true });
    }
    out += decoder.decode();
    assert.strictEqual(out, string);
  }
});
                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder-utf16-surrogates.js               0000664 0000000 0000000 00000002313 14746647661 0030706 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// From: https://github.com/w3c/web-platform-tests/blob/39a67e2fff/encoding/textdecoder-utf16-surrogates.html
// With the twist that we specifically test for Node.js error codes

const common = require('../common');

if (!common.hasIntl)
  common.skip('missing Intl');

const assert = require('assert');

const bad = [
  {
    encoding: 'utf-16le',
    input: [0x00, 0xd8],
    expected: '\uFFFD',
    name: 'lone surrogate lead'
  },
  {
    encoding: 'utf-16le',
    input: [0x00, 0xdc],
    expected: '\uFFFD',
    name: 'lone surrogate trail'
  },
  {
    encoding: 'utf-16le',
    input: [0x00, 0xd8, 0x00, 0x00],
    expected: '\uFFFD\u0000',
    name: 'unmatched surrogate lead'
  },
  {
    encoding: 'utf-16le',
    input: [0x00, 0xdc, 0x00, 0x00],
    expected: '\uFFFD\u0000',
    name: 'unmatched surrogate trail'
  },
  {
    encoding: 'utf-16le',
    input: [0x00, 0xdc, 0x00, 0xd8],
    expected: '\uFFFD\uFFFD',
    name: 'swapped surrogate pair'
  },
];

for (const t of bad) {
  assert.throws(
    () => {
      new TextDecoder(t.encoding, { fatal: true })
        .decode(new Uint8Array(t.input));
    }, {
      code: 'ERR_ENCODING_INVALID_ENCODED_DATA',
      name: 'TypeError'
    }
  );
}
                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-whatwg-encoding-custom-textdecoder.js                                0000664 0000000 0000000 00000015047 14746647661 0025557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals

// This tests Node.js-specific behaviors of TextDecoder

'use strict';

const common = require('../common');

const assert = require('assert');
const { customInspectSymbol: inspect } = require('internal/util');
const util = require('util');

const buf = Buffer.from([0xef, 0xbb, 0xbf, 0x74, 0x65,
                         0x73, 0x74, 0xe2, 0x82, 0xac]);

const encoding_sets = ['unicode-1-1-utf-8', 'unicode11utf8', 'unicode20utf8',
                       'utf8', 'utf-8', 'x-unicode20utf8'];
// Make Sure TextDecoder exist
assert(TextDecoder);

// Test TextDecoder, UTF-8, fatal: false, ignoreBOM: false
{
  encoding_sets.forEach((i) => {
    const dec = new TextDecoder(i);
    assert.strictEqual(dec.encoding, 'utf-8');
    const res = dec.decode(buf);
    assert.strictEqual(res, 'test€');
  });

  encoding_sets.forEach((i) => {
    const dec = new TextDecoder(i);
    let res = '';
    res += dec.decode(buf.slice(0, 8), { stream: true });
    res += dec.decode(buf.slice(8));
    assert.strictEqual(res, 'test€');
  });
}

// Test TextDecoder, UTF-8, fatal: false, ignoreBOM: true
{
  encoding_sets.forEach((i) => {
    const dec = new TextDecoder(i, { ignoreBOM: true });
    const res = dec.decode(buf);
    assert.strictEqual(res, '\ufefftest€');
  });

  encoding_sets.forEach((i) => {
    const dec = new TextDecoder(i, { ignoreBOM: true });
    let res = '';
    res += dec.decode(buf.slice(0, 8), { stream: true });
    res += dec.decode(buf.slice(8));
    assert.strictEqual(res, '\ufefftest€');
  });
}

// Invalid encoders
{
  ['meow', 'nonunicode', 'foo', 'bar'].forEach((fakeEncoding) => {
    assert.throws(
      () => { new TextDecoder(fakeEncoding); },
      {
        code: 'ERR_ENCODING_NOT_SUPPORTED',
        name: 'RangeError'
      }
    );
  });
}

// Test TextDecoder, UTF-8, fatal: true, ignoreBOM: false
if (common.hasIntl) {
  ['unicode-1-1-utf-8', 'utf8', 'utf-8'].forEach((i) => {
    const dec = new TextDecoder(i, { fatal: true });
    assert.throws(() => dec.decode(buf.slice(0, 8)),
                  {
                    code: 'ERR_ENCODING_INVALID_ENCODED_DATA',
                    name: 'TypeError',
                    message: 'The encoded data was not valid ' +
                          'for encoding utf-8'
                  });
  });

  ['unicode-1-1-utf-8', 'utf8', 'utf-8'].forEach((i) => {
    const dec = new TextDecoder(i, { fatal: true });
    dec.decode(buf.slice(0, 8), { stream: true });
    dec.decode(buf.slice(8));
  });
} else {
  assert.throws(
    () => new TextDecoder('utf-8', { fatal: true }),
    {
      code: 'ERR_NO_ICU',
      name: 'TypeError',
      message: '"fatal" option is not supported on Node.js compiled without ICU'
    });
}

// Test TextDecoder, label undefined, options null
{
  const dec = new TextDecoder(undefined, null);
  assert.strictEqual(dec.encoding, 'utf-8');
  assert.strictEqual(dec.fatal, false);
  assert.strictEqual(dec.ignoreBOM, false);
  assert.strictEqual(dec[Symbol.toStringTag], 'TextDecoder');
}

// Test TextDecoder, UTF-16le
{
  const dec = new TextDecoder('utf-16le');
  const res = dec.decode(Buffer.from('test€', 'utf-16le'));
  assert.strictEqual(res, 'test€');
}

// Test TextDecoder, UTF-16be
if (common.hasIntl) {
  const dec = new TextDecoder('utf-16be');
  const res = dec.decode(Buffer.from('test€', 'utf-16le').swap16());
  assert.strictEqual(res, 'test€');
}

// Test TextDecoder inspect with hidden fields
{
  const dec = new TextDecoder('utf-8', { ignoreBOM: true });
  if (common.hasIntl) {
    assert.strictEqual(
      util.inspect(dec, { showHidden: true }),
      'TextDecoder {\n' +
      '  encoding: \'utf-8\',\n' +
      '  fatal: false,\n' +
      '  ignoreBOM: true,\n' +
      '  [Symbol(flags)]: 4,\n' +
      '  [Symbol(handle)]: undefined\n' +
      '}'
    );
  } else {
    assert.strictEqual(
      util.inspect(dec, { showHidden: true }),
      'TextDecoder {\n' +
      "  encoding: 'utf-8',\n" +
      '  fatal: false,\n' +
      '  ignoreBOM: true,\n' +
      '  [Symbol(flags)]: 4,\n' +
      '  [Symbol(handle)]: StringDecoder {\n' +
      "    encoding: 'utf8',\n" +
      '    [Symbol(kNativeDecoder)]: <Buffer 00 00 00 00 00 00 01>\n' +
      '  }\n' +
      '}'
    );
  }
}


// Test TextDecoder inspect without hidden fields
{
  const dec = new TextDecoder('utf-8', { ignoreBOM: true });
  assert.strictEqual(
    util.inspect(dec, { showHidden: false }),
    'TextDecoder { encoding: \'utf-8\', fatal: false, ignoreBOM: true }'
  );
}

// Test TextDecoder inspect with negative depth
{
  const dec = new TextDecoder();
  assert.strictEqual(util.inspect(dec, { depth: -1 }), '[TextDecoder]');
}

{
  const inspectFn = TextDecoder.prototype[inspect];
  const decodeFn = TextDecoder.prototype.decode;
  const {
    encoding: { get: encodingGetter },
    fatal: { get: fatalGetter },
    ignoreBOM: { get: ignoreBOMGetter },
  } = Object.getOwnPropertyDescriptors(TextDecoder.prototype);

  const instance = new TextDecoder();

  const expectedError = {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type TextDecoder'
  };

  inspectFn.call(instance, Infinity, {});
  decodeFn.call(instance);
  encodingGetter.call(instance);
  fatalGetter.call(instance);
  ignoreBOMGetter.call(instance);

  const invalidThisArgs = [{}, [], true, 1, '', new TextEncoder()];
  invalidThisArgs.forEach((i) => {
    assert.throws(() => inspectFn.call(i, Infinity, {}), expectedError);
    assert.throws(() => decodeFn.call(i), expectedError);
    assert.throws(() => encodingGetter.call(i), expectedError);
    assert.throws(() => fatalGetter.call(i), expectedError);
    assert.throws(() => ignoreBOMGetter.call(i), expectedError);
  });
}

{
  assert.throws(
    () => new TextDecoder('utf-8', 1),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
}

// Test TextDecoder for incomplete UTF-8 byte sequence.
{
  const decoder = new TextDecoder();
  const chunk = new Uint8Array([0x66, 0x6f, 0x6f, 0xed]);
  const str = decoder.decode(chunk);
  assert.strictEqual(str, 'foo\ufffd');
}

if (common.hasIntl) {
  try {
    const decoder = new TextDecoder('Shift_JIS');
    const chunk = new Uint8Array([-1]);
    const str = decoder.decode(chunk);
    assert.strictEqual(str, '\ufffd');
  } catch (e) {
    // Encoding may not be available, e.g. small-icu builds
    assert.strictEqual(e.code, 'ERR_ENCODING_NOT_SUPPORTED');
  }
}

{
  const buffer = new ArrayBuffer(1);
  new MessageChannel().port1.postMessage(buffer, [buffer]); // buffer is detached
  const decoder = new TextDecoder();
  assert.strictEqual(decoder.decode(buffer), '');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-whatwg-events-add-event-listener-options-passive.js                  0000664 0000000 0000000 00000003630 14746647661 0030301 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

// Manually converted from https://github.com/web-platform-tests/wpt/blob/master/dom/events/AddEventListenerOptions-passive.html
// in order to define the `document` ourselves

const {
  fail,
  ok,
  strictEqual
} = require('assert');

{
  const document = new EventTarget();
  let supportsPassive = false;
  const query_options = {
    get passive() {
      supportsPassive = true;
      return false;
    },
    get dummy() {
      fail('dummy value getter invoked');
      return false;
    }
  };

  document.addEventListener('test_event', null, query_options);
  ok(supportsPassive);

  supportsPassive = false;
  document.removeEventListener('test_event', null, query_options);
  strictEqual(supportsPassive, false);
}
{
  function testPassiveValue(optionsValue, expectedDefaultPrevented) {
    const document = new EventTarget();
    let defaultPrevented;
    function handler(e) {
      if (e.defaultPrevented) {
        fail('Event prematurely marked defaultPrevented');
      }
      e.preventDefault();
      defaultPrevented = e.defaultPrevented;
    }
    document.addEventListener('test', handler, optionsValue);
    // TODO the WHATWG test is more extensive here and tests dispatching on
    // document.body, if we ever support getParent we should amend this
    const ev = new Event('test', { bubbles: true, cancelable: true });
    const uncanceled = document.dispatchEvent(ev);

    strictEqual(defaultPrevented, expectedDefaultPrevented);
    strictEqual(uncanceled, !expectedDefaultPrevented);

    document.removeEventListener('test', handler, optionsValue);
  }
  testPassiveValue(undefined, true);
  testPassiveValue({}, true);
  testPassiveValue({ passive: false }, true);

  common.skip('TODO: passive listeners is still broken');
  testPassiveValue({ passive: 1 }, false);
  testPassiveValue({ passive: true }, false);
  testPassiveValue({ passive: 0 }, true);
}
                                                                                                        node-23.7.0/test/parallel/test-whatwg-events-add-event-listener-options-signal.js                   0000664 0000000 0000000 00000011560 14746647661 0030105 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const {
  strictEqual,
  throws,
} = require('assert');

// Manually ported from: wpt@dom/events/AddEventListenerOptions-signal.any.js

{
  // Passing an AbortSignal to addEventListener does not prevent
  // removeEventListener
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  et.addEventListener('test', handler, { signal: controller.signal });
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 1, 'Adding a signal still adds a listener');
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 2, 'The listener was not added with the once flag');
  controller.abort();
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 2, 'Aborting on the controller removes the listener');
  // See: https://github.com/nodejs/node/pull/37696 , adding an event listener
  // should always return undefined.
  strictEqual(
    et.addEventListener('test', handler, { signal: controller.signal }),
    undefined);
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 2, 'Passing an aborted signal never adds the handler');
}

{
  // Passing an AbortSignal to addEventListener works with the once flag
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  et.addEventListener('test', handler, { signal: controller.signal });
  et.removeEventListener('test', handler);
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  // Removing a once listener works with a passed signal
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  const options = { signal: controller.signal, once: true };
  et.addEventListener('test', handler, options);
  controller.abort();
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  const options = { signal: controller.signal, once: true };
  et.addEventListener('test', handler, options);
  et.removeEventListener('test', handler);
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  // Passing an AbortSignal to multiple listeners
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  const options = { signal: controller.signal, once: true };
  et.addEventListener('first', handler, options);
  et.addEventListener('second', handler, options);
  controller.abort();
  et.dispatchEvent(new Event('first'));
  et.dispatchEvent(new Event('second'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  // Passing an AbortSignal to addEventListener works with the capture flag
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  const options = { signal: controller.signal, capture: true };
  et.addEventListener('test', handler, options);
  controller.abort();
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  // Aborting from a listener does not call future listeners
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  const options = { signal: controller.signal };
  et.addEventListener('test', () => {
    controller.abort();
  }, options);
  et.addEventListener('test', handler, options);
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  // Adding then aborting a listener in another listener does not call it
  let count = 0;
  function handler() {
    count++;
  }
  const et = new EventTarget();
  const controller = new AbortController();
  et.addEventListener('test', () => {
    et.addEventListener('test', handler, { signal: controller.signal });
    controller.abort();
  }, { signal: controller.signal });
  et.dispatchEvent(new Event('test'));
  strictEqual(count, 0, 'The listener was still removed');
}

{
  // Aborting from a nested listener should remove it
  const et = new EventTarget();
  const ac = new AbortController();
  let count = 0;
  et.addEventListener('foo', () => {
    et.addEventListener('foo', () => {
      count++;
      if (count > 5) ac.abort();
      et.dispatchEvent(new Event('foo'));
    }, { signal: ac.signal });
    et.dispatchEvent(new Event('foo'));
  }, { once: true });
  et.dispatchEvent(new Event('foo'));
}
{
  const et = new EventTarget();
  [1, 1n, {}, [], null, true, 'hi', Symbol(), () => {}].forEach((signal) => {
    throws(() => et.addEventListener('foo', () => {}, { signal }), {
      name: 'TypeError',
    });
  });
}
                                                                                                                                                node-23.7.0/test/parallel/test-whatwg-events-customevent.js                                         0000664 0000000 0000000 00000001262 14746647661 0024021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const { strictEqual, throws, equal } = require('assert');

// Manually converted from https://github.com/web-platform-tests/wpt/blob/master/dom/events/CustomEvent.html
// in order to define the `document` ourselves

{
  const type = 'foo';
  const target = new EventTarget();

  target.addEventListener(type, common.mustCall((evt) => {
    strictEqual(evt.type, type);
  }));

  target.dispatchEvent(new Event(type));
}

{
  throws(() => {
    new Event();
  }, TypeError);
}

{
  const event = new Event('foo');
  equal(event.type, 'foo');
  equal(event.bubbles, false);
  equal(event.cancelable, false);
  equal(event.detail, null);
}
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-whatwg-events-event-constructors.js                                  0000664 0000000 0000000 00000001420 14746647661 0025330 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const { test, assert_equals, assert_array_equals } =
  require('../common/wpt').harness;

// Source: https://github.com/web-platform-tests/wpt/blob/6cef1d2087d6a07d7cc6cee8cf207eec92e27c5f/dom/events/Event-constructors.any.js#L91-L112
test(function() {
  const called = [];
  const ev = new Event('Xx', {
    get cancelable() {
      called.push('cancelable');
      return false;
    },
    get bubbles() {
      called.push('bubbles');
      return true;
    },
    get sweet() {
      called.push('sweet');
      return 'x';
    },
  });
  assert_array_equals(called, ['bubbles', 'cancelable']);
  assert_equals(ev.type, 'Xx');
  assert_equals(ev.bubbles, true);
  assert_equals(ev.cancelable, false);
  assert_equals(ev.sweet, undefined);
});
                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-whatwg-events-eventtarget-this-of-listener.js                        0000664 0000000 0000000 00000006341 14746647661 0027172 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const { test, assert_equals, assert_unreached } =
  require('../common/wpt').harness;

// Manually ported from: https://github.com/web-platform-tests/wpt/blob/6cef1d2087d6a07d7cc6cee8cf207eec92e27c5f/dom/events/EventTarget-this-of-listener.html

// Mock document
const document = {
  createElement: () => new EventTarget(),
  createTextNode: () => new EventTarget(),
  createDocumentFragment: () => new EventTarget(),
  createComment: () => new EventTarget(),
  createProcessingInstruction: () => new EventTarget(),
};

test(() => {
  const nodes = [
    document.createElement('p'),
    document.createTextNode('some text'),
    document.createDocumentFragment(),
    document.createComment('a comment'),
    document.createProcessingInstruction('target', 'data'),
  ];

  let callCount = 0;
  for (const node of nodes) {
    node.addEventListener('someevent', function() {
      ++callCount;
      assert_equals(this, node);
    });

    node.dispatchEvent(new Event('someevent'));
  }

  assert_equals(callCount, nodes.length);
}, 'the this value inside the event listener callback should be the node');

test(() => {
  const nodes = [
    document.createElement('p'),
    document.createTextNode('some text'),
    document.createDocumentFragment(),
    document.createComment('a comment'),
    document.createProcessingInstruction('target', 'data'),
  ];

  let callCount = 0;
  for (const node of nodes) {
    const handler = {};

    node.addEventListener('someevent', handler);
    handler.handleEvent = function() {
      ++callCount;
      assert_equals(this, handler);
    };

    node.dispatchEvent(new Event('someevent'));
  }

  assert_equals(callCount, nodes.length);
}, 'addEventListener should not require handleEvent to be defined on object listeners');

test(() => {
  const nodes = [
    document.createElement('p'),
    document.createTextNode('some text'),
    document.createDocumentFragment(),
    document.createComment('a comment'),
    document.createProcessingInstruction('target', 'data'),
  ];

  let callCount = 0;
  for (const node of nodes) {
    function handler() {
      ++callCount;
      assert_equals(this, node);
    }

    handler.handleEvent = () => {
      assert_unreached('should not call the handleEvent method on a function');
    };

    node.addEventListener('someevent', handler);

    node.dispatchEvent(new Event('someevent'));
  }

  assert_equals(callCount, nodes.length);
}, 'handleEvent properties added to a function before addEventListener are not reached');

test(() => {
  const nodes = [
    document.createElement('p'),
    document.createTextNode('some text'),
    document.createDocumentFragment(),
    document.createComment('a comment'),
    document.createProcessingInstruction('target', 'data'),
  ];

  let callCount = 0;
  for (const node of nodes) {
    function handler() {
      ++callCount;
      assert_equals(this, node);
    }

    node.addEventListener('someevent', handler);

    handler.handleEvent = () => {
      assert_unreached('should not call the handleEvent method on a function');
    };

    node.dispatchEvent(new Event('someevent'));
  }

  assert_equals(callCount, nodes.length);
}, 'handleEvent properties added to a function after addEventListener are not reached');
                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-whatwg-readablebytestream-bad-buffers-and-views.js                   0000664 0000000 0000000 00000004124 14746647661 0030053 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('node:assert');

let pass = 0;

{
  // ReadableStream with byte source: respondWithNewView() throws if the
  // supplied view's buffer has a different length (in the closed state)
  const stream = new ReadableStream({
    pull: common.mustCall(async (c) => {
      const view = new Uint8Array(new ArrayBuffer(10), 0, 0);

      c.close();

      assert.throws(() => c.byobRequest.respondWithNewView(view), {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'RangeError',
      });
      pass++;
    }),
    type: 'bytes',
  });

  const reader = stream.getReader({ mode: 'byob' });
  reader.read(new Uint8Array([4, 5, 6]));
}

{
  // ReadableStream with byte source: respondWithNewView() throws if the
  // supplied view's buffer has been detached (in the closed state)
  const stream = new ReadableStream({
    pull: common.mustCall((c) => {
      c.close();

      // Detach it by reading into it
      const view = new Uint8Array([1, 2, 3]);
      reader.read(view);

      assert.throws(() => c.byobRequest.respondWithNewView(view), {
        code: 'ERR_INVALID_STATE',
        name: 'TypeError',
      });
      pass++;
    }),
    type: 'bytes',
  });

  const reader = stream.getReader({ mode: 'byob' });
  reader.read(new Uint8Array([4, 5, 6]));
}

{
  const stream = new ReadableStream({
    start(c) {
      c.enqueue(new Uint8Array([1, 2, 3]));
    },
    type: 'bytes',
  });
  const reader = stream.getReader({ mode: 'byob' });
  const view = new Uint8Array();
  assert
    .rejects(reader.read(view), {
      code: 'ERR_INVALID_STATE',
      name: 'TypeError',
    })
    .then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(c) {
      c.enqueue(new Uint8Array([1, 2, 3]));
    },
    type: 'bytes',
  });
  const reader = stream.getReader({ mode: 'byob' });
  const view = new Uint8Array(new ArrayBuffer(10), 0, 0);
  assert
    .rejects(reader.read(view), {
      code: 'ERR_INVALID_STATE',
      name: 'TypeError',
    })
    .then(common.mustCall());
}

process.on('exit', () => assert.strictEqual(pass, 2));
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-whatwg-readablebytestream.js                                         0000664 0000000 0000000 00000014624 14746647661 0024010 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');
const assert = require('assert');

const {
  ReadableStream,
  ReadableByteStreamController,
  ReadableStreamDefaultReader,
  ReadableStreamBYOBReader,
  ReadableStreamBYOBRequest,
} = require('stream/web');

const {
  kState,
} = require('internal/webstreams/util');

const {
  open,
} = require('fs/promises');

const {
  readFileSync,
} = require('fs');

const {
  Buffer,
} = require('buffer');

const {
  inspect,
} = require('util');

{
  const r = new ReadableStream({
    type: 'bytes',
  });

  assert(r[kState].controller instanceof ReadableByteStreamController);

  assert.strictEqual(typeof r.locked, 'boolean');
  assert.strictEqual(typeof r.cancel, 'function');
  assert.strictEqual(typeof r.getReader, 'function');
  assert.strictEqual(typeof r.pipeThrough, 'function');
  assert.strictEqual(typeof r.pipeTo, 'function');
  assert.strictEqual(typeof r.tee, 'function');

  ['', null, 'asdf'].forEach((mode) => {
    assert.throws(() => r.getReader({ mode }), {
      code: 'ERR_INVALID_ARG_VALUE',
    });
  });

  [1, 'asdf'].forEach((options) => {
    assert.throws(() => r.getReader(options), {
      code: 'ERR_INVALID_ARG_TYPE',
    });
  });

  assert(!r.locked);
  const defaultReader = r.getReader();
  assert(r.locked);
  assert(defaultReader instanceof ReadableStreamDefaultReader);
  defaultReader.releaseLock();
  const byobReader = r.getReader({ mode: 'byob' });
  assert(byobReader instanceof ReadableStreamBYOBReader);
  assert.match(
    inspect(byobReader, { depth: 0 }),
    /ReadableStreamBYOBReader/);
}

class Source {
  constructor() {
    this.controllerClosed = false;
  }

  async start(controller) {
    this.file = await open(__filename);
    this.controller = controller;
  }

  async pull(controller) {
    const byobRequest = controller.byobRequest;
    assert.match(inspect(byobRequest), /ReadableStreamBYOBRequest/);

    const view = byobRequest.view;
    const {
      bytesRead,
    } = await this.file.read({
      buffer: view,
      offset: view.byteOffset,
      length: view.byteLength
    });

    if (bytesRead === 0) {
      await this.file.close();
      this.controller.close();
    }

    assert.throws(() => byobRequest.respondWithNewView({}), {
      code: 'ERR_INVALID_ARG_TYPE',
    });

    byobRequest.respond(bytesRead);

    assert.throws(() => byobRequest.respond(bytesRead), {
      code: 'ERR_INVALID_STATE',
    });
    assert.throws(() => byobRequest.respondWithNewView(view), {
      code: 'ERR_INVALID_STATE',
    });
  }

  get type() { return 'bytes'; }

  get autoAllocateChunkSize() { return 1024; }
}

{
  const stream = new ReadableStream(new Source());
  assert(stream[kState].controller instanceof ReadableByteStreamController);

  async function read(stream) {
    const reader = stream.getReader({ mode: 'byob' });

    const chunks = [];
    let result;
    do {
      result = await reader.read(Buffer.alloc(100));
      if (result.value !== undefined)
        chunks.push(Buffer.from(result.value));
    } while (!result.done);

    return Buffer.concat(chunks);
  }

  read(stream).then(common.mustCall((data) => {
    const check = readFileSync(__filename);
    assert.deepStrictEqual(check, data);
  }));
}

{
  const stream = new ReadableStream(new Source());
  assert(stream[kState].controller instanceof ReadableByteStreamController);

  async function read(stream) {
    const chunks = [];
    for await (const chunk of stream)
      chunks.push(chunk);

    return Buffer.concat(chunks);
  }

  read(stream).then(common.mustCall((data) => {
    const check = readFileSync(__filename);
    assert.deepStrictEqual(check, data);
  }));
}

{
  const stream = new ReadableStream(new Source());
  assert(stream[kState].controller instanceof ReadableByteStreamController);

  async function read(stream) {
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream)
      break;
  }

  read(stream).then(common.mustCall());
}

{
  const stream = new ReadableStream(new Source());
  assert(stream[kState].controller instanceof ReadableByteStreamController);

  const error = new Error('boom');

  async function read(stream) {
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream)
      throw error;
  }

  assert.rejects(read(stream), error).then(common.mustCall());
}

{
  assert.throws(() => {
    Reflect.get(ReadableStreamBYOBRequest.prototype, 'view', {});
  }, {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => ReadableStreamBYOBRequest.prototype.respond.call({}), {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => {
    ReadableStreamBYOBRequest.prototype.respondWithNewView.call({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
}

{
  const readable = new ReadableStream({ type: 'bytes' });
  const reader = readable.getReader({ mode: 'byob' });
  reader.releaseLock();
  reader.releaseLock();
  assert.rejects(reader.read(new Uint8Array(10)), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
  assert.rejects(reader.cancel(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  let controller;
  new ReadableStream({
    type: 'bytes',
    start(c) { controller = c; }
  });
  assert.throws(() => controller.enqueue(1), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
  controller.close();
  assert.throws(() => controller.enqueue(new Uint8Array(10)), {
    code: 'ERR_INVALID_STATE',
  });
  assert.throws(() => controller.close(), {
    code: 'ERR_INVALID_STATE',
  });
}

{
  let controller;
  new ReadableStream({
    type: 'bytes',
    start(c) { controller = c; }
  });
  controller.enqueue(new Uint8Array(10));
  controller.close();
  assert.throws(() => controller.enqueue(new Uint8Array(10)), {
    code: 'ERR_INVALID_STATE',
  });
}

{
  const stream = new ReadableStream({
    type: 'bytes',
    pull(c) {
      const v = new Uint8Array(c.byobRequest.view.buffer, 0, 3);
      v.set([20, 21, 22]);
      c.byobRequest.respondWithNewView(v);
    },
  });
  const buffer = new ArrayBuffer(10);
  const view = new Uint8Array(buffer, 0, 3);
  view.set([10, 11, 12]);
  const reader = stream.getReader({ mode: 'byob' });
  reader.read(view);
}

{
  const stream = new ReadableStream({
    type: 'bytes',
    autoAllocateChunkSize: 10,
    pull(c) {
      const v = new Uint8Array(c.byobRequest.view.buffer, 0, 3);
      v.set([20, 21, 22]);
      c.byobRequest.respondWithNewView(v);
    },
  });
  const reader = stream.getReader();
  reader.read();
}
                                                                                                            node-23.7.0/test/parallel/test-whatwg-readablebytestreambyob.js                                     0000664 0000000 0000000 00000002230 14746647661 0024652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const {
  open,
} = require('fs/promises');

const {
  Buffer,
} = require('buffer');

class Source {
  async start(controller) {
    this.file = await open(__filename);
    this.controller = controller;
  }

  async pull(controller) {
    const byobRequest = controller.byobRequest;
    const view = byobRequest.view;

    const {
      bytesRead,
    } = await this.file.read({
      buffer: view,
      offset: view.byteOffset,
      length: view.byteLength
    });

    if (bytesRead === 0) {
      await this.file.close();
      this.controller.close();
    }

    byobRequest.respond(bytesRead);
  }

  get type() { return 'bytes'; }

  get autoAllocateChunkSize() { return 1024; }
}

(async () => {
  const source = new Source();
  const stream = new ReadableStream(source);

  const { emitWarning } = process;

  process.emitWarning = common.mustNotCall();

  try {
    const reader = stream.getReader({ mode: 'byob' });

    let result;
    do {
      result = await reader.read(Buffer.alloc(100));
    } while (!result.done);
  } finally {
    process.emitWarning = emitWarning;
  }
})().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-whatwg-readablestream.js                                             0000664 0000000 0000000 00000117270 14746647661 0023125 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');
const { isDisturbed, isErrored, isReadable } = require('stream');
const assert = require('assert');
const {
  isPromise,
} = require('util/types');
const {
  setImmediate: delay
} = require('timers/promises');

const {
  ByteLengthQueuingStrategy,
  CountQueuingStrategy,
  ReadableStream,
  ReadableStreamDefaultReader,
  ReadableStreamDefaultController,
  ReadableByteStreamController,
  ReadableStreamBYOBReader,
  ReadableStreamBYOBRequest,
  WritableStream,
} = require('stream/web');

const {
  readableStreamPipeTo,
  readableStreamTee,
  readableByteStreamControllerConvertPullIntoDescriptor,
  readableStreamDefaultControllerEnqueue,
  readableByteStreamControllerEnqueue,
  readableStreamDefaultControllerCanCloseOrEnqueue,
  readableByteStreamControllerClose,
  readableByteStreamControllerRespond,
  readableStreamReaderGenericRelease,
} = require('internal/webstreams/readablestream');

const {
  kState
} = require('internal/webstreams/util');

const {
  createReadStream,
  readFileSync,
} = require('fs');
const {
  Buffer,
} = require('buffer');

const {
  kTransfer,
} = require('internal/worker/js_transferable');

const {
  inspect,
} = require('util');

{
  const r = new ReadableStream();
  assert.strictEqual(typeof r.locked, 'boolean');
  assert.strictEqual(typeof r.cancel, 'function');
  assert.strictEqual(typeof r.getReader, 'function');
  assert.strictEqual(typeof r.pipeThrough, 'function');
  assert.strictEqual(typeof r.pipeTo, 'function');
  assert.strictEqual(typeof r.tee, 'function');

  ['', null, 'asdf'].forEach((mode) => {
    assert.throws(() => r.getReader({ mode }), {
      code: 'ERR_INVALID_ARG_VALUE',
    });
  });

  [1, 'asdf'].forEach((options) => {
    assert.throws(() => r.getReader(options), {
      code: 'ERR_INVALID_ARG_TYPE',
    });
  });

  assert(!r.locked);
  r.getReader();
  assert(r.locked);
}

{
  // Throw error and return rejected promise in `cancel()` method
  // would execute same cleanup code
  const r1 = new ReadableStream({
    cancel: () => {
      return Promise.reject('Cancel Error');
    },
  });
  r1.cancel().finally(common.mustCall(() => {
    const controllerState = r1[kState].controller[kState];

    assert.strictEqual(controllerState.pullAlgorithm, undefined);
    assert.strictEqual(controllerState.cancelAlgorithm, undefined);
    assert.strictEqual(controllerState.sizeAlgorithm, undefined);
  })).catch(() => {});

  const r2 = new ReadableStream({
    cancel() {
      throw new Error('Cancel Error');
    }
  });
  r2.cancel().finally(common.mustCall(() => {
    const controllerState = r2[kState].controller[kState];

    assert.strictEqual(controllerState.pullAlgorithm, undefined);
    assert.strictEqual(controllerState.cancelAlgorithm, undefined);
    assert.strictEqual(controllerState.sizeAlgorithm, undefined);
  })).catch(() => {});
}

{
  const source = {
    start: common.mustCall((controller) => {
      assert(controller instanceof ReadableStreamDefaultController);
    }),
    pull: common.mustCall((controller) => {
      assert(controller instanceof ReadableStreamDefaultController);
    }),
    cancel: common.mustNotCall(),
  };

  new ReadableStream(source);
}

{
  const source = {
    start: common.mustCall(async (controller) => {
      assert(controller instanceof ReadableStreamDefaultController);
    }),
    pull: common.mustCall(async (controller) => {
      assert(controller instanceof ReadableStreamDefaultController);
    }),
    cancel: common.mustNotCall(),
  };

  new ReadableStream(source);
}

{
  const source = {
    start: common.mustCall((controller) => {
      assert(controller instanceof ReadableByteStreamController);
    }),
    pull: common.mustNotCall(),
    cancel: common.mustNotCall(),
    type: 'bytes',
  };

  new ReadableStream(source);
}

{
  const source = {
    start: common.mustCall(async (controller) => {
      assert(controller instanceof ReadableByteStreamController);
    }),
    pull: common.mustNotCall(),
    cancel: common.mustNotCall(),
    type: 'bytes',
  };

  new ReadableStream(source);
}

{
  const source = {
    start: common.mustCall(async (controller) => {
      assert(controller instanceof ReadableByteStreamController);
    }),
    pull: common.mustCall(async (controller) => {
      assert(controller instanceof ReadableByteStreamController);
    }),
    cancel: common.mustNotCall(),
    type: 'bytes',
  };

  new ReadableStream(source, { highWaterMark: 10 });
}

{
  new ReadableStream({});
  new ReadableStream([]);
  new ReadableStream({}, null);
  new ReadableStream({}, {});
  new ReadableStream({}, []);
}

['a', false, 1, null].forEach((source) => {
  assert.throws(() => {
    new ReadableStream(source);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

['a', false, 1].forEach((strategy) => {
  assert.throws(() => {
    new ReadableStream({}, strategy);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

['a', {}, false].forEach((size) => {
  assert.throws(() => {
    new ReadableStream({}, { size });
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

['a', {}].forEach((highWaterMark) => {
  assert.throws(() => {
    new ReadableStream({}, { highWaterMark });
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
  });

  assert.throws(() => {
    new ReadableStream({ type: 'bytes' }, { highWaterMark });
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
  });
});

[-1, NaN].forEach((highWaterMark) => {
  assert.throws(() => {
    new ReadableStream({}, { highWaterMark });
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
  });

  assert.throws(() => {
    new ReadableStream({ type: 'bytes' }, { highWaterMark });
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
  });
});

{
  new ReadableStream({}, new ByteLengthQueuingStrategy({ highWaterMark: 1 }));
  new ReadableStream({}, new CountQueuingStrategy({ highWaterMark: 1 }));
}

{
  const strategy = new ByteLengthQueuingStrategy({ highWaterMark: 1 });
  assert.strictEqual(strategy.highWaterMark, 1);
  assert.strictEqual(strategy.size(new ArrayBuffer(10)), 10);

  const { size } = strategy;
  assert.strictEqual(size(new ArrayBuffer(10)), 10);
}

{
  const strategy = new CountQueuingStrategy({ highWaterMark: 1 });
  assert.strictEqual(strategy.highWaterMark, 1);
  assert.strictEqual(strategy.size(new ArrayBuffer(10)), 1);

  const { size } = strategy;
  assert.strictEqual(size(new ArrayBuffer(10)), 1);
}

{
  const r = new ReadableStream({
    async start() {
      throw new Error('boom');
    }
  });

  setImmediate(() => {
    assert.strictEqual(r[kState].state, 'errored');
    assert.match(r[kState].storedError?.message, /boom/);
  });
}

{
  const data = Buffer.from('hello');
  const r = new ReadableStream({
    start(controller) {
      controller.enqueue(data);
      controller.close();
    },
  });

  (async function read() {
    const reader = r.getReader();
    let res = await reader.read();
    if (res.done) return;
    const buf = Buffer.from(res.value);
    assert.strictEqual(buf.toString(), data.toString());
    res = await reader.read();
    assert(res.done);
  })().then(common.mustCall());
}

{
  const r = new ReadableStream({
    start(controller) {
      controller.close();
    },
  });

  (async function read() {
    const reader = r.getReader();
    const res = await reader.read();
    assert(res.done);
  })().then(common.mustCall());
}

assert.throws(() => {
  new ReadableStream({
    get start() { throw new Error('boom1'); }
  }, {
    get size() { throw new Error('boom2'); }
  });
}, /boom2/);

{
  const stream = new ReadableStream();
  const reader = stream.getReader();

  assert(stream.locked);
  assert.strictEqual(reader[kState].stream, stream);
  assert.strictEqual(stream[kState].reader, reader);

  assert.throws(() => stream.getReader(), {
    code: 'ERR_INVALID_STATE',
  });

  assert(reader instanceof ReadableStreamDefaultReader);

  assert(isPromise(reader.closed));
  assert.strictEqual(typeof reader.cancel, 'function');
  assert.strictEqual(typeof reader.read, 'function');
  assert.strictEqual(typeof reader.releaseLock, 'function');

  const read1 = reader.read();
  const read2 = reader.read();

  read1.then(common.mustNotCall(), common.mustCall());
  read2.then(common.mustNotCall(), common.mustCall());

  assert.notStrictEqual(read1, read2);

  assert.strictEqual(reader[kState].readRequests.length, 2);

  delay().then(common.mustCall());

  assert(stream.locked);
  reader.releaseLock();
  assert(!stream.locked);
}

{
  const stream = new ReadableStream();
  const reader = stream.getReader();
  const closedBefore = reader.closed;
  assert(stream.locked);
  reader.releaseLock();
  assert(!stream.locked);
  const closedAfter = reader.closed;

  assert.strictEqual(closedBefore, closedAfter);

  assert.rejects(reader.read(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());

  assert.rejects(closedBefore, {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  const stream = new ReadableStream();
  const iterable = stream.values();
  readableStreamReaderGenericRelease(stream[kState].reader);
  assert.rejects(iterable.next(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  const stream = new ReadableStream();
  const iterable = stream.values();
  readableStreamReaderGenericRelease(stream[kState].reader);
  assert.rejects(iterable.return(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(Buffer.from('hello'));
    }
  });

  const reader = stream.getReader();

  assert.rejects(stream.cancel(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());

  reader.cancel();

  reader.read().then(common.mustCall(({ value, done }) => {
    assert.strictEqual(value, undefined);
    assert(done);
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    }
  });
  assert(!stream.locked);

  const cancel1 = stream.cancel();
  const cancel2 = stream.cancel();

  assert.notStrictEqual(cancel1, cancel2);

  Promise.all([cancel1, cancel2]).then(common.mustCall((res) => {
    assert.deepStrictEqual(res, [undefined, undefined]);
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    }
  });

  stream.getReader().releaseLock();
  stream.getReader().releaseLock();
  stream.getReader();
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    }
  });

  stream.getReader();

  assert.throws(() => stream.getReader(), {
    code: 'ERR_INVALID_STATE',
  });
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    },
  });

  const reader = stream.getReader();

  reader.closed.then(common.mustCall());

  reader.read().then(common.mustCall(({ value, done }) => {
    assert.strictEqual(value, undefined);
    assert(done);
    reader.read().then(common.mustCall(({ value, done }) => {
      assert.strictEqual(value, undefined);
      assert(done);
    }));
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    },
  });

  const reader = stream.getReader();

  const closedBefore = reader.closed;
  reader.releaseLock();
  const closedAfter = reader.closed;
  assert.notStrictEqual(closedBefore, closedAfter);

  closedBefore.then(common.mustCall());
  assert.rejects(closedAfter, {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  let c;
  const stream = new ReadableStream({
    start(controller) {
      c = controller;
    },
  });

  const reader = stream.getReader();
  c.close();

  const closedBefore = reader.closed;
  reader.releaseLock();
  const closedAfter = reader.closed;
  assert.notStrictEqual(closedBefore, closedAfter);

  closedBefore.then(common.mustCall());
  assert.rejects(closedAfter, {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    },
  });

  const reader = stream.getReader();

  const cancel1 = reader.cancel();
  const cancel2 = reader.cancel();
  const closed = reader.closed;

  assert.notStrictEqual(cancel1, cancel2);
  assert.notStrictEqual(cancel1, closed);
  assert.notStrictEqual(cancel2, closed);

  Promise.all([cancel1, cancel2]).then(common.mustCall((res) => {
    assert.deepStrictEqual(res, [undefined, undefined]);
  }));
}

{
  let c;
  const stream = new ReadableStream({
    start(controller) {
      c = controller;
    },
  });

  const reader = stream.getReader();
  c.close();

  const cancel1 = reader.cancel();
  const cancel2 = reader.cancel();
  const closed = reader.closed;

  assert.notStrictEqual(cancel1, cancel2);
  assert.notStrictEqual(cancel1, closed);
  assert.notStrictEqual(cancel2, closed);

  Promise.all([cancel1, cancel2]).then(common.mustCall((res) => {
    assert.deepStrictEqual(res, [undefined, undefined]);
  }));
}

{
  const stream = new ReadableStream();
  const cancel1 = stream.cancel();
  const cancel2 = stream.cancel();
  assert.notStrictEqual(cancel1, cancel2);

  Promise.all([cancel1, cancel2]).then(common.mustCall((res) => {
    assert.deepStrictEqual(res, [undefined, undefined]);
  }));

  stream.getReader().read().then(common.mustCall(({ value, done }) => {
    assert.strictEqual(value, undefined);
    assert(done);
  }));
}

{
  const error = new Error('boom');
  const stream = new ReadableStream({
    start(controller) {
      controller.error(error);
    }
  });
  stream.getReader().releaseLock();
  const reader = stream.getReader();
  assert.rejects(reader.closed, error).then(common.mustCall());
  assert.rejects(reader.read(), error).then(common.mustCall());
  assert.rejects(reader.read(), error).then(common.mustCall());
}

{
  const error = new Error('boom');
  const stream = new ReadableStream({
    start(controller) {
      controller.error(error);
    }
  });
  const reader = stream.getReader();
  const cancel1 = reader.cancel();
  const cancel2 = reader.cancel();
  assert.notStrictEqual(cancel1, cancel2);
  assert.rejects(cancel1, error).then(common.mustCall());
  assert.rejects(cancel2, error).then(common.mustCall());
}

{
  const error = new Error('boom');
  const stream = new ReadableStream({
    async start(controller) {
      throw error;
    }
  });
  stream.getReader().releaseLock();
  const reader = stream.getReader();
  assert.rejects(reader.closed, error).then(common.mustCall());
  assert.rejects(reader.read(), error).then(common.mustCall());
  assert.rejects(reader.read(), error).then(common.mustCall());
}

{
  const buf1 = Buffer.from('hello');
  const buf2 = Buffer.from('there');
  let doClose;
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(buf1);
      controller.enqueue(buf2);
      doClose = controller.close.bind(controller);
    }
  });
  const reader = stream.getReader();
  doClose();
  reader.read().then(common.mustCall(({ value, done }) => {
    assert.deepStrictEqual(value, buf1);
    assert(!done);
    reader.read().then(common.mustCall(({ value, done }) => {
      assert.deepStrictEqual(value, buf2);
      assert(!done);
      reader.read().then(common.mustCall(({ value, done }) => {
        assert.strictEqual(value, undefined);
        assert(done);
      }));
    }));
  }));
}

{
  const buf1 = Buffer.from('hello');
  const buf2 = Buffer.from('there');
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(buf1);
      controller.enqueue(buf2);
    }
  });
  const reader = stream.getReader();
  reader.read().then(common.mustCall(({ value, done }) => {
    assert.deepStrictEqual(value, buf1);
    assert(!done);
    reader.read().then(common.mustCall(({ value, done }) => {
      assert.deepStrictEqual(value, buf2);
      assert(!done);
      reader.read().then(common.mustNotCall());
      delay().then(common.mustCall());
    }));
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
      controller.close();
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();

  assert(s1 instanceof ReadableStream);
  assert(s2 instanceof ReadableStream);

  async function read(stream) {
    const reader = stream.getReader();
    assert.deepStrictEqual(
      await reader.read(), { value: 'a', done: false });
    assert.deepStrictEqual(
      await reader.read(), { value: 'b', done: false });
    assert.deepStrictEqual(
      await reader.read(), { value: undefined, done: true });
  }

  Promise.all([
    read(s1),
    read(s2),
  ]).then(common.mustCall());
}

{
  const error = new Error('boom');
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
    },
    pull() { throw error; }
  });

  const { 0: s1, 1: s2 } = stream.tee();

  assert(stream.locked);

  assert(s1 instanceof ReadableStream);
  assert(s2 instanceof ReadableStream);

  const reader1 = s1.getReader();
  const reader2 = s2.getReader();

  const closed1 = reader1.closed;
  const closed2 = reader2.closed;

  assert.notStrictEqual(closed1, closed2);

  assert.rejects(closed1, error).then(common.mustCall());
  assert.rejects(closed2, error).then(common.mustCall());

  reader1.read();
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
      controller.close();
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();

  assert(s1 instanceof ReadableStream);
  assert(s2 instanceof ReadableStream);

  s2.cancel();

  async function read(stream, canceled = false) {
    const reader = stream.getReader();
    if (!canceled) {
      assert.deepStrictEqual(
        await reader.read(), { value: 'a', done: false });
      assert.deepStrictEqual(
        await reader.read(), { value: 'b', done: false });
    }
    assert.deepStrictEqual(
      await reader.read(), { value: undefined, done: true });
  }

  Promise.all([
    read(s1),
    read(s2, true),
  ]).then(common.mustCall());
}

{
  const error1 = new Error('boom1');
  const error2 = new Error('boom2');

  const stream = new ReadableStream({
    cancel(reason) {
      assert.deepStrictEqual(reason, [error1, error2]);
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();
  s1.cancel(error1);
  s2.cancel(error2);
}

{
  const error1 = new Error('boom1');
  const error2 = new Error('boom2');

  const stream = new ReadableStream({
    cancel(reason) {
      assert.deepStrictEqual(reason, [error1, error2]);
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();
  s2.cancel(error2);
  s1.cancel(error1);
}

{
  const error = new Error('boom1');

  const stream = new ReadableStream({
    cancel() {
      throw error;
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();

  assert.rejects(s1.cancel(), error).then(common.mustCall());
  assert.rejects(s2.cancel(), error).then(common.mustCall());
}

{
  const error = new Error('boom1');
  let c;
  const stream = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();
  c.error(error);

  assert.rejects(s1.cancel(), error).then(common.mustCall());
  assert.rejects(s2.cancel(), error).then(common.mustCall());
}

{
  const error = new Error('boom1');
  let c;
  const stream = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const { 0: s1, 1: s2 } = stream.tee();

  const reader1 = s1.getReader();
  const reader2 = s2.getReader();

  assert.rejects(reader1.closed, error).then(common.mustCall());
  assert.rejects(reader2.closed, error).then(common.mustCall());

  assert.rejects(reader1.read(), error).then(common.mustCall());
  assert.rejects(reader2.read(), error).then(common.mustCall());

  setImmediate(() => c.error(error));
}

{
  let pullCount = 0;
  const stream = new ReadableStream({
    pull(controller) {
      if (pullCount)
        controller.enqueue(pullCount);
      pullCount++;
    },
  });

  const reader = stream.getReader();

  queueMicrotask(common.mustCall(() => {
    assert.strictEqual(pullCount, 1);
    reader.read().then(common.mustCall(({ value, done }) => {
      assert.strictEqual(value, 1);
      assert(!done);

      reader.read().then(common.mustCall(({ value, done }) => {
        assert.strictEqual(value, 2);
        assert(!done);
      }));

    }));
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
    },
    pull: common.mustCall(),
  });

  stream.getReader().read().then(common.mustCall(({ value, done }) => {
    assert.strictEqual(value, 'a');
    assert(!done);
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
    },
    pull: common.mustCall(),
  });

  const reader = stream.getReader();
  reader.read().then(common.mustCall(({ value, done }) => {
    assert.strictEqual(value, 'a');
    assert(!done);

    reader.read().then(common.mustCall(({ value, done }) => {
      assert.strictEqual(value, 'b');
      assert(!done);
    }));
  }));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
      controller.close();
    },
    pull: common.mustNotCall(),
  });

  const reader = stream.getReader();
  reader.read().then(common.mustCall(({ value, done }) => {
    assert.strictEqual(value, 'a');
    assert(!done);

    reader.read().then(common.mustCall(({ value, done }) => {
      assert.strictEqual(value, 'b');
      assert(!done);

      reader.read().then(common.mustCall(({ value, done }) => {
        assert.strictEqual(value, undefined);
        assert(done);
      }));

    }));
  }));
}

{
  let res;
  let promise;
  let calls = 0;
  const stream = new ReadableStream({
    pull(controller) {
      controller.enqueue(++calls);
      promise = new Promise((resolve) => res = resolve);
      return promise;
    }
  });

  const reader = stream.getReader();

  (async () => {
    await reader.read();
    assert.strictEqual(calls, 1);
    await delay();
    assert.strictEqual(calls, 1);
    res();
    await delay();
    assert.strictEqual(calls, 2);
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
      controller.enqueue('c');
    },
    pull: common.mustCall(4),
  }, {
    highWaterMark: Infinity,
    size() { return 1; }
  });

  const reader = stream.getReader();
  (async () => {
    await delay();
    await reader.read();
    await reader.read();
    await reader.read();
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.enqueue('b');
      controller.enqueue('c');
      controller.close();
    },
    pull: common.mustNotCall(),
  }, {
    highWaterMark: Infinity,
    size() { return 1; }
  });

  const reader = stream.getReader();
  (async () => {
    await delay();
    await reader.read();
    await reader.read();
    await reader.read();
  })().then(common.mustCall());
}

{
  let calls = 0;
  let res;
  const ready = new Promise((resolve) => res = resolve);

  new ReadableStream({
    pull(controller) {
      controller.enqueue(++calls);
      if (calls === 4)
        res();
    }
  }, {
    size() { return 1; },
    highWaterMark: 4
  });

  ready.then(common.mustCall(() => {
    assert.strictEqual(calls, 4);
  }));
}

{
  const stream = new ReadableStream({
    pull: common.mustCall((controller) => controller.close())
  });

  const reader = stream.getReader();

  reader.closed.then(common.mustCall());
}

{
  const error = new Error('boom');
  const stream = new ReadableStream({
    pull: common.mustCall((controller) => controller.error(error))
  });

  const reader = stream.getReader();

  assert.rejects(reader.closed, error).then(common.mustCall());
}

{
  const error = new Error('boom');
  const error2 = new Error('boom2');
  const stream = new ReadableStream({
    pull: common.mustCall((controller) => {
      controller.error(error);
      throw error2;
    })
  });

  const reader = stream.getReader();

  assert.rejects(reader.closed, error).then(common.mustCall());
}

{
  let startCalled = false;
  new ReadableStream({
    start: common.mustCall((controller) => {
      controller.enqueue('a');
      controller.close();
      assert.throws(() => controller.enqueue('b'), {
        code: 'ERR_INVALID_STATE'
      });
      startCalled = true;
    })
  });
  assert(startCalled);
}

{
  let startCalled = false;
  new ReadableStream({
    start: common.mustCall((controller) => {
      controller.close();
      assert.throws(() => controller.enqueue('b'), {
        code: 'ERR_INVALID_STATE'
      });
      startCalled = true;
    })
  });
  assert(startCalled);
}

{
  class Source {
    startCalled = false;
    pullCalled = false;
    cancelCalled = false;

    start(controller) {
      assert.strictEqual(this, source);
      this.startCalled = true;
      controller.enqueue('a');
    }

    pull() {
      assert.strictEqual(this, source);
      this.pullCalled = true;
    }

    cancel() {
      assert.strictEqual(this, source);
      this.cancelCalled = true;
    }
  }

  const source = new Source();

  const stream = new ReadableStream(source);
  const reader = stream.getReader();

  (async () => {
    await reader.read();
    reader.releaseLock();
    stream.cancel();
    assert(source.startCalled);
    assert(source.pullCalled);
    assert(source.cancelCalled);
  })().then(common.mustCall());
}

{
  let startCalled = false;
  new ReadableStream({
    start(controller) {
      assert.strictEqual(controller.desiredSize, 10);
      controller.close();
      assert.strictEqual(controller.desiredSize, 0);
      startCalled = true;
    }
  }, {
    highWaterMark: 10
  });
  assert(startCalled);
}

{
  let startCalled = false;
  new ReadableStream({
    start(controller) {
      assert.strictEqual(controller.desiredSize, 10);
      controller.error();
      assert.strictEqual(controller.desiredSize, null);
      startCalled = true;
    }
  }, {
    highWaterMark: 10
  });
  assert(startCalled);
}

{
  class Foo extends ReadableStream {}
  const foo = new Foo();
  foo.getReader();
}

{
  let startCalled = false;
  new ReadableStream({
    start(controller) {
      assert.strictEqual(controller.desiredSize, 1);
      controller.enqueue('a');
      assert.strictEqual(controller.desiredSize, 0);
      controller.enqueue('a');
      assert.strictEqual(controller.desiredSize, -1);
      controller.enqueue('a');
      assert.strictEqual(controller.desiredSize, -2);
      controller.enqueue('a');
      assert.strictEqual(controller.desiredSize, -3);
      startCalled = true;
    }
  });
  assert(startCalled);
}

{
  let c;
  const stream = new ReadableStream({
    start(controller) {
      c = controller;
    }
  });

  const reader = stream.getReader();

  (async () => {
    assert.strictEqual(c.desiredSize, 1);
    c.enqueue(1);
    assert.strictEqual(c.desiredSize, 0);
    await reader.read();
    assert.strictEqual(c.desiredSize, 1);
    c.enqueue(1);
    c.enqueue(1);
    assert.strictEqual(c.desiredSize, -1);
    await reader.read();
    assert.strictEqual(c.desiredSize, 0);
    await reader.read();
    assert.strictEqual(c.desiredSize, 1);
  })().then(common.mustCall());
}

{
  let c;
  new ReadableStream({
    start(controller) {
      c = controller;
    }
  });
  assert(c instanceof ReadableStreamDefaultController);
  assert.strictEqual(typeof c.desiredSize, 'number');
  assert.strictEqual(typeof c.enqueue, 'function');
  assert.strictEqual(typeof c.close, 'function');
  assert.strictEqual(typeof c.error, 'function');
}

class Source {
  constructor() {
    this.cancelCalled = false;
  }

  start(controller) {
    this.stream = createReadStream(__filename);
    this.stream.on('data', (chunk) => {
      controller.enqueue(chunk);
    });
    this.stream.once('end', () => {
      if (!this.cancelCalled)
        controller.close();
    });
    this.stream.once('error', (error) => {
      controller.error(error);
    });
  }

  cancel() {
    this.cancelCalled = true;
  }
}

{
  const source = new Source();
  const stream = new ReadableStream(source);

  async function read(stream) {
    const reader = stream.getReader();
    const chunks = [];
    let read = await reader.read();
    while (!read.done) {
      chunks.push(Buffer.from(read.value));
      read = await reader.read();
    }
    return Buffer.concat(chunks);
  }

  read(stream).then(common.mustCall((data) => {
    const check = readFileSync(__filename);
    assert.deepStrictEqual(data, check);
  }));
}

{
  const source = new Source();
  const stream = new ReadableStream(source);

  async function read(stream) {
    const chunks = [];
    for await (const chunk of stream)
      chunks.push(chunk);
    return Buffer.concat(chunks);
  }

  read(stream).then(common.mustCall((data) => {
    const check = readFileSync(__filename);
    assert.deepStrictEqual(data, check);

    assert.strictEqual(stream[kState].state, 'closed');
    assert(!stream.locked);
  }));
}

{
  const source = new Source();
  const stream = new ReadableStream(source);

  [1, false, ''].forEach((options) => {
    assert.throws(() => stream.values(options), {
      code: 'ERR_INVALID_ARG_TYPE',
    });
  });

  async function read(stream) {
    for await (const _ of stream.values({ preventCancel: true }))
      return;
  }

  read(stream).then(common.mustCall((data) => {
    assert.strictEqual(stream[kState].state, 'readable');
  }));
}

{
  const source = new Source();
  const stream = new ReadableStream(source);

  async function read(stream) {
    for await (const _ of stream.values({ preventCancel: false }))
      return;
  }

  read(stream).then(common.mustCall((data) => {
    assert.strictEqual(stream[kState].state, 'closed');
  }));
}

{
  const source = new Source();
  const stream = new ReadableStream(source);

  const error = new Error('boom');

  async function read(stream) {
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream.values({ preventCancel: true }))
      throw error;
  }

  assert.rejects(read(stream), error).then(common.mustCall(() => {
    assert.strictEqual(stream[kState].state, 'readable');
  }));
}

{
  const source = new Source();
  const stream = new ReadableStream(source);

  const error = new Error('boom');

  async function read(stream) {
    // eslint-disable-next-line no-unused-vars
    for await (const _ of stream.values({ preventCancel: false }))
      throw error;
  }

  assert.rejects(read(stream), error).then(common.mustCall(() => {
    assert.strictEqual(stream[kState].state, 'closed');
  }));
}

{
  assert.throws(() => Reflect.get(ReadableStream.prototype, 'locked', {}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.rejects(() => ReadableStream.prototype.cancel.call({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.throws(() => ReadableStream.prototype.getReader.call({}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => ReadableStream.prototype.tee.call({}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => ReadableStream.prototype.values.call({}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => ReadableStream.prototype[kTransfer].call({}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.rejects(() => ReadableStreamDefaultReader.prototype.read.call({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.rejects(() => ReadableStreamDefaultReader.prototype.cancel.call({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.rejects(() => {
    return Reflect.get(ReadableStreamDefaultReader.prototype, 'closed');
  }, {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.throws(() => {
    ReadableStreamDefaultReader.prototype.releaseLock.call({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.rejects(() => ReadableStreamBYOBReader.prototype.read.call({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.throws(() => {
    ReadableStreamBYOBReader.prototype.releaseLock.call({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.rejects(() => {
    return Reflect.get(ReadableStreamBYOBReader.prototype, 'closed');
  }, {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.rejects(() => ReadableStreamBYOBReader.prototype.cancel.call({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());

  assert.throws(() => {
    Reflect.get(ReadableByteStreamController.prototype, 'byobRequest', {});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    Reflect.get(ReadableByteStreamController.prototype, 'desiredSize', {});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    ReadableByteStreamController.prototype.close.call({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    ReadableByteStreamController.prototype.enqueue.call({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    ReadableByteStreamController.prototype.error.call({});
  }, {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => new ReadableStreamBYOBRequest(), {
    code: 'ERR_ILLEGAL_CONSTRUCTOR',
  });

  assert.throws(() => new ReadableStreamDefaultController(), {
    code: 'ERR_ILLEGAL_CONSTRUCTOR',
  });

  assert.throws(() => new ReadableByteStreamController(), {
    code: 'ERR_ILLEGAL_CONSTRUCTOR',
  });
}

{
  let controller;
  const readable = new ReadableStream({
    start(c) { controller = c; }
  });

  assert.strictEqual(
    inspect(readable),
    'ReadableStream { locked: false, state: \'readable\', ' +
    'supportsBYOB: false }');
  assert.strictEqual(
    inspect(readable, { depth: null }),
    'ReadableStream { locked: false, state: \'readable\', ' +
    'supportsBYOB: false }');
  assert.strictEqual(
    inspect(readable, { depth: 0 }),
    'ReadableStream [Object]');

  assert.strictEqual(
    inspect(controller),
    'ReadableStreamDefaultController {}');
  assert.strictEqual(
    inspect(controller, { depth: null }),
    'ReadableStreamDefaultController {}');
  assert.strictEqual(
    inspect(controller, { depth: 0 }),
    'ReadableStreamDefaultController {}');

  const reader = readable.getReader();

  assert.match(
    inspect(reader),
    /ReadableStreamDefaultReader/);
  assert.match(
    inspect(reader, { depth: null }),
    /ReadableStreamDefaultReader/);
  assert.match(
    inspect(reader, { depth: 0 }),
    /ReadableStreamDefaultReader/);

  assert.rejects(readableStreamPipeTo(1), {
    code: 'ERR_INVALID_ARG_TYPE',
  }).then(common.mustCall());

  assert.rejects(readableStreamPipeTo(new ReadableStream(), 1), {
    code: 'ERR_INVALID_ARG_TYPE',
  }).then(common.mustCall());

  assert.rejects(
    readableStreamPipeTo(
      new ReadableStream(),
      new WritableStream(),
      false,
      false,
      false,
      {}),
    {
      code: 'ERR_INVALID_ARG_TYPE',
    }).then(common.mustCall());
}

{
  const readable = new ReadableStream();
  const reader = readable.getReader();
  reader.releaseLock();
  reader.releaseLock();
  assert.rejects(reader.read(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
  assert.rejects(reader.cancel(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
}

{
  // Test tee() cloneForBranch2 argument
  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue('hello');
    }
  });
  const [r1, r2] = readableStreamTee(readable, true);
  r1.getReader().read().then(
    common.mustCall(({ value }) => assert.strictEqual(value, 'hello')));
  r2.getReader().read().then(
    common.mustCall(({ value }) => assert.strictEqual(value, 'hello')));
}

{
  assert.throws(() => {
    readableByteStreamControllerConvertPullIntoDescriptor({
      bytesFilled: 10,
      byteLength: 5
    });
  }, {
    code: 'ERR_INVALID_STATE',
  });
}

{
  let controller;
  const readable = new ReadableStream({
    start(c) { controller = c; }
  });

  controller[kState].pendingPullIntos = [{}];
  assert.throws(() => readableByteStreamControllerRespond(controller, 0), {
    code: 'ERR_INVALID_ARG_VALUE',
  });

  readable.cancel().then(common.mustCall());

  assert.throws(() => readableByteStreamControllerRespond(controller, 1), {
    code: 'ERR_INVALID_ARG_VALUE',
  });

  assert(!readableStreamDefaultControllerCanCloseOrEnqueue(controller));
  readableStreamDefaultControllerEnqueue(controller);
  readableByteStreamControllerClose(controller);
  readableByteStreamControllerEnqueue(controller, new Uint8Array(1));
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('a');
      controller.close();
    },
    pull: common.mustNotCall(),
  });

  const reader = stream.getReader();
  (async () => {
    isDisturbed(stream, false);
    await reader.read();
    isDisturbed(stream, true);
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(controller) {
      controller.close();
    },
    pull: common.mustNotCall(),
  });

  const reader = stream.getReader();
  (async () => {
    isDisturbed(stream, false);
    await reader.read();
    isDisturbed(stream, true);
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    start(controller) {
    },
    pull: common.mustNotCall(),
  });
  stream.cancel();

  const reader = stream.getReader();
  (async () => {
    isDisturbed(stream, false);
    await reader.read();
    isDisturbed(stream, true);
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    pull: common.mustCall((controller) => {
      controller.error(new Error());
    }),
  });

  const reader = stream.getReader();
  (async () => {
    isErrored(stream, false);
    await reader.read().catch(common.mustCall());
    isErrored(stream, true);
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    pull: common.mustCall((controller) => {
      controller.error(new Error());
    }),
  });

  const reader = stream.getReader();
  (async () => {
    isReadable(stream, true);
    await reader.read().catch(common.mustCall());
    isReadable(stream, false);
  })().then(common.mustCall());
}

{
  const stream = new ReadableStream({
    type: 'bytes',
    start(controller) {
      controller.close();
    }
  });

  const buffer = new ArrayBuffer(1024);
  const reader = stream.getReader({ mode: 'byob' });

  reader.read(new DataView(buffer))
    .then(common.mustCall());
}

{
  const stream = new ReadableStream({
    type: 'bytes',
    autoAllocateChunkSize: 128,
    pull: common.mustCall((controller) => {
      const view = controller.byobRequest.view;
      const dest = new Uint8Array(
        view.buffer,
        view.byteOffset,
        view.byteLength
      );
      dest.fill(1);
      controller.byobRequest.respondWithNewView(dest);
    }),
  });

  const reader = stream.getReader({ mode: 'byob' });

  const buffer = new ArrayBuffer(10);
  const view = new Uint8Array(
    buffer,
    1,
    3
  );

  reader.read(view).then(common.mustCall(({ value }) => {
    assert.deepStrictEqual(value, new Uint8Array([1, 1, 1]));
  }));
}

// Initial Pull Delay
{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('data');
      controller.close();
    }
  });

  const iterator = stream.values();

  let microtaskCompleted = false;
  Promise.resolve().then(() => { microtaskCompleted = true; });

  iterator.next().then(common.mustCall(({ done, value }) => {
    assert.strictEqual(done, false);
    assert.strictEqual(value, 'data');
    assert.strictEqual(microtaskCompleted, true);
  }));
}

// Avoiding Prototype Pollution
{
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('data');
      controller.close();
    }
  });

  const iterator = stream.values();

  // Modify Promise.prototype.then to simulate prototype pollution
  const originalThen = Promise.prototype.then;
  Promise.prototype.then = function(onFulfilled, onRejected) {
    return originalThen.call(this, onFulfilled, onRejected);
  };

  iterator.next().then(common.mustCall(({ done, value }) => {
    assert.strictEqual(done, false);
    assert.strictEqual(value, 'data');

    // Restore original then method
    Promise.prototype.then = originalThen;
  }));
}
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-whatwg-readablestream.mjs                                            0000664 0000000 0000000 00000003316 14746647661 0023275 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import { mustCall } from '../common/index.mjs';
import { ReadableStream } from 'stream/web';
import assert from 'assert';

{
  // Test tee() with close in the nextTick after enqueue
  async function read(stream) {
    const chunks = [];
    for await (const chunk of stream)
      chunks.push(chunk);
    return Buffer.concat(chunks).toString();
  }

  const [r1, r2] = new ReadableStream({
    start(controller) {
      process.nextTick(() => {
        controller.enqueue(new Uint8Array([102, 111, 111, 98, 97, 114]));

        process.nextTick(() => {
          controller.close();
        });
      });
    }
  }).tee();

  (async () => {
    const [dataReader1, dataReader2] = await Promise.all([
      read(r1),
      read(r2),
    ]);

    assert.strictEqual(dataReader1, dataReader2);
    assert.strictEqual(dataReader1, 'foobar');
    assert.strictEqual(dataReader2, 'foobar');
  })().then(mustCall());
}

{
  // Test ReadableByteStream.tee() with close in the nextTick after enqueue
  async function read(stream) {
    const chunks = [];
    for await (const chunk of stream)
      chunks.push(chunk);
    return Buffer.concat(chunks).toString();
  }

  const [r1, r2] = new ReadableStream({
    type: 'bytes',
    start(controller) {
      process.nextTick(() => {
        controller.enqueue(new Uint8Array([102, 111, 111, 98, 97, 114]));

        process.nextTick(() => {
          controller.close();
        });
      });
    }
  }).tee();

  (async () => {
    const [dataReader1, dataReader2] = await Promise.all([
      read(r1),
      read(r2),
    ]);

    assert.strictEqual(dataReader1, dataReader2);
    assert.strictEqual(dataReader1, 'foobar');
    assert.strictEqual(dataReader2, 'foobar');
  })().then(mustCall());
}
                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-whatwg-transformstream.js                                            0000664 0000000 0000000 00000012360 14746647661 0023373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');
const assert = require('assert');

const {
  ReadableStream,
  TransformStream,
  TransformStreamDefaultController,
} = require('stream/web');

const {
  createReadStream,
  readFileSync,
} = require('fs');

const {
  kTransfer,
} = require('internal/worker/js_transferable');

const {
  inspect,
} = require('util');

assert.throws(() => new TransformStream({ readableType: 1 }), {
  code: 'ERR_INVALID_ARG_VALUE',
});
assert.throws(() => new TransformStream({ writableType: 1 }), {
  code: 'ERR_INVALID_ARG_VALUE',
});

{
  new TransformStream({});
  new TransformStream([]);
  new TransformStream({}, null);
  new TransformStream({}, {});
  new TransformStream({}, []);
  new TransformStream({}, {}, null);
  new TransformStream({}, {}, {});
  new TransformStream({}, {}, []);
}

['a', false, 1, null].forEach((transform) => {
  assert.throws(() => {
    new TransformStream(transform);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

['a', false, 1].forEach((writableStrategy) => {
  assert.throws(() => {
    new TransformStream({}, writableStrategy);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

['a', false, 1].forEach((readableStrategy) => {
  assert.throws(() => {
    new TransformStream({}, {}, readableStrategy);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

{
  const stream = new TransformStream();

  async function test(stream) {
    const writer = stream.writable.getWriter();
    const reader = stream.readable.getReader();

    const { 1: result } = await Promise.all([
      writer.write('hello'),
      reader.read(),
    ]);

    assert.strictEqual(result.value, 'hello');
  }

  test(stream).then(common.mustCall());
}

class Transform {
  start(controller) {
    this.started = true;
  }

  async transform(chunk, controller) {
    controller.enqueue(chunk.toUpperCase());
  }

  async flush() {
    this.flushed = true;
  }
}

{
  const transform = new Transform();
  const stream = new TransformStream(transform);
  assert(transform.started);

  async function test(stream) {
    const writer = stream.writable.getWriter();
    const reader = stream.readable.getReader();

    const { 1: result } = await Promise.all([
      writer.write('hello'),
      reader.read(),
    ]);

    assert.strictEqual(result.value, 'HELLO');

    await writer.close();
  }

  test(stream).then(common.mustCall(() => {
    assert(transform.flushed);
  }));
}

class Source {
  constructor() {
    this.cancelCalled = false;
  }

  start(controller) {
    this.stream = createReadStream(__filename);
    this.stream.on('data', (chunk) => {
      controller.enqueue(chunk.toString());
    });
    this.stream.once('end', () => {
      if (!this.cancelCalled)
        controller.close();
    });
    this.stream.once('error', (error) => {
      controller.error(error);
    });
  }

  cancel() {
    this.cancelCalled = true;
  }
}

{
  const instream = new ReadableStream(new Source());
  const tstream = new TransformStream(new Transform());
  const r = instream.pipeThrough(tstream);

  async function read(stream) {
    let res = '';
    for await (const chunk of stream)
      res += chunk;
    return res;
  }

  read(r).then(common.mustCall((data) => {
    const check = readFileSync(__filename);
    assert.strictEqual(check.toString().toUpperCase(), data);
  }));
}

{
  assert.throws(() => Reflect.get(TransformStream.prototype, 'readable', {}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => Reflect.get(TransformStream.prototype, 'writable', {}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => TransformStream.prototype[kTransfer]({}), {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => {
    Reflect.get(TransformStreamDefaultController.prototype, 'desiredSize', {});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    TransformStreamDefaultController.prototype.enqueue({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    TransformStreamDefaultController.prototype.error({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => {
    TransformStreamDefaultController.prototype.terminate({});
  }, {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => new TransformStreamDefaultController(), {
    code: 'ERR_ILLEGAL_CONSTRUCTOR',
  });
}

{
  let controller;
  const transform = new TransformStream({
    start(c) {
      controller = c;
    }
  });

  assert.match(inspect(transform), /TransformStream/);
  assert.match(inspect(transform, { depth: null }), /TransformStream/);
  assert.match(inspect(transform, { depth: 0 }), /TransformStream \[/);

  assert.match(inspect(controller), /TransformStreamDefaultController/);
  assert.match(
    inspect(controller, { depth: null }),
    /TransformStreamDefaultController/);
  assert.match(
    inspect(controller, { depth: 0 }),
    /TransformStreamDefaultController \[/);
}

{
  Object.defineProperty(Object.prototype, 'type', {
    get: common.mustNotCall('get %Object.prototype%.type'),
    set: common.mustNotCall('set %Object.prototype%.type'),
    configurable: true,
  });

  new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk);
    },
    flush(controller) {
      controller.terminate();
    }
  });

  delete Object.prototype.type;
}
                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-whatwg-url-canparse.js                                               0000664 0000000 0000000 00000002156 14746647661 0022542 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings --allow-natives-syntax
'use strict';

const common = require('../common');

const { URL } = require('url');
const assert = require('assert');

const { internalBinding } = require('internal/test/binding');

// One argument is required
assert.throws(() => {
  URL.canParse();
}, {
  code: 'ERR_MISSING_ARGS',
  name: 'TypeError',
});

// It should not throw when called without a base string
assert.strictEqual(URL.canParse('https://example.org'), true);

{
  // V8 Fast API
  function testFastPaths() {
    // `canParse` binding has two overloads.
    assert.strictEqual(URL.canParse('https://www.example.com/path/?query=param#hash'), true);
    assert.strictEqual(URL.canParse('/', 'http://n'), true);
  }

  eval('%PrepareFunctionForOptimization(URL.canParse)');
  testFastPaths();
  eval('%OptimizeFunctionOnNextCall(URL.canParse)');
  testFastPaths();

  if (common.isDebug) {
    const { getV8FastApiCallCount } = internalBinding('debug');
    assert.strictEqual(getV8FastApiCallCount('url.canParse'), 1);
    assert.strictEqual(getV8FastApiCallCount('url.canParse.withBase'), 1);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-whatwg-url-custom-deepequal.js                                       0000664 0000000 0000000 00000000767 14746647661 0024231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// This tests that the internal flags in URL objects are consistent, as manifest
// through assert libraries.
// See https://github.com/nodejs/node/issues/24211

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

assert.deepStrictEqual(
  new URL('./foo', 'https://example.com/'),
  new URL('https://example.com/foo')
);
assert.deepStrictEqual(
  new URL('./foo', 'https://user:pass@example.com/'),
  new URL('https://user:pass@example.com/foo')
);
         node-23.7.0/test/parallel/test-whatwg-url-custom-global.js                                          0000664 0000000 0000000 00000000731 14746647661 0023513 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

assert.deepStrictEqual(
  Object.getOwnPropertyDescriptor(globalThis, 'URL'),
  {
    value: URL,
    writable: true,
    configurable: true,
    enumerable: false
  }
);

assert.deepStrictEqual(
  Object.getOwnPropertyDescriptor(globalThis, 'URLSearchParams'),
  {
    value: URLSearchParams,
    writable: true,
    configurable: true,
    enumerable: false
  }
);
                                       node-23.7.0/test/parallel/test-whatwg-url-custom-href-side-effect.js                                0000664 0000000 0000000 00000000460 14746647661 0025352 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.
require('../common');
const assert = require('assert');

const ref = new URL('http://example.com/path');
const url = new URL('http://example.com/path');
assert.throws(() => {
  url.href = '';
}, {
  name: 'TypeError'
});

assert.deepStrictEqual(url, ref);
                                                                                                                                                                                                                node-23.7.0/test/parallel/test-whatwg-url-custom-inspect.js                                         0000664 0000000 0000000 00000003346 14746647661 0023725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

const common = require('../common');
if (!common.hasIntl) {
  // A handful of the tests fail when ICU is not included.
  common.skip('missing Intl');
}

const util = require('util');
const assert = require('assert');

const url = new URL('https://username:password@host.name:8080/path/name/?que=ry#hash');

assert.strictEqual(
  util.inspect(url),
  `URL {
  href: 'https://username:password@host.name:8080/path/name/?que=ry#hash',
  origin: 'https://host.name:8080',
  protocol: 'https:',
  username: 'username',
  password: 'password',
  host: 'host.name:8080',
  hostname: 'host.name',
  port: '8080',
  pathname: '/path/name/',
  search: '?que=ry',
  searchParams: URLSearchParams { 'que' => 'ry' },
  hash: '#hash'
}`);

assert.strictEqual(
  util.inspect(url, { showHidden: true }),
  `URL {
  href: 'https://username:password@host.name:8080/path/name/?que=ry#hash',
  origin: 'https://host.name:8080',
  protocol: 'https:',
  username: 'username',
  password: 'password',
  host: 'host.name:8080',
  hostname: 'host.name',
  port: '8080',
  pathname: '/path/name/',
  search: '?que=ry',
  searchParams: URLSearchParams { 'que' => 'ry' },
  hash: '#hash',
  [Symbol(context)]: URLContext {
    href: 'https://username:password@host.name:8080/path/name/?que=ry#hash',
    protocol_end: 6,
    username_end: 16,
    host_start: 25,
    host_end: 35,
    pathname_start: 40,
    search_start: 51,
    hash_start: 58,
    port: 8080,
    scheme_type: 2,
    [hasPort]: [Getter],
    [hasSearch]: [Getter],
    [hasHash]: [Getter]
  }
}`);

assert.strictEqual(
  util.inspect({ a: url }, { depth: 0 }),
  '{ a: URL {} }');

class MyURL extends URL {}
assert(util.inspect(new MyURL(url.href)).startsWith('MyURL {'));
                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-whatwg-url-custom-parsing.js                                         0000664 0000000 0000000 00000005132 14746647661 0023716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

const common = require('../common');
if (!common.hasIntl) {
  // A handful of the tests fail when ICU is not included.
  common.skip('missing Intl');
}

const assert = require('assert');
const fixtures = require('../common/fixtures');

const tests = require(
  fixtures.path('wpt', 'url', 'resources', 'urltestdata.json')
);

const originalFailures = tests.filter((test) => test.failure);

const typeFailures = [
  { input: '' },
  { input: 'test' },
  { input: undefined },
  { input: 0 },
  { input: true },
  { input: false },
  { input: null },
  { input: new Date() },
  { input: new RegExp() },
  { input: 'test', base: null },
  { input: 'http://nodejs.org', base: null },
  { input: () => {} },
];

// See https://github.com/w3c/web-platform-tests/pull/10955
// > If `failure` is true, parsing `about:blank` against `base`
// > must give failure. This tests that the logic for converting
// > base URLs into strings properly fails the whole parsing
// > algorithm if the base URL cannot be parsed.
const aboutBlankFailures = originalFailures
  .map((test) => ({
    input: 'about:blank',
    base: test.input,
    failure: true
  }));

const failureTests = originalFailures
  .concat(typeFailures)
  .concat(aboutBlankFailures);

const expectedError = { code: 'ERR_INVALID_URL', name: 'TypeError' };

for (const test of failureTests) {
  assert.throws(
    () => new URL(test.input, test.base),
    (error) => {
      assert.throws(() => { throw error; }, expectedError);
      assert.strictEqual(`${error}`, 'TypeError: Invalid URL');
      assert.strictEqual(error.message, 'Invalid URL');
      return true;
    });
}

const additional_tests =
  require(fixtures.path('url-tests-additional.js'));

for (const test of additional_tests) {
  const url = new URL(test.url);
  if (test.href) assert.strictEqual(url.href, test.href);
  if (test.origin) assert.strictEqual(url.origin, test.origin);
  if (test.protocol) assert.strictEqual(url.protocol, test.protocol);
  if (test.username) assert.strictEqual(url.username, test.username);
  if (test.password) assert.strictEqual(url.password, test.password);
  if (test.hostname) assert.strictEqual(url.hostname, test.hostname);
  if (test.host) assert.strictEqual(url.host, test.host);
  if (test.port !== undefined) assert.strictEqual(url.port, test.port);
  if (test.pathname) assert.strictEqual(url.pathname, test.pathname);
  if (test.search) assert.strictEqual(url.search, test.search);
  if (test.hash) assert.strictEqual(url.hash, test.hash);
}

assert.throws(() => {
  new URL();
}, {
  name: 'TypeError',
  code: 'ERR_MISSING_ARGS',
});
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-whatwg-url-custom-properties.js                                      0000664 0000000 0000000 00000013374 14746647661 0024456 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

const url = new URL('http://user:pass@foo.bar.com:21/aaa/zzz?l=24#test');
const oldParams = url.searchParams;  // For test of [SameObject]

// To retrieve enumerable but not necessarily own properties,
// we need to use the for-in loop.
const props = [];
for (const prop in url) {
  props.push(prop);
}

// See: https://url.spec.whatwg.org/#api
// https://heycam.github.io/webidl/#es-attributes
// https://heycam.github.io/webidl/#es-stringifier
const expected = ['toString',
                  'href', 'origin', 'protocol',
                  'username', 'password', 'host', 'hostname', 'port',
                  'pathname', 'search', 'searchParams', 'hash', 'toJSON'];

assert.deepStrictEqual(props, expected);

// `href` is writable (not readonly) and is stringifier
assert.strictEqual(url.toString(), url.href);
url.href = 'http://user:pass@foo.bar.com:21/aaa/zzz?l=25#test';
assert.strictEqual(url.href,
                   'http://user:pass@foo.bar.com:21/aaa/zzz?l=25#test');
assert.strictEqual(url.toString(), url.href);
// Return true because it's configurable, but because the properties
// are defined on the prototype per the spec, the deletion has no effect
assert.strictEqual((delete url.href), true);
assert.strictEqual(url.href,
                   'http://user:pass@foo.bar.com:21/aaa/zzz?l=25#test');
assert.strictEqual(url.searchParams, oldParams);  // [SameObject]

// searchParams is readonly. Under strict mode setting a
// non-writable property should throw.
// Note: this error message is subject to change in V8 updates
assert.throws(
  () => url.origin = 'http://foo.bar.com:22',
  /^TypeError: Cannot set property origin of \[object URL\] which has only a getter$/
);
assert.strictEqual(url.origin, 'http://foo.bar.com:21');
assert.strictEqual(url.toString(),
                   'http://user:pass@foo.bar.com:21/aaa/zzz?l=25#test');
assert.strictEqual((delete url.origin), true);
assert.strictEqual(url.origin, 'http://foo.bar.com:21');

// The following properties should be writable (not readonly)
url.protocol = 'https:';
assert.strictEqual(url.protocol, 'https:');
assert.strictEqual(url.toString(),
                   'https://user:pass@foo.bar.com:21/aaa/zzz?l=25#test');
assert.strictEqual((delete url.protocol), true);
assert.strictEqual(url.protocol, 'https:');

url.username = 'user2';
assert.strictEqual(url.username, 'user2');
assert.strictEqual(url.toString(),
                   'https://user2:pass@foo.bar.com:21/aaa/zzz?l=25#test');
assert.strictEqual((delete url.username), true);
assert.strictEqual(url.username, 'user2');

url.password = 'pass2';
assert.strictEqual(url.password, 'pass2');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.com:21/aaa/zzz?l=25#test');
assert.strictEqual((delete url.password), true);
assert.strictEqual(url.password, 'pass2');

url.host = 'foo.bar.net:22';
assert.strictEqual(url.host, 'foo.bar.net:22');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.net:22/aaa/zzz?l=25#test');
assert.strictEqual((delete url.host), true);
assert.strictEqual(url.host, 'foo.bar.net:22');

url.hostname = 'foo.bar.org';
assert.strictEqual(url.hostname, 'foo.bar.org');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.org:22/aaa/zzz?l=25#test');
assert.strictEqual((delete url.hostname), true);
assert.strictEqual(url.hostname, 'foo.bar.org');

url.port = '23';
assert.strictEqual(url.port, '23');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.org:23/aaa/zzz?l=25#test');
assert.strictEqual((delete url.port), true);
assert.strictEqual(url.port, '23');

url.pathname = '/aaa/bbb';
assert.strictEqual(url.pathname, '/aaa/bbb');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.org:23/aaa/bbb?l=25#test');
assert.strictEqual((delete url.pathname), true);
assert.strictEqual(url.pathname, '/aaa/bbb');

url.search = '?k=99';
assert.strictEqual(url.search, '?k=99');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.org:23/aaa/bbb?k=99#test');
assert.strictEqual((delete url.search), true);
assert.strictEqual(url.search, '?k=99');

url.hash = '#abcd';
assert.strictEqual(url.hash, '#abcd');
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.org:23/aaa/bbb?k=99#abcd');
assert.strictEqual((delete url.hash), true);
assert.strictEqual(url.hash, '#abcd');

// searchParams is readonly. Under strict mode setting a
// non-writable property should throw.
// Note: this error message is subject to change in V8 updates
assert.throws(
  () => url.searchParams = '?k=88',
  /^TypeError: Cannot set property searchParams of \[object URL\] which has only a getter$/
);
assert.strictEqual(url.searchParams, oldParams);
assert.strictEqual(url.toString(),
                   'https://user2:pass2@foo.bar.org:23/aaa/bbb?k=99#abcd');
assert.strictEqual((delete url.searchParams), true);
assert.strictEqual(url.searchParams, oldParams);

// Test special origins
[
  { expected: 'https://whatwg.org',
    url: 'blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f' },
  { expected: 'ftp://example.org', url: 'ftp://example.org/foo' },
  { expected: 'http://example.org', url: 'http://example.org/foo' },
  { expected: 'https://example.org', url: 'https://example.org/foo' },
  { expected: 'ws://example.org', url: 'ws://example.org/foo' },
  { expected: 'wss://example.org', url: 'wss://example.org/foo' },
  { expected: 'null', url: 'gopher://gopher.quux.org/1/' },
  { expected: 'null', url: 'file:///tmp/mock/path' },
  { expected: 'null', url: 'npm://nodejs/rules' },
].forEach((test) => {
  assert.strictEqual(new URL(test.url).origin, test.expected);
});
                                                                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-append.js                             0000664 0000000 0000000 00000002005 14746647661 0026165 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.append.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
  assert.throws(() => {
    params.append('a');
  }, {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: 'The "name" and "value" arguments must be specified'
  });

  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  assert.throws(() => params.set(obj, 'b'), /^Error: toString$/);
  assert.throws(() => params.set('a', obj), /^Error: toString$/);
  assert.throws(() => params.set(sym, 'b'),
                /^TypeError: Cannot convert a Symbol value to a string$/);
  assert.throws(() => params.set('a', sym),
                /^TypeError: Cannot convert a Symbol value to a string$/);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-constructor.js                        0000664 0000000 0000000 00000005251 14746647661 0027311 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

function makeIterableFunc(array) {
  return Object.assign(() => {}, {
    [Symbol.iterator]() {
      return array[Symbol.iterator]();
    }
  });
}

{
  const iterableError = {
    code: 'ERR_ARG_NOT_ITERABLE',
    name: 'TypeError',
    message: 'Query pairs must be iterable'
  };
  const tupleError = {
    code: 'ERR_INVALID_TUPLE',
    name: 'TypeError',
    message: 'Each query pair must be an iterable [name, value] tuple'
  };

  let params;
  params = new URLSearchParams(undefined);
  assert.strictEqual(params.toString(), '');
  params = new URLSearchParams(null);
  assert.strictEqual(params.toString(), '');
  params = new URLSearchParams(
    makeIterableFunc([['key', 'val'], ['key2', 'val2']])
  );
  assert.strictEqual(params.toString(), 'key=val&key2=val2');
  params = new URLSearchParams(
    makeIterableFunc([['key', 'val'], ['key2', 'val2']].map(makeIterableFunc))
  );
  assert.strictEqual(params.toString(), 'key=val&key2=val2');
  params = new URLSearchParams({ hasOwnProperty: 1 });
  assert.strictEqual(params.get('hasOwnProperty'), '1');
  assert.strictEqual(params.toString(), 'hasOwnProperty=1');
  assert.throws(() => new URLSearchParams([[1]]), tupleError);
  assert.throws(() => new URLSearchParams([[1, 2, 3]]), tupleError);
  assert.throws(() => new URLSearchParams({ [Symbol('test')]: 42 }),
                TypeError);
  assert.throws(() => new URLSearchParams({ [Symbol.iterator]: 42 }),
                iterableError);
  assert.throws(() => new URLSearchParams([{}]), tupleError);
  assert.throws(() => new URLSearchParams(['a']), tupleError);
  assert.throws(() => new URLSearchParams([null]), tupleError);
  assert.throws(() => new URLSearchParams([{ [Symbol.iterator]: 42 }]),
                tupleError);

  assert.throws(() => new URLSearchParams(
    makeIterableFunc([['key', 'val', 'val2']])
  ), tupleError);
}

{
  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  const toStringError = /^Error: toString$/;
  const symbolError = /^TypeError: Cannot convert a Symbol value to a string$/;

  assert.throws(() => new URLSearchParams({ a: obj }), toStringError);
  assert.throws(() => new URLSearchParams([['a', obj]]), toStringError);
  assert.throws(() => new URLSearchParams(sym), symbolError);
  assert.throws(() => new URLSearchParams({ [sym]: 'a' }), symbolError);
  assert.throws(() => new URLSearchParams({ a: sym }), symbolError);
  assert.throws(() => new URLSearchParams([[sym, 'a']]), symbolError);
  assert.throws(() => new URLSearchParams([['a', sym]]), symbolError);
}
                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-delete.js                             0000664 0000000 0000000 00000002313 14746647661 0026162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.delete.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
  assert.throws(() => {
    params.delete();
  }, {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: 'The "name" argument must be specified'
  });

  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  assert.throws(() => params.delete(obj), /^Error: toString$/);
  assert.throws(() => params.delete(sym),
                /^TypeError: Cannot convert a Symbol value to a string$/);
}

// https://github.com/nodejs/node/issues/10480
// Emptying searchParams should correctly update url's query
{
  const url = new URL('http://domain?var=1&var=2&var=3');
  for (const param of url.searchParams.keys()) {
    url.searchParams.delete(param);
  }
  assert.strictEqual(url.searchParams.toString(), '');
  assert.strictEqual(url.search, '');
  assert.strictEqual(url.href, 'http://domain/');
}
                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-entries.js                            0000664 0000000 0000000 00000001725 14746647661 0026377 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

// Tests below are not from WPT.
const params = new URLSearchParams('a=b&c=d');
const entries = params.entries();
assert.strictEqual(typeof entries[Symbol.iterator], 'function');
assert.strictEqual(entries[Symbol.iterator](), entries);
assert.deepStrictEqual(entries.next(), {
  value: ['a', 'b'],
  done: false
});
assert.deepStrictEqual(entries.next(), {
  value: ['c', 'd'],
  done: false
});
assert.deepStrictEqual(entries.next(), {
  value: undefined,
  done: true
});
assert.deepStrictEqual(entries.next(), {
  value: undefined,
  done: true
});

assert.throws(() => {
  entries.next.call(undefined);
}, {
  code: 'ERR_INVALID_THIS',
  name: 'TypeError',
  message: 'Value of "this" must be of type URLSearchParamsIterator'
});
assert.throws(() => {
  params.entries.call(undefined);
}, {
  code: 'ERR_INVALID_THIS',
  name: 'TypeError',
  message: 'Value of "this" must be of type URLSearchParams'
});
                                           node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-foreach.js                            0000664 0000000 0000000 00000000523 14746647661 0026330 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.forEach.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
}
                                                                                                                                                                             node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-get.js                                0000664 0000000 0000000 00000001454 14746647661 0025504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.get.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
  assert.throws(() => {
    params.get();
  }, {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: 'The "name" argument must be specified'
  });

  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  assert.throws(() => params.get(obj), /^Error: toString$/);
  assert.throws(() => params.get(sym),
                /^TypeError: Cannot convert a Symbol value to a string$/);
}
                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-getall.js                             0000664 0000000 0000000 00000001470 14746647661 0026173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.getAll.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
  assert.throws(() => {
    params.getAll();
  }, {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: 'The "name" argument must be specified'
  });

  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  assert.throws(() => params.getAll(obj), /^Error: toString$/);
  assert.throws(() => params.getAll(sym),
                /^TypeError: Cannot convert a Symbol value to a string$/);
}
                                                                                                                                                                                                        node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-has.js                                0000664 0000000 0000000 00000001454 14746647661 0025500 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.has.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
  assert.throws(() => {
    params.has();
  }, {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: 'The "name" argument must be specified'
  });

  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  assert.throws(() => params.has(obj), /^Error: toString$/);
  assert.throws(() => params.has(sym),
                /^TypeError: Cannot convert a Symbol value to a string$/);
}
                                                                                                                                                                                                                    node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-inspect.js                            0000664 0000000 0000000 00000002775 14746647661 0026401 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');
const util = require('util');

const sp = new URLSearchParams('?a=a&b=b&b=c');
assert.strictEqual(util.inspect(sp),
                   "URLSearchParams { 'a' => 'a', 'b' => 'b', 'b' => 'c' }");
assert.strictEqual(util.inspect(sp, { depth: -1 }), '[Object]');
assert.strictEqual(
  util.inspect(sp, { breakLength: 1 }),
  "URLSearchParams {\n  'a' => 'a',\n  'b' => 'b',\n  'b' => 'c' }"
);
assert.strictEqual(util.inspect(sp.keys()),
                   "URLSearchParams Iterator { 'a', 'b', 'b' }");
assert.strictEqual(util.inspect(sp.values()),
                   "URLSearchParams Iterator { 'a', 'b', 'c' }");
assert.strictEqual(util.inspect(sp.keys(), { breakLength: 1 }),
                   "URLSearchParams Iterator {\n  'a',\n  'b',\n  'b' }");
assert.throws(() => sp[util.inspect.custom].call(), {
  code: 'ERR_INVALID_THIS',
});

const iterator = sp.entries();
assert.strictEqual(util.inspect(iterator),
                   "URLSearchParams Iterator { [ 'a', 'a' ], [ 'b', 'b' ], " +
                                             "[ 'b', 'c' ] }");
iterator.next();
assert.strictEqual(util.inspect(iterator),
                   "URLSearchParams Iterator { [ 'b', 'b' ], [ 'b', 'c' ] }");
iterator.next();
iterator.next();
assert.strictEqual(util.inspect(iterator),
                   'URLSearchParams Iterator {  }');
const emptySp = new URLSearchParams();
assert.strictEqual(util.inspect(emptySp), 'URLSearchParams {}');
   node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-keys.js                               0000664 0000000 0000000 00000001650 14746647661 0025676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

const params = new URLSearchParams('a=b&c=d');
const keys = params.keys();

assert.strictEqual(typeof keys[Symbol.iterator], 'function');
assert.strictEqual(keys[Symbol.iterator](), keys);
assert.deepStrictEqual(keys.next(), {
  value: 'a',
  done: false
});
assert.deepStrictEqual(keys.next(), {
  value: 'c',
  done: false
});
assert.deepStrictEqual(keys.next(), {
  value: undefined,
  done: true
});
assert.deepStrictEqual(keys.next(), {
  value: undefined,
  done: true
});

assert.throws(() => {
  keys.next.call(undefined);
}, {
  code: 'ERR_INVALID_THIS',
  name: 'TypeError',
  message: 'Value of "this" must be of type URLSearchParamsIterator'
});
assert.throws(() => {
  params.keys.call(undefined);
}, {
  code: 'ERR_INVALID_THIS',
  name: 'TypeError',
  message: 'Value of "this" must be of type URLSearchParams'
});
                                                                                        node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-set.js                                0000664 0000000 0000000 00000002013 14746647661 0025510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.set.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
  assert.throws(() => {
    params.set('a');
  }, {
    code: 'ERR_MISSING_ARGS',
    name: 'TypeError',
    message: 'The "name" and "value" arguments must be specified'
  });

  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  assert.throws(() => params.append(obj, 'b'), /^Error: toString$/);
  assert.throws(() => params.append('a', obj), /^Error: toString$/);
  assert.throws(() => params.append(sym, 'b'),
                /^TypeError: Cannot convert a Symbol value to a string$/);
  assert.throws(() => params.append('a', sym),
                /^TypeError: Cannot convert a Symbol value to a string$/);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-sort.js                               0000664 0000000 0000000 00000002526 14746647661 0025715 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const { test, assert_array_equals } = require('../common/wpt').harness;

// TODO(joyeecheung): upstream this to WPT, if possible - even
// just as a test for large inputs. Other implementations may
// have a similar cutoff anyway.

// Test bottom-up iterative stable merge sort because we only use that
// algorithm to sort > 100 search params.
const tests = [{ input: '', output: [] }];
const pairs = [];
for (let i = 10; i < 100; i++) {
  pairs.push([`a${i}`, 'b']);
  tests[0].output.push([`a${i}`, 'b']);
}
tests[0].input = pairs.sort(() => Math.random() > 0.5)
  .map((pair) => pair.join('=')).join('&');

tests.push(
  {
    'input': 'z=a&=b&c=d',
    'output': [['', 'b'], ['c', 'd'], ['z', 'a']]
  }
);

tests.forEach((val) => {
  test(() => {
    const params = new URLSearchParams(val.input);
    let i = 0;
    params.sort();
    for (const param of params) {
      assert_array_equals(param, val.output[i]);
      i++;
    }
  }, `Parse and sort: ${val.input}`);

  test(() => {
    const url = new URL(`?${val.input}`, 'https://example/');
    url.searchParams.sort();
    const params = new URLSearchParams(url.search);
    let i = 0;
    for (const param of params) {
      assert_array_equals(param, val.output[i]);
      i++;
    }
  }, `URL parse and sort: ${val.input}`);
});
                                                                                                                                                                          node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-stringifier.js                        0000664 0000000 0000000 00000001212 14746647661 0027242 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

{
  const params = new URLSearchParams();
  assert.throws(() => {
    params.toString.call(undefined);
  }, {
    code: 'ERR_INVALID_THIS',
    name: 'TypeError',
    message: 'Value of "this" must be of type URLSearchParams'
  });
}

// The URLSearchParams stringifier mutates the base URL using
// different percent-encoding rules than the URL itself.
{
  const myUrl = new URL('https://example.org?foo=~bar');
  assert.strictEqual(myUrl.search, '?foo=~bar');
  myUrl.searchParams.sort();
  assert.strictEqual(myUrl.search, '?foo=%7Ebar');
}
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams-values.js                             0000664 0000000 0000000 00000001676 14746647661 0026232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

const params = new URLSearchParams('a=b&c=d');
const values = params.values();

assert.strictEqual(typeof values[Symbol.iterator], 'function');
assert.strictEqual(values[Symbol.iterator](), values);
assert.deepStrictEqual(values.next(), {
  value: 'b',
  done: false
});
assert.deepStrictEqual(values.next(), {
  value: 'd',
  done: false
});
assert.deepStrictEqual(values.next(), {
  value: undefined,
  done: true
});
assert.deepStrictEqual(values.next(), {
  value: undefined,
  done: true
});

assert.throws(() => {
  values.next.call(undefined);
}, {
  code: 'ERR_INVALID_THIS',
  name: 'TypeError',
  message: 'Value of "this" must be of type URLSearchParamsIterator'
});
assert.throws(() => {
  params.values.call(undefined);
}, {
  code: 'ERR_INVALID_THIS',
  name: 'TypeError',
  message: 'Value of "this" must be of type URLSearchParams'
});
                                                                  node-23.7.0/test/parallel/test-whatwg-url-custom-searchparams.js                                    0000664 0000000 0000000 00000010044 14746647661 0024722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');
const fixtures = require('../common/fixtures');

const serialized = 'a=a&a=1&a=true&a=undefined&a=null&a=%EF%BF%BD' +
                   '&a=%EF%BF%BD&a=%F0%9F%98%80&a=%EF%BF%BD%EF%BF%BD' +
                   '&a=%5Bobject+Object%5D';
const values = ['a', 1, true, undefined, null, '\uD83D', '\uDE00',
                '\uD83D\uDE00', '\uDE00\uD83D', {}];
const normalizedValues = ['a', '1', 'true', 'undefined', 'null', '\uFFFD',
                          '\uFFFD', '\uD83D\uDE00', '\uFFFD\uFFFD',
                          '[object Object]'];

const m = new URL('http://example.org');
const ownSymbolsBeforeGetterAccess = Object.getOwnPropertySymbols(m);
const sp = m.searchParams;
assert.deepStrictEqual(Object.getOwnPropertySymbols(m), ownSymbolsBeforeGetterAccess);

assert(sp);
assert.strictEqual(sp.toString(), '');
assert.strictEqual(m.search, '');

assert(!sp.has('a'));
values.forEach((i) => sp.set('a', i));
assert(sp.has('a'));
assert.strictEqual(sp.get('a'), '[object Object]');
sp.delete('a');
assert(!sp.has('a'));

m.search = '';
assert.strictEqual(sp.toString(), '');

values.forEach((i) => sp.append('a', i));
assert(sp.has('a'));
assert.strictEqual(sp.getAll('a').length, values.length);
assert.strictEqual(sp.get('a'), 'a');

assert.strictEqual(sp.toString(), serialized);

assert.strictEqual(m.search, `?${serialized}`);

sp.delete('a');
values.forEach((i) => sp.append('a', i));
assert.strictEqual(m.href, `http://example.org/?${serialized}`);

sp.delete('a');
values.forEach((i) => sp.append('a', i));
assert.strictEqual(m.toString(), `http://example.org/?${serialized}`);

sp.delete('a');
values.forEach((i) => sp.append('a', i));
assert.strictEqual(m.toJSON(), `http://example.org/?${serialized}`);

sp.delete('a');
values.forEach((i) => sp.append('a', i));
m.href = 'http://example.org';
assert.strictEqual(m.href, 'http://example.org/');
assert.strictEqual(sp.size, 0);

sp.delete('a');
values.forEach((i) => sp.append('a', i));
m.search = '';
assert.strictEqual(m.href, 'http://example.org/');
assert.strictEqual(sp.size, 0);

sp.delete('a');
values.forEach((i) => sp.append('a', i));
m.pathname = '/test';
assert.strictEqual(m.href, `http://example.org/test?${serialized}`);
m.pathname = '';

sp.delete('a');
values.forEach((i) => sp.append('a', i));
m.hash = '#test';
assert.strictEqual(m.href, `http://example.org/?${serialized}#test`);
m.hash = '';

assert.strictEqual(sp[Symbol.iterator], sp.entries);

let key, val;
let n = 0;
for ([key, val] of sp) {
  assert.strictEqual(key, 'a', n);
  assert.strictEqual(val, normalizedValues[n], n);
  n++;
}
n = 0;
for (key of sp.keys()) {
  assert.strictEqual(key, 'a', n);
  n++;
}
n = 0;
for (val of sp.values()) {
  assert.strictEqual(val, normalizedValues[n], n);
  n++;
}
n = 0;
sp.forEach(function(val, key, obj) {
  assert.strictEqual(this, undefined, n);
  assert.strictEqual(key, 'a', n);
  assert.strictEqual(val, normalizedValues[n], n);
  assert.strictEqual(obj, sp, n);
  n++;
});
sp.forEach(function() {
  assert.strictEqual(this, m);
}, m);

{
  const callbackErr = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  };
  assert.throws(() => sp.forEach(), callbackErr);
  assert.throws(() => sp.forEach(1), callbackErr);
}

m.search = '?a=a&b=b';
assert.strictEqual(sp.toString(), 'a=a&b=b');

const tests = require(fixtures.path('url-searchparams.js'));

for (const [input, expected, parsed] of tests) {
  if (input[0] !== '?') {
    const sp = new URLSearchParams(input);
    assert.strictEqual(String(sp), expected);
    assert.deepStrictEqual(Array.from(sp), parsed);

    m.search = input;
    assert.strictEqual(String(m.searchParams), expected);
    assert.deepStrictEqual(Array.from(m.searchParams), parsed);
  }

  {
    const sp = new URLSearchParams(`?${input}`);
    assert.strictEqual(String(sp), expected);
    assert.deepStrictEqual(Array.from(sp), parsed);

    m.search = `?${input}`;
    assert.strictEqual(String(m.searchParams), expected);
    assert.deepStrictEqual(Array.from(m.searchParams), parsed);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/parallel/test-whatwg-url-custom-setters.js                                         0000664 0000000 0000000 00000003542 14746647661 0023747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

const common = require('../common');
if (!common.hasIntl) {
  // A handful of the tests fail when ICU is not included.
  common.skip('missing Intl');
}

const assert = require('assert');
const { test, assert_equals } = require('../common/wpt').harness;
const fixtures = require('../common/fixtures');

// TODO(joyeecheung): we should submit these to the upstream
const additionalTestCases =
  require(fixtures.path('url-setter-tests-additional.js'));

{
  for (const attributeToBeSet in additionalTestCases) {
    if (attributeToBeSet === 'comment') {
      continue;
    }
    const testCases = additionalTestCases[attributeToBeSet];
    for (const testCase of testCases) {
      let name = `Setting <${testCase.href}>.${attributeToBeSet}` +
                 ` = "${testCase.new_value}"`;
      if ('comment' in testCase) {
        name += ` ${testCase.comment}`;
      }
      test(function() {
        const url = new URL(testCase.href);
        url[attributeToBeSet] = testCase.new_value;
        for (const attribute in testCase.expected) {
          assert_equals(url[attribute], testCase.expected[attribute]);
        }
      }, `URL: ${name}`);
    }
  }
}

{
  const url = new URL('http://example.com/');
  const obj = {
    toString() { throw new Error('toString'); },
    valueOf() { throw new Error('valueOf'); }
  };
  const sym = Symbol();
  const props = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(url));
  for (const [name, { set }] of Object.entries(props)) {
    if (set) {
      assert.throws(() => url[name] = obj,
                    /^Error: toString$/,
                    `url.${name} = { toString() { throw ... } }`);
      assert.throws(() => url[name] = sym,
                    /^TypeError: Cannot convert a Symbol value to a string$/,
                    `url.${name} = ${String(sym)}`);
    }
  }
}
                                                                                                                                                              node-23.7.0/test/parallel/test-whatwg-url-custom-tostringtag.js                                     0000664 0000000 0000000 00000001742 14746647661 0024623 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Tests below are not from WPT.

require('../common');
const assert = require('assert');

const toString = Object.prototype.toString;

const url = new URL('http://example.org');
const sp = url.searchParams;
const spIterator = sp.entries();

const test = [
  [url, 'URL'],
  [sp, 'URLSearchParams'],
  [spIterator, 'URLSearchParams Iterator'],
  // Web IDL spec says we have to return 'URLPrototype', but it is too
  // expensive to implement; therefore, use Chrome's behavior for now, until
  // spec is changed.
  [Object.getPrototypeOf(url), 'URL'],
  [Object.getPrototypeOf(sp), 'URLSearchParams'],
  [Object.getPrototypeOf(spIterator), 'URLSearchParams Iterator'],
];

test.forEach(([obj, expected]) => {
  assert.strictEqual(obj[Symbol.toStringTag], expected,
                     `${obj[Symbol.toStringTag]} !== ${expected}`);
  const str = toString.call(obj);
  assert.strictEqual(str, `[object ${expected}]`,
                     `${str} !== [object ${expected}]`);
});
                              node-23.7.0/test/parallel/test-whatwg-url-invalidthis.js                                            0000664 0000000 0000000 00000002276 14746647661 0023267 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const { URL } = require('url');
const assert = require('assert');

[
  'toString',
  'toJSON',
].forEach((i) => {
  assert.throws(() => Reflect.apply(URL.prototype[i], [], {}), {
    name: 'TypeError',
    message: /Receiver must be an instance of class/,
  });
});

[
  'href',
  'search',
].forEach((i) => {
  assert.throws(() => Reflect.get(URL.prototype, i, {}), {
    name: 'TypeError',
    message: /Receiver must be an instance of class/,
  });

  assert.throws(() => Reflect.set(URL.prototype, i, null, {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
});

[
  'protocol',
  'username',
  'password',
  'host',
  'hostname',
  'port',
  'pathname',
  'hash',
].forEach((i) => {
  assert.throws(() => Reflect.get(URL.prototype, i, {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });

  assert.throws(() => Reflect.set(URL.prototype, i, null, {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
});

[
  'origin',
  'searchParams',
].forEach((i) => {
  assert.throws(() => Reflect.get(URL.prototype, i, {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
});
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-whatwg-url-override-hostname.js                                      0000664 0000000 0000000 00000001336 14746647661 0024400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');

{
  const url = new (class extends URL { get hostname() { return 'bar.com'; } })('http://foo.com/');
  assert.strictEqual(url.href, 'http://foo.com/');
  assert.strictEqual(url.toString(), 'http://foo.com/');
  assert.strictEqual(url.toJSON(), 'http://foo.com/');
  assert.strictEqual(url.hash, '');
  assert.strictEqual(url.host, 'foo.com');
  assert.strictEqual(url.hostname, 'bar.com');
  assert.strictEqual(url.origin, 'http://foo.com');
  assert.strictEqual(url.password, '');
  assert.strictEqual(url.protocol, 'http:');
  assert.strictEqual(url.username, '');
  assert.strictEqual(url.search, '');
  assert.strictEqual(url.searchParams.toString(), '');
}
                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-whatwg-url-properties.js                                             0000664 0000000 0000000 00000006773 14746647661 0023153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { URL, URLSearchParams, format } = require('url');

[
  { name: 'toString' },
  { name: 'toJSON' },
  { name: Symbol.for('nodejs.util.inspect.custom') },
].forEach(({ name }) => {
  testMethod(URL.prototype, name);
});

[
  'http://www.google.com',
  'https://www.domain.com:443',
  'file:///Users/yagiz/Developer/node',
].forEach((url) => {
  const u = new URL(url);
  assert.strictEqual(JSON.stringify(u), `"${u.href}"`);
  assert.strictEqual(u.toString(), u.href);
  assert.strictEqual(format(u), u.href);
});

[
  { name: 'href' },
  { name: 'protocol' },
  { name: 'username' },
  { name: 'password' },
  { name: 'host' },
  { name: 'hostname' },
  { name: 'port' },
  { name: 'pathname' },
  { name: 'search' },
  { name: 'hash' },
  { name: 'origin', readonly: true },
  { name: 'searchParams', readonly: true },
].forEach(({ name, readonly = false }) => {
  testAccessor(URL.prototype, name, readonly);
});

[
  { name: 'createObjectURL' },
  { name: 'revokeObjectURL' },
].forEach(({ name }) => {
  testStaticAccessor(URL, name);
});

[
  { name: 'append' },
  { name: 'delete' },
  { name: 'get' },
  { name: 'getAll' },
  { name: 'has' },
  { name: 'set' },
  { name: 'sort' },
  { name: 'entries' },
  { name: 'forEach' },
  { name: 'keys' },
  { name: 'values' },
  { name: 'toString' },
  { name: Symbol.iterator, methodName: 'entries' },
  { name: Symbol.for('nodejs.util.inspect.custom') },
].forEach(({ name, methodName }) => {
  testMethod(URLSearchParams.prototype, name, methodName);
});

{
  const params = new URLSearchParams();
  params.append('a', 'b');
  params.append('a', 'c');
  params.append('b', 'c');
  assert.strictEqual(params.size, 3);
}

{
  const u = new URL('https://abc.com/?q=old');
  const s = u.searchParams;
  u.href = 'http://abc.com/?q=new';
  assert.strictEqual(s.get('q'), 'new');
}

function stringifyName(name) {
  if (typeof name === 'symbol') {
    const { description } = name;
    if (description === undefined) {
      return '';
    }
    return `[${description}]`;
  }

  return name;
}

function testMethod(target, name, methodName = stringifyName(name)) {
  const desc = Object.getOwnPropertyDescriptor(target, name);
  assert.notStrictEqual(desc, undefined);
  assert.strictEqual(desc.enumerable, typeof name === 'string');

  const { value } = desc;
  assert.strictEqual(typeof value, 'function');
  assert.strictEqual(value.name, methodName);
  assert.strictEqual(
    Object.hasOwn(value, 'prototype'),
    false,
  );
}

function testAccessor(target, name, readonly = false) {
  const desc = Object.getOwnPropertyDescriptor(target, name);
  assert.notStrictEqual(desc, undefined);
  assert.strictEqual(desc.enumerable, typeof name === 'string');

  const methodName = stringifyName(name);
  const { get, set } = desc;
  assert.strictEqual(typeof get, 'function');
  assert.strictEqual(get.name, `get ${methodName}`);
  assert.strictEqual(
    Object.hasOwn(get, 'prototype'),
    false,
  );

  if (readonly) {
    assert.strictEqual(set, undefined);
  } else {
    assert.strictEqual(typeof set, 'function');
    assert.strictEqual(set.name, `set ${methodName}`);
    assert.strictEqual(
      Object.hasOwn(set, 'prototype'),
      false,
    );
  }
}

function testStaticAccessor(target, name) {
  const desc = Object.getOwnPropertyDescriptor(target, name);
  assert.notStrictEqual(desc, undefined);

  assert.strictEqual(desc.configurable, true);
  assert.strictEqual(desc.enumerable, true);
  assert.strictEqual(desc.writable, true);
}
     node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-streambase.js                             0000664 0000000 0000000 00000003207 14746647661 0026245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');

const assert = require('assert');

const {
  internalBinding,
} = require('internal/test/binding');

const {
  newWritableStreamFromStreamBase,
  newReadableStreamFromStreamBase,
} = require('internal/webstreams/adapters');

const {
  JSStream
} = internalBinding('js_stream');

{
  const stream = new JSStream();
  stream.onwrite = common.mustCall((req, buf) => {
    assert.deepStrictEqual(buf[0], Buffer.from('hello'));
    req.oncomplete();
  });

  const writable = newWritableStreamFromStreamBase(stream);

  const writer = writable.getWriter();

  writer.write(Buffer.from('hello')).then(common.mustCall());
}

{
  const buf = Buffer.from('hello');
  const check = new Uint8Array(buf);

  const stream = new JSStream();

  const readable = newReadableStreamFromStreamBase(stream);

  const reader = readable.getReader();

  reader.read().then(common.mustCall(({ done, value }) => {
    assert(!done);
    assert.deepStrictEqual(new Uint8Array(value), check);

    reader.read().then(common.mustCall(({ done, value }) => {
      assert(done);
      assert.strictEqual(value, undefined);
    }));

  }));

  stream.readBuffer(buf);
  stream.emitEOF();
}

{
  const stream = new JSStream();
  stream.onshutdown = common.mustCall((req) => {
    req.oncomplete();
  });
  const readable = newReadableStreamFromStreamBase(stream);
  readable.cancel().then(common.mustCall());
}

{
  const stream = new JSStream();
  stream.onread = common.mustCall();
  assert.throws(() => newReadableStreamFromStreamBase(stream), {
    code: 'ERR_INVALID_STATE'
  });
  stream.emitEOF();
}
                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-to-readablestream.js                      0000664 0000000 0000000 00000011343 14746647661 0027512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings --expose-internals
'use strict';

const common = require('../common');

const assert = require('assert');

const {
  newReadableStreamFromStreamReadable,
} = require('internal/webstreams/adapters');

const {
  Duplex,
  Readable,
} = require('stream');

const {
  kState,
} = require('internal/webstreams/util');

{
  // Canceling the readableStream closes the readable.
  const readable = new Readable({
    read() {
      readable.push('hello');
      readable.push(null);
    }
  });

  readable.on('close', common.mustCall());
  readable.on('end', common.mustNotCall());
  readable.on('pause', common.mustCall());
  readable.on('resume', common.mustNotCall());
  readable.on('error', common.mustCall((error) => {
    assert.strictEqual(error.code, 'ABORT_ERR');
  }));

  const readableStream = newReadableStreamFromStreamReadable(readable);

  readableStream.cancel().then(common.mustCall());
}

{
  // Prematurely destroying the stream.Readable without an error
  // closes the ReadableStream with a premature close error but does
  // not error the readable.

  const readable = new Readable({
    read() {
      readable.push('hello');
      readable.push(null);
    }
  });

  const readableStream = newReadableStreamFromStreamReadable(readable);

  assert(!readableStream.locked);

  const reader = readableStream.getReader();

  assert.rejects(reader.closed, {
    code: 'ABORT_ERR',
  }).then(common.mustCall());

  readable.on('end', common.mustNotCall());
  readable.on('error', common.mustNotCall());

  readable.on('close', common.mustCall(() => {
    assert.strictEqual(readableStream[kState].state, 'errored');
  }));

  readable.destroy();
}

{
  // Ending the readable without an error just closes the
  // readableStream without an error.
  const readable = new Readable({
    read() {
      readable.push('hello');
      readable.push(null);
    }
  });

  const readableStream = newReadableStreamFromStreamReadable(readable);

  assert(!readableStream.locked);

  const reader = readableStream.getReader();

  reader.closed.then(common.mustCall());

  readable.on('end', common.mustCall());
  readable.on('error', common.mustNotCall());

  readable.on('close', common.mustCall(() => {
    assert.strictEqual(readableStream[kState].state, 'closed');
  }));

  readable.push(null);
}

{
  // Destroying the readable with an error should error the readableStream
  const error = new Error('boom');
  const readable = new Readable({
    read() {
      readable.push('hello');
      readable.push(null);
    }
  });

  const readableStream = newReadableStreamFromStreamReadable(readable);

  assert(!readableStream.locked);

  const reader = readableStream.getReader();

  assert.rejects(reader.closed, error).then(common.mustCall());

  readable.on('end', common.mustNotCall());
  readable.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  readable.on('close', common.mustCall(() => {
    assert.strictEqual(readableStream[kState].state, 'errored');
  }));

  readable.destroy(error);
}

{
  const readable = new Readable({
    encoding: 'utf8',
    read() {
      readable.push('hello');
      readable.push(null);
    }
  });

  const readableStream = newReadableStreamFromStreamReadable(readable);
  const reader = readableStream.getReader();

  readable.on('data', common.mustCall());
  readable.on('end', common.mustCall());
  readable.on('close', common.mustCall());

  (async () => {
    assert.deepStrictEqual(
      await reader.read(),
      { value: 'hello', done: false });
    assert.deepStrictEqual(
      await reader.read(),
      { value: undefined, done: true });

  })().then(common.mustCall());
}

{
  const data = {};
  const readable = new Readable({
    objectMode: true,
    read() {
      readable.push(data);
      readable.push(null);
    }
  });

  assert(readable.readableObjectMode);

  const readableStream = newReadableStreamFromStreamReadable(readable);
  const reader = readableStream.getReader();

  readable.on('data', common.mustCall());
  readable.on('end', common.mustCall());
  readable.on('close', common.mustCall());

  (async () => {
    assert.deepStrictEqual(
      await reader.read(),
      { value: data, done: false });
    assert.deepStrictEqual(
      await reader.read(),
      { value: undefined, done: true });

  })().then(common.mustCall());
}

{
  const readable = new Readable();
  readable.destroy();
  const readableStream = newReadableStreamFromStreamReadable(readable);
  const reader = readableStream.getReader();
  reader.closed.then(common.mustCall());
}

{
  const duplex = new Duplex({ readable: false });
  duplex.destroy();
  const readableStream = newReadableStreamFromStreamReadable(duplex);
  const reader = readableStream.getReader();
  reader.closed.then(common.mustCall());
}
                                                                                                                                                                                                                                                                                             node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-to-readablewritablepair.js                0000664 0000000 0000000 00000013565 14746647661 0030714 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings --expose-internals
'use strict';

const common = require('../common');

const assert = require('assert');

const {
  newReadableWritablePairFromDuplex,
} = require('internal/webstreams/adapters');

const {
  PassThrough,
} = require('stream');

{
  // Destroying the duplex without an error should close
  // the readable and error the writable.

  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  const reader = readable.getReader();
  const writer = writable.getWriter();

  assert.rejects(reader.closed, {
    code: 'ABORT_ERR',
  }).then(common.mustCall());

  assert.rejects(writer.closed, {
    code: 'ABORT_ERR',
  }).then(common.mustCall());

  duplex.destroy();

  duplex.on('close', common.mustCall());
}

{
  // Destroying the duplex with an error should error
  // both the readable and writable

  const error = new Error('boom');
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('close', common.mustCall());
  duplex.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  const reader = readable.getReader();
  const writer = writable.getWriter();

  assert.rejects(reader.closed, error).then(common.mustCall());
  assert.rejects(writer.closed, error).then(common.mustCall());

  duplex.destroy(error);
}

{
  const error = new Error('boom');
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('close', common.mustCall());
  duplex.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  const reader = readable.getReader();
  const writer = writable.getWriter();

  reader.closed.then(common.mustCall());
  assert.rejects(writer.closed, error).then(common.mustCall());

  reader.cancel(error).then(common.mustCall());
}

{
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('close', common.mustCall());
  duplex.on('error', common.mustNotCall());

  const reader = readable.getReader();
  const writer = writable.getWriter();

  reader.closed.then(common.mustCall());
  writer.closed.then(common.mustCall());

  writer.close().then(common.mustCall());
}

{
  const error = new Error('boom');
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('close', common.mustCall());
  duplex.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  const reader = readable.getReader();
  const writer = writable.getWriter();

  assert.rejects(reader.closed, error).then(common.mustCall());
  assert.rejects(writer.closed, error).then(common.mustCall());

  writer.abort(error).then(common.mustCall());
}

{
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('close', common.mustCall());

  duplex.on('error', common.mustCall((error) => {
    assert.strictEqual(error.code, 'ABORT_ERR');
  }));

  const reader = readable.getReader();
  const writer = writable.getWriter();

  assert.rejects(writer.closed, {
    code: 'ABORT_ERR',
  }).then(common.mustCall());

  reader.cancel();
}

{
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('close', common.mustCall());
  duplex.on('error', common.mustNotCall());

  const reader = readable.getReader();
  const writer = writable.getWriter();

  reader.closed.then(common.mustCall());
  assert.rejects(writer.closed, {
    code: 'ABORT_ERR',
  }).then(common.mustCall());

  duplex.end();
}

{
  const duplex = new PassThrough();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);

  duplex.on('data', common.mustCall(2));
  duplex.on('close', common.mustCall());
  duplex.on('end', common.mustCall());
  duplex.on('finish', common.mustCall());

  const writer = writable.getWriter();
  const reader = readable.getReader();

  const ec = new TextEncoder();
  const dc = new TextDecoder();

  Promise.all([
    writer.write(ec.encode('hello')),
    reader.read().then(common.mustCall(({ done, value }) => {
      assert(!done);
      assert.strictEqual(dc.decode(value), 'hello');
    })),
    reader.read().then(common.mustCall(({ done, value }) => {
      assert(!done);
      assert.strictEqual(dc.decode(value), 'there');
    })),
    writer.write(ec.encode('there')),
    writer.close(),
    reader.read().then(common.mustCall(({ done, value }) => {
      assert(done);
      assert.strictEqual(value, undefined);
    })),
  ]).then(common.mustCall());
}

{
  const duplex = new PassThrough();
  duplex.destroy();
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);
  const reader = readable.getReader();
  const writer = writable.getWriter();
  reader.closed.then(common.mustCall());
  writer.closed.then(common.mustCall());
}

{
  const duplex = new PassThrough({ writable: false });
  assert(duplex.readable);
  assert(!duplex.writable);
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);
  const reader = readable.getReader();
  const writer = writable.getWriter();
  writer.closed.then(common.mustCall());
  reader.cancel().then(common.mustCall());
}

{
  const duplex = new PassThrough({ readable: false });
  assert(!duplex.readable);
  assert(duplex.writable);
  const {
    readable,
    writable,
  } = newReadableWritablePairFromDuplex(duplex);
  const reader = readable.getReader();
  const writer = writable.getWriter();
  reader.closed.then(common.mustCall());
  writer.close().then(common.mustCall());
}

{
  assert.throws(() => newReadableWritablePairFromDuplex(null), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
}
                                                                                                                                           node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-to-streamduplex.js                        0000664 0000000 0000000 00000010772 14746647661 0027261 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings --expose-internals
'use strict';

const common = require('../common');

const assert = require('assert');

const {
  TransformStream,
} = require('stream/web');

const {
  newStreamDuplexFromReadableWritablePair,
} = require('internal/webstreams/adapters');

const {
  finished,
  pipeline,
  Readable,
  Writable,
} = require('stream');

const {
  kState,
} = require('internal/webstreams/util');

{
  const transform = new TransformStream();
  const duplex = newStreamDuplexFromReadableWritablePair(transform);

  assert(transform.readable.locked);
  assert(transform.writable.locked);

  duplex.destroy();

  duplex.on('close', common.mustCall(() => {
    assert.strictEqual(transform.readable[kState].state, 'closed');
    assert.strictEqual(transform.writable[kState].state, 'errored');
  }));
}

{
  const error = new Error('boom');
  const transform = new TransformStream();
  const duplex = newStreamDuplexFromReadableWritablePair(transform);

  assert(transform.readable.locked);
  assert(transform.writable.locked);

  duplex.destroy(error);
  duplex.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  duplex.on('close', common.mustCall(() => {
    assert.strictEqual(transform.readable[kState].state, 'closed');
    assert.strictEqual(transform.writable[kState].state, 'errored');
    assert.strictEqual(transform.writable[kState].storedError, error);
  }));
}

{
  const transform = new TransformStream();
  const duplex = new newStreamDuplexFromReadableWritablePair(transform);

  duplex.end();
  duplex.resume();

  duplex.on('close', common.mustCall(() => {
    assert.strictEqual(transform.readable[kState].state, 'closed');
    assert.strictEqual(transform.writable[kState].state, 'closed');
  }));
}

{
  const ec = new TextEncoder();
  const dc = new TextDecoder();
  const transform = new TransformStream({
    transform(chunk, controller) {
      const text = dc.decode(chunk);
      controller.enqueue(ec.encode(text.toUpperCase()));
    }
  });
  const duplex = new newStreamDuplexFromReadableWritablePair(transform, {
    encoding: 'utf8',
  });

  duplex.end('hello');
  duplex.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, 'HELLO');
  }));
  duplex.on('end', common.mustCall());

  duplex.on('close', common.mustCall(() => {
    assert.strictEqual(transform.readable[kState].state, 'closed');
    assert.strictEqual(transform.writable[kState].state, 'closed');
  }));
}

{
  const ec = new TextEncoder();
  const dc = new TextDecoder();
  const transform = new TransformStream({
    transform: common.mustCall((chunk, controller) => {
      const text = dc.decode(chunk);
      controller.enqueue(ec.encode(text.toUpperCase()));
    })
  });
  const duplex = new newStreamDuplexFromReadableWritablePair(transform, {
    encoding: 'utf8',
  });

  finished(duplex, common.mustCall());

  duplex.end('hello');
  duplex.resume();
}

{
  const ec = new TextEncoder();
  const dc = new TextDecoder();
  const transform = new TransformStream({
    transform: common.mustCall((chunk, controller) => {
      const text = dc.decode(chunk);
      controller.enqueue(ec.encode(text.toUpperCase()));
    })
  });
  const duplex = new newStreamDuplexFromReadableWritablePair(transform, {
    encoding: 'utf8',
  });

  const readable = new Readable({
    read() {
      readable.push(Buffer.from('hello'));
      readable.push(null);
    }
  });

  const writable = new Writable({
    write: common.mustCall((chunk, encoding, callback) => {
      assert.strictEqual(dc.decode(chunk), 'HELLO');
      assert.strictEqual(encoding, 'buffer');
      callback();
    })
  });

  finished(duplex, common.mustCall());
  pipeline(readable, duplex, writable, common.mustCall());
}

{
  const transform = new TransformStream();
  const duplex = newStreamDuplexFromReadableWritablePair(transform);
  duplex.setEncoding('utf-8');
  duplex.on('data', common.mustCall((data) => {
    assert.strictEqual(data, 'hello');
  }, 5));

  duplex.write(Buffer.from('hello'));
  duplex.write(Buffer.from('hello'));
  duplex.write(Buffer.from('hello'));
  duplex.write(Buffer.from('hello'));
  duplex.write(Buffer.from('hello'));

  duplex.end();
}

{
  const transform = { readable: {}, writable: {} };
  assert.throws(() => newStreamDuplexFromReadableWritablePair(transform), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
}

{
  const transform = {
    readable: new ReadableStream(),
    writable: null
  };

  assert.throws(() => newStreamDuplexFromReadableWritablePair(transform), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
}
      node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-to-streamreadable.js                      0000664 0000000 0000000 00000013075 14746647661 0027516 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');

const assert = require('assert');

const {
  pipeline,
  finished,
  Writable,
} = require('stream');

const {
  ReadableStream,
  WritableStream,
} = require('stream/web');

const {
  newStreamReadableFromReadableStream,
} = require('internal/webstreams/adapters');

const {
  kState,
} = require('internal/webstreams/util');

class MySource {
  constructor(value = new Uint8Array(10)) {
    this.value = value;
  }

  start(c) {
    this.started = true;
    this.controller = c;
  }

  pull(controller) {
    controller.enqueue(this.value);
    controller.close();
  }

  cancel(reason) {
    this.canceled = true;
    this.cancelReason = reason;
  }
}

{
  // Destroying the readable without an error closes
  // the readableStream.

  const readableStream = new ReadableStream();
  const readable = newStreamReadableFromReadableStream(readableStream);

  assert(readableStream.locked);

  assert.rejects(readableStream.cancel(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
  assert.rejects(readableStream.pipeTo(new WritableStream()), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());
  assert.throws(() => readableStream.tee(), {
    code: 'ERR_INVALID_STATE',
  });
  assert.throws(() => readableStream.getReader(), {
    code: 'ERR_INVALID_STATE',
  });
  assert.throws(() => {
    readableStream.pipeThrough({
      readable: new ReadableStream(),
      writable: new WritableStream(),
    });
  }, {
    code: 'ERR_INVALID_STATE',
  });

  readable.destroy();

  readable.on('close', common.mustCall(() => {
    assert.strictEqual(readableStream[kState].state, 'closed');
  }));
}

{
  // Destroying the readable with an error closes the readableStream
  // without error but records the cancel reason in the source.
  const error = new Error('boom');
  const source = new MySource();
  const readableStream = new ReadableStream(source);
  const readable = newStreamReadableFromReadableStream(readableStream);

  assert(readableStream.locked);

  readable.destroy(error);

  readable.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  readable.on('close', common.mustCall(() => {
    assert.strictEqual(readableStream[kState].state, 'closed');
    assert.strictEqual(source.cancelReason, error);
  }));
}

{
  // An error in the source causes the readable to error.
  const error = new Error('boom');
  const source = new MySource();
  const readableStream = new ReadableStream(source);
  const readable = newStreamReadableFromReadableStream(readableStream);

  assert(readableStream.locked);

  source.controller.error(error);

  readable.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  readable.on('close', common.mustCall(() => {
    assert.strictEqual(readableStream[kState].state, 'errored');
  }));
}

{
  const readableStream = new ReadableStream(new MySource());
  const readable = newStreamReadableFromReadableStream(readableStream);

  readable.on('data', common.mustCall((chunk) => {
    assert.deepStrictEqual(chunk, Buffer.alloc(10));
  }));
  readable.on('end', common.mustCall());
  readable.on('close', common.mustCall());
  readable.on('error', common.mustNotCall());
}

{
  const readableStream = new ReadableStream(new MySource('hello'));
  const readable = newStreamReadableFromReadableStream(readableStream, {
    encoding: 'utf8',
  });

  readable.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, 'hello');
  }));
  readable.on('end', common.mustCall());
  readable.on('close', common.mustCall());
  readable.on('error', common.mustNotCall());
}

{
  const readableStream = new ReadableStream(new MySource());
  const readable = newStreamReadableFromReadableStream(readableStream, {
    objectMode: true
  });

  readable.on('data', common.mustCall((chunk) => {
    assert.deepStrictEqual(chunk, new Uint8Array(10));
  }));
  readable.on('end', common.mustCall());
  readable.on('close', common.mustCall());
  readable.on('error', common.mustNotCall());
}

{
  const ec = new TextEncoder();
  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(ec.encode('hello'));
      setImmediate(() => {
        controller.enqueue(ec.encode('there'));
        controller.close();
      });
    }
  });
  const streamReadable = newStreamReadableFromReadableStream(readable);

  finished(streamReadable, common.mustCall());

  streamReadable.resume();
}

{
  const ec = new TextEncoder();
  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(ec.encode('hello'));
      setImmediate(() => {
        controller.enqueue(ec.encode('there'));
        controller.close();
      });
    }
  });
  const streamReadable = newStreamReadableFromReadableStream(readable);

  finished(streamReadable, common.mustCall());

  streamReadable.resume();
}

{
  const ec = new TextEncoder();
  const dc = new TextDecoder();
  const check = ['hello', 'there'];
  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(ec.encode('hello'));
      setImmediate(() => {
        controller.enqueue(ec.encode('there'));
        controller.close();
      });
    }
  });
  const writable = new Writable({
    write: common.mustCall((chunk, encoding, callback) => {
      assert.strictEqual(dc.decode(chunk), check.shift());
      assert.strictEqual(encoding, 'buffer');
      callback();
    }, 2),
  });

  const streamReadable = newStreamReadableFromReadableStream(readable);

  pipeline(streamReadable, writable, common.mustCall());

  streamReadable.resume();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-to-streamwritable.js                      0000664 0000000 0000000 00000013336 14746647661 0027570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings --expose-internals
'use strict';

const common = require('../common');

const assert = require('assert');

const {
  WritableStream,
} = require('stream/web');

const {
  newStreamWritableFromWritableStream,
} = require('internal/webstreams/adapters');

const {
  finished,
  pipeline,
  Readable,
} = require('stream');

const {
  kState,
} = require('internal/webstreams/util');

class TestSource {
  constructor() {
    this.chunks = [];
  }

  start(c) {
    this.controller = c;
    this.started = true;
  }

  write(chunk) {
    this.chunks.push(chunk);
  }

  close() {
    this.closed = true;
  }

  abort(reason) {
    this.abortReason = reason;
  }
}

[1, {}, false, []].forEach((arg) => {
  assert.throws(() => newStreamWritableFromWritableStream(arg), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

{
  // Ending the stream.Writable should close the writableStream
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable = newStreamWritableFromWritableStream(writableStream);

  assert(writableStream.locked);

  writable.end('chunk');

  writable.on('close', common.mustCall(() => {
    assert(writableStream.locked);
    assert.strictEqual(writableStream[kState].state, 'closed');
    assert.strictEqual(source.chunks.length, 1);
    assert.deepStrictEqual(source.chunks[0], Buffer.from('chunk'));
  }));
}

{
  // Destroying the stream.Writable without an error should close
  // the writableStream with no error.
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable = newStreamWritableFromWritableStream(writableStream);

  assert(writableStream.locked);

  writable.destroy();

  writable.on('close', common.mustCall(() => {
    assert(writableStream.locked);
    assert.strictEqual(writableStream[kState].state, 'closed');
    assert.strictEqual(source.chunks.length, 0);
  }));
}

{
  // Destroying the stream.Writable with an error should error
  // the writableStream
  const error = new Error('boom');
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable = newStreamWritableFromWritableStream(writableStream);

  assert(writableStream.locked);

  writable.destroy(error);

  writable.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));

  writable.on('close', common.mustCall(() => {
    assert(writableStream.locked);
    assert.strictEqual(writableStream[kState].state, 'errored');
    assert.strictEqual(writableStream[kState].storedError, error);
    assert.strictEqual(source.chunks.length, 0);
  }));
}

{
  // Attempting to close, abort, or getWriter on writableStream
  // should fail because it is locked. An internal error in
  // writableStream should error the writable.
  const error = new Error('boom');
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable = newStreamWritableFromWritableStream(writableStream);

  assert(writableStream.locked);

  assert.rejects(writableStream.close(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());

  assert.rejects(writableStream.abort(), {
    code: 'ERR_INVALID_STATE',
  }).then(common.mustCall());

  assert.throws(() => writableStream.getWriter(), {
    code: 'ERR_INVALID_STATE',
  });

  writable.on('error', common.mustCall((reason) => {
    assert.strictEqual(error, reason);
  }));

  source.controller.error(error);
}

{
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable = newStreamWritableFromWritableStream(writableStream);

  writable.on('error', common.mustNotCall());
  writable.on('finish', common.mustCall());
  writable.on('close', common.mustCall(() => {
    assert.strictEqual(source.chunks.length, 1);
    assert.deepStrictEqual(source.chunks[0], Buffer.from('hello'));
  }));

  writable.write('hello', common.mustCall());
  writable.end();
}

{
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable =
    newStreamWritableFromWritableStream(writableStream, {
      decodeStrings: false,
    });

  writable.on('error', common.mustNotCall());
  writable.on('finish', common.mustCall());
  writable.on('close', common.mustCall(() => {
    assert.strictEqual(source.chunks.length, 1);
    assert.strictEqual(source.chunks[0], 'hello');
  }));

  writable.write('hello', common.mustCall());
  writable.end();
}

{
  const source = new TestSource();
  const writableStream = new WritableStream(source);
  const writable =
    newStreamWritableFromWritableStream(
      writableStream, {
        objectMode: true
      });
  assert(writable.writableObjectMode);

  writable.on('error', common.mustNotCall());
  writable.on('finish', common.mustCall());
  writable.on('close', common.mustCall(() => {
    assert.strictEqual(source.chunks.length, 1);
    assert.strictEqual(source.chunks[0], 'hello');
  }));

  writable.write('hello', common.mustCall());
  writable.end();
}

{
  const writableStream = new WritableStream({
    write: common.mustCall(5),
    close: common.mustCall(),
  });
  const writable = newStreamWritableFromWritableStream(writableStream);

  finished(writable, common.mustCall());

  writable.write('hello');
  writable.write('hello');
  writable.write('hello');
  writable.write('world');
  writable.write('world');
  writable.end();
}

{
  const writableStream = new WritableStream({
    write: common.mustCall(2),
    close: common.mustCall(),
  });
  const writable = newStreamWritableFromWritableStream(writableStream);

  const readable = new Readable({
    read() {
      readable.push(Buffer.from('hello'));
      readable.push(Buffer.from('world'));
      readable.push(null);
    }
  });

  pipeline(readable, writable, common.mustCall());
}
                                                                                                                                                                                                                                                                                                  node-23.7.0/test/parallel/test-whatwg-webstreams-adapters-to-writablestream.js                      0000664 0000000 0000000 00000010202 14746647661 0027555 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings --expose-internals

'use strict';

const common = require('../common');

const assert = require('assert');

const {
  newWritableStreamFromStreamWritable,
} = require('internal/webstreams/adapters');

const {
  Duplex,
  Writable,
  PassThrough,
} = require('stream');

class TestWritable extends Writable {
  constructor(asyncWrite = false) {
    super();
    this.chunks = [];
    this.asyncWrite = asyncWrite;
  }

  _write(chunk, encoding, callback) {
    this.chunks.push({ chunk, encoding });
    if (this.asyncWrite) {
      setImmediate(() => callback());
      return;
    }
    callback();
  }
}

[1, {}, false, []].forEach((arg) => {
  assert.throws(() => newWritableStreamFromStreamWritable(arg), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

{
  // Closing the WritableStream normally closes the stream.Writable
  // without errors.

  const writable = new TestWritable();
  writable.on('error', common.mustNotCall());
  writable.on('finish', common.mustCall());
  writable.on('close', common.mustCall());

  const writableStream = newWritableStreamFromStreamWritable(writable);

  writableStream.close().then(common.mustCall(() => {
    assert(writable.destroyed);
  }));
}

{
  // Aborting the WritableStream errors the stream.Writable

  const error = new Error('boom');
  const writable = new TestWritable();
  writable.on('error', common.mustCall((reason) => {
    assert.strictEqual(reason, error);
  }));
  writable.on('finish', common.mustNotCall());
  writable.on('close', common.mustCall());

  const writableStream = newWritableStreamFromStreamWritable(writable);

  writableStream.abort(error).then(common.mustCall(() => {
    assert(writable.destroyed);
  }));
}

{
  // Destroying the stream.Writable prematurely errors the
  // WritableStream

  const error = new Error('boom');
  const writable = new TestWritable();

  const writableStream = newWritableStreamFromStreamWritable(writable);
  assert.rejects(writableStream.close(), error).then(common.mustCall());
  writable.destroy(error);
}

{
  // Ending the stream.Writable directly errors the WritableStream
  const writable = new TestWritable();

  const writableStream = newWritableStreamFromStreamWritable(writable);

  assert.rejects(writableStream.close(), {
    code: 'ABORT_ERR'
  }).then(common.mustCall());

  writable.end();
}

{
  const writable = new TestWritable();
  const writableStream = newWritableStreamFromStreamWritable(writable);
  const writer = writableStream.getWriter();
  const ec = new TextEncoder();
  writer.write(ec.encode('hello')).then(common.mustCall(() => {
    assert.strictEqual(writable.chunks.length, 1);
    assert.deepStrictEqual(
      writable.chunks[0],
      {
        chunk: Buffer.from('hello'),
        encoding: 'buffer'
      });
  }));
}

{
  const writable = new TestWritable(true);

  writable.on('error', common.mustNotCall());
  writable.on('close', common.mustCall());
  writable.on('finish', common.mustCall());

  const writableStream = newWritableStreamFromStreamWritable(writable);
  const writer = writableStream.getWriter();
  const ec = new TextEncoder();
  writer.write(ec.encode('hello')).then(common.mustCall(() => {
    assert.strictEqual(writable.chunks.length, 1);
    assert.deepStrictEqual(
      writable.chunks[0],
      {
        chunk: Buffer.from('hello'),
        encoding: 'buffer'
      });
    writer.close().then(common.mustCall());
  }));
}

{
  const duplex = new PassThrough();
  duplex.setEncoding('utf8');
  const writableStream = newWritableStreamFromStreamWritable(duplex);
  const ec = new TextEncoder();
  writableStream
    .getWriter()
    .write(ec.encode('hello'))
    .then(common.mustCall());

  duplex.on('data', common.mustCall((chunk) => {
    assert.strictEqual(chunk, 'hello');
  }));
}

{
  const writable = new Writable();
  writable.destroy();
  const writableStream = newWritableStreamFromStreamWritable(writable);
  const writer = writableStream.getWriter();
  writer.closed.then(common.mustCall());
}

{
  const duplex = new Duplex({ writable: false });
  const writableStream = newWritableStreamFromStreamWritable(duplex);
  const writer = writableStream.getWriter();
  writer.closed.then(common.mustCall());
}
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-whatwg-webstreams-compression.js                                     0000664 0000000 0000000 00000004102 14746647661 0024652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings
'use strict';

const common = require('../common');

const {
  CompressionStream,
  DecompressionStream,
} = require('stream/web');

const assert = require('assert');
const dec = new TextDecoder();

async function test(format) {
  const gzip = new CompressionStream(format);
  const gunzip = new DecompressionStream(format);

  assert.strictEqual(gzip[Symbol.toStringTag], 'CompressionStream');
  assert.strictEqual(gunzip[Symbol.toStringTag], 'DecompressionStream');

  gzip.readable.pipeTo(gunzip.writable).then(common.mustCall());

  const reader = gunzip.readable.getReader();
  const writer = gzip.writable.getWriter();

  const compressed_data = [];
  const reader_function = ({ value, done }) => {
    if (value)
      compressed_data.push(value);
    if (!done)
      return reader.read().then(reader_function);
    assert.strictEqual(dec.decode(Buffer.concat(compressed_data)), 'hello');
  };
  const reader_promise = reader.read().then(reader_function);

  await Promise.all([
    reader_promise,
    reader_promise.then(() => reader.read().then(({ done }) => assert(done))),
    writer.write('hello'),
    writer.close(),
  ]);
}

Promise.all(['gzip', 'deflate', 'deflate-raw'].map((i) => test(i))).then(common.mustCall());

[1, 'hello', false, {}].forEach((i) => {
  assert.throws(() => new CompressionStream(i), {
    code: 'ERR_INVALID_ARG_VALUE',
  });
  assert.throws(() => new DecompressionStream(i), {
    code: 'ERR_INVALID_ARG_VALUE',
  });
});

assert.throws(
  () => Reflect.get(CompressionStream.prototype, 'readable', {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
assert.throws(
  () => Reflect.get(CompressionStream.prototype, 'writable', {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
assert.throws(
  () => Reflect.get(DecompressionStream.prototype, 'readable', {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
assert.throws(
  () => Reflect.get(DecompressionStream.prototype, 'writable', {}), {
    name: 'TypeError',
    message: /Cannot read private member/,
  });
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/parallel/test-whatwg-webstreams-coverage.js                                        0000664 0000000 0000000 00000003166 14746647661 0024115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings --expose-internals
'use strict';

require('../common');

const {
  ByteLengthQueuingStrategy,
  CountQueuingStrategy,
} = require('stream/web');

const {
  inspect,
} = require('util');

const {
  isPromisePending,
} = require('internal/webstreams/util');

const assert = require('assert');

assert(!isPromisePending({}));
assert(!isPromisePending(Promise.resolve()));
assert(isPromisePending(new Promise(() => {})));

// Brand checking works
assert.throws(() => {
  Reflect.get(ByteLengthQueuingStrategy.prototype, 'highWaterMark', {});
}, {
  name: 'TypeError',
  message: /Cannot read private member/,
});

assert.throws(() => {
  Reflect.get(ByteLengthQueuingStrategy.prototype, 'size', {});
}, {
  name: 'TypeError',
  message: /Cannot read private member/,
});

assert.throws(() => {
  Reflect.get(CountQueuingStrategy.prototype, 'highWaterMark', {});
}, {
  name: 'TypeError',
  message: /Cannot read private member/,
});

assert.throws(() => {
  Reflect.get(CountQueuingStrategy.prototype, 'size', {});
}, {
  name: 'TypeError',
  message: /Cannot read private member/,
});

// Custom Inspect Works

{
  const strategy = new CountQueuingStrategy({ highWaterMark: 1 });

  assert.strictEqual(
    inspect(strategy, { depth: null }),
    'CountQueuingStrategy { highWaterMark: 1 }');

  assert.strictEqual(
    inspect(strategy),
    'CountQueuingStrategy { highWaterMark: 1 }');

  assert.strictEqual(
    inspect(strategy, { depth: 0 }),
    'CountQueuingStrategy [Object]');

  assert.strictEqual(
    inspect(new ByteLengthQueuingStrategy({ highWaterMark: 1 })),
    'ByteLengthQueuingStrategy { highWaterMark: 1 }');
}
                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/parallel/test-whatwg-webstreams-encoding.js                                        0000664 0000000 0000000 00000004551 14746647661 0024107 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-warnings
'use strict';

const common = require('../common');
const assert = require('assert');

const {
  TextEncoderStream,
  TextDecoderStream,
} = require('stream/web');

const kEuroBytes = Buffer.from([0xe2, 0x82, 0xac]);
const kEuro = Buffer.from([0xe2, 0x82, 0xac]).toString();

[1, false, [], {}, 'hello'].forEach((i) => {
  assert.throws(() => new TextDecoderStream(i), {
    code: 'ERR_ENCODING_NOT_SUPPORTED',
  });
});

[1, false, 'hello'].forEach((i) => {
  assert.throws(() => new TextDecoderStream(undefined, i), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

{
  const tds = new TextDecoderStream();
  const writer = tds.writable.getWriter();
  const reader = tds.readable.getReader();
  reader.read().then(common.mustCall(({ value, done }) => {
    assert(!done);
    assert.strictEqual(kEuro, value);
    reader.read().then(common.mustCall(({ done }) => {
      assert(done);
    }));
  }));
  Promise.all([
    writer.write(kEuroBytes.slice(0, 1)),
    writer.write(kEuroBytes.slice(1, 2)),
    writer.write(kEuroBytes.slice(2, 3)),
    writer.close(),
  ]).then(common.mustCall());

  assert.strictEqual(tds.encoding, 'utf-8');
  assert.strictEqual(tds.fatal, false);
  assert.strictEqual(tds.ignoreBOM, false);
  ['encoding', 'fatal', 'ignoreBOM', 'readable', 'writable'].forEach((getter) => {
    assert.throws(
      () => Reflect.get(TextDecoderStream.prototype, getter, {}), {
        name: 'TypeError',
        message: /Cannot read private member/,
        stack: new RegExp(`at get ${getter}`)
      }
    );
  });
}

{
  const tds = new TextEncoderStream();
  const writer = tds.writable.getWriter();
  const reader = tds.readable.getReader();
  reader.read().then(common.mustCall(({ value, done }) => {
    assert(!done);
    const buf = Buffer.from(value.buffer, value.byteOffset, value.byteLength);
    assert.deepStrictEqual(kEuroBytes, buf);
    reader.read().then(common.mustCall(({ done }) => {
      assert(done);
    }));
  }));
  Promise.all([
    writer.write(kEuro),
    writer.close(),
  ]).then(common.mustCall());

  assert.strictEqual(tds.encoding, 'utf-8');
  ['encoding', 'readable', 'writable'].forEach((getter) => {
    assert.throws(
      () => Reflect.get(TextDecoderStream.prototype, getter, {}), {
        name: 'TypeError',
        message: /Cannot read private member/,
        stack: new RegExp(`at get ${getter}`)
      }
    );
  });
}
                                                                                                                                                       node-23.7.0/test/parallel/test-whatwg-webstreams-transfer.js                                        0000664 0000000 0000000 00000041001 14746647661 0024134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');

const {
  ReadableStream,
  WritableStream,
  TransformStream,
} = require('stream/web');

const {
  Worker
} = require('worker_threads');

const {
  isReadableStream,
  isReadableByteStreamController,
} = require('internal/webstreams/readablestream');

const {
  isWritableStream,
} = require('internal/webstreams/writablestream');

const {
  isTransformStream,
} = require('internal/webstreams/transformstream');

const {
  kState,
} = require('internal/webstreams/util');

const {
  markTransferMode,
  kClone,
  kTransfer,
  kDeserialize,
} = require('internal/worker/js_transferable');

const assert = require('assert');

const theData = 'hello';

{
  const { port1, port2 } = new MessageChannel();
  port1.onmessageerror = common.mustNotCall();
  port2.onmessageerror = common.mustNotCall();

  // This test takes the ReadableStream and transfers it to the
  // port1 first, then again to port2, which reads the data.
  // Internally, this sets up a pipelined data flow that is
  // important to understand in case this test fails..
  //
  // Specifically:
  //
  // 1. We start with ReadableStream R1,
  // 2. Calling port2.postMessage causes a new internal WritableStream W1
  //    and a new ReadableStream R2 to be created, both of which are coupled
  //    to each other via a pair of MessagePorts P1 and P2.
  // 3. ReadableStream R2 is passed to the port1.onmessage callback as the
  //    data property of the MessageEvent, and R1 is configured to pipeTo W1.
  // 4. Within port1.onmessage, we transfer ReadableStream R2 to port1, which
  //    creates a new internal WritableStream W2 and a new ReadableStream R3,
  //    both of which are coupled to each other via a pair of MessagePorts
  //    P3 and P4.
  // 5. ReadableStream R3 is passed to the port2.onmessage callback as the
  //    data property of the MessageEvent, and R2 is configured to pipeTo W2.
  // 6. Once the reader is attached to R3 in the port2.onmessage callback,
  //    a message is sent along the path: R3 -> P4 -> P3 -> R2 -> P2 -> P1 -> R1
  //    to begin pulling the data. The data is then pushed along the pipeline
  //    R1 -> W1 -> P1 -> P2 -> R2 -> W2 -> P3 -> P4 -> R3
  // 7. The MessagePorts P1, P2, P3, and P4 serve as a control channel for
  //    passing data and control instructions, potentially across realms,
  //    to the other ReadableStream and WritableStream instances.
  //
  // If this test experiences timeouts (hangs without finishing), it's most
  // likely because the control instructions are somehow broken and the
  // MessagePorts are not being closed properly or it could be caused by
  // failing the close R1's controller which signals the end of the data
  // flow.

  const readable = new ReadableStream({
    start: common.mustCall((controller) => {
      controller.enqueue(theData);
      controller.close();
    }),
  });

  port2.onmessage = common.mustCall(({ data }) => {
    assert(isReadableStream(data));

    const reader = data.getReader();
    reader.read().then(common.mustCall((chunk) => {
      assert.deepStrictEqual(chunk, { done: false, value: theData });
    }));

    port2.close();
  });

  port1.onmessage = common.mustCall(({ data }) => {
    assert(isReadableStream(data));
    assert(!data.locked);
    port1.postMessage(data, [data]);
    assert(data.locked);
  });

  assert.throws(() => port2.postMessage(readable), {
    constructor: DOMException,
    name: 'DataCloneError',
    code: 25,
  });

  port2.postMessage(readable, [readable]);
  assert(readable.locked);
}

{
  const { port1, port2 } = new MessageChannel();
  port1.onmessageerror = common.mustNotCall();
  port2.onmessageerror = common.mustNotCall();

  // This test repeats the test above, but with a readable byte stream.
  // Note transferring a readable byte stream results in a regular
  // value-oriented stream on the other side:
  // https://streams.spec.whatwg.org/#abstract-opdef-setupcrossrealmtransformwritable

  const theByteData = new Uint8Array([1, 2, 3]);

  const readable = new ReadableStream({
    type: 'bytes',
    start: common.mustCall((controller) => {
      // `enqueue` will detach its argument's buffer, so clone first
      controller.enqueue(theByteData.slice());
      controller.close();
    }),
  });
  assert(isReadableByteStreamController(readable[kState].controller));

  port2.onmessage = common.mustCall(({ data }) => {
    assert(isReadableStream(data));
    assert(!isReadableByteStreamController(data[kState].controller));

    const reader = data.getReader();
    reader.read().then(common.mustCall((chunk) => {
      assert.deepStrictEqual(chunk, { done: false, value: theByteData });
    }));

    port2.close();
  });

  port1.onmessage = common.mustCall(({ data }) => {
    assert(isReadableStream(data));
    assert(!isReadableByteStreamController(data[kState].controller));
    assert(!data.locked);
    port1.postMessage(data, [data]);
    assert(data.locked);
  });

  assert.throws(() => port2.postMessage(readable), {
    constructor: DOMException,
    name: 'DataCloneError',
    code: 25,
  });

  port2.postMessage(readable, [readable]);
  assert(readable.locked);
}

{
  const { port1, port2 } = new MessageChannel();
  port1.onmessageerror = common.mustNotCall();
  port2.onmessageerror = common.mustNotCall();

  // Like the ReadableStream test above, this sets up a pipeline
  // through which the data flows...
  //
  // We start with WritableStream W1, which is transferred to port1.
  // Doing so creates an internal ReadableStream R1 and WritableStream W2,
  // which are coupled together with MessagePorts P1 and P2.
  // The port1.onmessage callback receives WritableStream W2 and
  // immediately transfers that to port2. Doing so creates an internal
  // ReadableStream R2 and WritableStream W3, which are coupled together
  // with MessagePorts P3 and P4. WritableStream W3 is handed off to
  // port2.onmessage.
  //
  // When the writer on port2.onmessage writes the chunk of data, it
  // gets passed along the pipeline:
  // W3 -> P4 -> P3 -> R2 -> W2 -> P2 -> P1 -> R1 -> W1

  const writable = new WritableStream({
    write: common.mustCall((chunk) => {
      assert.strictEqual(chunk, theData);
    }),
  });

  port2.onmessage = common.mustCall(({ data }) => {
    assert(isWritableStream(data));
    assert(!data.locked);
    const writer = data.getWriter();
    writer.write(theData).then(common.mustCall());
    writer.close();
    port2.close();
  });

  port1.onmessage = common.mustCall(({ data }) => {
    assert(isWritableStream(data));
    assert(!data.locked);
    port1.postMessage(data, [data]);
    assert(data.locked);
  });

  assert.throws(() => port2.postMessage(writable), {
    constructor: DOMException,
    name: 'DataCloneError',
    code: 25,
  });

  port2.postMessage(writable, [writable]);
  assert(writable.locked);
}

{
  const { port1, port2 } = new MessageChannel();
  port1.onmessageerror = common.mustNotCall();
  port2.onmessageerror = common.mustNotCall();

  // The data flow here is actually quite complicated, and is a combination
  // of the WritableStream and ReadableStream examples above.
  //
  // We start with TransformStream T1, which creates ReadableStream R1,
  // and WritableStream W1.
  //
  // When T1 is transferred to port1.onmessage, R1 and W1 are individually
  // transferred.
  //
  // When R1 is transferred, it creates internal WritableStream W2, and
  // new ReadableStream R2, coupled together via MessagePorts P1 and P2.
  //
  // When W1 is transferred, it creates internal ReadableStream R3 and
  // new WritableStream W3, coupled together via MessagePorts P3 and P4.
  //
  // A new TransformStream T2 is created that owns ReadableStream R2 and
  // WritableStream W3. The port1.onmessage callback immediately transfers
  // that to port2.onmessage.
  //
  // When T2 is transferred, R2 and W3 are individually transferred.
  //
  // When R2 is transferred, it creates internal WritableStream W4, and
  // ReadableStream R4, coupled together via MessagePorts P5 and P6.
  //
  // When W3 is transferred, it creates internal ReadableStream R5, and
  // WritableStream W5, coupled together via MessagePorts P7 and P8.
  //
  // A new TransformStream T3 is created that owns ReadableStream R4 and
  // WritableStream W5.
  //
  // port1.onmessage then writes a chunk of data. That chunk of data
  // flows through the pipeline to T1:
  //
  // W5 -> P8 -> P7 -> R5 -> W3 -> P4 -> P3 -> R3 -> W1 -> T1
  //
  // T1 performs the transformation, then pushes the chunk back out
  // along the pipeline:
  //
  // T1 -> R1 -> W2 -> P1 -> P2 -> R2 -> W4 -> P5 -> P6 -> R4

  const transform = new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk.toUpperCase());
    }
  });

  port2.onmessage = common.mustCall(({ data }) => {
    assert(isTransformStream(data));
    const writer = data.writable.getWriter();
    const reader = data.readable.getReader();
    Promise.all([
      writer.write(theData),
      writer.close(),
      reader.read().then(common.mustCall((result) => {
        assert(!result.done);
        assert.strictEqual(result.value, theData.toUpperCase());
      })),
      reader.read().then(common.mustCall((result) => {
        assert(result.done);
      })),
    ]).then(common.mustCall());
    port2.close();
  });

  port1.onmessage = common.mustCall(({ data }) => {
    assert(isTransformStream(data));
    assert(!data.readable.locked);
    assert(!data.writable.locked);
    port1.postMessage(data, [data]);
    assert(data.readable.locked);
    assert(data.writable.locked);
  });

  assert.throws(() => port2.postMessage(transform), {
    constructor: DOMException,
    name: 'DataCloneError',
    code: 25,
  });

  port2.postMessage(transform, [transform]);
  assert(transform.readable.locked);
  assert(transform.writable.locked);
}

{
  const { port1, port2 } = new MessageChannel();
  let controller;

  const readable = new ReadableStream({
    start(c) { controller = c; },

    cancel: common.mustCall((error) => {
      assert.strictEqual(error.code, 25);
      assert.strictEqual(error.name, 'DataCloneError');
    }),
  });

  port1.onmessage = ({ data }) => {
    const reader = data.getReader();
    assert.rejects(reader.read(), {
      code: 25,
      name: 'DataCloneError',
    }).then(common.mustCall());
    port1.close();
  };

  port2.postMessage(readable, [readable]);

  const notActuallyTransferable = {
    [kClone]() {
      return {
        data: {},
        deserializeInfo: 'nothing that will work',
      };
    },
    [kDeserialize]: common.mustNotCall(),
  };
  markTransferMode(notActuallyTransferable, true, false);

  controller.enqueue(notActuallyTransferable);
}

{
  const { port1, port2 } = new MessageChannel();

  const source = {
    abort: common.mustCall((error) => {
      process.nextTick(() => {
        assert.strictEqual(error.code, 25);
        assert.strictEqual(error.name, 'DataCloneError');
      });
    })
  };

  const writable = new WritableStream(source);

  const notActuallyTransferable = {
    [kClone]() {
      return {
        data: {},
        deserializeInfo: 'nothing that will work',
      };
    },
    [kDeserialize]: common.mustNotCall(),
  };
  markTransferMode(notActuallyTransferable, true, false);

  port1.onmessage = common.mustCall(({ data }) => {
    const writer = data.getWriter();

    assert.rejects(writer.closed, {
      code: 25,
      name: 'DataCloneError',
    }).then(common.mustCall());

    writer.write(notActuallyTransferable).then(common.mustCall());

    port1.close();
  });

  port2.postMessage(writable, [writable]);
}

{
  const error = new Error('boom');
  const { port1, port2 } = new MessageChannel();

  const source = {
    abort: common.mustCall((reason) => {
      process.nextTick(() => {
        assert.deepStrictEqual(reason, error);

        // Reason is a clone of the original error.
        assert.notStrictEqual(reason, error);
      });
    }),
  };

  const writable = new WritableStream(source);

  port1.onmessage = common.mustCall(({ data }) => {
    const writer = data.getWriter();

    assert.rejects(writer.closed, error).then(common.mustCall());

    writer.abort(error).then(common.mustCall());
    port1.close();
  });

  port2.postMessage(writable, [writable]);
}

{
  const { port1, port2 } = new MessageChannel();

  const source = {
    abort: common.mustCall((error) => {
      process.nextTick(() => {
        assert.strictEqual(error.code, 25);
        assert.strictEqual(error.name, 'DataCloneError');
      });
    })
  };

  const writable = new WritableStream(source);

  port1.onmessage = common.mustCall(({ data }) => {
    const writer = data.getWriter();

    const m = new WebAssembly.Memory({ initial: 1 });

    assert.rejects(writer.abort(m), {
      code: 25,
      name: 'DataCloneError',
    }).then(common.mustCall());
    port1.close();
  });

  port2.postMessage(writable, [writable]);
}

{
  // Verify that the communication works across worker threads...

  const worker = new Worker(`
    const {
      isReadableStream,
    } = require('internal/webstreams/readablestream');

    const {
      parentPort,
    } = require('worker_threads');

    const assert = require('assert');

    const tracker = new assert.CallTracker();
    process.on('exit', () => {
      tracker.verify();
    });

    // We create an interval to keep the event loop alive while
    // we wait for the stream read to complete. The reason this is needed is because there's
    // otherwise nothing to keep the worker thread event loop alive long enough to actually
    // complete the read from the stream. Under the covers the ReadableStream uses an
    // unref'd MessagePort to communicate with the main thread. Because the MessagePort
    // is unref'd, it's existence would not keep the thread alive on its own. There was previously
    // a bug where this MessagePort was ref'd which would block the thread and main thread
    // from terminating at all unless the stream was consumed/closed.
    const i = setInterval(() => {}, 1000);

    parentPort.onmessage = tracker.calls(({ data }) => {
      assert(isReadableStream(data));
      const reader = data.getReader();
      reader.read().then(tracker.calls((result) => {
        assert(!result.done);
        assert(result.value instanceof Uint8Array);
        clearInterval(i);
      }));
      parentPort.close();
    });
    parentPort.onmessageerror = () => assert.fail('should not be called');
  `, { eval: true });

  worker.on('error', common.mustNotCall());

  const readable = new ReadableStream({
    start(controller) {
      controller.enqueue(new Uint8Array(10));
      controller.close();
    }
  });

  worker.postMessage(readable, [readable]);
}

{
  const source = {
    cancel: common.mustCall(),
  };

  const readable = new ReadableStream(source);

  const { port1, port2 } = new MessageChannel();

  port1.onmessage = common.mustCall(({ data }) => {
    data.cancel().then(common.mustCall());
    port1.close();
  });

  port2.postMessage(readable, [readable]);
}

{
  const source = {
    cancel: common.mustCall((error) => {
      process.nextTick(() => {
        assert.strictEqual(error.code, 25);
        assert.strictEqual(error.name, 'DataCloneError');
      });
    }),
  };

  const readable = new ReadableStream(source);

  const { port1, port2 } = new MessageChannel();

  port1.onmessage = common.mustCall(({ data }) => {
    const m = new WebAssembly.Memory({ initial: 1 });

    const reader = data.getReader();

    const cancel = reader.cancel(m);

    reader.closed.then(common.mustCall());

    assert.rejects(cancel, {
      code: 25,
      name: 'DataCloneError',
    }).then(common.mustCall());

    port1.close();
  });

  port2.postMessage(readable, [readable]);
}

{
  const source = {
    abort: common.mustCall((error) => {
      process.nextTick(() => {
        assert.strictEqual(error.code, 25);
        assert.strictEqual(error.name, 'DataCloneError');
      });
    }),
  };

  const writable = new WritableStream(source);

  const { port1, port2 } = new MessageChannel();

  port1.onmessage = common.mustCall(({ data }) => {
    const m = new WebAssembly.Memory({ initial: 1 });
    const writer = data.getWriter();
    const write = writer.write(m);
    assert.rejects(write, { code: 25, name: 'DataCloneError' }).then(common.mustCall());
    port1.close();
  });

  port2.postMessage(writable, [writable]);
}

{
  const readable = new ReadableStream();
  readable.getReader();
  assert.throws(() => readable[kTransfer](), {
    code: 25,
    name: 'DataCloneError',
  });

  const writable = new WritableStream();
  writable.getWriter();
  assert.throws(() => writable[kTransfer](), {
    code: 25,
    name: 'DataCloneError',
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/parallel/test-whatwg-writablestream.js                                             0000664 0000000 0000000 00000014601 14746647661 0023171 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --no-warnings
'use strict';

const common = require('../common');
const assert = require('assert');

const {
  WritableStream,
  WritableStreamDefaultController,
  WritableStreamDefaultWriter,
  CountQueuingStrategy,
} = require('stream/web');

const {
  kState,
} = require('internal/webstreams/util');

const {
  isPromise,
} = require('util/types');

const {
  kTransfer,
} = require('internal/worker/js_transferable');

const {
  inspect,
} = require('util');

class Sink {
  constructor() {
    this.chunks = [];
  }

  start() {
    this.started = true;
  }

  write(chunk) {
    this.chunks.push(chunk);
  }

  close() {
    this.closed = true;
  }

  abort() {
    this.aborted = true;
  }
}

{
  const stream = new WritableStream();

  assert(stream[kState].controller instanceof WritableStreamDefaultController);
  assert(!stream.locked);

  assert.strictEqual(typeof stream.abort, 'function');
  assert.strictEqual(typeof stream.close, 'function');
  assert.strictEqual(typeof stream.getWriter, 'function');
}

['a', false, 1, null].forEach((sink) => {
  assert.throws(() => new WritableStream(sink), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

['a', false, 1].forEach((strategy) => {
  assert.throws(() => new WritableStream({}, strategy), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

[1, false, ''].forEach((type) => {
  assert.throws(() => new WritableStream({ type }), {
    code: 'ERR_INVALID_ARG_VALUE',
  });
});

['a', {}].forEach((highWaterMark) => {
  assert.throws(() => new WritableStream({}, { highWaterMark }), {
    code: 'ERR_INVALID_ARG_VALUE',
  });
});

['a', false, {}].forEach((size) => {
  assert.throws(() => new WritableStream({}, { size }), {
    code: 'ERR_INVALID_ARG_TYPE',
  });
});

{
  new WritableStream({});
  new WritableStream([]);
  new WritableStream({}, null);
  new WritableStream({}, {});
  new WritableStream({}, []);
}

{
  const sink = new Sink();
  const stream = new WritableStream(
    sink,
    new CountQueuingStrategy({ highWaterMark: 1 }));

  assert(!stream.locked);
  const writer = stream.getWriter();
  assert(stream.locked);
  assert(writer instanceof WritableStreamDefaultWriter);

  assert(isPromise(writer.closed));
  assert(isPromise(writer.ready));
  assert(typeof writer.desiredSize, 'number');
  assert(typeof writer.abort, 'function');
  assert(typeof writer.close, 'function');
  assert(typeof writer.releaseLock, 'function');
  assert(typeof writer.write, 'function');

  writer.releaseLock();
  assert(!stream.locked);

  const writer2 = stream.getWriter();

  assert(sink.started);

  writer2.closed.then(common.mustCall());
  writer2.ready.then(common.mustCall());

  writer2.close().then(common.mustCall(() => {
    assert.strict(sink.closed);
  }));
}

{
  const sink = new Sink();

  const stream = new WritableStream(
    sink,
    new CountQueuingStrategy({ highWaterMark: 1 }));

  const error = new Error('boom');

  const writer = stream.getWriter();

  assert.rejects(writer.closed, error).then(common.mustCall());

  writer.abort(error).then(common.mustCall(() => {
    assert.strictEqual(stream[kState].state, 'errored');
    assert(sink.aborted);
  }));
}

{
  const sink = new Sink();

  const stream = new WritableStream(
    sink, { highWaterMark: 1 }
  );

  async function write(stream) {
    const writer = stream.getWriter();
    const p = writer.write('hello');
    assert.strictEqual(writer.desiredSize, 0);
    await p;
    assert.strictEqual(writer.desiredSize, 1);
  }

  write(stream).then(common.mustCall(() => {
    assert.deepStrictEqual(['hello'], sink.chunks);
  }));
}

{
  assert.throws(() => Reflect.get(WritableStream.prototype, 'locked', {}), {
    code: 'ERR_INVALID_THIS',
  });
  assert.rejects(() => WritableStream.prototype.abort({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.rejects(() => WritableStream.prototype.close({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.throws(() => WritableStream.prototype.getWriter.call(), {
    code: 'ERR_INVALID_THIS',
  });
  assert.throws(() => WritableStream.prototype[kTransfer].call(), {
    code: 'ERR_INVALID_THIS',
  });
  assert.rejects(
    Reflect.get(WritableStreamDefaultWriter.prototype, 'closed'), {
      code: 'ERR_INVALID_THIS',
    }).then(common.mustCall());
  assert.rejects(
    Reflect.get(WritableStreamDefaultWriter.prototype, 'ready'), {
      code: 'ERR_INVALID_THIS',
    }).then(common.mustCall());
  assert.throws(
    () => Reflect.get(WritableStreamDefaultWriter.prototype, 'desiredSize'), {
      code: 'ERR_INVALID_THIS',
    });
  assert.rejects(WritableStreamDefaultWriter.prototype.abort({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.rejects(WritableStreamDefaultWriter.prototype.close({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.rejects(WritableStreamDefaultWriter.prototype.write({}), {
    code: 'ERR_INVALID_THIS',
  }).then(common.mustCall());
  assert.throws(() => WritableStreamDefaultWriter.prototype.releaseLock({}), {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => {
    Reflect.get(WritableStreamDefaultController.prototype, 'signal', {});
  }, {
    code: 'ERR_INVALID_THIS',
  });

  assert.throws(() => {
    WritableStreamDefaultController.prototype.error({});
  }, {
    code: 'ERR_INVALID_THIS',
  });
}

{
  let controller;
  const writable = new WritableStream({
    start(c) { controller = c; }
  });
  assert.strictEqual(
    inspect(writable),
    'WritableStream { locked: false, state: \'writable\' }');
  assert.strictEqual(
    inspect(writable, { depth: null }),
    'WritableStream { locked: false, state: \'writable\' }');
  assert.strictEqual(
    inspect(writable, { depth: 0 }),
    'WritableStream [Object]');

  const writer = writable.getWriter();
  assert.match(
    inspect(writer),
    /WritableStreamDefaultWriter/);
  assert.match(
    inspect(writer, { depth: null }),
    /WritableStreamDefaultWriter/);
  assert.match(
    inspect(writer, { depth: 0 }),
    /WritableStreamDefaultWriter \[/);

  assert.match(
    inspect(controller),
    /WritableStreamDefaultController/);
  assert.match(
    inspect(controller, { depth: null }),
    /WritableStreamDefaultController/);
  assert.match(
    inspect(controller, { depth: 0 }),
    /WritableStreamDefaultController \[/);

  writer.abort(new Error('boom'));

  assert.strictEqual(writer.desiredSize, null);
  setImmediate(() => assert.strictEqual(writer.desiredSize, null));
}
                                                                                                                               node-23.7.0/test/parallel/test-windows-abort-exitcode.js                                            0000664 0000000 0000000 00000001167 14746647661 0023251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
if (!common.isWindows)
  common.skip('test is windows specific');

const assert = require('assert');
const spawn = require('child_process').spawn;

// This test makes sure that an aborted node process
// exits with code 3 on Windows.
// Spawn a child, force an abort, and then check the
// exit code in the parent.

if (process.argv[2] === 'child') {
  process.abort();
} else {
  const child = spawn(process.execPath, [__filename, 'child']);
  child.on('exit', common.mustCall((code, signal) => {
    assert.strictEqual(code, 134);
    assert.strictEqual(signal, null);
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-windows-failed-heap-allocation.js                                    0000664 0000000 0000000 00000002020 14746647661 0024607 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// This test ensures that an out of memory error exits with code 134 on Windows

if (!common.isWindows) return common.skip('Windows-only');

const assert = require('assert');
const { exec } = require('child_process');

if (process.argv[2] === 'heapBomb') {
  // Heap bomb, imitates a memory leak quickly
  const fn = (nM) => [...Array(nM)].map((i) => fn(nM * 2));
  fn(2);
}

// Run child in tmpdir to avoid report files in repo
const tmpdir = require('../common/tmpdir');
tmpdir.refresh();

// --max-old-space-size=3 is the min 'old space' in V8, explodes fast
const cmd = `"${process.execPath}" --max-old-space-size=30 "${__filename}"`;
exec(`${cmd} heapBomb`, { cwd: tmpdir.path }, common.mustCall((err, stdout, stderr) => {
  const msg = `Wrong exit code of ${err.code}! Expected 134 for abort`;
  // Note: common.nodeProcessAborted() is not asserted here because it
  // returns true on 134 as well as 0x80000003 (V8's base::OS::Abort)
  assert.strictEqual(err.code, 134, msg);
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/parallel/test-worker-abort-on-uncaught-exception-terminate.js                      0000664 0000000 0000000 00000000670 14746647661 0027474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --abort-on-uncaught-exception
'use strict';
const common = require('../common');
const assert = require('assert');
const { Worker } = require('worker_threads');

// Tests that --abort-on-uncaught-exception does not apply to
// termination exceptions.

const w = new Worker('while(true);', { eval: true });
w.on('online', common.mustCall(() => w.terminate()));
w.on('exit', common.mustCall((code) => assert.strictEqual(code, 1)));
                                                                        node-23.7.0/test/parallel/test-worker-abort-on-uncaught-exception.js                                0000664 0000000 0000000 00000000632 14746647661 0025504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --abort-on-uncaught-exception
'use strict';
const common = require('../common');
const assert = require('assert');
const { Worker } = require('worker_threads');

// Tests that --abort-on-uncaught-exception does not apply to
// Workers.

const w = new Worker('throw new Error()', { eval: true });
w.on('error', common.mustCall());
w.on('exit', common.mustCall((code) => assert.strictEqual(code, 1)));
                                                                                                      node-23.7.0/test/parallel/test-worker-arraybuffer-zerofill.js                                       0000664 0000000 0000000 00000002665 14746647661 0024317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const Countdown = require('../common/countdown');
const assert = require('assert');
const { Worker } = require('worker_threads');
const { describe, it, mock } = require('node:test');

describe('Allocating uninitialized ArrayBuffers ...', () => {
  it('...should not affect zero-fill in other threads', () => {
    const w = new Worker(`
      const { parentPort } = require('worker_threads');

      function post() {
        const uint32array = new Uint32Array(64);
        parentPort.postMessage(uint32array.reduce((a, b) => a + b));
      }

      setInterval(post, 0);
    `, { eval: true });

    const fn = mock.fn(() => {
      // Continuously allocate memory in the main thread. The allocUnsafe
      // here sets a scope internally that indicates that the memory should
      // not be initialized. While this is happening, the other thread is
      // also allocating buffers that must remain zero-filled. The purpose
      // of this test is to ensure that the scope used to determine whether
      // to zero-fill or not does not impact the other thread.
      setInterval(() => Buffer.allocUnsafe(32 * 1024 * 1024), 0).unref();
    });

    w.on('online', fn);

    const countdown = new Countdown(100, () => {
      w.terminate();
      assert(fn.mock.calls.length > 0);
    });

    w.on('message', (sum) => {
      assert.strictEqual(sum, 0);
      if (countdown.remaining) countdown.dec();
    });
  });
});
                                                                           node-23.7.0/test/parallel/test-worker-beforeexit-throw-exit.js                                      0000664 0000000 0000000 00000001427 14746647661 0024422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Worker } = require('worker_threads');

// Test that 'exit' is emitted if 'beforeExit' throws, both inside the Worker.

const workerData = new Uint8Array(new SharedArrayBuffer(2));
const w = new Worker(`
  const { workerData } = require('worker_threads');
  process.on('exit', () => {
    workerData[0] = 100;
  });
  process.on('beforeExit', () => {
    workerData[1] = 200;
    throw new Error('banana');
  });
`, { eval: true, workerData });

w.on('error', common.mustCall((err) => {
  assert.strictEqual(err.message, 'banana');
}));

w.on('exit', common.mustCall((code) => {
  assert.strictEqual(code, 1);
  assert.strictEqual(workerData[0], 100);
  assert.strictEqual(workerData[1], 200);
}));
                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-worker-broadcastchannel-wpt.js                                       0000664 0000000 0000000 00000011347 14746647661 0024263 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const {
  BroadcastChannel,
} = require('worker_threads');

{
  const c1 = new BroadcastChannel('eventType').unref();
  const c2 = new BroadcastChannel('eventType');

  c2.onmessage = common.mustCall((e) => {
    assert(e instanceof MessageEvent);
    assert.strictEqual(e.target, c2);
    assert.strictEqual(e.type, 'message');
    assert.strictEqual(e.data, 'hello world');
    c2.close();
  });
  c1.postMessage('hello world');
}

{
  // Messages are delivered in port creation order.
  // TODO(@jasnell): The ordering here is different than
  // what the browsers would implement due to the different
  // dispatching algorithm under the covers. What's not
  // immediately clear is whether the ordering is spec
  // mandated. In this test, c1 should receive events
  // first, then c2, then c3. In the Node.js dispatching
  // algorithm this means the ordering is:
  //    from c3    (c1 from c3)
  //    done       (c1 from c2)
  //    from c1    (c2 from c1)
  //    from c3    (c2 from c3)
  //    from c1    (c3 from c1)
  //    done       (c3 from c2)
  //
  // Whereas in the browser-ordering (as illustrated in the
  // Web Platform Tests) it would be:
  //    from c1    (c2 from c1)
  //    from c1    (c3 from c1)
  //    from c3    (c1 from c3)
  //    from c3    (c2 from c3)
  //    done       (c1 from c2)
  //    done       (c3 from c2)
  const c1 = new BroadcastChannel('order');
  const c2 = new BroadcastChannel('order');
  const c3 = new BroadcastChannel('order');

  const events = [];
  let doneCount = 0;
  const handler = common.mustCall((e) => {
    events.push(e);
    if (e.data === 'done') {
      doneCount++;
      if (doneCount === 2) {
        assert.strictEqual(events.length, 6);
        // TODO: Don't skip Windows once ordering is fixed per comment above.
        // Right now, the ordering for Windows is unreliable.
        if (!common.isWindows) {
          assert.strictEqual(events[0].data, 'from c3');
          assert.strictEqual(events[1].data, 'done');
          assert.strictEqual(events[2].data, 'from c1');
          assert.strictEqual(events[3].data, 'from c3');
          assert.strictEqual(events[4].data, 'from c1');
          assert.strictEqual(events[5].data, 'done');
        }
        c1.close();
        c2.close();
        c3.close();
      }
    }
  }, 6);
  c1.onmessage = handler;
  c2.onmessage = handler;
  c3.onmessage = handler;

  c1.postMessage('from c1');
  c3.postMessage('from c3');
  c2.postMessage('done');
}

{
  // Messages aren't delivered to a closed port
  const c1 = new BroadcastChannel('closed1').unref();
  const c2 = new BroadcastChannel('closed1');
  const c3 = new BroadcastChannel('closed1');

  c2.onmessage = common.mustNotCall();
  c2.close();
  c3.onmessage = common.mustCall(() => c3.close());
  c1.postMessage('test');
}

{
  // Messages aren't delivered to a port closed after calling postMessage.
  const c1 = new BroadcastChannel('closed2').unref();
  const c2 = new BroadcastChannel('closed2');
  const c3 = new BroadcastChannel('closed2');

  c2.onmessage = common.mustNotCall();
  c3.onmessage = common.mustCall(() => c3.close());
  c1.postMessage('test');
  c2.close();
}

{
  // Closing and creating channels during message delivery works correctly
  const c1 = new BroadcastChannel('create-in-onmessage').unref();
  const c2 = new BroadcastChannel('create-in-onmessage');

  c2.onmessage = common.mustCall((e) => {
    assert.strictEqual(e.data, 'first');
    c2.close();
    const c3 = new BroadcastChannel('create-in-onmessage');
    c3.onmessage = common.mustCall((event) => {
      assert.strictEqual(event.data, 'done');
      c3.close();
    });
    c1.postMessage('done');
  });
  c1.postMessage('first');
  c2.postMessage('second');
}

{
  // TODO: Fix failure on Windows CI. Skipping for now.
  if (!common.isWindows) {
    // Closing a channel in onmessage prevents already queued tasks
    // from firing onmessage events
    const c1 = new BroadcastChannel('close-in-onmessage2').unref();
    const c2 = new BroadcastChannel('close-in-onmessage2');
    const c3 = new BroadcastChannel('close-in-onmessage2');
    const events = [];
    c1.onmessage = (e) => events.push('c1: ' + e.data);
    c2.onmessage = (e) => events.push('c2: ' + e.data);
    c3.onmessage = (e) => events.push('c3: ' + e.data);

    // c2 closes itself when it receives the first message
    c2.addEventListener('message', common.mustCall(() => c2.close()));

    c3.addEventListener('message', common.mustCall((e) => {
      if (e.data === 'done') {
        assert.deepStrictEqual(events, [
          'c2: first',
          'c3: first',
          'c3: done']);
        c3.close();
      }
    }, 2));
    c1.postMessage('first');
    c1.postMessage('done');
  }
}
                                                                                                                                                                                                                                                                                         node-23.7.0/test/parallel/test-worker-broadcastchannel.js                                           0000664 0000000 0000000 00000012133 14746647661 0023445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const {
  BroadcastChannel,
  Worker,
  receiveMessageOnPort
} = require('worker_threads');
const assert = require('assert');
const { inspect } = require('util');

assert.throws(() => new BroadcastChannel(Symbol('test')), {
  message: /Cannot convert a Symbol value to a string/
});

assert.throws(() => new BroadcastChannel(), {
  message: /The "name" argument must be specified/
});

// These should all just work
[undefined, 1, null, 'test', 1n, false, Infinity].forEach((i) => {
  const bc = new BroadcastChannel(i);
  assert.strictEqual(bc.name, `${i}`);
  bc.close();
});

{
  // Empty postMessage throws
  const bc = new BroadcastChannel('whatever');
  assert.throws(() => bc.postMessage(), {
    message: /The "message" argument must be specified/
  });
  bc.close();
  // Calling close multiple times should not throw
  bc.close();

  // Calling postMessage after close should throw
  assert.throws(() => bc.postMessage(null), {
    message: /BroadcastChannel is closed/
  });
}

{
  const bc1 = new BroadcastChannel('channel1');
  const bc2 = new BroadcastChannel('channel1');
  const bc3 = new BroadcastChannel('channel1');
  const bc4 = new BroadcastChannel('channel2');
  assert.strictEqual(bc1.name, 'channel1');
  assert.strictEqual(bc2.name, 'channel1');
  assert.strictEqual(bc3.name, 'channel1');
  assert.strictEqual(bc4.name, 'channel2');
  bc1.addEventListener('message', common.mustCall((event) => {
    assert.strictEqual(event.data, 'hello');
    bc1.close();
    bc2.close();
    bc4.close();
  }));
  bc3.addEventListener('message', common.mustCall((event) => {
    assert.strictEqual(event.data, 'hello');
    bc3.close();
  }));
  bc2.addEventListener('message', common.mustNotCall());
  bc4.addEventListener('message', common.mustNotCall());
  bc2.postMessage('hello');
}

{
  const bc1 = new BroadcastChannel('onmessage-channel1');
  const bc2 = new BroadcastChannel('onmessage-channel1');
  const bc3 = new BroadcastChannel('onmessage-channel1');
  const bc4 = new BroadcastChannel('onmessage-channel2');
  assert.strictEqual(bc1.name, 'onmessage-channel1');
  assert.strictEqual(bc2.name, 'onmessage-channel1');
  assert.strictEqual(bc3.name, 'onmessage-channel1');
  assert.strictEqual(bc4.name, 'onmessage-channel2');
  bc1.onmessage = common.mustCall((event) => {
    assert.strictEqual(event.data, 'hello');
    bc1.close();
    bc2.close();
    bc4.close();
  });
  bc3.onmessage = common.mustCall((event) => {
    assert.strictEqual(event.data, 'hello');
    bc3.close();
  });
  bc2.onmessage = common.mustNotCall();
  bc4.onmessage = common.mustNotCall();
  bc2.postMessage('hello');
}

{
  const bc = new BroadcastChannel('worker1');
  new Worker(`
    const assert = require('assert');
    const { BroadcastChannel } = require('worker_threads');
    const bc = new BroadcastChannel('worker1');
    bc.addEventListener('message', (event) => {
      assert.strictEqual(event.data, 123);
      // If this close() is not executed, the test should hang and timeout.
      // If the test does hang and timeout in CI, then the first step should
      // be to check that the two bc.close() calls are being made.
      bc.close();
    });
    bc.postMessage(321);
  `, { eval: true });
  bc.addEventListener('message', common.mustCall(({ data }) => {
    assert.strictEqual(data, 321);
    bc.postMessage(123);
    bc.close();
  }));
}

{
  const bc1 = new BroadcastChannel('channel3');
  const bc2 = new BroadcastChannel('channel3');
  const bc3 = new BroadcastChannel('channel3');
  bc3.postMessage(new SharedArrayBuffer(10));
  let received = 0;
  for (const bc of [bc1, bc2]) {
    bc.addEventListener('message', common.mustCall(({ data }) => {
      assert(data instanceof SharedArrayBuffer);
      if (++received === 2) {
        bc1.close();
        bc2.close();
        bc3.close();
      }
    }));
  }
}

{
  const bc1 = new BroadcastChannel('channel3');
  const mc = new MessageChannel();
  assert.throws(() => bc1.postMessage(mc), {
    message: /Object that needs transfer was found/
  });
  assert.throws(() => bc1.postMessage(Symbol()), {
    message: /Symbol\(\) could not be cloned/
  });
  bc1.close();
  assert.throws(() => bc1.postMessage(Symbol()), {
    message: /BroadcastChannel is closed/
  });
}

{
  const bc1 = new BroadcastChannel('channel4');
  const bc2 = new BroadcastChannel('channel4');
  bc1.postMessage('some data');
  assert.strictEqual(receiveMessageOnPort(bc2).message, 'some data');
  assert.strictEqual(receiveMessageOnPort(bc2), undefined);
  bc1.close();
  bc2.close();
}

{
  assert.throws(() => Reflect.get(BroadcastChannel.prototype, 'name', {}), {
    code: 'ERR_INVALID_THIS',
  });

  [
    'close',
    'postMessage',
    'ref',
    'unref',
  ].forEach((i) => {
    assert.throws(() => Reflect.apply(BroadcastChannel.prototype[i], [], {}), {
      code: 'ERR_INVALID_THIS',
    });
  });
}

{
  const bc = new BroadcastChannel('channel5');
  assert.strictEqual(
    inspect(bc.ref()),
    "BroadcastChannel { name: 'channel5', active: true }"
  );

  bc.close();
  assert.strictEqual(
    inspect(bc.ref()),
    "BroadcastChannel { name: 'channel5', active: false }"
  );
}
                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/parallel/test-worker-cjs-workerdata.js                                             0000664 0000000 0000000 00000000626 14746647661 0023076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');
const { Worker } = require('worker_threads');

const workerData = 'Hello from main thread';

const worker = new Worker(fixtures.path('worker-data.cjs'), {
  workerData
});

worker.on('message', common.mustCall((message) => {
  assert.strictEqual(message, workerData);
}));
                                                                                                          node-23.7.0/test/parallel/test-worker-cleanexit-with-js.js                                          0000664 0000000 0000000 00000001370 14746647661 0023512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// Harden the thread interactions on the exit path.
// Ensure workers are able to bail out safe at
// arbitrary execution points. By running a lot of
// JS code in a tight loop, the expectation
// is that those will be at various control flow points
// preferably in the JS land.

const { Worker } = require('worker_threads');
const code = 'setInterval(() => {' +
      "require('v8').deserialize(require('v8').serialize({ foo: 'bar' }));" +
      "require('vm').runInThisContext('x = \"foo\";');" +
      "eval('const y = \"vm\";');}, 10);";
for (let i = 0; i < 9; i++) {
  new Worker(code, { eval: true });
}
new Worker(code, { eval: true }).on('online', common.mustCall((msg) => {
  process.exit(0);
}));
                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-worker-cleanexit-with-moduleload.js                                  0000664 0000000 0000000 00000001536 14746647661 0025227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// Harden the thread interactions on the exit path.
// Ensure workers are able to bail out safe at
// arbitrary execution points. By using a number of
// internal modules as load candidates, the expectation
// is that those will be at various control flow points
// preferably in the C++ land.

const { Worker } = require('worker_threads');
const modules = [ 'fs', 'assert', 'async_hooks', 'buffer', 'child_process',
                  'net', 'http', 'os', 'path', 'v8', 'vm',
];
if (common.hasCrypto) {
  modules.push('https');
}

for (let i = 0; i < 10; i++) {
  new Worker(`const modules = [${modules.map((m) => `'${m}'`)}];` +
    'modules.forEach((module) => {' +
    'const m = require(module);' +
    '});', { eval: true });
}

// Allow workers to go live.
setTimeout(() => {
  process.exit(0);
}, 200);
                                                                                                                                                                  node-23.7.0/test/parallel/test-worker-cleanup-handles.js                                            0000664 0000000 0000000 00000001412 14746647661 0023213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const assert = require('assert');
const fs = require('fs');
const { Server } = require('net');
const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
  const w = new Worker(__filename);
  let fd = null;
  w.on('message', common.mustCall((fd_) => {
    assert.strictEqual(typeof fd_, 'number');
    fd = fd_;
  }));
  w.on('exit', common.mustCall(() => {
    if (fd === -1) {
      // This happens when server sockets don’t have file descriptors,
      // i.e. on Windows.
      return;
    }
    assert.throws(() => fs.fstatSync(fd), { code: 'EBADF' });
  }));
} else {
  const server = new Server();
  server.listen(0);
  parentPort.postMessage(server._handle.fd);
  server.unref();
}
                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-worker-cli-options.js                                                0000664 0000000 0000000 00000003370 14746647661 0022415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals --expose-gc
'use strict';
const common = require('../common');
const { Worker } = require('worker_threads');
const assert = require('assert');

const CODE = `
// If the --expose-internals flag does not pass to worker
// require function will throw an error
require('internal/options');
globalThis.gc();
`;

// Test if the flags is passed to worker threads correctly
// and do not throw an error with the invalid execArgv
// when execArgv is inherited from parent
// See https://github.com/nodejs/node/issues/52825
// See https://github.com/nodejs/node/issues/53011

// Inherited env, execArgv from the parent will be ok
new Worker(CODE, { eval: true });
// Pass process.env explicitly and inherited execArgv from parent will be ok
new Worker(CODE, { eval: true, env: process.env });
// Inherited env from the parent and pass execArgv (Node.js options) explicitly will be ok
new Worker(CODE, { eval: true, execArgv: ['--expose-internals'] });
// Pass process.env and execArgv (Node.js options) explicitly will be ok
new Worker(CODE, { eval: true, env: process.env, execArgv: ['--expose-internals'] });
//  Pass execArgv (V8 options) explicitly will throw an error
assert.throws(() => {
  new Worker(CODE, { eval: true, execArgv: ['--expose-gc'] });
}, /ERR_WORKER_INVALID_EXEC_ARGV/);

// Test ESM eval
new Worker('export {}', { eval: true, execArgv: ['--input-type=module'] });
new Worker('export {}', { eval: true, execArgv: ['--input-type=commonjs'] })
  .once('error', common.expectsError({ name: 'SyntaxError' }));
new Worker('export {}', { eval: true, execArgv: ['--experimental-detect-module'] });
new Worker('export {}', { eval: true, execArgv: ['--no-experimental-detect-module'] })
  .once('error', common.expectsError({ name: 'SyntaxError' }));
                                                                                                                                                                                                                                                                        node-23.7.0/test/parallel/test-worker-console-listeners.js                                          0000664 0000000 0000000 00000000733 14746647661 0023625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Worker, isMainThread } = require('worker_threads');
const EventEmitter = require('events');

if (isMainThread) {
  process.on('warning', common.mustNotCall('unexpected warning'));

  for (let i = 0; i < EventEmitter.defaultMaxListeners; ++i) {
    const worker = new Worker(__filename);

    worker.on('exit', common.mustCall(() => {
      console.log('a'); // This console.log() is part of the test.
    }));
  }
}
                                     node-23.7.0/test/parallel/test-worker-crypto-sign-transfer-result.js                                0000664 0000000 0000000 00000001661 14746647661 0025572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { Worker } = require('worker_threads');
const fixturesPath = require.resolve('../common/fixtures');

// Test that transferring the result of e.g. crypto.sign() from Worker to parent
// thread does not crash

const w = new Worker(`
const { parentPort } = require('worker_threads');
const crypto = require('crypto');
const assert = require('assert');
const fixtures = require(${JSON.stringify(fixturesPath)});

const keyPem = fixtures.readKey('rsa_private.pem');

const buf = crypto.sign('sha256', Buffer.from('hello'), keyPem);
assert.notStrictEqual(buf.byteLength, 0);
parentPort.postMessage(buf, [buf.buffer]);
assert.strictEqual(buf.byteLength, 0);
`, { eval: true });

w.on('message', common.mustCall((buf) => {
  assert.notStrictEqual(buf.byteLength, 0);
}));
w.on('exit', common.mustCall());
                                                                               node-23.7.0/test/parallel/test-worker-data-url.js                                                   0000664 0000000 0000000 00000001530 14746647661 0021662 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Worker } = require('worker_threads');
const assert = require('assert');

new Worker(new URL('data:text/javascript,'))
  .on('error', common.mustNotCall());
new Worker(new URL('data:text/javascript,export{}'))
  .on('error', common.mustNotCall());

new Worker(new URL('data:text/plain,'))
  .on('error', common.mustCall());
new Worker(new URL('data:text/javascript,module.exports={}'))
  .on('error', common.mustCall());

new Worker(new URL('data:text/javascript,await Promise.resolve()'))
  .on('error', common.mustNotCall());
new Worker(new URL('data:text/javascript,await Promise.reject()'))
  .on('error', common.mustCall());
new Worker(new URL('data:text/javascript,await new Promise(()=>{})'))
  .on(
    'exit',
    common.mustCall((exitCode) => { assert.strictEqual(exitCode, 13); })
  );
                                                                                                                                                                        node-23.7.0/test/parallel/test-worker-debug.js                                                      0000664 0000000 0000000 00000022132 14746647661 0021240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

common.skipIfInspectorDisabled();

const assert = require('assert');
const EventEmitter = require('events');
const { Session } = require('inspector');
const {
  Worker, isMainThread, parentPort, workerData
} = require('worker_threads');


const workerMessage = 'This is a message from a worker';

function waitForMessage() {
  return new Promise((resolve) => {
    parentPort.once('message', resolve);
  });
}

// This is at the top so line numbers change less often
if (!isMainThread) {
  if (workerData === 1) {
    console.log(workerMessage);
    debugger;  // eslint-disable-line no-debugger
  } else if (workerData === 2) {
    parentPort.postMessage('running');
    waitForMessage();
  }
  return;
}

function doPost(session, method, params) {
  return new Promise((resolve, reject) => {
    session.post(method, params, (error, result) => {
      if (error)
        reject(JSON.stringify(error));
      else
        resolve(result);
    });
  });
}

function waitForEvent(emitter, event) {
  return new Promise((resolve) => emitter.once(event, resolve));
}

function waitForWorkerAttach(session) {
  return waitForEvent(session, 'NodeWorker.attachedToWorker')
      .then(({ params }) => params);
}

async function waitForWorkerDetach(session, id) {
  let sessionId;
  do {
    const { params } =
        await waitForEvent(session, 'NodeWorker.detachedFromWorker');
    sessionId = params.sessionId;
  } while (sessionId !== id);
}

function runWorker(id, workerCallback = () => {}) {
  return new Promise((resolve, reject) => {
    const worker = new Worker(__filename, { workerData: id });
    workerCallback(worker);
    worker.on('error', reject);
    worker.on('exit', resolve);
  });
}

class WorkerSession extends EventEmitter {
  constructor(parentSession, id) {
    super();
    this._parentSession = parentSession;
    this._id = id;
    this._requestCallbacks = new Map();
    this._nextCommandId = 1;
    this._parentSession.on('NodeWorker.receivedMessageFromWorker',
                           ({ params }) => {
                             if (params.sessionId === this._id)
                               this._processMessage(JSON.parse(params.message));
                           });
  }

  _processMessage(message) {
    if (message.id === undefined) {
      // console.log(JSON.stringify(message));
      this.emit('inspectorNotification', message);
      this.emit(message.method, message);
      return;
    }
    if (!this._requestCallbacks.has(message.id))
      return;
    const [ resolve, reject ] = this._requestCallbacks.get(message.id);
    this._requestCallbacks.delete(message.id);
    if (message.error)
      reject(new Error(message.error.message));
    else
      resolve(message.result);
  }

  async waitForBreakAfterCommand(command, script, line) {
    const notificationPromise = waitForEvent(this, 'Debugger.paused');
    this.post(command);
    const notification = await notificationPromise;
    const callFrame = notification.params.callFrames[0];
    assert.strictEqual(callFrame.location.lineNumber, line);
  }

  post(method, parameters) {
    const msg = {
      id: this._nextCommandId++,
      method
    };
    if (parameters)
      msg.params = parameters;

    return new Promise((resolve, reject) => {
      this._requestCallbacks.set(msg.id, [resolve, reject]);
      this._parentSession.post('NodeWorker.sendMessageToWorker', {
        sessionId: this._id, message: JSON.stringify(msg)
      });
    });
  }
}

async function testBasicWorkerDebug(session, post) {
  // 1. Do 'enable' with waitForDebuggerOnStart = true
  // 2. Run worker. It should break on start.
  // 3. Enable Runtime (to get console message) and Debugger. Resume.
  // 4. Breaks on the 'debugger' statement. Resume.
  // 5. Console message received, worker runs to a completion.
  // 6. contextCreated/contextDestroyed had been properly dispatched
  console.log('Test basic debug scenario');
  await post('NodeWorker.enable', { waitForDebuggerOnStart: true });
  const attached = waitForWorkerAttach(session);
  const worker = runWorker(1);
  const { sessionId, waitingForDebugger } = await attached;
  assert.strictEqual(waitingForDebugger, true);
  const detached = waitForWorkerDetach(session, sessionId);
  const workerSession = new WorkerSession(session, sessionId);
  const contextEventPromises = Promise.all([
    waitForEvent(workerSession, 'Runtime.executionContextCreated'),
    waitForEvent(workerSession, 'Runtime.executionContextDestroyed'),
  ]);
  const consolePromise = waitForEvent(workerSession, 'Runtime.consoleAPICalled')
      .then((notification) => notification.params.args[0].value);
  await workerSession.post('Debugger.enable');
  await workerSession.post('Runtime.enable');
  await workerSession.waitForBreakAfterCommand(
    'Runtime.runIfWaitingForDebugger', __filename, 1);
  await workerSession.waitForBreakAfterCommand(
    'Debugger.resume', __filename, 25);  // V8 line number is zero-based
  const msg = await consolePromise;
  assert.strictEqual(msg, workerMessage);
  workerSession.post('Debugger.resume');
  await Promise.all([worker, detached, contextEventPromises]);
}

async function testNoWaitOnStart(session, post) {
  console.log('Test disabled waitForDebuggerOnStart');
  await post('NodeWorker.enable', { waitForDebuggerOnStart: false });
  let worker;
  const promise = waitForWorkerAttach(session);
  const exitPromise = runWorker(2, (w) => { worker = w; });
  const { waitingForDebugger } = await promise;
  assert.strictEqual(waitingForDebugger, false);
  worker.postMessage('resume');
  await exitPromise;
}

async function testTwoWorkers(session, post) {
  console.log('Test attach to a running worker and then start a new one');
  await post('NodeWorker.disable');
  let okToAttach = false;
  const worker1attached = waitForWorkerAttach(session).then((notification) => {
    assert.strictEqual(okToAttach, true);
    return notification;
  });

  let worker1Exited;
  const worker = await new Promise((resolve, reject) => {
    worker1Exited = runWorker(2, resolve);
  }).then((worker) => new Promise(
    (resolve) => worker.once('message', () => resolve(worker))));
  okToAttach = true;
  await post('NodeWorker.enable', { waitForDebuggerOnStart: true });
  const { waitingForDebugger: worker1Waiting } = await worker1attached;
  assert.strictEqual(worker1Waiting, false);

  const worker2Attached = waitForWorkerAttach(session);
  let worker2Done = false;
  const worker2Exited = runWorker(1)
      .then(() => assert.strictEqual(worker2Done, true));
  const worker2AttachInfo = await worker2Attached;
  assert.strictEqual(worker2AttachInfo.waitingForDebugger, true);
  worker2Done = true;

  const workerSession = new WorkerSession(session, worker2AttachInfo.sessionId);
  workerSession.post('Runtime.runIfWaitingForDebugger');
  worker.postMessage('resume');
  await Promise.all([worker1Exited, worker2Exited]);
}

async function testWaitForDisconnectInWorker(session, post) {
  console.log('Test NodeRuntime.waitForDisconnect in worker');

  const sessionWithoutWaiting = new Session();
  sessionWithoutWaiting.connect();
  const sessionWithoutWaitingPost = doPost.bind(null, sessionWithoutWaiting);

  await sessionWithoutWaitingPost('NodeWorker.enable', {
    waitForDebuggerOnStart: true
  });
  await post('NodeWorker.enable', { waitForDebuggerOnStart: true });

  const attached = [
    waitForWorkerAttach(session),
    waitForWorkerAttach(sessionWithoutWaiting),
  ];

  let worker = null;
  const exitPromise = runWorker(2, (w) => worker = w);

  const [{ sessionId: sessionId1 }, { sessionId: sessionId2 }] =
      await Promise.all(attached);

  const workerSession1 = new WorkerSession(session, sessionId1);
  const workerSession2 = new WorkerSession(sessionWithoutWaiting, sessionId2);

  await workerSession2.post('Runtime.enable');
  await workerSession1.post('Runtime.enable');
  await workerSession1.post('NodeRuntime.notifyWhenWaitingForDisconnect', {
    enabled: true
  });
  await workerSession1.post('Runtime.runIfWaitingForDebugger');

  // Create the promises before sending the exit message to the Worker in order
  // to avoid race conditions.
  const disconnectPromise =
    waitForEvent(workerSession1, 'NodeRuntime.waitingForDisconnect');
  const executionContextDestroyedPromise =
    waitForEvent(workerSession2, 'Runtime.executionContextDestroyed');
  worker.postMessage('resume');

  await disconnectPromise;
  post('NodeWorker.detach', { sessionId: sessionId1 });
  await executionContextDestroyedPromise;

  await exitPromise;

  await post('NodeWorker.disable');
  await sessionWithoutWaitingPost('NodeWorker.disable');
  sessionWithoutWaiting.disconnect();
}

(async function test() {
  const session = new Session();
  session.connect();
  const post = doPost.bind(null, session);

  await testBasicWorkerDebug(session, post);

  console.log('Test disabling attach to workers');
  await post('NodeWorker.disable');
  await runWorker(1);

  await testNoWaitOnStart(session, post);

  await testTwoWorkers(session, post);

  await testWaitForDisconnectInWorker(session, post);

  session.disconnect();
  console.log('Test done');
})().then(common.mustCall()).catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-worker-dns-terminate-during-query.js                                 0000664 0000000 0000000 00000001155 14746647661 0025357 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Resolver } = require('dns');
const dgram = require('dgram');
const { Worker, isMainThread } = require('worker_threads');

// Test that Workers can terminate while DNS queries are outstanding.

if (isMainThread) {
  return new Worker(__filename);
}

const socket = dgram.createSocket('udp4');

socket.bind(0, common.mustCall(() => {
  const resolver = new Resolver();
  resolver.setServers([`127.0.0.1:${socket.address().port}`]);
  resolver.resolve4('example.org', common.mustNotCall());
}));

socket.on('message', common.mustCall(() => {
  process.exit();
}));
                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/parallel/test-worker-dns-terminate.js                                              0000664 0000000 0000000 00000000634 14746647661 0022727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { Worker } = require('worker_threads');

const w = new Worker(`
const dns = require('dns');
dns.lookup('nonexistent.org', () => {});
require('worker_threads').parentPort.postMessage('0');
`, { eval: true });

w.on('message', common.mustCall(() => {
  // This should not crash the worker during a DNS request.
  w.terminate().then(common.mustCall());
}));
                                                                                                    node-23.7.0/test/parallel/test-worker-environmentdata.js                                            0000664 0000000 0000000 00000002132 14746647661 0023346 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals

require('../common');
const {
  Worker,
  getEnvironmentData,
  setEnvironmentData,
  threadId,
} = require('worker_threads');

const { assignEnvironmentData } = require('internal/worker');

const {
  deepStrictEqual,
  strictEqual,
} = require('assert');

if (!process.env.HAS_STARTED_WORKER) {
  process.env.HAS_STARTED_WORKER = 1;
  setEnvironmentData('foo', 'bar');
  setEnvironmentData('hello', { value: 'world' });
  setEnvironmentData(1, 2);
  strictEqual(getEnvironmentData(1), 2);
  setEnvironmentData(1); // Delete it, key won't show up in the worker.
  new Worker(__filename);
  setEnvironmentData('hello');  // Delete it. Has no impact on the worker.
} else {
  strictEqual(getEnvironmentData('foo'), 'bar');
  deepStrictEqual(getEnvironmentData('hello'), { value: 'world' });
  strictEqual(getEnvironmentData(1), undefined);
  assignEnvironmentData(undefined); // It won't setup any key.
  strictEqual(getEnvironmentData(undefined), undefined);

  // Recurse to make sure the environment data is inherited
  if (threadId <= 2)
    new Worker(__filename);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/parallel/test-worker-error-stack-getter-throws.js                                  0000664 0000000 0000000 00000001137 14746647661 0025224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Worker } = require('worker_threads');

const w = new Worker(
  `const fn = (err) => {
    if (err.message === 'fhqwhgads')
      throw new Error('come on');
    return 'This is my custom stack trace!';
  };
  Error.prepareStackTrace = fn;
  throw new Error('fhqwhgads');
  `,
  { eval: true }
);
w.on('message', common.mustNotCall());
w.on('error', common.mustCall((err) => {
  assert.strictEqual(err.stack, undefined);
  assert.strictEqual(err.message, 'fhqwhgads');
  assert.strictEqual(err.name, 'Error');
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/parallel/test-worker-esm-exit.js                                                   0000664 0000000 0000000 00000000561 14746647661 0021707 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');
const { Worker } = require('worker_threads');

const w = new Worker(fixtures.path('es-modules/import-process-exit.mjs'));
w.on('error', common.mustNotCall());
w.on('exit',
     common.mustCall((code) => assert.strictEqual(code, 42))
);
                                                                                                                                               node-23.7.0/test/parallel/test-worker-esm-missing-main.js                                           0000664 0000000 0000000 00000000727 14746647661 0023335 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { Worker } = require('worker_threads');

const tmpdir = require('../common/tmpdir');
tmpdir.refresh();
const missing = tmpdir.resolve('does-not-exist.js');

const worker = new Worker(missing);

worker.on('error', common.mustCall((err) => {
  // eslint-disable-next-line node-core/no-unescaped-regexp-dot
  assert.match(err.message, /Cannot find module .+does-not-exist.js/);
}));
                                         node-23.7.0/test/parallel/test-worker-esmodule.js                                                   0000664 0000000 0000000 00000000522 14746647661 0021766 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const fixtures = require('../common/fixtures');
const assert = require('assert');
const { Worker } = require('worker_threads');

const w = new Worker(fixtures.path('worker-script.mjs'));
w.on('message', common.mustCall((message) => {
  assert.strictEqual(message, 'Hello, world!');
}));
                                                                                                                                                                              node-23.7.0/test/parallel/test-worker-eval-typescript.js                                            0000664 0000000 0000000 00000006116 14746647661 0023311 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { Worker } = require('worker_threads');
const { test } = require('node:test');
const { once } = require('events');

const esmHelloWorld = `
    import worker from 'worker_threads';
    const foo: string = 'Hello, World!';
    worker.parentPort.postMessage(foo);
`;

const cjsHelloWorld = `
    const { parentPort } = require('worker_threads');
    const foo: string = 'Hello, World!';
    parentPort.postMessage(foo);
`;

const disableTypeScriptWarningFlag = '--disable-warning=ExperimentalWarning';

test('Worker eval module typescript without input-type', async () => {
  const w = new Worker(esmHelloWorld, { eval: true, execArgv: [disableTypeScriptWarningFlag] });
  assert.deepStrictEqual(await once(w, 'message'), ['Hello, World!']);
});

test('Worker eval module typescript with --input-type=module-typescript', async () => {
  const w = new Worker(esmHelloWorld, { eval: true, execArgv: ['--input-type=module-typescript',
                                                               disableTypeScriptWarningFlag] });
  assert.deepStrictEqual(await once(w, 'message'), ['Hello, World!']);
});

test('Worker eval module typescript with --input-type=commonjs-typescript', async () => {
  const w = new Worker(esmHelloWorld, { eval: true, execArgv: ['--input-type=commonjs-typescript',
                                                               disableTypeScriptWarningFlag] });

  const [err] = await once(w, 'error');
  assert.strictEqual(err.name, 'SyntaxError');
  assert.match(err.message, /Cannot use import statement outside a module/);
});

test('Worker eval module typescript with --input-type=module', async () => {
  const w = new Worker(esmHelloWorld, { eval: true, execArgv: ['--input-type=module',
                                                               disableTypeScriptWarningFlag] });
  const [err] = await once(w, 'error');
  assert.strictEqual(err.name, 'SyntaxError');
  assert.match(err.message, /Missing initializer in const declaration/);
});

test('Worker eval commonjs typescript without input-type', async () => {
  const w = new Worker(cjsHelloWorld, { eval: true, execArgv: [disableTypeScriptWarningFlag] });
  assert.deepStrictEqual(await once(w, 'message'), ['Hello, World!']);
});

test('Worker eval commonjs typescript with --input-type=commonjs-typescript', async () => {
  const w = new Worker(cjsHelloWorld, { eval: true, execArgv: ['--input-type=commonjs-typescript',
                                                               